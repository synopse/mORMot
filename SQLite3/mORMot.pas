/// Common ORM and SOA classes for mORMot
// - this unit is a part of the freeware Synopse mORMot framework,
// licensed under a MPL/GPL/LGPL tri-license; version 1.18
unit mORMot;

(*
    This file is part of Synopse mORMot framework.

    Synopse mORMot framework. Copyright (C) 2014 Arnaud Bouchez
      Synopse Informatique - http://synopse.info

  *** BEGIN LICENSE BLOCK *****
  Version: MPL 1.1/GPL 2.0/LGPL 2.1

  The contents of this file are subject to the Mozilla Public License Version
  1.1 (the "License"); you may not use this file except in compliance with
  the License. You may obtain a copy of the License at
  http://www.mozilla.org/MPL

  Software distributed under the License is distributed on an "AS IS" basis,
  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  for the specific language governing rights and limitations under the License.

  The Original Code is Synopse mORMot framework.

  The Initial Developer of the Original Code is Arnaud Bouchez.

  Portions created by the Initial Developer are Copyright (C) 2014
  the Initial Developer. All Rights Reserved.

  Contributor(s):
    Alexander (chaa)
    Esmond
    Pavel (mpv)

  Alternatively, the contents of this file may be used under the terms of
  either the GNU General Public License Version 2 or later (the "GPL"), or
  the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  in which case the provisions of the GPL or the LGPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of either the GPL or the LGPL, and not to allow others to
  use your version of this file under the terms of the MPL, indicate your
  decision by deleting the provisions above and replace them with the notice
  and other provisions required by the GPL or the LGPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the MPL, the GPL or the LGPL.

  ***** END LICENSE BLOCK *****


       Client-Server ORM and SOA kernel of the mORMot framework
      **********************************************************

	- Client-Server classes using a RESTful model via JSON, over named pipes
	  or Windows messages  (HTTP/1.1 protocol with unit mORMotHttpServer/Client)
	- Client-Server ORM via TSQLRecord classes definition
	- Client-Server interface-based services for SOA process
	- optimized low-level RTTI and JSON process (TSQLTable)
	- ready to be used by mORMotSQLite3.pas with a SQLite3 engine
	- implements in-memory database tables with JSON/binary disk persistence

      Initial version: 2008 March, by Arnaud Bouchez

    Version 1.1 - 14 January 2010:
    - SQLite3 database layer updated to version 3.6.22
    - new communication layer, to be used on a local computer: windows messages
      (see TSQLRestClientURIMessage class). On a local machine, this is faster
      than named pipes and http, for small messages (quite as fast as direct
      access); but named pipes seems to be better for bigger messages
    - allow to get rid of our Enhanced Runtime Library dependency if not available
      (e.g. for FPC or on cross-platform, or on Delphi version newer than Delphi
      2007): just define the ENHANCEDRTL conditional below if installed it
      (always undefined if UNICODE is defined)
    - attempt to reach Delphi 2009/2010 compilation (string=UnicodeString):
      the UNICODE conditional will adapt the framework to these compilers
      (you shouldn't have to change any conditional define below)
    - attempt to reach Free Pascal Compiler 2.4.0 compatibility
    - all asm code equivalence in pure pascal code for 64 bits compatibility
      (always slower, but always portable to all CPUs)
    - use of PtrUInt / PtrInt for 64 bits compatibility
    - in case of FPC, the typinfo.pp unit is used: so all published properties
      in any TSQLRecord descendant must have a setter (i.e. a "write fValue"
      statement); the FPC's RTTI is not the same as Delphi's: it's a shame :(

    Version 1.2 - 16 January 2010
    - compatibility tested up to Delphi 2009 (that is tested with Delphi 7,
      Delphi 2007 and Delphi 2009), with or without our Enhanced
      Run Time Library (which now compiles up to Delphi 2007) - by default, the
      ENHANCEDRTL compiler conditional is not defined;
    - lot of rewrite made for the Unicode version of the compiler (tested with
      Delphi 2009) - it was quite difficult to avoid most implicit conversions...
      the compiler is a bit tricky, as soon as you want to use the UTF-8 encoding
      (as we do, since JSON and HTTP do like this encoding, together as SQLite3),
      and not Unicode (which is in fact UTF-16);
    - can create an internal TSQLRestClientURIMessage messaging window, if
      you don't have any User Interface (so you don't have to add Forms unit)
    - named pipe speed improvement (10 times faster) under Vista and Seven

    Version 1.3 - January 22, 2010
    - disconnect piped name client after 30 min of inactivity to free the
      corresponding thread resource if the client failed to close cleanly
    - some small fixes (e.g. integer to and from string conversion, GPF) and
      multi-compiler (Delphi 2009/2010, especialy with TypInfo define) compatibility
    - compiler conditional renamed ENHANCEDRTL instead of ENHANCEDTRTL
    - new TSQLTable.GetRowValues overloaded methods

    Version 1.3.1 - January 23, 2010
    - some Pos() overload problem under Delphi 20007 compiler; since
      this Pos() is seldom used, it was decided to only define it under
      Delphi 2009/2010 (which expect such a RawUTF8 specific overloaded version)
    - source code adaptation to use only ASCII 7 bits characters: should be OK
      with asiatic MBCS text encoding and such IDE

    Version 1.3.2 - January 24, 2010
    - new StringToUTF8() and UTF8ToString() functions; it's prefered to use
    TLanguageFile.StringToUTF8() method from SQLite3i18n, which will handle full
    i18n of your application; these functions use the current RTL codepage
    under Delphi 3-2007

    Version 1.4 - February 8, 2010
    - whole Synopse SQLite3 database framework released under the GNU Lesser
      General Public License version 3, instead of generic "Public Domain"

    Version 1.5 - March 10, 2010
    - SQLite3 database layer updated to version 3.6.23
    - User Interface Query action implementation
    - added security attributes to the named pipes creation: now this
      communication layer can work as a windows service, under Vista or Seven
      (thanks to esmond comment in our blog for the tip)
    - added new FastCGI server (not 100% tested)
    - first attempt to add REST paging requests for 'GET ModelRoot/TableName',
      as expected by the YUI DataSource Request Syntax for data pagination:
      see http://developer.yahoo.com/yui/datatable/#data

    Version 1.6
    - SQLite3 database layer updated to version 3.6.23.1
    - most useful functions are now shared in a separate SynCommons unit
    - the framework is now licensed under a MPL/GPL/LGPL tri-license
    - obscure JSON parsing bug fixed (when a field content finished with '\')

    Version 1.7
    - alter table with newly added fields to a TSQLRecord (see GetSQLAddField()
      methods)
    - some compatibility fixes for Delphi 2009/2010
    - fixed bug: negative numbers were not updated when calling *.Update()

    Version 1.8
    - includes Unitary Testing class and functions
    - update engine to version 3.7.0
    - new direct methods to handle BLOB fields from clients or servers
    - new URI to GET or PUT BLOB fields: ModelRoot/TableName/TableID/BlobFieldName
    - fixed bug in TSQLTable.GetJSONValues: FirstRow parameter not used
    - TTextWriter class moved from SQLite3Commons to SynCommons
    - new ModelRoot/[TableName/TableID/]MethodName RESTful GET/PUT request
     (see TSQLRestServerCallBack definition and comments): implements some custom
     Client/Server request, similar to the DataSnap technology, but in a KISS way;
     it's fully integrated in the Client/Server architecture of our framework,
     and extend its ORM feature to Object-less communication - see new
     ModelRoot/Stat method implement in TSQLRestServer
    - floating point numbers are now encoded using new ExtendedStr[ing] methods:
     such values are now encoded in a more human readable way in the JSON content
    - new tests added (mostly relative to the new functions or classes)

    Version 1.9
    - update engine to version 3.7.1
    - fixed error calling a TSQLRestServerCallBack with both record & parameters
    - TSQLRecordSigned must now be signed with a specified content (content
      was formerly a fixed field of type RawUTF8, but it didn't apply in
      all cases, e.g. if content field is defined as TSQLRawBlob)
    - new TSQLRestClientURI.ForceBlobTransfert property which enable to
      get and set BLOB fields values with usual Add/Update/Retrieve methods
    - new TSQLRestClientURI.RetrieveBlobFields/UpdateBlobFields methods
      for retrieving/updating all BLOB fields of a record at once
    - better handling of sftID in the User Interface and database use (e.g.
      creates a dedicated index for the TSQLRecord published fields)
    - some code rewrite in order to avoid any implicit conversion from/to
      integer/cardinal after new definition of PtrInt/PtrUInt (matching
      NativeInt/NativeUInt types, available since Delphi 2007)
    - updated TSQLRibbonTabParameters object, with some new fields dedicated
      to the automatic edition of records, via the new SQLite3UIEdit unit
    - new sftSet SQL field kind, handling a TSQLRecord published property
      with a set of enumeration as Delphi type (stored as bit-mapped INTEGER)
    - handle now RowID as a valid alias to the ID field (needed for TSQLRecordFTS3)
    - defines a new TSQLRecordFTS3 type, for defining a FTS3 virtual table,
      i.e. implementing full-text search

    Version 1.9.1
    - update engine to version 3.7.2: an obscure but very old bug makes
      SQLite authors recommend to use 3.7.2  for all new development.
      Upgrading from all prior SQLite versions is also recommended.

    Version 1.9.2
    - WriteObject and CopyObject functions now handle Int64 properties,
      as TJSONWriter.WriteObject method does now also
    - new TSQLRestServerStatic.GetOne and TSQLRestServerStatic.UpdateOne methods,
      methods available since a TSQLRestServerStatic instance may be created
      stand-alone, i.e. without any associated Model/TSQLRestServer
    - diverse fixes in TSQLRestServerStatic which could occur in not expected
      behavior if security events are enabled for this table (wrong IDToIndex)
    - new TSQLRecordLog.CreateFrom method used to append some log records
      to an existing JSON log content

    Version 1.10
    - code modifications to compile with Delphi 6 compiler (Delphi 5 failed due
      to some obscure compiler bugs in SynCrypto.pas)
    - update SQLite3 engine to version 3.7.3

    Version 1.11
    - update SQLite3 engine to version 3.7.4
    - new TSQLRecordProperties class, used internally by TSQLRecord to access
      to the RTTI via some high-level structures (therefore save memory for each
      TSQLRecord instance, and make operations faster)
    - new TSQLRecordFill class, used internally by TSQLRecord.FillPrepare()
      to save memory: a TSQLRecord instance has now only 20 bytes of InstanceSize
    - TSQLRecord.ID reader has now a GetID() getter which can handle the fact that
      a published property declared as TSQLRecord (sftID type) contains not a
      true TSQLRecord instance, but the ID of this record: you can use
      aProperty.ID method in order to get the idea - but prefered method is to
      typecast it via PtrInt(aProperty), because GetID() relies on some low-level
      windows memory mapping trick
    - new TSQLRecordMany to handle "has many" and "has many through" relationships
    - TSQLRestServer.AfterDeleteForceCoherency now handles specifically
      TRecordReference, TSQLRecord (fixed) and new 'has many' Source/Dest fields
      (this is our internal "FOREIGN KEY" implementation - we choose not to
      rely on the database engine for that, in order to be engine-independent...
      and SQLite3 introduced FOREIGN KEY in 3.6.19 version only)
    - TSQLRestServer.AfterDeleteForceCoherency now synchronizes as expected
      TSQLRestServerStatic table content
    - new TSQLRestServerStatic.SearchField method, for fast retrieval of
      all IDs matching a field of a TSQLRestServerStatic table (faster than
      using any OneFieldValues method, which creates a temporary JSON content)
    - TSQLRecord.FillRow method has been made virtual, so that some calculated
      field can be initialize during table content enumeration
    - corrected possible GPF error in TSQLRestServer.Retrieve
    - sftMany/TSQLRecordMany field type handled as a not simple field
    - new TSQLRecord.SimplePropertiesFill() method, to fill the simple properties
      with a given list of const parameters, following the declared order of
      published properties of the supplied table
    - new TSQLRest.Add(aTable: TSQLRecordClass; const aSimpleFields: array of const)
      overloaded method to add a record from a supplied list of const parameters
    - new TSQLRest.Update(aTable,aID,aSimpleFields) overloaded method to update
      a record from a supplied list of const parameters for each simple field
    - new property TSQLRecord.SimpleFieldsCount
    - FTS3Match method renamed FTSMatch, in order to be used without hesitation
      for both FTS3 and FTS4 classes
    - new overloaded FTSMatch method, accepting ranking of MATCH, using the
      new RANK internal function - see http://www.sqlite.org/draft/fts3.html#appendix_a
    - new TSQLRecordFTS4 class, to handle new FTS4 extension module  - see
      http://sqlite.org/fts3.html#section_1_1 - which is available since 3.7.4
    - new TSQLRecord.FillClose method
    - new TSQLRecord.CreateAndFillPrepare() methods, to makes loop into records
      easier (an hidden TSQLTable is created and released by TSQLRecord.Destroy)
    - new overloaded TSQLRestServer.CreateSQLIndex() method, accepting an array
      of field names
    - new TSQLRecord.FillPrepare(const aIDs: TIntegerDynArray) overloaded method,
      which can be handy to loop into some records via an IDs set
    - new TSQLTable.OwnerMustFree property for generic owning of a TSQLTable
      by a record - used for both CreateAndFillPrepare and TSQLRecordMany.FillMany
    - better non-ascii search handling in TSQLTable.SearchValue
    - source code modified to be 7 bit Ansi (so will work with all encodings)

    Version 1.12
    - now handle automaticaly prepared SQL statements: the parameters must
      be surrounded with :(...): in order to use an internal pool of prepared
      TSQLRequest statements; example of possible inlined values are :(1234):
      :(12.34): :(12E-34): :("text"): or :('text'): (with double quoting
      inside the text, just like any SQL statement)
    - with Delphi 2009+, you can define any string parameter in your
      TSQLRecord definition (will be handled as sftUTF8Text field)
    - with Delphi 2009+, WriteObject, ReadObject and CopyObject functions
      now handle string (UnicodeString) properties, as TINIWriter.WriteObject
      method does also: UTF-8 encoding is used at the storage level
    - new function SQLParamContent() to retrieve :(...): param content and type
    - another review of Pos() calls in the code (now use our fast PosEx)
    - some functions or type/const definitions moved to SynCommons in order
      to introduce new TSynTable class (TJSONWriter, IsRowID, GotoNextJSONField,
      TSynTableStatement...)
    - new TSQLRestServer.CreateSQLMultiIndex method
    - new TSQLTable.GetString and TSQLTable.GetVariant methods
    - new TPropInfo.SetVariant/GetVariant/CopyValue methods
    - new GetFieldValue/SetFieldValue and GetFieldVariant/SetFieldVariant
      methods for TSQLRecord
    - fixed issue in TSQLTable.GetWP(), which truncated data in Grid display
    - fixed issue in TSQLRestServerNamedPipe[Response] multi-thread architecture:
      FastMM in full debug mode detected that a block has been modified after
      being freed - now TSQLRestServerNamedPipeResponse is fully stand-alone

    Version 1.13
    - the ORM will now include all published properties of the parents, up to
      TSQLRecord, to the database fields (it was only using the published
      properties at the topmost class level)
    - dynamic arrays can now be specified for TSQLRecord published properties:
      a new sftBlobDynArray field kind has been added - will be stored as BLOB in
      the database (following the TDynArray.SaveTo binary stream layout), and
      will be transmitted as Base64 encoded in the JSON stream - we implemented
      a sftBlobRecord field kind, but Delphi RTTI is not generated for published
      properties of records: so our code is disabled (see PUBLISHRECORD
      conditional) :( - but you can use dynamic arrays of records
    - TPersistent can be now be specified for TSQLRecord published properties:
      a new sftObject field kind has been added - will be stored as TEXT in the
      database (following the ObjectToJSON serialization format) - TStrings or
      TRawUTF8List will be stored as a JSON array of string, and TCollection
      as a JSON array of objects, other TPersistent classes will have their
      published properties serialized as a JSON object
    - introducing direct content filtering and validation using
      TSynFilterOrValidate dedicated classes
    - filtering is handled directly in the new TSQLRecord.Filter virtual method,
      or via some TSynFilter classes - TSynFilterUpperCase, TSynFilterUpperCaseU,
      TSynFilterLowerCase, TSynFilterLowerCaseU and TSynFilterTrim e.g.
    - validation is handled in the new TSQLRecord.Validate virtual method,
      or via some TSynValidate classes - TSynValidateRest, TSynValidateIPAddress,
      TSynValidateEmail, TSynValidatePattern, TSynValidatePatternI,
      TSynValidateText, TSynValidatePassWord e.g.
    - introducing TSQLRecordRTree to implement R-Tree virtual tables - and new
      TSQLRecordVirtual parent table for all virtual tables like TSQLRecordFTS*
    - new TSQLRestClientURI methods to implement BATCH sequences to speed up
      database modifications: after a call to BatchStart, database modification
      statements are added to the sequence via BatchAdd/BatchUpdate/BatchDelete,
      then all statments are sent as once to the remote server via BatchSend -
      this is MUCH faster than individual calls to Add/Update/Delete in case
      of a slow remote connection (typically HTTP over Internet)
    - introducing TSQLVirtualTableModule / TSQLVirtualTable /
      TSQLVirtualTableCursor classes for a generic Virtual table mechanism
      (used e.g. by TSQLVirtualTableModuleDB in the SQLite3 unit)
    - new TSQLRecordVirtualTableAutoID and TSQLRecordVirtualTableForcedID
      classes, used to access any TSQLVirtualTable in our ORM
    - security and per-user access rights is now implemented in the framework
      core using per-User authentication via in-memory sessions (stored as
      TAuthSession), with group-defined associated security parameters (via
      TSQLAuthUser and TSQLAuthGroup tables), and RESTful Query Authentication
      via URI signature; should avoid most MITM and replay attacks
    - new TJSONSerializer class and ObjectToJSON/JSONToObject method
      (handles also dynamic arrays following the TTextWriter.AddDynArrayJSON
      format, i.e. plain JSON array for common types aka '[1,2,3]', but Base64
      encoded stream aka '["\uFFF0base64encodedbinary"]' for other arrays) and
      corresponding UrlDecodeObject() function (to be called by RESTful Services
      implementation on Server side)
    - wider usage of TSQLRecordProperties, for faster RTTI access, via the new
      class function TSQLRecord.RecordProps: TSQLRecordProperties: only
      virtual class function or procedure are now defined in TSQLRecord
    - enhanced TPropInfo.GetLongStrValue/SetLongStrValue methods, now converting
      RawUnicode, WinAnsiString, TSQLRawBlob and AnsiString properties
    - now ensure that no published property named ID or RowID was defined (this
      unique primary key field must be handled directly by TSQLRecord)
    - MAX_SQLFIELDS default is still 64, but can now be set to any value (64,
      128, 192 and 256 have optimized fast code) so that you can have any number
      of fields in a Table
    - MAX_SQLTABLES default is now 256, i.e. you can have up to 256 tables in a
      TSQLModel instance (you can set any other value, on need)
    - removed MAX_SQLLOCKS constant non-sense (replaced by two dynamic arrays)
    - TSQLModel implementation speed up, in case of a huge number of registered
      TSQLRecord in the database Model (since MAX_SQLTABLES=256 by default)
    - enhanced TSQLRecordMany.DestGetJoinedTable method to handle custom fields
    - TSQLRecordMany.DestGetJoined* methods now accept generic TSQLRest class
    - new aCustomFieldsCSV parameter for FillPrepare / CreateAndFillPrepare
      methods of TSQLRecord, to retrieve only neeeded fields: be aware that
      not specified fields will be left untouched, so a later Update() call may
      corrupt the row data - this optional parameter is about to save bandwidth
      when retrieving records field in a loop 
    - TSQLRestServerStaticInMemory can now store its content into UTF-8 JSON
      or an optimized (SynLZ) compressed binary format - associated TPropInfo
      GetBinary/SetBinary and TSQLRecord GetBinaryValues/SetBinaryValues methods
    - the generic TVarData type is now used as a standard way of fast values
      communication: only handled VType are varNull, varInt64, varDouble,
      varString (mapping a constant PUTF8Char), and varAny (BLOB with size =
      VLongs[0]) - used e.g. by SQLite3 unit (VarDataToContext/VarDataFromValue)
    - new TSQLRest.Retrieve(aPublishedRecord, aValue: TSQLRecord) and
      TSQLRecord.Create(aClient: TSQLRest; aPublishedRecord: TSQLRecord..) methods
    - ExecuteList defined in TSQLRest, so now available also in TSQLRestServer
    - added a magic pattern check to ignore broadcasted WM_COPYDATA message
    - fixed issue in serializing sftCurrency type in TSQLRecord.GetJSONValue

  Version 1.14
    - new TPropInfo.GetCurrencyValue method
    - fixed issue in produced JSON stream using '=' instead of ':'

  Version 1.15
    - unit now tested with Delphi XE2 (32 Bit)
    - new sftModTime / TModTime published field type in TSQLRecord, which will
      be set to the current server time stamp before update/adding
    - new sftCreateTime / TCreateTime published field type in TSQLRecord, which
      will be set to the current server time stamp at record creation
    - new TSQLRest.ServerTimeStamp property, which will return the current
      server time as TTimeLog/Int64 value (will use the new /TimeStamp RESTful
      service to retrieve the exact server time)
    - TSQLRestServerStaticInMemory uses a per-Table Critical Section to have
      its EngineList, EngineRetrieve, EngineAdd, EngineUpdate, EngineDelete,
      EngineRetrieveBlob, EngineUpdateBlob methods begin thread-safe
    - enhanced TSQLRestServer.URI thread-safety (e.g. Sessions access)
    - TSQLTable.InitFieldTypes will now also use column type retrieved during
      JSON parsing
    - new TSQLTable.GetCSVValues method
    - GetJSONValues() is now using an internal TRawByteStringStream when
      the expected result is a RawUTF8 (avoid copying content twice, and is
      perfectly thread-safe)
    - the shared fTempMemoryStream is not available any more (not thread-safe)
    - new TSQLRest.AcquireWrite/ReleaseWrite protected methods, used by
      TSQLRestServer.URI to safely write to the DB (e.g. for POST/PUT/DELETE...)
      with TSQLRest.AcquireWriteTimeOut, both thread-safe and transaction-safe
    - TSQLRest.TransactionBegin / Commit / RollBack methods now expect a
      SessionID parameter in order to allow safe concurent access: writing to
      the database is queued within a single client session
    - CreateSQLMultiIndex and CreateSQLIndex methods now working on external
      DB virtual tables (using SynDB.TSQLDBConnectionProperties.SQLAddIndex)
    - new TSQLRecordProperties.ExternalTableName and ExternalDatabase fields
      used by SQLite3DB to handle external SynDB-based database access
    - code refactoring to make TSQLRestServerStatic more generic (for SQLite3DB)
    - TSQLRestServer.UpdateField now accepts to search by ID or by value (used
      e.g. by rewritten TSQLRestServer.AfterDeleteForceCoherency method)
    - introducing TSQLRecordExternal kind of record, able to use any SynDB
      external database engine (e.g. OleDB/MSSQL/Oracle/MySQL/PostgreSQL/SQLite3)
    - new ExtractInlineParameters procedure to handle :(1234): SQL statements
    - new MakePrivateCopy property in TSQLTableJSON.Create, which will avoid
      creating a private copy of the JSON (used e.g. in SynDBExplorer to handle
      very large result sets, with half the memory)
    - new TSQLRecordProperties.SQLUpdateSet, SQLInsertSet and AppendFieldName
      properties/method (used for external DB handling)
    - new TSQLRecord.Create, TSQLRecord.FillPrepare,
      TSQLRecord.CreateAndFillPrepare, TSQLRest.OneFieldValue,
      TSQLRest.MultiFieldValues, TSQLRestClient.EngineExecuteFmt and
      TSQLRestClient.ListFmt overloaded methods, accepting both '%' and '?'
      characters in the SQL WHERE format text, inlining '?' parameters
      with :(...): and auto-quoting strings
    - new UnicodeComparison parameter in TSQLTable.SearchValue to handle
      property non WinAnsi (code page 1252) characters
    - fixed issue in TPropInfo.GetBinary method with dynamic arrays (used e.g.
      by TSQLRestServerStaticInMemory.SaveToBinary)
    - fixed issue with TAuthSession.IDCardinal=0 or 1 after 76 connections
    - fixed issue in SetInt64Prop() with a setter method
    - fixed potential issue in TSQLTable.SearchValue in case of invalid Client
      supplied parameter (now checks TSQLRest class type)

  Version 1.16
    - mORMot framework now implements Client-Server service implementation
      using regular Delphi interfaces (over a RESTful or JSON-RPC protocol),
      using TServiceContainer / TServiceFactory classes, accessible via
      TSQLRest.Services property, on both client and server side, with
      auto-marshaling, JSON serialization, and built-in security
    - added dedicated Exception classes (EORMException, EParsingException,
      ESecurityException, ECommunicationException, EBusinessLayerException,
      EServiceException) all inheriting from SynCommons.ESynException
    - added a generic JSON error message mechanism within the framework
      (including error code as integer and text, with custom error messages
      in RecordCanBeUpdated method and also in TSQLRestServerCallBackParams)
    - added TSQLRestServerFullMemory class to implement a basic REST server
      using only in-memory tables (will only handle CRUD commands, but is
      enough to handle authentication with optional persistence in JSON file)
    - added TSQLRestServerRemoteDB class to implement a REST server using a
      remote TSQLRestClient connection for all its ORM process: can be used
      e.g. to publish services with a dedicated process in a DMZ
    - deep refactoring of TSQLRestClient / TSQLRestClientURI methods, for
      better compliance with the Liskov substitution principle (LSP) 
    - TSQLRestServer published method names are now hash-stored for speed
    - the TSQLRestServerCallBack method prototype has been modified to supply
      "var aParams: TSQLRestServerCallBackParams" as unique parameter:
      this is a CODE BREAK change and you shall refresh ALL your server-side
      code to match the new signature (using a record passed by value as
      parameter will ensure faster code and seamless evolution of this structure) 
    - new TSQLRestServer.SessionGetUser method to be used e.g. by any
      TSQLRestServerCallBack method implementation to retrieve the connected user
    - now the TSQLAuthUser instance retrieved during the session opening will
      retrieve the Data BLOB field (ready to be consummed on the server side)
    - introduced TSQLRestServerSessionContext structure to include current User
      and Group ID to the execution context (in addition to the Session ID)
    - TSQLRestServerStaticInMemory binary format changed: now will store its
      content per field (to ensure better compression) - magic identifier changed 
    - now TSQLRestClientURI BATCH sequences methods will allow to mix several
      TSQLRecord in its sequence of BatchAdd/BatchUpdate/BatchDelete calls - if
      initiated as BatchStart(nil)
    - code clean-up of TSQLRestClientURI.SetUser + added aHashedPassword optional
      parameter (to use already hashed password) 
    - added TSQLOccasion to handle the special case of field type (like
      TCreateTime) in case of Upate/Insert/Select
    - TCreateTime published fields now are not modified at update
    - fixed unexpected exception raised in TSQLRecord.FillOne if FillPrepare
      was successfull, but did not return any row
    - introducing TSQLRest.Cache and TSQLRestCache class to handle Client or
      Server side fast in-memory cache (with tuned configuration and timeout)
    - associated TSQLRestServer.CacheFlush service for flushing the Server cache,
      and remote TSQLRestClientURI.ServerCacheFlush() method for the client
    - fixed issue in TSQLRecord.FillPrepare when the table has less columns
      that the filling TSQLTable (can occur e.g. when using aCustomFieldsCSV
      parameter in FillPrepare method)
    - EngineList methods (including TSQLRestServerStaticInMemory class) now
      handles an optional integer pointer, to return the count of row data
    - uses new generic TSynAnsiConvert classes for code page process: that is,
      SQLite3i18n S2U() and U2S() match the SynCommons StringToUTF8() and
      UTF8ToString() functions - therefore, the TUTF8ToStringEvent parameter is
      not useful any more
    - more than MAX_SQLFIELDS-1 columns (by default, 63) will raise an exception
    - added TJSONSerializer.RegisterCustomSerializer() method to allow JSON
      serialization of any class (thanks Pavel "aka mpv" for the idea and patch)
    - added TSQLRestServer.ServiceMethodByPassAuthentication method in order to
      allow by-pass of the RESTful authentication scheme for some methods (can
      be used e.g. to server some HTML content for a non SOA client)
    - fix issue about missing last item in JSONToObject() function
    - fix issue when handling null JSON objects in GetJSONObjectAsSQL() function
    - JSON functions now handle '0' as number according to http://json.org specs
    - fix issue about record locking in TSQLRestClientURI.Retrieve method
    - fix execution issue in TSQLRestServer.AfterDeleteForceCoherency()
    - fix issue about abusive session timeout: TSQLRestServer.SessionGet is now
      renamed SessionAccess and refreshes the session access timestamp each time
      a session is retrieved (+internal implementation fix)
    - fix issue in SetInt64Prop() procedure which failed the update of a property
      with no explicit setter
    - fix issue in TSQLRecord.FillFrom() which forgot to update InternalState
    - fix issue in TPropInfo.SetValue + TSQLRecord.ClearProperties with Value=nil
    - fix potential formating issue in TSQLTable.GetJSONValues/GetCSVValues
      methods which may create some wrong formating if TEXT is null/false/true
      (were formerly recognized as JSON keywords, whereas it should have already
      been transformed into nil, '0' or '1')
    - fix issue of unhandled buffer in TSQLTableJSON.UpdateFrom()
    - fix issue about transactions not working with TSQLRestServerStaticInMemory
    - fix issue in TSQLRestServerStaticInMemory on SELECT with only one column
    - fix TSQLTable.GetCSVValues() format (adding UTF-8 BOM)
    - TSQLRestServer.URI now returns "Location:" header without the digital
      signature (e.g. 'Location: People/11012') for a POST (=CRUD create/add)
    - TSQLRestClient.List and ListFmt methods now use TSQLRecordClass open
      array instead of TClass (for consistency)
    - new global RecordClassesToClasses() wrapper function to convert an
      array of TSQLRecordClass into the expected array of TClass
    - TPropInfo.CopyValue method now specifically handle copy of TCollection
      published properties items (used e.g. in TSQLRecord.FillFrom)
    - new GetEnumNameTrimed() wrapper function
    - new TRecordType definition, and TTypeinfo.RecordType associated method
    - now JSONToObject/ObjectToJSON functions and WriteObject method will handle
      standard TPersistent class serialization into/from JSON object
    - now ObjectToJSON/JSONToObject will unserialize sets and enumerations
      as an array of string, if HumanReadable is set to TRUE
    - now TSQLRestServer.Auth service returns true JSON response as specified
      by its content type (for better AJAX compatibility)
    - re-declared TSQLAccessRights record as an object, and added some
      dedicated methods: FromString, ToString, Edit
    - faster and more generic TSQLRecord.FillPrepare/FillRow implementation,
      including enhanced TSQLRecordFill class
    - faster TSQLRestServerStaticInMemory.LoadFromJSON and LoadFromBinary methods
    - reUrlEncodedSQL remote access right allows execution of SQL statement from
      a GET with the content encoded on the URI (as from XMLHTTPRequest)
    - new TSQLRest.EngineUpdateField protected method for a field content update
      (with PUT ModelRoot/TableName?setname=..&set=..&wherename=..&where=..)
    - new TSQLRecord.CreateAndFillPrepareMany and FillPrepareMany methods, able
      to create a JOINed SELECT statement including all nested TSQLRecordMany
      properties (including custom WHERE clause if necessary)
    - now nested TCollection and TStringList/TRawUTF8List objects are
      transmitted as true JSON arrays or objects for adding (POST) and update
      (PUT) - this will save bandwidth and increase compatibility
      with AJAX clients (they were formerly transmitted as JSON strings) - note
      that retrieval (GET) is not yet implemented, since it is faster to transmit
      directly the TEXT value as stored within the database
    - new TSQLRest.MainFieldIDs() method
    - new ForceID parameter for TSQLRest.Add() and TSQLRestClientURI.BatchAdd()
      to allow adding a record with a given ID
    - added TSQLRestClientURI.OnSetUser notification event (called from SetUser)
    - now TSQLRestClientURI.BatchUpdate() will set only ID, TModTime and mapped
      fields when called over a TSQLRecord on which a FillPrepare() was made
      (and no FillClose was performed)
    - now TSQLRestServerStats is a plain TPersistent class, and will be sent
      as a JSON object to the client
    - added function IsNotAjaxJSON() function - formerly internal IsExpanded()
    - added RecordManySourceProp / RecordManyDestProp / RecordManySourceClass /
      RecordManyDestClass to the TSQLRecordProperties
    - TSQLRestClientURI.CallBackPut() will now return any HTTP response content
      (even if it is not HTTP/1.1 compliant, and not work over some networks)
    - circumvent some bugs of Delphi XE2 background compiler (main compiler is OK)

  Version 1.17
    - TSQLRecord.Create/FillPrepare/CreateAndFillPrepare and
      TSQLRest.OneFieldValue/MultiFieldValues methods signature BREAKING CHANGE:
      array of const used to be ParamsSQLWhere and expecting '%' in the
      FormatSQLWhere statement, is now called BoundsSQLWhere, and expects bound
      parameters specified as '?' in the FormatSQLWhere statement - this is less
      confusing for new users, and more close to the usual way of preparing
      database queries; but your existing user code SHALL BE CHECKED and fixed
    - fixed issue in TSQLTable.GetJSONValues about JSON number encoding
    - added optional "rowCount": in TSQLRestServerStaticInMemory.GetJSONValues,
      TSQLTable.GetJSONValues and in TSQLTableJSON.ParseAndConvert for about
      5% faster process of huge content (mpv proposal)
    - major speedup of TSQLTableJSON.Create(): buffer hashing by-passed until
      TSQLTableJSON.UpdateFrom() method is effectively called
    - fixed issue about BLOB unproperly serialized into JSON (e.g. now uses null)
    - fixed issue about harcoded 'ID' column, not compatible with virtual tables
    - fixed issue about pessimistic TSQLRestServerStaticInMemory.fIDSorted value
    - fixed ticket [fdf7158601] - about incorrect null value parsing in
      JSONToObject when isObj = oCustom (fix by mpv - thanks!)
    - fixed ticket [a1d9e9148e] - about incorrect reading empty JSON object by
      JSONToObject (fix by mpv - thanks!)
    - fixed ticket [4f5df7f18f] - about potential overflow of TSQLRestServerStats
      values (changed to QWord kind of property)
    - implemented feature request [7f6828999d] - about the possibility to use
      standard read/write in conjunction with custom read/write in JSONToObject
      and ObjectToJSON (mpv proposal - thanks!)
    - JSONToObject is now able to un-serialize a TObjectList class, when a class
      for its items is supplied as TObjectListItemClass optional parameter
    - ExtractInlineParameters() and SQLParamContent() decode ':("\uFFF12012-05-04"):'
      inlined parameters (i.e. text starting with JSON_SQLDATE_MAGIC after UTF-8
      encoding) as sftDateTime kind of parameter
    - added TJSONObjectDecoder.DecodedRowID member and fix GPF issue in Decode()
    - change vague boolean parameter into a TSQLOccasion enumerate in
      TJSONObjectDecoder.EncodeAsSQLPrepared()
    - added ForceID: boolean parameter to TSQLRest.AddOne() method
    - fixed random issue in TSQLRest.GetServerTimeStamp method (using wrongly
      TTimeLog direct arithmetic, therefore raising EncodeTime() errors)
    - internal cache added in TSQLRest.GetServerTimeStamp method for better speed
    - added TSQLRest.Retrieve() overloaded method for easy parameter binding
    - added TSQLRest.Delete() overloaded method with a WHERE clause parameter
    - implemented transaction process for (external database) virtual tables
    - added ReplaceRowIDWithID optional parameter to GetJSONObjectAsSQL(), in
      order to allow working with external DB not allowing RowID (e.g. Oracle)
    - TSQLRestCache.Notify*() methods made public for low-level potential use
    - made URI check case-insensitive (as for official RFC)
    - new TPropInfo.GetHash and TPropInfo.SameValue methods, with optional
      case sentivity handling
    - changed TSQLRecordProperties.BlobFieldsBits property into BlobFields,
      as an array of PPropInfo (for faster process)
    - added TSQLRecordProperties.HasTypeFields containing set of field types
      appearing in the record - replaces HasModTimeFields and HasCreateTimeField
    - new TListFieldHash class for efficient O(1) search using hashing handling
    - now unique fields are hashed in TSQLRestServerStaticInMemory implementation:
      "stored: false" properties are now checked for unicity before adding or
      update, and search will use the hash table for very fast O(1) process
    - speed optimization: all TSQLRestServerStaticInMemory search methods will
      now call a generic FindWhereEqual() for better code speed and maintenance
    - added ObjectFromInterface() function working also with TInterfacedObjectFake
    - introducing SetWeak() function to handle Weak interface assignment
    - added SetWeakZero() function and TObject class helper to handle ZEROed
      Weak interface assignment (with small performance penalty and memory use),
      corresponding to the ARC's Zeroing Weak pointers model
    - CopyObject() procedure now handle TCollection kind of object not only
      as sub properties
    - introducing TInterfacedCollection dedicated class, properly handling
      collection item creation on the Server side, with interface-based services:
      all contract operations shall use it instead of TCollection
    - changed the non expanded JSON format to use lowercase first column names:
      {"fieldCount":1,"values":["col1"... instead of {"FieldCount":1,"Values":[..
    - added TSQLTable.FieldLengthMax() and ExpandAsSynUnicode() methods
    - added BlobToBytes() function and TSQLTable.GetBytes/GetStream methods
    - added virtual TSQLRestServer.FlushInternalDBCache method and dedicated
      TSQLRestServerStaticInMemoryExternal class, to properly handle external
      DB modification for virtual tables (i.e. flush SQL/JSON cache as expected)
    - added virtual TSQLRestServer.BeginCurrentThread method
    - added virtual TSQLRestServer.EndCurrentThread method which will be called
      e.g. by TSQLite3HttpServer or TSQLRestServerNamedPipeResponse for each
      terminating threads, to release any thread-specific resources (like
      external DB connections defined in SQlite3DB)
    - added new TServiceMethod.ExecutionOptions member, and the new
      TServiceMethodExecutionOption[s] types - used by ExecuteInMainThread()
    - added TServiceFactoryServer.ExecuteInMainThread() method, to force a method
      to be executed with RunningThread.Synchronize() call on multi-thread server
      instances (e.g. TSQLite3HttpServer or TSQLRestServerNamedPipeResponse)
    - refactoring of TServiceMethod.InternalExecute low-level asm code, and
      changed the Instance parameter to be specified as an open array for
      fast execution over multiple instances of implementation classes
    - 'SELECT *' statements on virtual/external tables will by-pass the SQLite3
      virtual table module: TSQLRecord.FillPrepare can be up to 30% faster -
      added TSQLRestServerStatic.AdaptSQLForEngineList virtual method to
      handle most generic SELECT cases (overridden e.g. in SQLite3DB unit)
    - TSQLRestServerStaticInMemory.GetJSONValues will now generate expanded
      JSON content, if specified (only non-expanded format was implemented),
      via the new TSQLRestServerStaticInMemory.ExpandedJSON property
    - added TSQLRestServerStatic.InternalBatchStart / InternalBatchStop methods
      to handle fast grouped sending to remote database engine (e.g. Oracle
      bound arrays or MS SQL bulk insert via SynDB)
    - fixed issue in TSQLRestClientURI.EngineAdd() when server returned -1
    - changed TSQLRestServerCallBackParams content to be used as a generic
      parameters wrapper for both method callbacks and interface-based services:
      now aParams.Context.ID is to be used instead of aParams.ID
    - added TJSONObjectDecoder record/object helper for JSON object decoding
      (used e.g. by GetJSONObjectAsSQL() function, and for SQlite3DB process)
    - removed TSQLRecordExternal class type, to allow any TSQLRecord (e.g.
      TSQLRecordMany) to be used with VirtualTableExternalRegister() - there was
      indeed no implementation requirement to force a specific class type
    - added aUseBatchMode optional parameter to TSQLRecordMany.ManyDelete() method
    - now JSON parser will handle #1..' ' chars as whitespace (not only ' ')
    - now huge service JSON response is truncated (to default 20 KB) in logs

  Version 1.18
    - full Windows 64 bit compatibility, including RTTI and services
    - renamed SQLite3Commons.pas to mORMot.pas
    - BREAKING CHANGE in TSQLRestServerCallBackParams which is replace by the
      TSQLRestServerURIContext class: in addition, all method-based services
      should be a procedure, and use Ctxt.Results()/Error() methods to return
      any content - new definition of Ctxt features now full access to
      incoming/outgoing context and parameters, especially via
      the new Input*[] properties, for easy URI parameter retrieval, and
      also allow define specific URI routing by a dedicated class
    - BREAKING CHANGE; TSQLRestServerStatic* classes are now renamed as
      TSQLRestStorage* and do not inherit from TSQLRestServer but plain TSQLRest
      for a much cleaner design
    - TSQLRestServer.StaticDataServer[] will now return an abstract TSQLRest
    - URI routing for interface-based service is now specified by the two
      TSQLRestRoutingREST and TSQLRestRoutingJSON_RPC classes (inheriting from
      the abstract TSQLRestServerURIContext class) instead of rmJSON and
      rmJSON_RPC enums - it allows any custom URI routing by inheritance
    - BREAKING CHANGE of TJSONWriter.WriteObject() method and ObjectToJSON()
      function: serialization is now defined with TTextWriterWriteObjectOptions
      set - therefore, TJSONSerializerCustomWriter callback signature changed
    - BREAKING CHANGE of TJSONSerializerCustomReader callback signature, which
      now has an additional aOptions: TJSONToObjectOptions parameter
    - remove some unused TPropInfo methods, which were duplicates of the
      TSQLPropInfo cleaner class hierarchy: SetValue/GetValue/GetValueVar
      GetBinary/SetBinary GetVariant/SetVariant NormalizeValue/SameValue GetHash
      IsSimpleField AppendName GetCaption GetSQLFromFieldValue SetFieldAddr
    - you can now define any custom property and store it as JSON, e.g. TGUID,
      by using overriding InternalRegisterCustomProperties(), or directly as
      record published properties (since Delphi XE6) - see ticket [b653e5f4ca]
    - TSQLRestRoutingREST will now recognize several URI schemes:
      /root/Calculator.Add + body, /root/Calculator.Add?+%5B+1%2C2+%5D,
      or even root/Calculator.Add?n1=1&n2=2 - and /root/Calculator/Add as a
      valid alternative to default /root/Calculator.Add, if needed
    - added optional CustomFields parameter to TSQLRest.Update() - and in case
      of a previous *FillPrepare() call, only the retrieved fields are updated
    - added TSQLRestServer.AcquireExecutionMode[] AcquireExecutionLockedTimeOut[]
      properties, able to define execution plan for all ORM/SOA operations
    - changed RESTful URI to ModelRoot/Table?where=WhereClause to delete members
    - added TSQLRestServer.URIPagingParameters property, to support alternate
      URI parameters sets for request paging (in addition to YUI syntax),
      and an optional "total":... field within the JSON result (calling
      "SELECT count()" may be slow, especially on external databases)
    - deep code refactoring, introducing TSQLPropInfo* classes in order to
      decouple the ORM definitions from the RTTI - will allow definition of
      any class members, even if there is no RTTI generated or via custom
      properties attributes or a fluent interface
    - new TJSONSerializer.RegisterClassForJSON() methods, allowing recognition
      of class types from a new {"ClassName":"TMyObject" JSON field generated
      by ObjectToJSON(..[woStoreClassName]) new option: it will be recognized
      by JSONToObject() for TObjectList members, and by the new JSONToNewObject()
      method - all TSQLRecord classes of a model are automaticaly registered
    - new TJSONSerializer.RegisterCollectionForJSON() method, to register a
      TCollection/TCollectionItem pair and allow JSON serialization of any
      "plain" collection - may be a good alternative to TInterfacedCollection
    - sets including all enumerate values will be written in JSON as "*"
      with woHumanReadable option (and recognized as such e.g. by JSONToObject);
      see also the new TJSONSerializer.AddTypedJSONWithOptions() method
    - interface-based services are now able to work with TObjectList parameters
    - interface-based services will now avoid to transmit the "id":... value
      when ID equals 0
    - interface-based services can now return the result value as JSON object
      instead of JSON array if TServiceFactoryServer.ResultAsJSONObject is set
      (can be useful e.g. when consuming services from JavaScript)
    - added TServiceCustomAnswer.Status member to override default HTML_SUCCESS
    - new TSQLRest.Service<T: IInterface> method to retrieve a service instance
    - added TServiceMethodArgument.AddJSON/AddValueJSON/AddDefaultJSON methods
    - method-based services are now able to handle "304 Not Modified" optimized
      response to save bandwidth, in TSQLRestServerURIContext.Returns/Results
    - added TSQLRestServerURIContext.ReturnFile() method, for direct fast
      transmission to a HTTP client, handling "304 Not Modified" and mime type
    - added TSQLRestServer.ServiceMethodRegisterPublishedMethods() to allow
      multi-class method-based services (e.g. for implementing MVC model)
    - ServiceContext threadvar will now be available also within
      optExecInMainThread and optExecInPerInterfaceThread execution context
    - to make the implicit explicit, TSQLRestServerURIContext.ID has been
      renamed TableID, and a new ServiceInstanceID instance has been added
    - fixed TSQLRestServer.BeginCurrentThread/EndCurrentThread process to be
      triggered as expected (and checking that it is from the thread itself)
    - new function CurrentServiceContext, to be used from packages instead of
      direct ServiceContext threadvar access - circumvent Delphi RTL/compiler
      restriction (bug?) as reported by [155b09dc1b]
    - let TSQLRest.OneFieldValues() handle directly naive expressions like
      'SELECT ID from Table where ID=10' or 'where ID in (10,20,30)'
    - new TSQLRestClientURI.ForceBlobTransfertTable[] property which enable to
      get and set BLOB fields values with usual Add/Update/Retrieve methods for
      a particular table (more tuned than existing ForceBlobTransfert property)
    - added TSQLRestClientURI.SessionID property
    - added new TSQLRestClientURI.RetryOnceOnTimeout property
    - fixed TServiceFactoryClient.Get() not working properly in sicPerSession,
      sicPerUser or sicPerGroup modes - ticket [3fafb53be4]
    - added TServiceInstanceImplementation.sicPerThread mode - feature [cb76c866bb]
    - introduced more readable "stored AS_UNIQUE" published property definition
      in TSQLRecord (via the explicit AS_UNIQUE=false constant)
    - introduced TSQLRecord.Create(aSimpleFields) constructor
    - introduced 32bit/64bit safe TSQLRecord.AsTSQLRecord property, to be used
      when assigning IDs to a TSQLRecord published property
    - TSQLRecord.[CreateAnd]FillPrepare() will now handle aCustomFieldsCSV='*'
      parameter as a all fields selection, including BLOBs (whereas default ''
      value will continue to return simple fields, excluding BLOBs)
    - introducing TSQLRecord.CreateJoined() and CreateAndFillPrepareJoined()
      constructors, to auto-initialize and load nested TSQLRecord properties
    - TSQLRecord.InitializeTable() will now create DB indexes for aUnique
      fields (including ID/RowID)
    - introducing TInterfaceStub and TInterfaceMock classes to define
      high-performance interface stubbing and mocking via a fluent interface
    - integrated Windows Authentication to the mORMot Client-Server layer: in
      order to enable it, define a SSPIAUTH conditional and call
      TSQLRestClientURI.SetUser() with an empty user name, and ensure that
      TSQLAuthUser.LoginName contains a matching 'DomainName\UserName' value
    - Windows Authentication can use either NTLM or the more secure Kerberos
      protocol, if the corresponding SPN domain is set as password
    - feature request [5a17a4277f]: you can now define in the Model your custom
      TSQLAuthUser and/or TSQLAuthGroup classes to store the authorization
      information: TSQLRestServer will search for any table inheriting from
      TSQLAuthUser/TSQLAuthGroup in the TSQLModel - see also corresponding
      TSQLRestServer.SQLAuthUserClass/SQLAuthGroupClass new properties
    - added TSQLRestServer.OnSessionCreate / OnSessionClosed methods
    - added TSQLRestServer.SessionClass property to specify the class type
      to handle in-memory sessions, and override e.g. IsValidURI() method 
    - CreateMissingTables() method is not declared as virtual in TSQLRestServer
    - TSQLRestServer.URI() and TSQLRestClientURI.InternalURI() methods now uses
      one TSQLRestURIParams parameter for all request input and output values
    - TSQLRestServer.URI() method will return "405 Method Not Allowed" error
      (HTML_NOTALLOWED) if the supplied URI does not match RestAccessRights
    - TSQLRestServer.URI() will now handle POST/PUT/DELETE ModelRoot/MethodName
      as method-based services
    - added TSQLRestServerFullMemory.Flush method-based service
    - added TSQLRestServerFullMemory.DropDatabase method
    - completed HTML_* constant list and messages - feature request [d8de3eb76a]
    - handle HTML_NOTMODIFIED as successful status - as expected by [5d2634e8a3]
    - enhanced sllAuth session creation/deletion logged information
    - added TAuthSession.SentHeaders, RemoteIP and ConnectionID properties
    - added process of Variant and WideString types in TSQLRecord properties,
      including any custom type, like TDocVariant or TBSONVariant (for MongoDB
      objects), or even a dynamic array of variants (see [d9d091baab])
    - added JSON serialization of Variant and WideString types, and corresponding
      TJSONToObjectOptions optional parameter in JSONToObject() / ObjectToJSON()
      functions and WriteObject() method - including TDocVariant or TBSONVariant
    - added TTypeInfo.ClassCreate() method to create a TObject instance from RTTI
    - TEnumType.GetEnumNameValue() will now recognize both 'sllWarning' and
      'Warning' text as a sllWarning item (will enhance JSONToObject() process)
    - fix and enhance boolean values parsing from JSON content ("Yes"=true) 
    - implement woHumanReadableFullSetsAsStar and woHumanReadableEnumSetAsComment
      option for JSON serialization and TEnumType.GetEnumNameTrimedAll()
    - fixed potential buffer overflow in TJSONObjectDecoder.EncodeAsSQLPrepared()
    - use GetTickCount64() to fix any issue in case of GetTickCount() overflow -
      some *: cardinal properties are renamed *64: Int64 for consistency
    - added ClassInstanceCreate() function calling any known virtual constructor
    - added GetInterfaceFromEntry() function to speed up interface execution,
      e.g. for TServiceFactoryServer (avoid the RTTI lookup of GetInterface) 
    - added TPropInfo.ClassFromJSON() to properly unserialize TObject properties
    - added TSQLPropInfo.SQLFieldTypeName property
    - fixed [f96cf0fc5d] and [221ee9c767] about TSQLRecordMany JSON serialization
    - fixed issue when retrieving a TSQLRecord containing TSQLRecordMany
      properties with external tables (like 'no such column DestList' error)
      via SQLite3 virtual tables (e.g. for a JOINed query like FillPrepareMany)
    - fixed TInterfacedCollection.GetClass to be defined as a class function
    - TSQLRestClientURINamedPipe and TSQLRestClientURIMessage are now thread-safe
      (i.e. protected by a system mutex) therefore can be called from a
      multi-threaded process, e.g. TSQLRestServer instances as proxies
    - modified named pipe client side to avoid unexpected file not found errors
    - TInterfaceFactory instances are now shared among all interface-based
      features (e.g. services, callbacks or mocks/stubs), in a thread-safe cache
    - added dedicated EInterfaceFactoryException
    - added TServiceFactoryServer.TimeoutSec / SetTimeoutSec() property / method 
    - TServiceFactoryServer.ExecuteInMainThread() method is now replaced by
      a more generic TServiceFactoryServer.SetOptions() method
    - new optFreeInMainThread execution options for the service, allowing server
      side service class instance release via Synchronize() - ticket [57bea48f30]
    - new optExecInPerInterfaceThread and optFreeInPerInterfaceThread options
      for the service, allowing server side service class instance execution and
      release in a thread dedicated to the interface - ticket [8307f8a547]
    - new optExecLockedPerInterface option for the service, allowing server side
      service instance execution and release to be locked for the whole interface
    - added TServiceFactoryServer.ByPassAuthentication property to release
      authentication for a given interface-based service
    - new TInterfaceFactory.CreateFakeInstance() method for easy mocking of
      any interface, via some event callbacks
    - stub creation speed-up by using a shared PAGE_EXECUTE_READWRITE buffer
    - added TServiceMethod.DefaultResult property, to be used for stubs/mocks
    - TServiceFactory.Create() and its children will now always have an optional
      aContractExpected parameter (for consistency with TServiceFactoryClient)
    - introduce smvVariant kind of parameter for interface-based services
    - new RawJSON string type to force no JSON serialization in interface-based
      services (to be used e.g. for transmitting TSQLTableJSON results)
    - safer TInterfacedObjectFake.FakeCall() stack use
    - TServiceFactoryServerInstance will now create instances server-side
      with a RefCount=1, to allow passing self as an interface in sub-methods
    - huge code refactoring of the ORM model implementation: a new dedicated
      TSQLModelRecordProperties will contain per-TSQLModel parameters, whereas
      shared information retrieved by RTTI remain in TSQLRecordProperties - this
      will allow use of the same TSQLRecord in several TSQLModel at once, with
      dedicated SQL auto-generation and external DB settings
    - added aExternalTableName/Database optional parameters to method
      TSQLModel.VirtualTableRegister()
    - added Owner, Actions, Events parameters to TSQLModel.Create() constructor
    - fixed issue in TSQLRestServer.Create() about authentication enabling
    - added TSQLModel.GetTableIndexExisting() method to raise an explicit
      EModelException if the table is not part of the model - used now by
      almost all CRUD Client and Server operations - ticket [aa0d6f1e90]
    - added TSQLModel.URIMatch() method to allow sub-domains generic matching
      at database model level (so that you can set root='/root/sub1' URIs)
    - moved SQLFromSelectWhere() from a global function to a TSQLModel method
      (to prepare "Table per class hierarchy" mapping in mORMot)
    - SQLParamContent() / ExtractInlineParameters() functions moved to SynCommons
    - added TSQLRecordHistory and TSQLRestServer.TrackChanges() for [a78ffe992b] 
    - TSQLAuthUser and TSQLAuthGroup have now "index ..." attributes to their
      RawUTF8 properties, to allow direct handling in external databases
    - new protected TSQLRestServer.InternalAdaptSQL method, extracted from URI()
      process to also be called by TSQLRestServer.MultiFieldValues() for proper
      TSQLRestStorage.AdaptSQLForEngineList(SQL) call
    - new TSQLRestStorage.fOutInternalStateForcedRefresh protected field to
      optionally force the refresh of the content
    - new TSQLRestServer.OnBlobUpdateEvent: TNotifyFieldSQLEvent event handler
      to implement feature request [4cafc41f67]
    - new protected TSQLRestServer.InternalUpdateEvent virtual method, to allow
      a server-wide update notification, not coupled to OnUpdateEvent callback -
      see feature request [5688e97251]
    - TSQLRestStorageInMemory.AdaptSQLForEngineList() will now handle
      'select count(*') from TableName' statements directly, and any RESTful
      requests from client
    - TSQLRestStorageInMemory will now handle SELECT .... WHERE ID IN (...)
    - fixed issue in TSQLRestStorageInMemory.EngineList() when only ID
    - added TSQLRestServerFullMemory.Storage[] and Storages[] properties
    - changed TSQLAccessRights and TSQLAuthGroup.SQLAccessRights CSV format
      to use 'first-last,' pattern to regroup set bits (reduce storage size)
    - added overloaded TSQLAccessRights.Edit() method using TSQLOccasions set
    - added reOneSessionPerUser kind of remote execution in TSQLAccessRight
    - enabled reUrlEncodedSQL by default for TSQLAccessRights (needed e.g. for
      plain HTTP GET request, without any body)
    - introducing TSQLRestClientURI.InternalCheckOpen/InternalClose methods to
      properly handle remote connection and re-connection
    - added TSQLRestClientURI.LastErrorCode/LastErrorMessage/LastErrorException
      properties, to retrieve additional information about remote URI() execution
    - added TSQLRestClientURI.ServiceRegister() and ServiceRegisterClientDriven()
      methods for easier Client-side interface-based services initialization
    - added JSONFileToObject() and ObjectToJSONFile() functions
    - unit interface deep refactoring: e.g. now TSQLTable will refers explicitly
      to TSQLRecord classes and not to plain TClass (e.g. for QueryTables[])
    - introducing new TSQLTable[JSON].CreateFromTables/CreateWithColumnTypes() 
      constructors, able to specify the column type information to be used
    - added TSQLTable.SetFieldType() method to specify a column type and size
    - added TSQLTable.SortFields() overloaded method, able to sort a TSQLTable
      row content by multiple fields - implements feature request [d277153f03]
    - added optional CustomFormat: string parameter to TSQLTable.ExpandAsString()
      to allow numerical or date/time format for a given column [749dfbdb6a]
    - added optional CustomCompare: TUTF8Compare param to TSQLTable.SortFields()
      to allow any kind of custom ordering - feature request [c6804d48a4]
    - speed up of TSQLTable.FieldIndex() method (using binary search)
    - added TSQLTable.ToObjectList() and ToObjectList<T: TSQLRecord>() methods
    - added TSQLTable.Step(), FieldBuffer() and Field() methods, handling a
      cursor at TSQLTable level, with optional late-binding column access
    - added TSQLTable.GetSynUnicode() method
    - added TSQLTable.ToDocVariant() and TSQLRest.RetrieveDocVariantArray()
      overloaded methods, which can be used e.g. to process directly some data
      retrieved from the ORM with TSynMustache.Render()
    - added TSQLRecord.CreateAndFillPrepare(aJSON) overloaded method
    - introducing TSQLRecordInterfaced class, if your TSQLRecord definition
      should be able to implement interfaces
    - now Batch*() methods are available at TSQLRest level, so will work
      for TSQLRestClientURI and TSQLRestServer classes (not TSQLRestStorage)
    - added optional CustomFields parameter to TSQLRest.BatchUpdate()
      and BatchAdd() methods - TModTime fields will always be sent
    - implemented automatic transaction generation during BATCH process via
      a new AutomaticTransactionPerRow parameter in BatchStart()
    - fixed unexpected issue in TSQLRest.BatchSend() when nothing is to be sent
    - added TSQLRestClientURI.ServerTimeStampSynchronize method to force time
      synchronization with the server - can be handy to test the connection
    - added TSQLRest.TableHasRows/TableRowCount methods, and overridden direct
      implementation for TSQLRestServer/TSQLRestStorageInMemory (including
      SQL pattern recognition for TSQLRestStorageInMemory)
    - added TSQLRest.RetrieveList method to retrieve a TObjectList of TSQLRecord
    - added TSQLRest.RetrieveList<T> generic method to retrieve a TObjectList<T>
    - added TSQLRest.UpdateField() overloaded methods to update a single field
    - "rowCount": is added in TSQLRestStorageInMemory.GetJSONValues,
      TSQLTable.GetJSONValues and in TSQLTableJSON.ParseAndConvert, at the end
      of the non expanded JSON content, if needed - improves client performance
    - UpdateBlobFields() and RetrieveBlobFields() methods are now defined at
      TSQLRest level, with dedicated implementation for TSQLRestClient* and
      TSQLRestServer* classes - implements feature request [34664934a9]
    - fixed TSQLRestStorageInMemory.UpdateBlobFields() to return true
      if no BLOB field is defined (as with TSQLRestServer) - ticket [bfa13889d5]
    - fixed issue in TSQLRestStorageInMemory.GetJSONValues(), and handle
      optional LIMIT clause in this very same method
    - fix potential GDI handle resource leak in TSQLRestClientURIMessage.Create
    - introducing TSQLRestClientURIMessage.DoNotProcessMessages property
    - TSQLRestClientURINamedPipe.InternalCheckOpen/InternalURI refactoring
    - added TInterfacedObjectWithCustomCreate kind of class, making easy to
      use virtual constructors for TSQLRestServer.ServiceRegister()
    - allow TSQLRestServer.ServiceRegister() to register an existing instance
      of a class for a shared service - feature request [6e8b2ff3e9]
    - added TPersistentWithCustomCreate kind of class, allowing to use virtual
      constructors for TPersistent kind of objects (to be used e.g. with
      internal JSON serialization and interface-based services) 
    - allow TSQLRestServer.ExportServerMessage to be started in conjunction
      with other protocols (like named pipes)
    - added STATICFILE_CONTENT_TYPE[_HEADER] as aliases to HTTP_RESP_STATICFILE
      as defined in SynCrtSock.pas unit, for generic handling
    - added TSQLRestServerStats.CurrentThreadCount
    - now TSQLRestServerStats.ClientsMax/ClientsCurrent will reflect session
      authentication process, and OutcomingFiles the number of files
      transmitted via OutContentType=STATICFILE_CONTENT_TYPE/HTTP_RESP_STATICFILE
      (feature request [4a2433c045])
    - fixed potential errors JSON generation issue in TSQLRestServer.URI
      (ticket [b0e9116aeb])
    - TSQLRestServer.LaunchCallBack() is now inlined in TSQLRestServer.URI()
    - fixed ticket [a5e3564e48] about RecordRef typecast (and enhance comments)
    - fixed ticket [4f4dd18ad9] about TPropInfo.IsStored not handling methods
      callbacks, e.g. for TPersistent storage
    - fixed ticket [21c2d5ae96] when inserting/updating blob-only table content
    - fixed ticket [7e9f06bf1a] to let TSQLTable.FieldLengthMax() use caption
      text for enumeration columns
    - fixed ticket [28545a4ce0] about TSQLRestStorageInMemory.EngineDelete
      not thread-safe when run directly on server side
    - fixed ticket [027bb9678d] - now TSQLRecordRTree class works as expected
    - fixed ticket [876a097316] about TSQLRest.Add() when ForcedID<>0
    - implement ticket [e3f9742865] for enhanced JSON in woHumanReadable mode
    - fixed GPF issue in TServiceFactoryServer after instance time-out deletion
    - added TSQLPropInfo.PropertyIndex member
    - added TSQLRecordProperties.SimpleFieldsCount[] array
    - added TSQLRecordProperties.BlobFieldsBits field index map and new
      TSQLRecordProperties.FieldIndexsFromBlobField() method
    - added TSQLRecordProperties.FieldIndexsFromCSV()/FieldIndexsFromRawUTF8()
      methods (with functions ready to be used e.g. in BatchAdd/BatchUpdate)
    - added TSQLRecordProperties.RegisterCustomFixedSizeRecordProperty() and
      RegisterCustomRTTIRecordProperty() methods
    - added TSQLRecordProperties.SetCustomCollationForAllRawUTF8() +
      SetCustomCollation() methods, and TSQLModel.SetCustomCollationForAllRawUTF8()
      to implement ticket [bfdc198e70]
    - fixed issue in TSQLRecordProperties.SetSimpleFieldsExpandedJSONWriter()
      when the record contains some TCreateTime published field type
    - added TSQLTable.GetAsInt64() method (proposal [3bea5d89c6])
    - added TSQLTable.GetAsFloat() GetAsCurrency() GetAsDateTime() methods
    - JSON parsing will now expect true, false or null to be in lowercase
      (as in json.org specifications)
    - SetWeakZero() function will now use a much faster per-class lock design
    - exposed StatusCodeToErrorMsg() function
    - extraction of TTestLowLevelTypes and TTestBasicClasses code into
      SynSelfTests.pas unit
    - allow only to delete its own session - security fix for ticket [7723fa7ebd]
    - variant published properties will use getter/setter - ticket [479938b694]
    - double/currency published properties will use getter/setter as expected
    - fix TSQLRestClientURI.Commit/RollBack to work as expected
    - introducing TSQLRestServer.AuthenticationRegister/AuthenticationUnregister
      methods and associated TSQLRestServerAuthentication* classes, used also by
      TSQLRestClientURI.SetUser() to allow generic class-driven authentication
      schemes for feature request [8c8a2a880c]
    - new TSQLRestServerAuthenticationNone weak but simple method
    - force almost-random session ID for TSQLRestServer to avoid collision
      after server restart
    - stronger client-generated nonce for TSQLRestServerAuthenticationDefault
    - introducing TSQLRestServerKind enumeration to identify the kind of
      TSQLRestServer instance running (SQlite3/static/virtual) for a table
    - TSQLRestServer.SessionGetUser method is now made public (e.g. when
      calling CurrentServiceContext.Factory.RestServer.SessionGetUser)
    - added TSQLRestClientURI.OnIdle property, to enable more responsive
      User Interface in case of slow network - feature request [68337ae98a]
    - replaced confusing TVarData by a new dedicated TSQLVar memory structure,
      shared with SynDB and mORMotSQLite3 units (includes methods refactoring)

*)


{$I Synopse.inc} // define HASINLINE USETYPEINFO CPU32 CPU64

{.$define PUREPASCAL}  // define for debugg, not on production
{.$define USETYPEINFO} // define for debugg, not on production

{$ifdef MSWINDOWS}

  {.$define ANONYMOUSNAMEDPIPE}
  // if defined, the security attributes of the named pipe will use an
  // anonymous connection - it should allow access to a service initialized
  // named pipe on a remote computer.
  // - I tried to implement the code as detailed in this Microsoft article:
  // http://support.microsoft.com/kb/813414 but it didn't work as
  // expected: see our forum http://synopse.info/forum/viewtopic.php?id=43
  // - don't define it, because it's still buggy, and consider using HTTP
  // connection for remote access over the network
    {$define NOSECURITYFORNAMEDPIPECLIENTS}
    // define this may avoid issues with Delphi XE+ for obscure reasons


  {$define SSPIAUTH}
  // if defined, the Windows built-in authentication will be used
  // along with the usual one
  // - If you pass to TSQLRestClientURI.SetUser an empty string as user name,
  // the Windows authentication will be performed
  // - In this case, in table TSQLAuthUser should be an entry for the
  // windows user, with the LoginName in form 'DomainName\UserName'

{$endif}


interface

uses
{$ifdef MSWINDOWS}
  Windows,
  Messages,
{$endif}
{$ifdef LINUX} // for Kylix
  Libc,
  Types,
{$endif}
{$ifdef UNICODE}
  Generics.Collections,
{$endif}
  Classes,
  SynZip, // use crc32 for TSQLRestClientURI.SetUser
{$ifdef USETYPEINFO}
  // some pure pascal version must handle the 64-bits ordinal values or
  // a not-Delphi RTTI layout of the underlying compiler (e.g. FPC)
  TypInfo,
{$endif}
{$ifndef LVCL}
  Contnrs,  // for TObjectList
  {$ifndef NOVARIANTS}
    Variants,
  {$endif}
{$endif}
  SysUtils,
{$ifdef SSPIAUTH}
  SynSSPIAuth,
{$endif}
  SynCommons;



{ ************ low level types and constants for handling JSON and fields }

  { Why use JSON? (extracted from the main framework documentation)
    - The JavaScript Object Notation (JSON) is a lightweight computer data
     interchange format
    - Like XML, it's a text-based, human-readable format for representing
     simple data structures and associative arrays (called objects)
    - It's easier to read, quicker to implement and smaller in size than XML
    - It's a very efficient format for cache
    - It's natively supported by the JavaScript language, making it a perfect
     serialization format for any Ajax application
    - The JSON format is specified in http://tools.ietf.org/html/rfc4627
    - The default text encoding for both JSON and SQLite3 is UTF-8, which
     allows the full Unicode charset to be stored and communicated
    - It is the default data format used by ASP.NET AJAX services created in
     Windows Communication Foundation (WCF) since .NET framework 3.5
    - For binary blob transmission, we simply encode the binary data as hexa
     using the SQLite3 BLOB literals format : hexadecimal data preceded by
     a single "x" or "X" character (for example: X'53514C697465'), or Base64
     encoding - see BlobToTSQLRawBlob() function }


const
  /// maximum number of Tables in a Database Model
  // - this constant is used internaly to optimize memory usage in the
  // generated asm code
  // - you should not change it to a value lower than expected in an existing
  // database (e.g. as expected by TSQLAccessRights or such)
  MAX_SQLTABLES = 256;


type
  /// used to store bit set for all available Tables in a Database Model
  TSQLFieldTables = set of 0..MAX_SQLTABLES-1;

  /// a String used to store the BLOB content
  // - equals RawByteString for byte storage, to force no implicit charset
  // conversion, thatever the codepage of the resulting string is
  // - will identify a sftBlob field type, if used to define such a published
  // property
  // - by default, the BLOB fields are not retrieved or updated with raw
  // TSQLRest.Retrieve() method, that is "Lazy loading" is enabled by default
  // for blobs, unless TSQLRestClientURI.ForceBlobTransfert property is TRUE
  // (for all tables), or ForceBlobTransfertTable[] (for a particular table);
  // so use RetrieveBlob() methods for handling BLOB fields
  TSQLRawBlob = type RawByteString;

  /// a reference to another record in any table in the database Model
  // - stored as an 32 bits unsigned integer (i.e. a pointer=TObject)
  // - type cast any value of TRecordReference with the RecordRef object below
  // for easy access to its content
  // - use TSQLRest.Retrieve(Reference) to get a record value
  // - don't change associated TSQLModel tables order, since TRecordReference
  // depends on it to store the Table type in its highest bits
  // - when the pointed record will be deleted, this property will be set to 0
  // by TSQLRestServer.AfterDeleteForceCoherency()
  TRecordReference = type PtrUInt;

  /// a reference to another record in any table in the database Model
  // - stored as an 32 bits unsigned integer (i.e. a pointer=TObject)
  // - type cast any value of TRecordReference with the RecordRef object below
  // for easy access to its content
  // - use TSQLRest.Retrieve(Reference) to get a record value
  // - don't change associated TSQLModel tables order, since TRecordReference
  // depends on it to store the Table type in its highest bits
  // - when the pointed record will be deleted, any record containg a matching
  // property will be deleted by TSQLRestServer.AfterDeleteForceCoherency()
  TRecordReferenceToBeDeleted = type TRecordReference;

  /// an Int64-encoded date and time of the latest update of a record
  // - can be used as published property field in TSQLRecord for sftModTime:
  // if any such property is defined in the table, it will be auto-filled with
  // the server timestamp corresponding to the latest record update
  // - use internally for computation an abstract "year" of 16 months of 32 days
  // of 32 hours of 64 minutes of 64 seconds - faster than TDateTime
  // - use TimeLogFromDateTime/TimeLogToDateTime/TimeLogNow/Iso8601ToTimeLog
  // functions, or type-cast the value with a TTimeLogBits memory structure for
  // direct access to its bit-oriented content (or via PTimeLogBits pointer)
  TModTime = type TTimeLog;

  /// an Int64-encoded date and time of the record creation
  // - can be used as published property field in TSQLRecord for sftCreateTime:
  // if any such property is defined in the table, it will be auto-filled with
  // the server timestamp corresponding to the record creation
  // - use internally for computation an abstract "year" of 16 months of 32 days
  // of 32 hours of 64 minutes of 64 seconds - faster than TDateTime
  // - use TimeLogFromDateTime/TimeLogToDateTime/TimeLogNow/Iso8601ToTimeLog
  // functions, or type-cast the value with a TTimeLogBits memory structure for
  // direct access to its bit-oriented content (or via PTimeLogBits pointer)
  TCreateTime = type TTimeLog;

  /// the available types for any SQL field property, as managed with the
  // database driver
  TSQLFieldType = (
    /// unknown or not defined field type
    sftUnknown,
    /// a WinAnsi encoded TEXT: force a NOCASE collation
    // (TSQLRecord Delphi property was declared as AnsiString or string before
    // Delphi 2009)
    sftAnsiText,
    /// UTF-8 encoded TEXT: force a SYSTEMNOCASE collation, i.e. using UTF8IComp()
    // (TSQLRecord property was declared as RawUTF8, RawUnicode or WideString -
    // or string in Delphi 2009+)
    sftUTF8Text,
    /// an INTEGER value corresponding to an index in any enumerate Delphi type
    // - storage is an INTEGER value (fast, easy and storage efficient)
    // - display convert this integer index into the left-trimed lowercased chars
    // of the enumerated type text conversion: TOpenType(1) = otDone -> 'Done'
    sftEnumerate,
    // an INTEGER value corresponding to a bitmaped set of enumeration
    // - storage is an INTEGER value (fast, easy and storage efficient)
    // - displayed as an integer by default
    // - sets with an enumeration type with up to 32 elements is allowed 
    sftSet,
    /// an INTEGER (Int64 precision, as expected by SQLite3) field
    sftInteger,
    /// an INTEGER field pointing to the ID/ROWID of another record of a table
    // defined by the class type of the TSQLRecord inherited property
    // - coherency is always ensured: after a delete, all values pointing to
    // it is reset to 0
    sftID,
    /// an INTEGER field pointing to the ID/ROWID of another record
    // (TRecordReference=PtrUInt Delphi property which can be typecasted to RecordRef)
    // - coherency is always ensured: after a delete, all values pointing to
    // it is reset to 0
    sftRecord,
    /// an INTEGER field for a boolean value: 0 is FALSE, anything else TRUE
    // (encoded as JSON 'true' or 'false' constants)
    sftBoolean,
    /// a FLOAT (floating point double precision, cf. SQLite3) field
    sftFloat,
    /// a ISO 8601 encoded TEXT field - SQLite3 compatible;
    // - a ISO8601 collation is forced 
   	// - corresponds to a TDateTime Delphi property
    sftDateTime,
    /// an INTEGER field for coding a date and time - not SQLite3 compatible
    // - TTimeLog=Int64 Delphi property which can be typecasted to Iso8601
    sftTimeLog,
    /// a FLOAT containing a 4 decimals floating point value
    // (Currency Delphi property minimizes rounding errors in monetary
    // calculations which may occur with sftFloat type)
    sftCurrency,
    /// a TEXT containing an ObjectToJSON serialization
    // - able to handle published properties of any not TPersistent as JSON object,
    // TStrings or TRawUTF8List  as JSON arrays of strings, TCollection or
    // TObjectList as JSON arrays of JSON objects
    sftObject,
    {$ifndef NOVARIANTS}
    /// a TEXT containing a variant value encoded as JSON
    // - string values are stored between quotes, numerical values directly
    // - JSON objects or arrays will be handled as TDocVariant custom types  
    sftVariant,
    {$endif}
    /// a BLOB field (TSQLRawBlob Delphi property)
    // - not retrieved by default
    sftBlob,
    /// a dynamic array, stored as BLOB field
    // - is retrieved by default, i.e. is recognized as a "simple" field
    // - will use Base64 encoding in JSON content, or a true JSON array,
    // depending on the database back-end (e.g. MongoDB)
    sftBlobDynArray,
    /// a custom property, stored as BLOB field
    // - defined by overriding TSQLRecord.InternalRegisterCustomProperties
    // virtual method, and adding a TSQLPropInfoCustom instance
    sftBlobCustom,
    /// a custom property, stored as JSON in a TEXT field
    // - defined by overriding TSQLRecord.InternalRegisterCustomProperties
    // virtual method, and adding a TSQLPropInfoCustom instance, e.g. via
    // RegisterCustomPropertyFromTypeName() or RegisterCustomPropertyFromRTTI()
    sftUTF8Custom,
    /// a 'many to many' field (TSQLRecordMany Delphi property)
    // - nothing is stored in the table row, but in a separate pivot table: so
    // there is nothing to retrieve here
    // - in contrast to other TSQLRecord properties, which contains an INTEGER
    // ID, the TSQLRecord.Create will instanciate a TSQLRecordMany instance
    // to handle this pivot table via its dedicated ManyAdd/FillMany/ManySelect methods
    sftMany,
    /// an INTEGER field containing the TModTime time of the record latest update
    // - TModTime=TCreateTime=TTimeLog=Int64 Delphi property which can be
    // typecasted to TTimeLogBits memory structure
    // - the value of this field is automatically updated with the current
    // date and time each time a record is updated (with external DB, it will
    // use the Server time, as retrieved from SynDB) - see ComputeFieldsBeforeWrite
    // virtual method of TSQLRecord
    // - note only RESTful PUT/POST access will change this field value: manual
    // SQL statements (like 'UPDATE Table SET Column=0') won't change its content
    // - note also that this is automated on Delphi client side, so only within
    // TSQLRecord ORM use (an AJAX application should handle this explicitely)
    sftModTime,
    /// an INTEGER field containing the TCreateTime time of the record creation
    // - TModTime=TCreateTime=TTimeLog=Int64 Delphi property which can be
    // typecasted to TTimeLogBits memory structure
    // - the value of this field is automatically updated with the current
    // date and time when the record is created (with external DB, it will
    // use the Server time, as retrieved from SynDB) - see ComputeFieldsBeforeWrite
    // virtual method of TSQLRecord
    // - note only RESTful PUT/POST access will set this field value: manual
    // SQL statements (like 'INSERT INTO Table ...') won't set its content
    // - note also that this is automated on Delphi client side, so only within
    // TSQLRecord ORM use (an AJAX application should handle this explicitely)
    sftCreateTime);

  /// set of available SQL field property types
  TSQLFieldTypes = set of TSQLFieldType;

  //// a fixed array of SQL field property types
  TSQLFieldTypeArray = array[0..MAX_SQLFIELDS] of TSQLFieldType;

  /// contains the parameters used for sorting
  // - FieldCount is 0 if was never sorted
  // - used to sort data again after a successfull data update with TSQLTableJSON.FillFrom()
  TSQLTableSortParams = record
    FieldCount, FieldIndex: integer;
    FieldType: TSQLFieldType;
    Asc: boolean;
  end;

  /// used to define the triggered Event types for TNotifySQLEvent
  // - some Events can be triggered via TSQLRestServer.OnUpdateEvent when
  // a Table is modified, and actions can be authorized via overriding the
  // TSQLRest.RecordCanBeUpdated method
  // - OnUpdateEvent is called BEFORE deletion, and AFTER insertion or update; it
  // should be used only server-side, not to synchronize some clients: the framework
  // is designed around a stateless RESTful architecture (like HTTP/1.1), in which
  // clients ask the server for refresh (see TSQLRestClientURI.UpdateFromServer)
  // - is used also by TSQLRecord.ComputeFieldsBeforeWrite virtual method
  TSQLEvent = (
    seAdd,
    seUpdate,
    seDelete,
    seUpdateBlob);

  /// used to defined the CRUD associated SQL statement of a command
  // - used e.g. by TSQLRecord.GetJSONValues methods and SimpleFieldsBits[] array
  // (in this case, soDelete is never used, since deletion is global for all fields)
  // - also used for cache content notification
  TSQLOccasion = (
    soSelect,
    soInsert,
    soUpdate,
    soDelete);

  /// used to defined a set of CRUD associated SQL statement of a command
  TSQLOccasions = set of TSQLOccasion;

const
  /// kind of fields not retrieved during normal query, update or adding
  NOT_SIMPLE_FIELDS: TSQLFieldTypes =
    [sftUnknown, sftBlob, sftMany];

  /// kind of fields which can be copied from one TSQLRecord instance to another
  COPIABLE_FIELDS: TSQLFieldTypes =
    [low(TSQLFieldType)..high(TSQLFieldType)] - [sftUnknown, sftMany];

  /// kind of fields which will contain TEXT content when converted to JSON
  TEXT_FIELDS: TSQLFieldTypes =
    [sftAnsiText, sftUTF8Text, sftDateTime, sftObject, sftUTF8Custom
      {$ifndef NOVARIANTS}, sftVariant{$endif}];

type
  /// define how TJSONObjectDecoder.Decode() will handle JSON string values
  TJSONObjectDecoderParams = (pInlined, pQuoted, pNonQuoted);

  /// record/object helper to handle JSON object decoding
  // - used e.g. by GetJSONObjectAsSQL() function or TSQLRestStorageExternal
  // ExecuteFromJSON and InternalBatchStop methods
  TJSONObjectDecoder = {$ifdef UNICODE}record{$else}object{$endif}
    /// contains the decoded field names or value
    FieldNames, FieldValues: array[0..MAX_SQLFIELDS-1] of RawUTF8;
    /// Decode() will set each field type approximation
    // - will recognize also JSON_BASE64_MAGIC/JSON_SQLDATE_MAGIC prefix
    FieldTypeApproximation: array[0..MAX_SQLFIELDS-1] of
      (ftaNumber,ftaBoolean,ftaString,ftaDate,ftaNull,ftaBlob,ftaObject,ftaArray);
    /// number of fields decoded in FieldNames[] and FieldValues[]
    FieldCount: integer;
    /// size of the TEXT data (in bytes) in FieldValues[]
    FieldValueLen: integer;
    /// size of the TEXT data (in bytes) in FieldNames[]
    FieldNameLen: integer;
    /// set to TRUE if parameters are to be :(...): inlined
    InlinedParams: boolean;
    /// internal pointer over field names to be used after Decode() call
    // - either FieldNames, either Fields[] array as defined in Decode()
    DecodedFieldNames: PRawUTF8Array;
    /// the ID=.. value as sent within the JSON object supplied to Decode()
    DecodedRowID: integer;
    /// decode the JSON object fields into FieldNames[] and FieldValues[]
    // - if Fields=nil, P should be a true JSON object, i.e. defined
    // as "COL1"="VAL1" pairs, stopping at '}' or ']'; otherwise, Fields[]
    // contains column names and expects a JSON array as "VAL1","VAL2".. in P
    // - P returns the next object start or nil on unexpected end of input
    // - FieldValues[] strings will be quoted and/or inlined depending on Params
    // - if RowID is set, a RowID column will be added within the returned content
    procedure Decode(var P: PUTF8Char; const Fields: TRawUTF8DynArray;
      Params: TJSONObjectDecoderParams; RowID: integer=0; ReplaceRowIDWithID: Boolean=false); overload;
    /// decode the JSON object fields into FieldNames[] and FieldValues[]
    // - overloaded method expecting a RawUTF8 buffer, calling Decode(P: PUTF8Char)
    procedure Decode(JSON: RawUTF8; const Fields: TRawUTF8DynArray;
      Params: TJSONObjectDecoderParams; RowID: Integer=0; ReplaceRowIDWithID: Boolean=false); overload;
    /// encode as a SQL-ready INSERT or UPDATE statement
    // - after a successfull call to Decode()
    // - escape SQL strings, according to the official SQLite3 documentation
    // (i.e. ' inside a string is stored as '')
    // - if InlinedParams was TRUE, it will create prepared parameters like
    // 'COL1=:("VAL1"):, COL2=:(VAL2):'
    // - called by GetJSONObjectAsSQL() function or TSQLRestStorageExternal
    function EncodeAsSQL(Update: boolean): RawUTF8;
    /// encode as a SQL-ready INSERT or UPDATE statement with ? as values
    // - after a successfull call to Decode()
    // - FieldValues[] content will be ignored
    // - Occasion can be only soInsert or soUpdate
    // - for soInsert, it will create an INSERT with multiple VALUES if
    //  MultipleInsertCount>1, like 'INSERT ... VALUES (?,?), (?,?), ....'
    // - for soUpdate, will create UPDATE ... SET ... where UpdateIDFieldName=? 
    function EncodeAsSQLPrepared(const TableName: RawUTF8; Occasion: TSQLOccasion;
      const UpdateIDFieldName: RawUTF8; MultipleInsertCount: integer=0): RawUTF8;
    /// set the specified array to the fields names
    // - after a successfull call to Decode()
    procedure AssignFieldNamesTo(var Fields: TRawUTF8DynArray);
    /// returns TRUE if the specified array match the decoded fields names
    // - after a successfull call to Decode()
    function SameFieldNames(const Fields: TRawUTF8DynArray): boolean;
  end;

/// decode JSON fields object into an UTF-8 encoded SQL-ready statement
// - this function decodes in the P^ buffer memory itself (no memory allocation
// or copy), for faster process - so take care that it is an unique string
// - P contains the next object start or nil on unexpected end of input
// - if Fields is void, expects expanded "COL1"="VAL1" pairs in P^, stopping at '}' or ']'
// - otherwise, Fields[] contains the column names and expects "VAL1","VAL2".. in P^
// - returns 'COL1="VAL1", COL2=VAL2' if UPDATE is true (UPDATE SET format)
// - returns '(COL1, COL2) VALUES ("VAL1", VAL2)' otherwise (INSERT format)
// - escape SQL strings, according to the official SQLite3 documentation
// (i.e. ' inside a string is stored as '')
// - if InlinedParams is set, will create prepared parameters like
// 'COL1=:("VAL1"):, COL2=:(VAL2):'
// - if RowID is set, a RowID column will be added within the returned content
function GetJSONObjectAsSQL(var P: PUTF8Char; const Fields: TRawUTF8DynArray;
  Update, InlinedParams: boolean; RowID: Integer=0; ReplaceRowIDWithID: Boolean=false): RawUTF8; overload;

/// decode JSON fields object into an UTF-8 encoded SQL-ready statement
// - is used mainly by TSQLRestServerDB.EngineAdd/EngineUpdate methods
// - expect JSON expanded object as "COL1"="VAL1",...} pairs
// - make its own temporary copy of JSON data before calling GetJSONObjectAsSQL() above
// - returns 'COL1="VAL1", COL2=VAL2' if UPDATE is true (UPDATE SET format)
// - returns '(COL1, COL2) VALUES ("VAL1", VAL2)' otherwise (INSERT format)
// - if InlinedParams is set, will create prepared parameters like 'COL2=:(VAL2):'
// - if RowID is set, a RowID column will be added within the returned content
function GetJSONObjectAsSQL(JSON: RawUTF8; Update, InlinedParams: boolean;
  RowID: Integer=0; ReplaceRowIDWithID: Boolean=false): RawUTF8; overload;

/// get the FIRST field value of the FIRST row, from a JSON content
// - e.g. useful to get an ID without converting a JSON content into a TSQLTableJSON
function UnJSONFirstField(var P: PUTF8Char): RawUTF8;

/// returns TRUE if the JSON content is in expanded format
// - i.e. as plain [{"ID":10,"FirstName":"John","LastName":"Smith"}...]
// - i.e. not as '{"fieldCount":3,"values":["ID","FirstName","LastName",...']}
function IsNotAjaxJSON(P: PUTF8Char): Boolean;

/// retrieve a JSON '{"Name":Value,....}' object
// - P is nil in return in case of an invalid object
// - returns the UTF-8 encoded JSON object, including first '{' and last '}'
// - if ExtractID is set, it will contain the "ID":203 field value, and this
// field won't be included in thre resulting UTF-8 encoded JSON object (will
// expect this "ID" property to be the FIRST in the "Name":Value pairs
function JSONGetObject(var P: PUTF8Char; ExtractID: PInteger;
  var EndOfObject: AnsiChar): RawUTF8;

/// fill a TSQLRawBlob from TEXT-encoded blob data
// - blob data can be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.) or
// or Base-64 encoded content ('\uFFF0base64encodedbinary') or plain TEXT
function BlobToTSQLRawBlob(P: PUTF8Char): TSQLRawBlob; overload;

/// fill a TSQLRawBlob from TEXT-encoded blob data
// - blob data can be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.) or
// or Base-64 encoded content ('\uFFF0base64encodedbinary') or plain TEXT
function BlobToTSQLRawBlob(const Blob: RawByteString): TSQLRawBlob; overload;

/// create a TBytes from TEXT-encoded blob data
// - blob data can be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.) or
// or Base-64 encoded content ('\uFFF0base64encodedbinary') or plain TEXT
function BlobToBytes(P: PUTF8Char): TBytes;

/// create a memory stream from TEXT-encoded blob data
// - blob data can be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.) or
// or Base-64 encoded content ('\uFFF0base64encodedbinary') or plain TEXT
// - the caller must free the stream instance after use
function BlobToStream(P: PUTF8Char): TStream;

/// creates a TEXT-encoded version of blob data from a TSQLRawBlob
// - TEXT will be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.)
function TSQLRawBlobToBlob(const RawBlob: TSQLRawBlob): RawUTF8; overload;
  {$ifdef HASINLINE}inline;{$endif}

/// creates a TEXT-encoded version of blob data from a memory data
// - same as TSQLRawBlob, but with direct memory access via a pointer/byte size pair
// - TEXT will be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.)
function TSQLRawBlobToBlob(RawBlob: pointer; RawBlobLength: integer): RawUTF8; overload;

/// convert a Base64-encoded content into binary hexadecimal ready for SQL
// - returns e.g. X'53514C697465'
procedure Base64MagicToBlob(Base64: PUTF8Char; var result: RawUTF8);


/// return true if the TEXT is encoded as SQLite3 BLOB literals (X'53514C697465' e.g.)
function isBlobHex(P: PUTF8Char): boolean;
  {$ifdef HASINLINE}inline;{$endif}

/// compute the SQL corresponding to a WHERE clause
// - returns directly the Where value if it starts by ORDER/GROUP/LIMIT
// - otherwise, append ' WHERE '+Where  
function SQLFromWhere(const Where: RawUTF8): RawUTF8;


/// guess the content type of an UTF-8 encoded field value, as used in TSQLTable.Get()
// - if P if nil or 'null', return sftUnknown
// - otherwise, guess its type from its value characters
// - sftBlob is returned if the field is encoded as SQLite3 BLOB literals
// (X'53514C697465' e.g.) or with '\uFFF0' magic code
// - since P is PUTF8Char, string type is sftUTF8Text only
// - sftFloat is returned for any floating point value, even if it was
// declared as sftCurrency type
// - sftInteger is returned for any INTEGER stored value, even if it was declared
// as sftEnumerate, sftSet, sftID, sftRecord, sftBoolean or
// sftModTime / sftCreateTime / sftTimeLog type
function UTF8ContentType(P: PUTF8Char): TSQLFieldType;


/// read an object properties, as saved by TINIWriter.WriteObject() method
// - i.e. only Integer, Int64, enumerates (including boolean), floating point,
// variant and (Ansi/Wide/Unicode)String properties (excluding shortstring)
// - read only the published properties of the current class level (do NOT
// read the properties content published in the parent classes)
// - "From" must point to the [section] containing the object properties
// - for integers and enumerates, if no value is stored in From (or From is ''),
// the default value from the property definition is set
procedure ReadObject(Value: TObject; From: PUTF8Char; const SubCompName: RawUTF8=''); overload;

/// read an object properties, as saved by TINIWriter.WriteObject() method
// - i.e. only Integer, Int64, enumerates (including boolean), floating point values
// and (Ansi/Wide/Unicode)String properties (excluding shortstring)
// - read only the published properties of the current class level (do NOT
// read the properties content published in the parent classes)
// - for integers, if no value is stored in FromContent, the default value is set
// - this version gets the appropriate section from [Value.ClassName]
// - this version doesn't handle embedded objects
procedure ReadObject(Value: TObject; const FromContent: RawUTF8;
  const SubCompName: RawUTF8=''); overload;

/// write an object properties, as saved by TINIWriter.WriteObject() method
// - i.e. only Integer, Int64, enumerates (including boolean), floating point values
// and (Ansi/Wide/Unicode)String properties (excluding shortstring)
// - write only the published properties of the current class level (do NOT
// write the properties content published in the parent classes)
// - direct update of INI-like content
// - for integers, value is always written, even if matches the default value
procedure WriteObject(Value: TObject; var IniContent: RawUTF8;
  const Section: RawUTF8; const SubCompName: RawUTF8=''); overload;

/// write an object properties, as saved by TINIWriter.WriteObject() method
// - i.e. only Integer, Int64, enumerates (including boolean), floating point values
// and (Ansi/Wide/Unicode)String properties (excluding shortstring)
// - write only the published properties of the current class level (do NOT
// write the properties content published in the parent classes)
// - return the properties as text Name=Values pairs, with no section
// - for integers, if the value matches the default value, it is not added to the result
function WriteObject(Value: TObject): RawUTF8; overload;

/// copy object properties
// - copy only Integer, Int64, enumerates (including boolean), object properties
// and (Ansi/Wide/Unicode)String properties (excluding shortstring)
// - TCollection items can be copied also, if they are of the same exact class
// - object properties instances are created in aTo if the objects are not
// TSQLRecord children (in this case, these are not class instances, but
// INTEGER reference to records, so only the integer value is copied), that is
// for regular Delphi classes
procedure CopyObject(aFrom, aTo: TObject);

{$ifndef LVCL}
/// copy two TCollection instances
// - will call CopyObject() in loop to repopulate the Dest collection
procedure CopyCollection(Source, Dest: TCollection);
{$endif}

/// set any default integer or enumerates (including boolean) published
// properties values for an object
// - reset only the published properties of the current class level (do NOT
// reset the properties content published in the parent classes)
procedure SetDefaultValuesObject(Value: TObject);

/// will serialize any TObject into its UTF-8 JSON representation
/// - serialize as JSON the published integer, Int64, floating point values,
// TDateTime (stored as ISO 8601 text), string, variant and enumerate
// (e.g. boolean) properties of the object (and its parents)
// - won't handle shortstring properties
// - the enumerates properties are stored with their integer index value
// - will write also the properties published in the parent classes
// - nested properties are serialized as nested JSON objects
// - any TCollection property will also be serialized as JSON arrays
// - you can add some custom serializers for ANY Delphi class, via the
// TJSONSerializer.RegisterCustomSerializer() class method
// - call internaly TJSONSerializer.WriteObject() method
function ObjectToJSON(Value: TObject;
  Options: TTextWriterWriteObjectOptions=[woDontStoreDefault]): RawUTF8;

/// encode supplied parameters to be compatible with URI encoding
// - parameters must be supplied two by two, as Name,Value pairs, e.g.
// ! url := UrlEncodeFull(['select','*','where','ID=12','offset',23,'object',aObject]);
// - parameters can be either textual, integer or extended, or any TObject
// (standard UrlEncode() will only handle
// - TObject serialization into UTF-8 will be processed by the ObjectToJSON()
// function
function UrlEncode(const NameValuePairs: array of const): RawUTF8; overload;

type
  /// available options for JSONToObject() parsing process
  // - by default, function will fail if a JSON field name is not part of the
  // object published properties, unless j2oIgnoreUnknownProperty is defined
  // - by default, only simple kind of variant types (string/numbers) are
  // handled: set j2oHandleCustomVariants if you want to handle any custom -
  // in this case , it will handle direct JSON [array] of {object}: but if you
  // also define j2oHandleCustomVariantsWithinString, it will also try to
  // un-escape a JSON string first, i.e. handle "[array]" or "{object}" content
  // (may be used e.g. when JSON has been retrieved from a database TEXT column)
  TJSONToObjectOption = (
    j2oIgnoreUnknownProperty,
    j2oHandleCustomVariants, j2oHandleCustomVariantsWithinString);
  /// set of options for JSONToObject() parsing process
  TJSONToObjectOptions = set of TJSONToObjectOption;

/// read an object properties, as saved by ObjectToJSON function
// - ObjectInstance must be an existing TObject instance
// - the data inside From^ is modified in-place (unescaped and transformed):
// don't call JSONToObject(pointer(JSONRawUTF8)) but makes a temporary copy of
// the JSON text buffer before calling this function, if want to reuse it later
// - handle Integer, Int64, enumerate (including boolean), set, floating point,
// TDateTime, TCollection, TStrings, TRawUTF8List, variant, and string properties
// (excluding ShortString, but including WideString and UnicodeString under
// Delphi 2009+)
// - TList won't be handled since it may leak memory when calling TList.Clear
// - won't handle TObjectList (even if ObjectToJSON is able to serialize
// them) since has now way of knowing the object type to add (TCollection.Add
// is missing), unless: 1. you set the TObjectListItemClass property as expected,
// and provide a TObjectList object, or 2. woStoreClassName option has been
// used at ObjectToJSON() call and the corresponding classes have been previously
// registered by TJSONSerializer.RegisterClassForJSON() (or Classes.RegisterClass)
// - will clear any previous TCollection objects, and convert any null JSON
// basic type into nil - e.g. if From='null', will call FreeAndNil(Value)
// - you can add some custom (un)serializers for ANY Delphi class, via the
// TJSONSerializer.RegisterCustomSerializer() class method
// - set Valid=TRUE on success, Valid=FALSE on error, and the main function
// will point in From at the syntax error place (e.g. on any unknown property name)
// - caller should explicitely perform a SetDefaultValuesObject(Value) if
// the default values are expected to be set before JSON parsing
function JSONToObject(var ObjectInstance; From: PUTF8Char; var Valid: boolean;
  TObjectListItemClass: TClass=nil; Options: TJSONToObjectOptions=[]): PUTF8Char;

/// create a new object instance, as saved by ObjectToJSON(..woStoreClassName]);
// - JSON input should be either 'null', either '{"ClassName":"TMyClass",...}'
// - woStoreClassName option shall have been used at ObjectToJSON() call
// - and the corresponding class shall have been previously registered by
// TJSONSerializer.RegisterClassForJSON(), in order to retrieve the class type
// from it name - or, at least, by a Classes.RegisterClass() function call
// - the data inside From^ is modified in-place (unescaped and transformed):
// don't call JSONToObject(pointer(JSONRawUTF8)) but makes a temporary copy of
// the JSON text buffer before calling this function, if want to reuse it later
function JSONToNewObject(var From: PUTF8Char; var Valid: boolean;
  Options: TJSONToObjectOptions=[]): TObject;

/// decode a specified parameter compatible with URI encoding into its original
// object contents
// - ObjectInstance must be an existing TObject instance
// - will call internaly JSONToObject() function to unserialize its content
// - UrlDecodeExtended('price=20.45&where=LastName%3D%27M%C3%B4net%27','PRICE=',P,@Next)
// will return Next^='where=...' and P=20.45
// - if Upper is not found, Value is not modified, and result is FALSE
// - if Upper is found, Value is modified with the supplied content, and result is TRUE
function UrlDecodeObject(U: PUTF8Char; Upper: PAnsiChar; var ObjectInstance; Next: PPUTF8Char=nil;
  Options: TJSONToObjectOptions=[]): boolean;

/// fill the object properties from a JSON file content 
// - ObjectInstance must be an existing TObject instance
// - this function will call RemoveCommentsFromJSON() before process
function JSONFileToObject(const JSONFile: TFileName; var ObjectInstance;
  TObjectListItemClass: TClass=nil; Options: TJSONToObjectOptions=[]): boolean;

/// persist a class instance into a JSON file
procedure ObjectToJSONFile(Value: TObject; const JSONFile: TFileName;
  Options: TTextWriterWriteObjectOptions=[woHumanReadable]);



{ ************ some RTTI and SQL mapping routines }

{ type definitions below were adapted from TypInfo.pas
 - this implementation doesn't require to include Variant.pas any more (which
  allow easy server-side compile with LVCL, e.g.)
 - some code was rewritten in an object orientation manner (declared as objects
  instead of records) to avoid use of global function/procedure
 - allows easy published properties enumeration with ClassProp()
 - if a property doesn't have a write attribute (i.e. no setter), its value
  is set using the field adress itself (from read f* getter)
 - some useful but not implemented functions were added in optimized assembler }

type
{$ifdef FPC}
  /// available type families for Free Pascal RTTI values
  // - values differs from Delphi, and are taken from FPC typinfo.pp unit
  TTypeKind = (tkUnknown,tkInteger,tkChar,tkEnumeration,tkFloat,
    tkSet,tkMethod,tkSString,tkLString,tkAString,
    tkWString,tkVariant,tkArray,tkRecord,tkInterface,
    tkClass,tkObject,tkWChar,tkBool,tkInt64,tkQWord,
    tkDynArray,tkInterfaceRaw,tkProcVar,tkUString,tkUChar,tkHelper);
{$else}
  /// available type families for Delphi 6 and up 
  TTypeKind = (tkUnknown, tkInteger, tkChar, tkEnumeration, tkFloat,
    tkString, tkSet, tkClass, tkMethod, tkWChar, tkLString, tkWString,
    tkVariant, tkArray, tkRecord, tkInterface, tkInt64, tkDynArray
    {$ifdef UNICODE}, tkUString{$endif});
{$endif}

  /// specify ordinal (tkInteger and tkEnumeration) storage size and sign
  // - note: Int64 is stored as its own TTypeKind, not as tkInteger
  TOrdType = (otSByte, otUByte, otSWord, otUWord, otSLong, otULong);

  /// specify floating point (ftFloat) storage size and precision
  // - here ftDouble is renamed ftDoub to avoid confusion with TSQLDBFieldType
  TFloatType = (ftSingle, ftDoub, ftExtended, ftComp, ftCurr);

  PPTypeInfo = ^PTypeInfo;

{$ifdef FPC}
{$ifdef FPC_REQUIRES_PROPER_ALIGNMENT}
{$PACKRECORDS C}
{$else}
{$A-}
{$endif}
{$else}
{$A-} { Delphi compiler use packed storage for this internal types, not aligned data }
{$endif}

  PPropInfo = ^TPropInfo;
  PMethodInfo = ^TMethodInfo;

  /// pointer to TClassProp
  PClassProp = ^TClassProp;
  /// a wrapper to published properties of a class
  // - start enumeration by getting a PClassProp with ClassProp()
  // - use PropCount, P := @PropList to get the first PPropInfo, and then P^.Next
  // - this enumeration is very fast and doesn't require any temporary memory,
  //  as in the TypInfo.GetPropInfos() PPropList usage
  // - for TSQLRecord, you should better use the RecordProps.Fields[] array,
  // which is faster and contains the properties published in parent classes
  {$ifndef ISDELPHI2010}
  TClassProp = object
  {$else}
  TClassProp = record
  {$endif}
    /// number of published properties in this object
    PropCount: Word;
    /// point to a TPropInfo packed array
    // - layout is as such, with variable TPropInfo storage size:
    // ! PropList: array[1..PropCount] of TPropInfo
    // - use TPropInfo.Next to get the next one:
    // ! P := @PropList;
    // ! for i := 1 to PropCount do begin
    // !   // ... do something with P
    // !   P := P^.Next;
    // ! end;
    PropList: record end;
    /// retrieve a Field property RTTI information from a Property Name
    function FieldProp(const PropName: shortstring): PPropInfo;
    /// return the total count of the published properties in this class
    // and all its parents
    function FieldCountWithParents: integer;
  end;

  PClassType = ^TClassType;
  /// a wrapper to class type information, as defined by the Delphi RTTI
  TClassType = {$ifndef ISDELPHI2010}object{$else}record{$endif}
     /// the class type
     ClassType: TClass;
     /// the parent class type information
     ParentInfo: PPTypeInfo;
     /// the number of published properties
     PropCount: SmallInt;
     /// the name (without .pas extension) of the unit were the class was defined
     // - then the PClassProp follows: use the method ClassProp to retrieve its
     // address
     UnitName: string[255];
     /// get the information about the published properties of this class
     // - stored after UnitName memory
     function ClassProp: PClassProp;
       {$ifdef HASINLINE}inline;{$endif}
     /// fast and easy find if this class inherits from a specific class type
     function InheritsFrom(AClass: TClass): boolean;
     /// return the size (in bytes) of this class type information
     // - can be used to create class types at runtime
     function RTTISize: integer;
  end;

  PEnumType = ^TEnumType;
  /// a wrapper to enumeration type information, as defined by the Delphi RTTI
  // - we use this to store the enumeration values as integer, but easily provide
  // a text equivalent, translated if necessary, from the enumeration type
  // definition itself
  TEnumType = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// specify ordinal storage size and sign
    OrdType: TOrdType;
    /// first value of enumeration type, typicaly 0
    MinValue: Longint;
    /// same as ord(high(type)): not the enumeration count, but the highest index
    MaxValue: Longint;
    /// the base type of this enumeration
    /// - always use PEnumType(typeinfo(TEnumType))^.BaseType or more useful
    // method PTypeInfo(typeinfo(TEnumType))^.EnumBaseType before calling
    // any of the methods below
    BaseType: PPTypeInfo;
    /// a concatenation of shortstrings, containing the enumeration names
    NameList: string[255];
    /// get the corresponding enumeration name
    // - return the first one if Value is invalid (>MaxValue)
    function GetEnumNameOrd(Value: Integer): PShortString;
    /// get the corresponding enumeration name
    // - return the first one if Value is invalid (>MaxValue)
    // - Value will be converted to the matching ordinal value (byte or word)
    function GetEnumName(const Value): PShortString;
       {$ifdef HASINLINE}inline;{$endif}
    /// get the corresponding enumeration ordinal value, from its name
    // - if EnumName does start with lowercases 'a'..'z', they will be searched:
    // e.g. GetEnumNameValue('sllWarning') will find sllWarning item
    // - if EnumName does not start with lowercases 'a'..'z', they will be ignored:
    // e.g. GetEnumNameValue('Warning') will find sllWarning item
    // - return -1 if not found (don't use directly this value to avoid any GPF)
    function GetEnumNameValue(const EnumName: ShortString): Integer; overload;
       {$ifdef HASINLINE}inline;{$endif}
    /// get the corresponding enumeration ordinal value, from its name
    // - if Value does start with lowercases 'a'..'z', they will be searched:
    // e.g. GetEnumNameValue('sllWarning') will find sllWarning item
    // - if Value does not start with lowercases 'a'..'z', they will be ignored:
    // e.g. GetEnumNameValue('Warning') will find sllWarning item
    // - return -1 if not found (don't use directly this value to avoid any GPF)
    function GetEnumNameValue(Value: PUTF8Char): Integer; overload;
       {$ifdef HASINLINE}inline;{$endif}
    /// get the corresponding enumeration ordinal value, from its name
    // - if Value does start with lowercases 'a'..'z', they will be searched:
    // e.g. GetEnumNameValue('sllWarning') will find sllWarning item
    // - if Value does not start with lowercases 'a'..'z', they will be ignored:
    // e.g. GetEnumNameValue('Warning') will find sllWarning item
    // - return -1 if not found (don't use directly this value to avoid any GPF)
    function GetEnumNameValue(Value: PUTF8Char; ValueLen: integer): Integer; overload;
    /// get the corresponding enumeration name, without the first lowercase chars
    // (otDone -> 'Done')
    // - Value will be converted to the matching ordinal value (byte or word)
    function GetEnumNameTrimed(const Value): RawUTF8;
       {$ifdef HASINLINE}inline;{$endif}
    ///  get the corresponding caption name, without the first lowercase chars
    // (otDone -> 'Done')
    // - return "string" type, i.e. UnicodeString for Delphi 2009+
    // - internally call UnCamelCase() then System.LoadResStringTranslate() if available
    // - Value will be converted to the matching ordinal value (byte or word)
    function GetCaption(const Value): string;
    /// get all caption names, ready to be display, as lines separated by #13#10
    // - return "string" type, i.e. UnicodeString for Delphi 2009+
    // - if UsedValuesBits is not nil, only the corresponding bits set are added
    function GetCaptionStrings(UsedValuesBits: Pointer=nil): string;
    /// add caption names, ready to be display, to a TStrings class
    // - add pointer(ord(element)) as Objects[] value
    // - if UsedValuesBits is not nil, only the corresponding bits set are added
    // - can be used e.g. to populate a combo box as such:
    // ! PTypeInfo(TypeInfo(TMyEnum))^.EnumBaseType^.AddCaptionStrings(ComboBox.Items);
    procedure AddCaptionStrings(Strings: TStrings; UsedValuesBits: Pointer=nil);
    /// retrieve all trimed element names as CSV
    procedure GetEnumNameTrimedAll(var result: RawUTF8);
    /// get the corresponding enumeration ordinal value, from its name without
    // its first lowercase chars ('Done' will find otDone e.g.)
    // - return -1 if not found (don't use directly this value to avoid any GPF)
    function GetEnumNameTrimedValue(const EnumName: ShortString): Integer; overload;
    /// get the corresponding enumeration ordinal value, from its name without
    // its first lowercase chars ('Done' will find otDone e.g.)
    // - return -1 if not found (don't use directly this value to avoid any GPF)
    function GetEnumNameTrimedValue(Value: PUTF8Char): Integer; overload;
  end;


{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  TRecordField = packed record
    TypeInfo: PPTypeInfo;
    Offset: Cardinal;
  end;
  TRecordType = packed record
    Size: cardinal;
    Count: integer;
    Fields: array[word] of TRecordField;
  end;
  PRecordField = ^TRecordField;
  PRecordType = ^TRecordType;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  PTypeInfo = ^TTypeInfo;
  /// a wrapper containing type information definition
  // - user types defined as an alias don't have this type information:
  // & type NewType = OldType;
  // - user types defined as new types have this type information:
  // & type NewType = type OldType;
  TTypeInfo = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// the value type family
    Kind: TTypeKind;
    /// the declared name of the type ('String','Word','RawUnicode'...)
    Name: ShortString;
    /// get the class type information
    function ClassType: PClassType;
      {$ifdef FPC}inline;{$endif} {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    /// create an instance of the corresponding class
    // - will call TObject.Create, or TSQLRecord.Create virtual constructor
    // - will raise EParsingException if class cannot be constructed on the fly,
    // e.g. for a plain TCollectionItem class
    function ClassCreate: TObject;
    /// get the SQL type of this Delphi class type
    function ClassSQLFieldType: TSQLFieldType;
       {$ifdef HASINLINE}inline;{$endif}
    /// for ordinal types, get the storage size and sign
    function OrdType: TOrdType;
      {$ifdef HASINLINE}inline;{$endif}
    /// for set types, get the type information of the corresponding enumeration
    function SetEnumType: PEnumType;
    /// for gloating point types, get the storage size and procision
    function FloatType: TFloatType;
      {$ifdef HASINLINE}inline;{$endif}
    /// get the SQL type of this Delphi type, as managed with the database driver
    function SQLFieldType: TSQLFieldType;
     /// fast and easy find if a class type inherits from a specific class type
    function InheritsFrom(AClass: TClass): boolean;
    /// get the enumeration type information
    function EnumBaseType: PEnumType;
      {$ifdef FPC}inline;{$endif} {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    /// get the record type information
    function RecordType: PRecordType;
      {$ifdef FPC}inline;{$endif} {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
  end;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  {/ a wrapper containing a property definition, with GetValue() and SetValue()
    functions for direct Delphi / UTF-8 SQL type mapping/conversion:
    - handle byte, word, integer, cardinal, Int64 properties as INTEGER
    - handle boolean properties as INTEGER (0 is false, anything else is true)
    - handle enumeration properties as INTEGER, storing the ordinal value of the
      enumeration (i.e. starting at 0 for the first element)
    - handle enumerations set properties as INTEGER, each bit corresponding to
      an enumeration (therefore a set of up to 64 elements can be stored in such
      a field)
    - handle RawUTF8 properties as TEXT (UTF-8 encoded) - this is the preferred
      field type for storing some textual content in the ORM
    - handle WinAnsiString properties as TEXT (UTF-8 decoded in WinAnsi char set)
    - handle RawUnicode properties as TEXT (UTF-8 decoded as UTF-16 Win32 unicode)
    - handle Single, Double and Extended properties as FLOAT
    - handle TDateTime properties as ISO-8061 encoded TEXT
    - handle TTimeLog properties as properietary fast INTEGER date time
    - handle Currency property as FLOAT (safely converted to/from currency)
    - handle TSQLRecord descendant properties as INTEGER ROWID index to another record
     (warning: the value contains pointer(ROWID), not a valid object memory - you
     have to manually retrieve the record, using a integer(IDField) typecast)
    - handle TSQLRecordMany descendant properties as an "has many" instance (this
     is a particular case of TSQLRecord: it won't contain pointer(ID), but an object)
    - handle TRecordReference properties as INTEGER RecordRef-like value
      (use TSQLRest.Retrieve(Reference) to get a record content)
    - handle TSQLRawBlob properties as BLOB
    - handle dynamic arrays as BLOB, in the TDynArray.SaveTo binary format (is able
      to handle dynamic arrays of records, with records or strings within records)
    - handle records as BLOB, in the RecordSave binary format (our code is ready
      for that, but Delphi doesn't create the RTTI for records so it won't work)
    - WideString, shortstring, UnicodeString (i.e. Delphi 2009+ generic string),
      indexed properties are not handled yet (use faster RawUnicodeString instead
      of WideString and UnicodeString) - in fact, the generic string type is handled  }
  {$ifndef ISDELPHI2010}
  TPropInfo = object
  {$else}
  TPropInfo = record
  {$endif}
  public
    /// the type definition of this property
    PropType: PPTypeInfo;
    /// contains the offset of a field, or the getter method set by 'read' Delphi declaration
    GetProc: PtrInt;
    /// contains the offset of a field, or the setter method set by 'write' Delphi declaration
    // - if this field is nil (no 'write' was specified), SetValue() use GetProc to
    // get the field memory address to save into
    SetProc: PtrInt;
    /// contains the 'stored' boolean value/method (used in TPersistent saving)
    // - either integer(True) - the default, integer(False), reference to a Boolean
    // field, or reference to a parameterless method that returns a Boolean value
    // - if a property is marked as "stored AS_UNIQUE" (i.e. "stored false"),
    // it is created as UNIQUE in the SQL database and its bit is set in
    // Model.fIsUnique[]
    StoredProc: PtrInt;
    /// contains the index value of an indexed class data property
    // - outside SQLite3, this can be used to define a VARCHAR() length value
    // for the textual field definition (sftUTF8Text/sftAnsiText); e.g.
    // the following will create a NAME VARCHAR(40) field:
    // ! Name: RawUTF8 index 40 read fName write fName;
    // - is used by a dynamic array property for fast usage of the
    // TSQLRecord.DynArray(DynArrayFieldIndex) method
    Index: Integer;
    /// contains the default value (2147483648=$80000000 indicates nodefault)
    // when an ordinal or set property is saved as TPersistent
    Default: Longint;
    /// index of the property in the current inherited class definition
    // - first name index at a given class level is 0
    // - index is reset to 0 at every inherited class level
    NameIndex: SmallInt;
{$ifdef FPC}
    /// contains the type of the Get/Set/Storedproc, see also ptxxx
    // bit 0..1 GetProc
    //     2..3 SetProc
    //     4..5 StoredProc
    //     6 : true, constant index property
    PropProcs : Byte;
{$endif}
    /// the property definition Name
    Name: ShortString;

    /// get the next property information
    // - no range check: use ClassProp()^.PropCount to determine the properties count
    // - get the first PPropInfo with ClassProp()^.PropList
    function Next: PPropInfo;
      {$ifdef FPC}inline;{$else}{$ifdef HASINLINE}inline;{$endif} {$endif}
    /// return FALSE (AS_UNIQUE) if was marked as "stored AS_UNIQUE"
    //  (i.e. "stored false"), or TRUE by default
    // - if Instance=nil, will work only at RTTI level, not with field or method
    // (and will return TRUE if nothing is defined in the RTTI)
    function IsStored(Instance: TObject): boolean;
    /// copy a published property value from one instance to another
    // - this method use direct copy of the low-level binary content, and is
    // therefore faster than a SetValue(Dest,GetValue(Source)) call
    procedure CopyValue(Source, Dest: TObject);
    /// return true if this property is a BLOB (TSQLRawBlob)
    function IsBlob: boolean;
      {$ifdef HASINLINE}inline;{$endif}
    /// low-level getter of the ordinal property value of a given instance
    // - this method will check if the corresponding property is ordinal
    // - return -1 on any error
    function GetOrdValue(Instance: TObject): Integer;
    /// low-level getter of the ordinal property value of a given instance
    // - this method will check if the corresponding property is ordinal
    // - ordinal properties smaller than tkInt64 will return an Int64-converted
    // value (e.g. tkInteger)
    // - return 0 on any error
    function GetInt64Value(Instance: TObject): Int64;
    /// low-level getter of the currency property value of a given instance
    // - this method will check if the corresponding property is exactly currency
    // - return 0 on any error
    function GetCurrencyValue(Instance: TObject): Currency;
    /// low-level getter of the floating-point property value of a given instance
    // - this method will check if the corresponding property is floating-point
    // - return 0 on any error
    function GetExtendedValue(Instance: TObject): Extended;
    /// low-level setter of the floating-point property value of a given instance
    // - this method will check if the corresponding property is floating-point
    procedure SetExtendedValue(Instance: TObject; const Value: Extended);
    /// low-level getter of the long string property value of a given instance
    // - this method will check if the corresponding property is a Long String,
    // and will return '' if it's not the case
    // - it will convert the property content into RawUTF8, for RawUnicode,
    // WinAnsiString, TSQLRawBlob and generic Delphi 6-2007 string property
    function GetLongStrValue(Instance: TObject): RawUTF8;
    /// low-level getter of the long string property content of a given instance
    // - just a wrapper around low-level GetLongStrProp() function
    // - call GetLongStrValue() method if you want a conversion into RawUTF8
    // - will work only for Kind=tkLString
    procedure GetRawByteStringValue(Instance: TObject; var Value: RawByteString);
    /// low-level setter of the ordinal property value of a given instance
    // - this method will check if the corresponding property is ordinal
    procedure SetOrdValue(Instance: TObject; Value: Integer);
    /// low-level setter of the ordinal property value of a given instance
    // - this method will check if the corresponding property is ordinal
    procedure SetInt64Value(Instance: TObject; Value: Int64);
    /// low-level setter of the long string property value of a given instance
    // - this method will check if the corresponding property is a Long String
    // - it will convert the property content into RawUTF8, for RawUnicode,
    // WinAnsiString, TSQLRawBlob and generic Delphi 6-2007 string property
    procedure SetLongStrValue(Instance: TObject; const Value: RawUTF8);
    /// low-level setter of the string property value of a given instance
    // - uses the generic string type: to be used within the VCL
    // - this method will check if the corresponding property is a Long String
    // or an UnicodeString (for Delphi 2009+), and will call the corresponding
    // SetLongStrValue() or SetUnicodeStrValue() method
    procedure SetGenericStringValue(Instance: TObject; const Value: string);
    /// low-level getter of the long string property value of a given instance
    // - uses the generic string type: to be used within the VCL
    // - this method will check if the corresponding property is a Long String,
    // or an UnicodeString (for Delphi 2009+),and will return '' if it's
    // not the case
    function GetGenericStringValue(Instance: TObject): string;
{$ifdef UNICODE}
    /// low-level setter of the Unicode string property value of a given instance
    // - this method will check if the corresponding property is a Unicode String
    procedure SetUnicodeStrValue(Instance: TObject; const Value: UnicodeString);
    /// low-level getter of the Unicode string property value of a given instance
    // - this method will check if the corresponding property is a Unicode String
    function GetUnicodeStrValue(Instance: TObject): UnicodeString;
{$endif}
    /// low-level getter of a dynamic array wrapper
    // - this method will NOT check if the property is a dynamic array: caller
    // must have already checked that PropType^^.Kind=tkDynArray
    function GetDynArray(Instance: TObject): TDynArray;
      {$ifdef HASINLINE}inline;{$endif}
    /// low-level getter of the field value memory pointer
    // - return NIL if both getter and setter are methods
    function GetFieldAddr(Instance: TObject): pointer;
      {$ifdef HASINLINE}inline;{$endif}
    /// read an TObject published property, as saved by ObjectToJSON() function
    // - will use direct in-memory reference to the object, or call the corresponding
    // setter method (if any), creating a temporary instance via TTypeInfo.ClassCreate
    // - unserialize the JSON input buffer via a call to JSONToObject()
    function ClassFromJSON(Instance: TObject; From: PUTF8Char; var Valid: boolean;
      Options: TJSONToObjectOptions=[]): PUTF8Char;
  end;

  /// the available methods calling conventions
  // - this is by design only relevant to the x86 model
  // - Win64 has one unique calling convention
  TCallingConvention = (ccRegister, ccCdecl, ccPascal, ccStdCall, ccSafeCall);

  /// the available kind of method parameters
  TParamFlag = (pfVar, pfConst, pfArray, pfAddress, pfReference, pfOut, pfResult);

  /// a set of kind of method parameters
  TParamFlags = set of TParamFlag;

  PReturnInfo = ^TReturnInfo;
  PParamInfo  = ^TParamInfo;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  {/ a wrapper around method returned result definition }
  TReturnInfo = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// RTTI version
    // - 2 up to Delphi 2010, 3 for Delphi XE and up
    Version: byte;
    /// expected calling convention (only relevant for x86 mode)
    CallingConvention: TCallingConvention;
    /// the expected type of the returned function result
    // - is nil for procedure
    ReturnType: ^PTypeInfo;
    /// total size of data needed for stack parameters + 8 (ret-addr + pushed EBP)
    ParamSize: Word;
    /// number of expected parameters
    ParamCount: Byte;
    /// access to the first method parameter definition
    function Param: PParamInfo;
      {$ifdef HASINLINE}inline;{$endif}
  end;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  {/ a wrapper around an individual method parameter definition }
  TParamInfo = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// the kind of parameter
    Flags: TParamFlags;
    /// the parameter type information
    ParamType: PPTypeInfo;
    /// parameter offset
    // - 0 for EAX, 1 for EDX, 2 for ECX
    // - any value >= 8 for stack-based parameter
    Offset: Word;
    /// parameter name
    Name: ShortString;
    /// get the next parameter information
    // - no range check: use TReturnInfo.ParamCount to determine the appropriate count
    function Next: PParamInfo;
      {$ifdef HASINLINE}inline;{$endif}
  end;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  {/ a wrapper around a method definition }
  TMethodInfo = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    {$ifdef FPC}
    /// method name
    Name: PShortString;
    /// the associated method code address
    Addr: Pointer;
    {$else}
    /// size (in bytes) of this TMethodInfo block
    Len: Word;
    /// the associated method code address
    Addr: Pointer;
    /// method name
    Name: ShortString;
    {$endif}
    /// retrieve the associated return information
    function ReturnInfo: PReturnInfo;
      {$ifdef HASINLINE}inline;{$endif}
    /// wrapper returning nil and avoiding a GPF if @self=nil
    function MethodAddr: Pointer;
      {$ifdef HASINLINE}inline;{$endif}
  end;

{$ifdef FPC}
{$PACKRECORDS 8}
{$else}
{$A+} { default aligned data }
{$endif}

  TJSONSerializer = class;

  /// ORM attributes for a TSQLPropInfo definition
  TSQLPropInfoAttribute = (
    aIsUnique);

  /// set of ORM attributes for a TSQLPropInfo definition
  TSQLPropInfoAttributes = set of TSQLPropInfoAttribute;

  /// abstract parent class to store information about a published property
  // - property information could be retrieved from RTTI (TSQLPropInfoRTTI*),
  // or be defined by code (TSQLPropInfoCustom derivated classes) when RTTI
  // is not available
  TSQLPropInfo = class
  protected
    fName: RawUTF8;
    fSQLFieldType: TSQLFieldType;
    fAttributes: TSQLPropInfoAttributes;
    fFieldWidth: integer;
    fPropertyIndex: integer;
    /// those two protected methods allow custom storage of binary content
    // as text
    // - default implementation is to use hexa (ToSQL=true) or Base64 encodings
    procedure BinaryToText(var Value: RawUTF8; ToSQL: boolean; wasSQLString: PBoolean); virtual;
    procedure TextToBinary(Value: PUTF8Char; var result: RawByteString); virtual;
    function GetSQLFieldTypeName: PShortString;
  public
    /// initialize the internal fields
    // - should not be called directly, but with dedicated class methods like
    // class function TSQLPropInfoRTTI.CreateFrom() or overridden constructors
    constructor Create(const aName: RawUTF8; aSQLFieldType: TSQLFieldType;
      aAttributes: TSQLPropInfoAttributes; aFieldWidth, aPropertyIndex: integer); reintroduce; virtual;
    /// the property definition Name
    property Name: RawUTF8 read fName;
    /// the property index in the RTTI
    property PropertyIndex: integer read fPropertyIndex; 
    /// the corresponding column type, as managed by the ORM layer
    property SQLFieldType: TSQLFieldType read fSQLFieldType;
    /// the corresponding column type name, as managed by the ORM layer and
    // retrieved by the RTTI
    property SQLFieldTypeName: PShortString read GetSQLFieldTypeName;
    /// the ORM attributes of this property
    // - contains aIsUnique e.g for TSQLRecord published properties marked as
    // ! property MyProperty: RawUTF8 stored AS_UNIQUE;
    // (i.e. "stored false")
    property Attributes: TSQLPropInfoAttributes read fAttributes;
    /// the optional width of this field, in external databases
    // - is set e.g. by index attribute of TSQLRecord published properties as
    // ! property MyProperty: RawUTF8 index 10;
    property FieldWidth: integer read fFieldWidth;
  public
    /// convert UTF-8 encoded text into the property value
    // - setter method (write Set*) is called if available
    // - if no setter exists (no write declaration), the getted field address is used
    // - handle UTF-8 SQL to Delphi values conversion
    // - expect BLOB fields encoded as SQlite3 BLOB literals ("x'01234'" e.g.)
    // or base-64 encoded stream for JSON ("\uFFF0base64encodedbinary") - i.e.
    // both format supported by BlobToTSQLRawBlob() function
    // - handle TPersistent, TCollection, TRawUTF8List or TStrings with JSONToObject
    // - note that the supplied Value buffer won't be modified by this method:
    // overriden implementation should create their own temporary copy 
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); virtual; abstract;
    /// convert the property value into an UTF-8 encoded text
    // - if ToSQL is true, result is on SQL form (false->'0' e.g.)
    // - if ToSQL is false, result is on JSON form (false->'false' e.g.)
    // - BLOB field returns SQlite3 BLOB literals ("x'01234'" e.g.) if ToSQL is
    // true, or base-64 encoded stream for JSON ("\uFFF0base64encodedbinary")
    // - getter method (read Get*) is called if available
    // - handle Delphi values into UTF-8 SQL conversion
    // - sftBlobDynArray, sftBlobCustom or sftBlobRecord are returned as BLOB
    // litterals ("X'53514C697465'") if ToSQL is true, or base-64 encoded stream
    // for JSON ("\uFFF0base64encodedbinary")
    // - handle TPersistent, TCollection, TRawUTF8List or TStrings with ObjectToJSON
    function GetValue(Instance: TObject; ToSQL: boolean; wasSQLString: PBoolean=nil): RawUTF8;
      {$ifdef HASINLINE}inline;{$endif}
    /// convert the property value into an UTF-8 encoded text
    // - this method is the same as GetValue(), but avoid assigning the result
    // string variable (some speed up on multi-core CPUs, since avoid a CPU LOCK)
    // - this virtual method is the one to be overridden by the implementing classes
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); virtual; abstract;
    /// retrieve a field value into a TSQLVar value
    // - the temp RawByteString is used as a temporary storage for TEXT or BLOB
    // and should be available during all access to the TSQLVar fields
    procedure GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
      var temp: RawByteString); virtual;
    /// set a field value from a TSQLVar value
    function SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean; virtual;
    /// append the property value into a binary buffer
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); virtual; abstract;
    /// read the property value from a binary buffer
    // - returns next char in input buffer on success, or nil in case of invalid
    // content supplied e.g.
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; virtual; abstract;
    /// copy a property value from one instance to another
    // - this method use direct copy of the low-level binary content, and is
    // therefore faster than a SetValue(Dest,GetValue(Source)) call
    procedure CopyValue(Source, Dest: TObject); virtual; abstract;
    {$ifndef NOVARIANTS}
    /// retrieve the property value into a Variant
    // - will set the Variant type to the best matching kind according to the
    // SQLFieldType type
    // - BLOB field returns SQlite3 BLOB textual literals ("x'01234'" e.g.)
    // - dynamic array field is returned as a variant array
    procedure GetVariant(Instance: TObject; var Dest: Variant); virtual;  
    /// set the property value from a Variant value
    // - dynamic array field must be set from a variant array
    // - will set the Variant type to the best matching kind according to the
    // SQLFieldType type
    // - expect BLOB fields encoded as SQlite3 BLOB literals ("x'01234'" e.g.)
    procedure SetVariant(Instance: TObject; const Source: Variant); virtual; 
    {$endif}
    /// compare the content of the property of two objects
    // - not all kind of properties are handled: only main types (like GetHash)
    // - if CaseInsensitive is TRUE, will apply NormToUpper[] 8 bits uppercase,
    // handling RawUTF8 properties just like the SYSTEMNOCASE collation
    // - this default implementation will call GetValueVar() for slow comparison
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; virtual;
    /// retrieve an unsigned 32 bit hash of the corresponding property
    // - not all kind of properties are handled: only main types
    // - if CaseInsensitive is TRUE, will apply NormToUpper[] 8 bits uppercase,
    // handling RawUTF8 properties just like the SYSTEMNOCASE collation
    // - note that this method can return a hash value of 0
    // - this default implementation will call GetValueVar() for slow computation
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; virtual;
    /// normalize the content of Value, so that GetValue(Object,true) should return the
    // same content (true for ToSQL format)
    procedure NormalizeValue(var Value: RawUTF8); virtual; abstract;
    /// add the JSON content corresponding to the given property
    // - this default implementation will call safe but slow GetValueVar() method
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); virtual;
    /// returns an untyped pointer to the field property memory in a given instance
    function GetFieldAddr(Instance: TObject): pointer; virtual; abstract;
  end;

  /// type of a TSQLPropInfo class
  TSQLPropInfoClass = class of TSQLPropInfo;

  /// parent information about a published property retrieved from RTTI
  TSQLPropInfoRTTI = class(TSQLPropInfo)
  protected
    fPropInfo: PPropInfo;
  public
    /// this meta-constructor will create an instance of the exact descendant
    // of the specified property RTTI
    // - it will raise an EORMException in case of an unhandled type
    class function CreateFrom(aPropInfo: PPropInfo; aPropIndex: integer): TSQLPropInfo;
    /// initialize the internal fields
    // - should not be called directly, but with dedicated class methods like
    // class function CreateFrom()
    constructor Create(aPropInfo: PPropInfo; aPropIndex: integer;
      aSQLFieldType: TSQLFieldType); reintroduce; virtual;
    /// generic way of implementing it
    function GetFieldAddr(Instance: TObject): pointer; override;
    /// corresponding RTTI information
    property PropInfo: PPropInfo read fPropInfo;
  end;

  /// type of a TSQLPropInfoRTTI class
  TSQLPropInfoRTTIClass = class of TSQLPropInfoRTTI;

  /// information about an ordinal Int32 published property
  TSQLPropInfoRTTIInt32 = class(TSQLPropInfoRTTI)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
      var temp: RawByteString); override;
    function SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean; override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
  end;

  /// information about a set published property
  TSQLPropInfoRTTISet = class(TSQLPropInfoRTTIInt32)
  protected
    fSetEnumType: PEnumType;
  public
    constructor Create(aPropInfo: PPropInfo; aPropIndex: integer; aSQLFieldType: TSQLFieldType); override;
    property SetEnumType: PEnumType read fSetEnumType;
  end;

  /// information about a enumeration published property
  // - can be either sftBoolean or sftEnumerate kind of property
  TSQLPropInfoRTTIEnum = class(TSQLPropInfoRTTIInt32)
  protected
    fEnumType: PEnumType;
  public
    constructor Create(aPropInfo: PPropInfo; aPropIndex: integer; aSQLFieldType: TSQLFieldType); override;
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
    property EnumType: PEnumType read fEnumType;
  end;

  /// information about a character published property
  TSQLPropInfoRTTIChar = class(TSQLPropInfoRTTIInt32)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure NormalizeValue(var Value: RawUTF8); override;
  end;

  /// information about an ordinal Int64 published property
  TSQLPropInfoRTTIInt64 = class(TSQLPropInfoRTTI)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
      var temp: RawByteString); override;
    function SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean; override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
  end;

  /// information about a TTimeLog published property
  // - stored as an Int64, but with a specific class
  TSQLPropInfoRTTITimeLog = class(TSQLPropInfoRTTIInt64);

  /// information about a floating-point Double published property
  TSQLPropInfoRTTIDouble = class(TSQLPropInfoRTTIInt64)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
      var temp: RawByteString); override;
    function SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
  end;

  /// information about a fixed-decimal Currency published property
  TSQLPropInfoRTTICurrency = class(TSQLPropInfoRTTIDouble)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
      var temp: RawByteString); override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
  end;

  /// information about a TDateTime published property
  TSQLPropInfoRTTIDateTime = class(TSQLPropInfoRTTIDouble)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
      var temp: RawByteString); override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
  end;

  /// information about a AnsiString published property
  TSQLPropInfoRTTIAnsi = class(TSQLPropInfoRTTI)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
      var temp: RawByteString); override;
    function SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
  end;

  /// information about a RawUTF8 published property
  TSQLPropInfoRTTIRawUTF8 = class(TSQLPropInfoRTTIAnsi)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
      var temp: RawByteString); override;
    function SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean; override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
  end;

  /// information about a WinAnsiString published property
  TSQLPropInfoRTTIWinAnsi = class(TSQLPropInfoRTTIAnsi)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
  end;

  /// information about a RawUnicode published property
  TSQLPropInfoRTTIRawUnicode = class(TSQLPropInfoRTTIAnsi)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
  end;

  /// information about a TSQLRawBlob published property
  TSQLPropInfoRTTIRawBlob = class(TSQLPropInfoRTTIAnsi)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
      var temp: RawByteString); override;
    function SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean; override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
    procedure GetBlob(Instance: TObject; var Blob: RawByteString);
    procedure SetBlob(Instance: TObject; const Blob: RawByteString);
    function IsNull(Instance: TObject): Boolean;
  end;

  /// information about a WideString published property
  TSQLPropInfoRTTIWide = class(TSQLPropInfoRTTI)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
  end;

{$ifdef UNICODE}
  /// information about a UnicodeString published property
  TSQLPropInfoRTTIUnicode = class(TSQLPropInfoRTTI)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
      var temp: RawByteString); override;
    function SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
  end;
{$endif}

  /// information about a dynamic array published property
  TSQLPropInfoRTTIDynArray = class(TSQLPropInfoRTTI)
  protected
    function GetDynArray(Instance: TObject): TDynArray;
      {$ifdef HASINLINE}inline;{$endif}
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
      var temp: RawByteString); override;
    function SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean; override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
    {$ifndef NOVARIANTS}
    procedure GetVariant(Instance: TObject; var Dest: Variant); override;
    procedure SetVariant(Instance: TObject; const Source: Variant); override;
    {$endif}
    /// optional index of the dynamic array published property
    // - used e.g. for fast lookup by TSQLRecord.DynArray(DynArrayFieldIndex)
    property DynArrayIndex: integer read fFieldWidth;
  end;

{$ifndef NOVARIANTS}
  /// information about a variant published property
  TSQLPropInfoRTTIVariant = class(TSQLPropInfoRTTI)
  protected
    fDocVariantOptions: TDocVariantOptions;
  public
    /// initialize the internal fields
    constructor Create(aPropInfo: PPropInfo; aPropIndex: integer;
      aSQLFieldType: TSQLFieldType); override;
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
    procedure GetVariant(Instance: TObject; var Dest: Variant); override;
    procedure SetVariant(Instance: TObject; const Source: Variant); override;
    /// how this property will deal with its instances (including TDocVariant)
    // - by default, contains JSON_OPTIONS[true] for best performance - i.e.
    // [dvoReturnNullForUnknownProperty,dvoValueCopiedByReference]
    property DocVariantOptions: TDocVariantOptions read fDocVariantOptions write fDocVariantOptions;
  end;
{$endif NOVARIANTS}

  /// optional event handler used by TSQLPropInfoRecord to handle textual storage
  // - by default, TSQLPropInfoRecord content will be stored as sftBlobCustom;
  // specify such a callback event to allow storage as UTF-8 textual field and
  // use a sftUTF8Custom kind of column
  // - event implementation shall convert data/datalen binary value into Text
  TOnSQLPropInfoRecord2Text = procedure(Data: pointer; DataLen: integer;
    var Text: RawUTF8);
  /// optional event handler used by TSQLPropInfoRecord to handle textual storage
  // - by default, TSQLPropInfoRecord content will be stored as sftBlobCustom;
  // specify such a callback event to allow storage as UTF-8 textual field and
  // use a sftUTF8Custom kind of column
  // - event implementaiton shall convert Text into Data binary value
  TOnSQLPropInfoRecord2Data = procedure(Text: PUTF8Char; var Data: RawByteString);

  /// abstract information about a record-like property defined directly in code
  // - do not use this class, but TSQLPropInfoRecordRTTI and TSQLPropInfoRecordFixedSize
  // - will store the content as BLOB by default, and SQLFieldType as sftBlobCustom
  // - if aData2Text/aText2Data are defined, use TEXT storage and sftUTF8Custom type
  TSQLPropInfoCustom = class(TSQLPropInfo)
  protected
    fOffset: PtrUInt;
    fData2Text: TOnSQLPropInfoRecord2Text;
    fText2Data: TOnSQLPropInfoRecord2Data;
    procedure BinaryToText(var Value: RawUTF8; ToSQL: boolean; wasSQLString: PBoolean); override;
    procedure TextToBinary(Value: PUTF8Char; var result: RawByteString); override;
  public
    /// define a custom property in code
    // - do not call this constructor directly, but one of its inherited classes,
    // via a call to TSQLRecordProperties.RegisterCustom*()
    constructor Create(const aName: RawUTF8; aSQLFieldType: TSQLFieldType;
      aAttributes: TSQLPropInfoAttributes; aFieldWidth, aPropIndex: Integer;
      aProperty: pointer; aData2Text: TOnSQLPropInfoRecord2Text;
      aText2Data: TOnSQLPropInfoRecord2Data); reintroduce;
  public
    function GetFieldAddr(Instance: TObject): pointer; override;
  end;

  /// information about a record property defined directly in code
  // - Delphi does not publish RTTI for published record properties
  // - you can use this class to register a record property from its RTTI
  // - will store the content as BLOB by default, and SQLFieldType as sftBlobCustom
  // - if aData2Text/aText2Data are defined, use TEXT storage and sftUTF8Custom type
  // - this class will use only binary RecordLoad/RecordSave methods
  TSQLPropInfoRecordRTTI = class(TSQLPropInfoCustom)
  protected
    fTypeInfo: PTypeInfo;
  public
    /// define a record property from its RTTI definition
    // - handle any kind of record with TypeInfo() generated
    // - aPropertyPointer shall be filled with the offset to the private
    // field within a nil object, e.g for
    // !  class TMainObject = class(TSQLRecord)
    // !    (...)
    // !    fFieldName: TMyRecord;
    // !  public
    // !    (...)
    // !    property FieldName: TMyRecord read fFieldName write fFieldName;
    // !  end;
    // you will have to register it via a call to
    // TSQLRecordProperties.RegisterCustomRTTIRecordProperty()
    // - optional aIsNotUnique parametercanl be defined
    // - implementation will use internally RecordLoad/RecordSave functions
    // - you can specify optional aData2Text/aText2Data callbacks to store
    // the content as textual values, and not as BLOB
    constructor Create(aRecordInfo: PTypeInfo; const aName: RawUTF8; aPropertyIndex: integer;
      aPropertyPointer: pointer; aAttributes: TSQLPropInfoAttributes=[];
      aFieldWidth: integer=0; aData2Text: TOnSQLPropInfoRecord2Text=nil;
      aText2Data: TOnSQLPropInfoRecord2Data=nil); reintroduce; overload;
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
      var temp: RawByteString); override;
    function SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean; override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    {$ifndef NOVARIANTS}
    procedure GetVariant(Instance: TObject; var Dest: Variant); override;
    procedure SetVariant(Instance: TObject; const Source: Variant); override;
    {$endif}
  end;

  /// information about a fixed-size record property defined directly in code
  // - Delphi does not publish RTTI for published record properties
  // - you can use this class to register a record property with no RTTI (i.e.
  // a record with no reference-counted types within) 
  // - will store the content as BLOB by default, and SQLFieldType as sftBlobCustom
  // - if aData2Text/aText2Data are defined, use TEXT storage and sftUTF8Custom type
  TSQLPropInfoRecordFixedSize = class(TSQLPropInfoCustom)
  protected
    fTypeInfo: PTypeInfo;
    fRecordSize: integer;
  public
    /// define an unmanaged fixed-size record property
    // - simple kind of records (i.e. those not containing reference-counted
    // members) do not have RTTI generated, at least in older versions of Delphi:
    // use this constructor to define a direct property access
    // - main parameter is the record size, in bytes
    constructor Create(aRecordSize: cardinal; const aName: RawUTF8; aPropertyIndex: integer;
      aPropertyPointer: pointer; aAttributes: TSQLPropInfoAttributes=[];
      aFieldWidth: integer=0; aData2Text: TOnSQLPropInfoRecord2Text=nil;
      aText2Data: TOnSQLPropInfoRecord2Data=nil); reintroduce; overload;
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
      var temp: RawByteString); override;
    function SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean; override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt; override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    {$ifndef NOVARIANTS}
    procedure GetVariant(Instance: TObject; var Dest: Variant); override;
    procedure SetVariant(Instance: TObject; const Source: Variant); override;
    {$endif}
  end;

  /// information about a custom property defined directly in code
  // - you can define any kind of property, either a record or any type
  // - this class will use JSON serialization, by type name or TypeInfo() pointer
  // - will store the content as TEXT by default, and SQLFieldType as sftUTF8Custom
  TSQLPropInfoCustomJSON = class(TSQLPropInfoCustom)
  protected
    fCustomParser: TJSONCustomParserRTTI;
    procedure SetCustomParser(aCustomParser: TJSONCustomParserRTTI);
  public
    /// initialize the internal fields
    // - should not be called directly
    constructor Create(aPropInfo: PPropInfo; aPropIndex: integer);
      reintroduce; overload; virtual;
    /// define a custom property from its RTTI definition
    // - handle any kind of property, e.g. from enhanced RTTI or a custom record
    // defined via TTextWriter.RegisterCustomJSONSerializer[FromText]()
    // - aPropertyPointer shall be filled with the offset to the private
    // field within a nil object, e.g for
    // !  class TMainObject = class(TSQLRecord)
    // !    (...)
    // !    fFieldName: TMyRecord;
    // !  public
    // !    (...)
    // !    property FieldName: TMyRecord read fFieldName write fFieldName;
    // !  end;
    // you will have to register it via a call to
    // TSQLRecordProperties.RegisterCustomPropertyFromRTTI()
    // - optional aIsNotUnique parameter can be defined
    // - implementation will use internally RecordLoadJSON/RecordSave functions
    // - you can specify optional aData2Text/aText2Data callbacks to store
    // the content as textual values, and not as BLOB
    constructor Create(aTypeInfo: PTypeInfo; const aName: RawUTF8;
      aPropertyIndex: integer; aPropertyPointer: pointer;
      aAttributes: TSQLPropInfoAttributes=[]; aFieldWidth: integer=0);
        reintroduce; overload;
    /// define a custom property from its RTTI definition
    // - handle any kind of property, e.g. from enhanced RTTI or a custom record
    // defined via TTextWriter.RegisterCustomJSONSerializer[FromText]()
    // - aPropertyPointer shall be filled with the offset to the private
    // field within a nil object, e.g for
    // !  class TMainObject = class(TSQLRecord)
    // !    (...)
    // !    fGUID: TGUID;
    // !  public
    // !    (...)
    // !    property GUID: TGUID read fGUID write fGUID;
    // !  end;
    // you will have to register it via a call to
    // TSQLRecordProperties.RegisterCustomPropertyFromTypeName()
    // - optional aIsNotUnique parameter can be defined
    // - implementation will use internally RecordLoadJSON/RecordSave functions
    // - you can specify optional aData2Text/aText2Data callbacks to store
    // the content as textual values, and not as BLOB
    constructor Create(const aTypeName, aName: RawUTF8;
      aPropertyIndex: integer; aPropertyPointer: pointer;
      aAttributes: TSQLPropInfoAttributes=[]; aFieldWidth: integer=0);
        reintroduce; overload;
    /// finalize the instance
    destructor Destroy; override;
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    procedure NormalizeValue(var Value: RawUTF8); override;
  end;

  /// dynamic array of ORM fields information for published properties
  TSQLPropInfoDynArray = array of TSQLPropInfo;

  /// handle a read-only list of ORM fields information for published properties
  TSQLPropInfoList = class
  protected
    fList: TSQLPropInfoDynArray;
    fCount: integer;
    fOrderedByName: TIntegerDynArray;
    function GetItem(aIndex: integer): TSQLPropInfo;
    procedure QuickSortByName(L,R: PtrInt);
  public
    /// release internal list items
    destructor Destroy; override;
    /// add a TSQLPropInfo to the list
    function Add(aTable: TClass; aItem: TSQLPropInfo): integer;
    /// find an item in the list
    // - returns nil if not found
    function ByRawUTF8Name(const aName: RawUTF8): TSQLPropInfo; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// find an item in the list
    // - returns nil if not found
    function ByName(aName: PUTF8Char): TSQLPropInfo; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// find an item in the list
    // - returns -1 if not found
    function IndexByName(const aName: RawUTF8): integer; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// find an item in the list
    // - returns -1 if not found
    function IndexByName(aName: PUTF8Char): integer; overload;
    /// find an item in the list, including RowID/ID
    // - will identify 'ID' / 'RowID' field name as -1
    // - raise an EORMException if not found in the internal list
    function IndexByNameOrExcept(const aName: RawUTF8): integer;
    /// fill a TRawUTF8DynArray instance from the field names
    // - excluding ID
    procedure NamesToRawUTF8DynArray(var Names: TRawUTF8DynArray);
    /// returns the number of TSQLPropInfo in the list
    property Count: integer read fCount;
    /// quick access to the TSQLPropInfo list
    // - note that length(List) may not equal Count, since is its capacity
    property List: TSQLPropInfoDynArray read fList;
    /// read-only retrieval of a TSQLPropInfo item
    // - will raise an exception if out of range
    property Items[aIndex: integer]: TSQLPropInfo read GetItem; //default;
  end;

  /// simple writer to a Stream, specialized for writing an object as INI
  // - resulting content will be UTF-8 encoded
  // - use an internal buffer, faster than string+string
  TINIWriter = class(TTextWriter)
    /// write the published integer, Int64, floating point values, (wide)string,
    // enumerates (e.g. boolean), variant properties of the object
    // - won't handle shortstring properties
    // - add a new INI-like section with [Value.ClassName] if WithSection is true
    // - the object must have been compiled with the $M+ define, i.e. must
    // inherit from TPersistent or TSQLRecord
    // - the enumerates properties are stored with their integer index value
    // - content can be read back using overloaded procedures ReadObject() 
    procedure WriteObject(Value: TObject; const SubCompName: RawUTF8='';
      WithSection: boolean=true); reintroduce;
  end;

  /// method prototype to be used for custom serialization of a class
  // - to be used with TJSONSerializer.RegisterCustomSerializer() method
  // - note that the generated JSON content is not required to start with '{',
  // as a normal JSON object (you may e.g. write a JSON string for some class) -
  // as a consequence, custom code could explicitely start with Add('{')
  // - implementation code shall follow function TJSONSerializer.WriteObject()
  // patterns, i.e. aSerializer.Add/AddInstanceName/AddJSONEscapeString...
  // - implementation code shall follow the same exact format for the
  // associated TJSONSerializerCustomReader callback
  TJSONSerializerCustomWriter = procedure(const aSerializer: TJSONSerializer;
    aValue: TObject; aOptions: TTextWriterWriteObjectOptions) of object;
  /// method prototype to be used for custom un-serialization of a class
  // - to be used with TJSONSerializer.RegisterCustomSerializer() method
  // - note that the read JSON content is not required to start with '{',
  // as a normal JSON object (you may e.g. read a JSON string for some class) -
  // as a consequence, custom code could explicitely start with "if aFrom^='{'..."
  // - implementation code shall follow function JSONToObject() patterns, i.e.
  // calling low-level GetJSONField() function to decode the JSON content
  // - implementation code shall follow the same exact format for the
  // associated TJSONSerializerCustomWriter callback
  TJSONSerializerCustomReader = function(const aValue: TObject; aFrom: PUTF8Char;
    var aValid: Boolean; aOptions: TJSONToObjectOptions): PUTF8Char of object;

  /// simple writer to a Stream, specialized for writing an object as JSON
  // - resulting JSON content will be UTF-8 encoded
  // - use an internal buffer, faster than string+string
  TJSONSerializer = class(TJSONWriter)
  protected
    /// used by WriteObjectAsString method
    fInternalJSONWriter: TJSONWriter;
  public
    /// serialize as JSON the published integer, Int64, floating point values,
    // TDateTime (stored as ISO 8601 text), string and enumerate (e.g. boolean)
    // properties of the object
    // - won't handle shortstring properties
    // - the object must have been compiled with the $M+ define, i.e. must
    // inherit from TPersistent or TSQLRecord, or has been defined with a
    // custom serializer via RegisterCustomSerializer()
    // - will write also the properties published in the parent classes
    // - the enumerates properties are stored with their integer index value by
    // default, but will be written as text if woFullExpand option is set
    // - TList objects are not handled by default - they will be written only
    // if FullExpand is set to true (and JSONToObject won't be able to read it)
    // - nested properties are serialized as nested JSON objects
    // - any TCollection property will also be serialized as JSON array
    // - any TStrings or TRawUTF8List property will also be serialized as
    // JSON string array
    // - function ObjectToJSON() is just a wrapper over this method
    procedure WriteObject(Value: TObject;
      Options: TTextWriterWriteObjectOptions=[woDontStoreDefault]); override;
    /// same as WriteObject(), but will double all internal " and bound with "
    // - this implementation will avoid most memory allocations
    procedure WriteObjectAsString(Value: TObject;
      Options: TTextWriterWriteObjectOptions=[woDontStoreDefault]);
    /// override method, able to write sets using RTTI
    procedure AddTypedJSON(aTypeInfo: pointer; const aValue); overload; override;
    /// overloaded method, able to write sets using RTTI in human readable mode
    // - if woFullExpand or woHumanReadable is set, enumerates and sets will
    // be stored as JSON string
    procedure AddTypedJSONWithOptions(aTypeInfo: pointer; var aValue;
      Options: TTextWriterWriteObjectOptions);
    /// relase all used memory and handles
    destructor Destroy; override;
    /// define a custom serialization for a given class
    // - by default, TSQLRecord, TPersistent, TStrings, TCollection classes
    // are processed: but you can specify here some callbacks to perform
    // the serialization process for any class
    // - any previous registration is overridden
    // - setting both aReader=aWriter=nil will return back to the default class
    // serialization (i.e. published properties serialization)
    // - note that any inherited classes will be serialized as the parent class
    class procedure RegisterCustomSerializer(aClass: TClass;
      aReader: TJSONSerializerCustomReader; aWriter: TJSONSerializerCustomWriter);
    /// let a given class be recognized by JSONToObject() from "ClassName":".."
    // - TObjectList item instances will be created corresponding to the
    // serialized class name field specified, and JSONToNewObject() can create a
    // new instance using the "ClassName":"..." field to identify the class type
    // - by default, all referenced TSQLRecord classes will be globally
    // registered when TSQLRecordProperties information is retrieved
    class procedure RegisterClassForJSON(aItemClass: TClass); overload;
    /// let a given class be recognized by JSONToObject() from "ClassName":".."
    // - TObjectList item instances will be created corresponding to the
    // serialized class name field specified, and JSONToNewObject() can create a
    // new instance using the "ClassName":"..." field to identify the class type
    // - by default, all referenced TSQLRecord classes will be globally
    // registered when TSQLRecordProperties information is retrieved
    class procedure RegisterClassForJSON(const aItemClass: array of TClass); overload;
{$ifndef LVCL}
    /// let a given TCollection be recognized during JSON serialization
    // - due to how TCollection instances are created, you can not create a
    // server-side instance of TCollection directly
    // - first workaround is to inherit from TInterfacedCollection
    // - this method allows to recognize the needed TCollectionItem class for
    // a given TCollection class, so allow to (un)serialize any TCollection,
    // without defining a new method and inherits from TInterfacedCollection
    // - note that both supplied classes will be registered for the internal
    // "ClassName":"..." RegisterClassForJSON() process
    class procedure RegisterCollectionForJSON(aCollection: TCollectionClass;
      aItem: TCollectionItemClass); 
{$endif}
  end;

/// retreive a Field property index from a Property Name
function ClassFieldIndex(ClassType: TClass; const PropName: shortstring): integer;

/// retrieve a Field property RTTI information from a Property Name
function ClassFieldProp(ClassType: TClass; const PropName: shortstring): PPropInfo;

/// retrieve a Field property RTTI information from a Property Name
// - this special version also search into parent properties (default is only current)
function ClassFieldPropWithParents(aClassType: TClass; const PropName: shortstring): PPropInfo;

/// retrieve a Field property RTTI information from a Property Name
// - this special version also search into parent properties (default is only current)
function ClassFieldPropWithParentsFromUTF8(aClassType: TClass; PropName: PUTF8Char): PPropInfo;

/// retrieve an object's component from its property name and class
// - useful to set User Interface component, e.g.
function GetObjectComponent(Obj: TPersistent; const ComponentName: shortstring;
  ComponentClass: TClass): pointer;

/// retrieve the class property RTTI information for a specific class
function InternalClassProp(ClassType: TClass): PClassProp;
  {$ifdef FPC}inline;{$endif}

/// create an instance of the given class
// - will handle the custom virtual constructors of TSQLRecord or
// TCollection classes as expected, so is to be preferred to aClass.Create
function ClassInstanceCreate(aClass: TClass): TObject; overload;

/// create an instance of the given class from its registered class name
// - the class shall have been registered via TJSONSerializer.RegisterClassForJSON()
// or via the standard RegisterClass() function of Classes.pas unit
// - will handle the custom virtual constructors of TSQLRecord or
// TCollection classes as expected, so is to be preferred to aClass.Create
function ClassInstanceCreate(const aClassName: RawUTF8): TObject; overload;

/// retrieve a method RTTI information for a specific class
function InternalMethodInfo(aClassType: TClass; const aMethodName: ShortString): PMethodInfo;

/// execute an instance method from its RTTI per-interface information
// - calling this function with a pre-computed PInterfaceEntry value is faster
// than calling the TObject.GetInterface() method, especially when the class
// implements several interfaces
function GetInterfaceFromEntry(Instance: TObject; Entry: PInterfaceEntry; out Obj): boolean;

/// retrieve the ready to be displayed text of an enumeration
// - will "uncamel" then translate into a generic VCL string
// - aIndex will be converted to the matching ordinal value (byte or word)
function GetEnumCaption(aTypeInfo: PTypeInfo; const aIndex): string;

/// get the corresponding enumeration name, without the first lowercase chars
// (otDone -> 'Done')
// - aIndex will be converted to the matching ordinal value (byte or word)
// - this will return the code-based English text; use GetEnumCaption() to
// retrieve the enumeration display text
function GetEnumNameTrimed(aTypeInfo: PTypeInfo; const aIndex): RawUTF8;


{$ifdef MSWINDOWS}
{$ifdef CONDITIONALEXPRESSIONS}
{$if CompilerVersion >= 22.0} // fix Delphi XE imcompatilibility
type
  TSecurityAttributes = packed record
    nLength: DWORD;
    lpSecurityDescriptor: Pointer;
    bInheritHandle: BOOL;
  end;

const
  SECURITY_DESCRIPTOR_REVISION = 1;
  SECURITY_DESCRIPTOR_MIN_LENGTH = 20;
{$ifend}
{$endif}
{$endif}

const
  /// HTML Status Code for "Continue"
  HTML_CONTINUE = 100;
  /// HTML Status Code for "Switching Protocols"
  HTML_SWITCHINGPROTOCOLS = 101;
  /// HTML Status Code for "Success"
  HTML_SUCCESS = 200;
  /// HTML Status Code for "Created"
  HTML_CREATED = 201;
  /// HTML Status Code for "Accepted"
  HTML_ACCEPTED = 202;
  /// HTML Status Code for "Non-Authoritative Information"
  HTML_NONAUTHORIZEDINFO = 203;
  /// HTML Status Code for "No Content"
  HTML_NOCONTENT = 204;
  /// HTML Status Code for "Multiple Choices"
  HTML_MULTIPLECHOICES = 300;
  /// HTML Status Code for "Moved Permanently"
  HTML_MOVEDPERMANENTLY = 301;
  /// HTML Status Code for "Found"
  HTML_FOUND = 302;
  /// HTML Status Code for "See Other"
  HTML_SEEOTHER = 303;
  /// HTML Status Code for "Not Modified"
  HTML_NOTMODIFIED = 304;
  /// HTML Status Code for "Use Proxy"
  HTML_USEPROXY = 305;
  /// HTML Status Code for "Temporary Redirect"
  HTML_TEMPORARYREDIRECT = 307;
  /// HTML Status Code for "Bad Request"
  HTML_BADREQUEST = 400;
  /// HTML Status Code for "Unauthorized"
  HTML_UNAUTHORIZED = 401;
  /// HTML Status Code for "Forbidden"
  HTML_FORBIDDEN = 403;
  /// HTML Status Code for "Not Found"
  HTML_NOTFOUND = 404;
  // HTML Status Code for "Method Not Allowed"
  HTML_NOTALLOWED = 405;
  // HTML Status Code for "Not Acceptable"
  HTML_NOTACCEPTABLE = 406;
  // HTML Status Code for "Proxy Authentication Required"
  HTML_PROXYAUTHREQUIRED = 407;
  /// HTML Status Code for "Request Time-out"
  HTML_TIMEOUT = 408;
  /// HTML Status Code for "Internal Server Error"
  HTML_SERVERERROR = 500;
  /// HTML Status Code for "Not Implemented"
  HTML_NOTIMPLEMENTED = 501;
  /// HTML Status Code for "Bad Gateway"
  HTML_BADGATEWAY = 502;
  /// HTML Status Code for "Service Unavailable"
  HTML_UNAVAILABLE = 503;
  /// HTML Status Code for "Gateway Timeout"
  HTML_GATEWAYTIMEOUT = 504;
  /// HTML Status Code for "HTTP Version Not Supported"
  HTML_HTTPVERSIONNONSUPPORTED = 505;

  /// used e.g. by THttpApiServer.Request for http.sys to send a static file
  // - the OutCustomHeader should contain the proper 'Content-type: ....'
  // corresponding to the file (e.g. by calling GetMimeContentType() function
  // from SynCommons supplyings the file name)
  // - should match HTTP_RESP_STATICFILE constant defined in SynCrtSock.pas unit
  STATICFILE_CONTENT_TYPE = '!STATICFILE';

  /// HTTP header used e.g. by THttpApiServer.Request for http.sys to send
  // a static file in kernel mode
  STATICFILE_CONTENT_TYPE_HEADER = HEADER_CONTENT_TYPE+STATICFILE_CONTENT_TYPE;

/// convert any HTML_* constant to a short English text
// - see @http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
procedure StatusCodeToErrorMsg(Code: integer; var result: RawUTF8);



{ ************ main ORM / SOA classes and types }

const
  /// the used TAuthSession.IDCardinal value if the session not started yet
  // - i.e. if the session handling is still in its handshaking phase
  CONST_AUTHENTICATION_SESSION_NOT_STARTED = 0;

  /// the used TAuthSession.IDCardinal value if authentication mode is not set
  // - i.e. if TSQLRest.HandleAuthentication equals FALSE
  CONST_AUTHENTICATION_NOT_USED = 1;

  /// maximum handled dimension for TSQLRecordRTree
  // - this value is the one used by SQLite3 R-Tree virtual table
  RTREE_MAX_DIMENSION = 5;

  /// used as "stored AS_UNIQUE" published property definition in TSQLRecord
  AS_UNIQUE = false;

  
type
  /// exception raised in case of incorrect TSQLTable.Step / Field*() use
  ESQLTableException = class(ESynException);

  /// generic parent class of all custom Exception types of this unit
  EORMException = class(ESynException);

  /// exception raised in case of wrong Model definition
  EModelException = class(EORMException);

  /// exception raised in case of unexpected parsing error
  EParsingException = class(EORMException);

  /// exception raised in case of a Client-Server communication error
  ECommunicationException = class(EORMException);

  /// exception raised in case of an error in project implementation logic
  EBusinessLayerException = class(EORMException);

  /// exception raised in case of any authentication error
  ESecurityException = class(EORMException);

  /// exception dedicated to interface factory, e.g. services and mock/stubs
  EInterfaceFactoryException = class(ESynException);

  /// exception dedicated to interface based service implementation
  EServiceException = class(EORMException);

  TSQLModel = class;
  TSQLRest = class;
  TSQLRestClient = class;
  TSQLModelRecordProperties = class;
  TSQLTable = class;

{$M+} { we need the RTTI information to be compiled for the published
        properties of these classes and their children (like TPersistent),
        to enable ORM - must be defined at the forward definition level }
  TSQLRecord = class;      // published properties = ORM fields/columns
  TSQLRecordMany = class;
  TSQLAuthUser = class;
  TSQLRestServer = class;  // published methods = RESTful callbacks handlers
  TSQLRestStorage = class;
  TSQLRestClientURI = class;
{$M-}

  /// class-reference type (metaclass) of TSQLRecord
  TSQLRecordClass = class of TSQLRecord;

  PClass = ^TClass;
  PSQLRecordClass = ^TSQLRecordClass;

  /// a dynamic array used to store the TSQLRecord classes in a Database Model
  TSQLRecordClassDynArray = array of TSQLRecordClass;


  /// information about a TSQLRecord class property
  // - sftID for TSQLRecord properties, which are pointer(RecordID), not
  // any true class instance
  // - sftMany for TSQLRecordMany properties, for which no data is
  // stored in the table itself, but in a pivot table
  // - sftObject for e.g. TStrings TRawUTF8List TCollection instances
  {$ifdef CPU64}
  TSQLPropInfoRTTIInstance = class(TSQLPropInfoRTTIInt64){$else}
  TSQLPropInfoRTTIInstance = class(TSQLPropInfoRTTIInt32){$endif}
  protected
    fObjectClass: TClass;
  public
    /// will setup the corresponding RecordClass property
    constructor Create(aPropInfo: PPropInfo; aPropIndex: integer; aSQLFieldType: TSQLFieldType); override;
    /// direct access to the property class instance
    function GetInstance(Instance: TObject): TObject;
    /// direct access to the property class instance
    procedure SetInstance(Instance, Value: TObject);
    /// direct access to the property class
    // - can be used e.g. for TSQLRecordMany properties
    property ObjectClass: TClass read fObjectClass;
  end;

  /// information about a TSQLRecord class TSQLRecord property
  // - kind sftID, which are pointer(RecordID), not any true class instance
  // - will store the content just as an integer value
  // - will recognize any instance pre-allocated via Create*Joined() constructor
  TSQLPropInfoRTTIID = class(TSQLPropInfoRTTIInstance)
  public
    /// raise an exception if was created by Create*Joined() constructor
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    /// this method will recognize if the TSQLRecord was allocated by
    // a Create*Joined() constructor: in this case, it will write the ID
    // of the nested property, and not the PtrInt() transtyped value
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
  end;

  /// information about a TSQLRecord class TStrings/TRawUTF8List/TCollection
  // property
  // - kind sftObject e.g. for TStrings TRawUTF8List TCollection TObjectList instances
  // - binary serialization will store textual JSON serialization of the
  // object, including custom serialization
  TSQLPropInfoRTTIObject = class(TSQLPropInfoRTTIInstance)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
    procedure CopyValue(Source, Dest: TObject); override;
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal; override;
    procedure NormalizeValue(var Value: RawUTF8); override;
    procedure GetJSONValues(Instance: TObject; W: TJSONSerializer); override;
  end;

  /// information about a TSQLRecord class TSQLRecordMany property
  // - kind sftMany, for which no data is stored in the table itself, but in
  // a separated pivot table
  TSQLPropInfoRTTIMany = class(TSQLPropInfoRTTIInstance)
  public
    procedure SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean); override;
    procedure GetValueVar(Instance: TObject; ToSQL: boolean;
      var result: RawUTF8; wasSQLString: PBoolean); override;
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter); override;
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar; override;
  end;

  /// class-refrence type (metaclass) for a TSynFilter or a TSynValidate
  TSynFilterOrValidateClass = class of TSynFilterOrValidate;

  /// the kind of SQlite3 (virtual) table
  // - TSQLRecordFTS3 will be associated with vFTS3, TSQLRecordFTS4 with vFTS4,
  // TSQLRecordRTree with vRTree, any native SQlite3 table as vSQLite3, and
  // a TSQLRecordVirtualTable*ID with rCustomForcedID/rCustomAutoID
  // - a plain TSQLRecord class can be defined as rCustomForcedID (e.g. for
  // TSQLRecordMany) after registration for an external DB via a call to
  // VirtualTableExternalRegister() from mORMotDB unit
  TSQLRecordVirtualKind = (
    rSQLite3, rFTS3, rFTS4, rRTree, rCustomForcedID, rCustomAutoID);

  /// kind of (static) database server implementation available
  // - sMainEngine will identify the default main SQlite3 engine
  // - sStaticDataTable will identify a TSQLRestStorageInMemory - i.e.
  // TSQLRestServer.fStaticData[] which can work without SQLite3
  // - sVirtualTable will identify virtual TSQLRestStorage classes - i.e.
  // TSQLRestServer.fStaticVirtualTable[] which points to SQLite3 virtual tables
  // (e.g. TObjectList or external databases)
  TSQLRestServerKind = (sMainEngine, sStaticDataTable, sVirtualTable);
  /// pointer to the kind of (static) database server implementation
  PSQLRestServerKind = ^TSQLRestServerKind;

  /// some information about a given TSQLRecord class properties
  // - used internaly by TSQLRecord, via a global cache handled by this unit:
  // you can access to each record's properties via TSQLRecord.RecordProps class
  // - such a global cache saves some memory for each TSQLRecord instance,
  // and allows faster access to most wanted RTTI properties
  TSQLRecordProperties = class
  protected
    fSQLFillPrepareMany: RawUTF8;
    fRecordManySourceProp: TSQLPropInfoRTTIInstance;
    fRecordManyDestProp: TSQLPropInfoRTTIInstance;
    fWeakZeroClass: TObject;
    /// the associated TSQLModel instances
    // - e.g. allow O(1) search of a TSQLRecordClass in a model
    fModel: array of record
      /// one associated model
      Model: TSQLModel;
      /// the index in the Model.Tables[] array
      TableIndex: integer;
      /// associated ORM parameters
      Properties: TSQLModelRecordProperties;
    end;
    fLock: TRTLCriticalSection;
    fModelMax: integer;
    fCustomCollation: TRawUTF8DynArray;
    /// add an entry in fModel[] / fModelMax
    procedure InternalRegisterModel(aModel: TSQLModel;
      aTableIndex: integer; aProperties: TSQLModelRecordProperties);
  public
    /// the TSQLRecord class
    Table: TSQLRecordClass;
    {/ the Table name in the database, associated with this TSQLRecord class
     - 'TSQL' or 'TSQLRecord' chars are trimmed at the beginning of the ClassName
     - or the ClassName is returned as is, if no 'TSQL' or 'TSQLRecord' at first }
    SQLTableName: RawUTF8;
    {/ the Table name in the database in uppercase with a final '.'
     - e.g. 'TEST.' for TSQLRecordTest class
     - can be used with IdemPChar() for fast check of a table name }
    SQLTableNameUpperWithDot: RawUTF8;
    /// fast access to the RTTI properties attribute
    ClassProp: PClassProp;
    /// if this class has any BLOB or TSQLRecodMany fields
    // - i.e. some fields to be ignored
    HasNotSimpleFields: boolean;
    /// set of field types appearing in this record
    HasTypeFields: TSQLFieldTypes;
    /// list all fields, as retrieved from RTTI
    Fields: TSQLPropInfoList;
    /// list all "simple" fields of this TSQLRecord
    // - by default, the TSQLRawBlob and TSQLRecordMany fields are not included
    // into this set: they must be read specificaly (in order to spare
    // bandwidth for BLOBs)
    // - dynamic arrays belong to simple fields: they are sent with other
    // properties content
    // - match inverted NOT_SIMPLE_FIELDS mask
    SimpleFields: TSQLPropInfoDynArray;
    /// list all fields which can be copied from one TSQLRecord instance to another
    // - match COPIABLE_FIELDS mask, i.e. all fields except sftMany
    CopiableFields: TSQLPropInfoDynArray;
    /// list all TSQLRecordMany fields of this TSQLRecord
    ManyFields: array of TSQLPropInfoRTTIMany;
    /// list all TSQLRecord fields of this TSQLRecord
    // - ready to be used by TSQLTableJSON.CreateFromTables()
    // - i.e. the class itself then, all fields of type sftID (excluding sftMany)
    JoinedFields: array of TSQLPropInfoRTTIID;
    /// wrapper of all nest TSQLRecord class of this TSQLRecord
    // - ready to be used by TSQLTableJSON.CreateFromTables()
    // - i.e. the class itself as JoinedFieldsTable[0], then, all nested
    // TSQLRecord published properties (of type sftID, ergo excluding sftMany)
    // - equals nil if there is no nested TSQLRecord property (i.e. JoinedFields=nil)
    JoinedFieldsTable: TSQLRecordClassDynArray;
    /// list of all sftBlobDynArray fields of this TSQLRecord
    DynArrayFields: array of TSQLPropInfoRTTIDynArray;
    /// list of all sftBlobCustom fields of this TSQLRecord
    // - have been defined e.g. as TSQLPropInfoCustom custom definition 
    BlobCustomFields: TSQLPropInfoDynArray;
    /// list all BLOB fields of this TSQLRecord
    // - i.e. generic sftBlob fields (not sftBlobDynArray, sftBlobCustom nor
    // sftBlobRecord)
    BlobFields: array of TSQLPropInfoRTTI;
    /// bit set to 1 for indicating BLOB fields of this TSQLRecord
    // - i.e. generic sftBlob fields (not sftBlobDynArray, sftBlobCustom nor
    // sftBlobRecord)
    BlobFieldsBits: TSQLFieldBits;
    /// bit set to 1 for indicating TModTime fields of this TSQLRecord
    // - i.e. sftModTime fields
    ModTimeFieldsBits: TSQLFieldBits;
    /// bit set to 1 for indicating TModTime and TCreateTime fields
    // of this TSQLRecord
    // - i.e. sftModTime and sftCreateTime fields
    ModCreateTimeFieldsBits: TSQLFieldBits;
    /// bit set to 1 for indicating fields to export, i.e. "simple" fields
    // - this array will handle special cases, like the TCreateTime fields
    // which shall not be included in soUpdate but soInsert and soSelect e.g.
    SimpleFieldsBits: array[TSQLOccasion] of TSQLFieldBits;
    /// number of fields to export, i.e. "simple" fields
    // - this array will handle special cases, like the TCreateTime fields
    // which shall not be included in soUpdate but soInsert and soSelect e.g.
    SimpleFieldsCount: array[TSQLOccasion] of integer;
    /// bit set to 1 for an unique field
    // - an unique field is defined as "stored AS_UNIQUE" (i.e. "stored false")
    // in its property definition
    IsUniqueFieldsBits: TSQLFieldBits;
    /// contains the main field index (e.g. mostly 'Name')
    // - the [boolean] is for [ReturnFirstIfNoUnique] version
    // - contains -1 if no field matches
    MainField: array[boolean] of integer;
    /// returns 'COL1,COL2' with all COL* set to simple field names 
    // - same value as SQLTableSimpleFields[false,false]
    // - this won't change depending on the ORM settings: so it can be safely
    // computed here and not in TSQLModelRecordProperties
    // - used e.g. by TSQLRecord.GetSQLValues 
    SQLTableSimpleFieldsNoRowID: RawUTF8;
    /// returns 'COL1=?,COL2=?' with all BLOB columns names
    // - used e.g. by TSQLRestServerDB.UpdateBlobFields()
    SQLTableUpdateBlobFields: RawUTF8;
    /// returns 'COL1,COL2' with all BLOB columns names
    // - used e.g. by TSQLRestServerDB.RetrieveBlobFields()
    SQLTableRetrieveBlobFields: RawUTF8;
    /// returns 'COL1,COL2' with all COL* set to all field names, including
    // RowID and BLOBs 
    // - this won't change depending on the ORM settings: so it can be safely
    // computed here and not in TSQLModelRecordProperties
    // - used e.g. by TSQLRest.InternalListJSON()
    SQLTableRetrieveAllFields: RawUTF8;
    /// all TSynFilter or TSynValidate instances registered per each field
    // - since validation and filtering are used within some CPU-consuming
    // part of the framework (like UI edition), both filters and validation
    // rules are grouped in the same TObjectList - for TSynTableFieldProperties
    // there are separated Filters[] and Validates[] array, for better performance
    Filters: array of TObjectList;
    /// for a TSQLRecordMany class, points to the Source property RTTI
    property RecordManySourceProp: TSQLPropInfoRTTIInstance read fRecordManySourceProp;
    /// for a TSQLRecordMany class, points to the Dest property RTTI
    property RecordManyDestProp: TSQLPropInfoRTTIInstance read fRecordManyDestProp;

    /// initialize the properties content
    constructor Create(aTable: TSQLRecordClass);
    /// release associated used memory
    destructor Destroy; override;

    /// return TRUE if the given name is either ID/RowID, either a property name
    function IsFieldName(const PropName: RawUTF8): boolean;
    /// set all bits corresponding to the supplied field names
    // - returns TRUE on success, FALSE if any field name is not existing
    function FieldIndexsFromRawUTF8(const aFields: array of RawUTF8;
      var Bits: TSQLFieldBits): boolean; overload;
    /// set all bits corresponding to the supplied field names
    // - returns the matching fields set
    function FieldIndexsFromRawUTF8(const aFields: array of RawUTF8): TSQLFieldBits; overload;
    /// set all bits corresponding to the supplied CSV field names
    // - returns TRUE on success, FALSE if any field name is not existing
    function FieldIndexsFromCSV(const aFieldsCSV: RawUTF8;
      var Bits: TSQLFieldBits): boolean; overload;
    /// set all bits corresponding to the supplied CSV field names
    // - returns the matching fields set
    function FieldIndexsFromCSV(const aFieldsCSV: RawUTF8): TSQLFieldBits; overload;
    /// set all bits corresponding to the supplied BLOB field type information
    // - returns TRUE on success, FALSE if blob field is not recognized
    function FieldIndexsFromBlobField(aBlobField: PPropInfo;
      var Bits: TSQLFieldBits): boolean;
    {/ retrieve a Field property RTTI information from a Property Name
      - this version returns nil if the property is not a BLOB field }
    function BlobFieldPropFromRawUTF8(const PropName: RawUTF8): PPropInfo;
    {/ retrieve a Field property RTTI information from a Property Name
      - this version returns nil if the property is not a BLOB field }
    function BlobFieldPropFromUTF8(PropName: PUTF8Char; PropNameLen: integer): PPropInfo;

    /// append a field name to a RawUTF8 Text buffer
    // - if FieldIndex=VIRTUAL_TABLE_ROWID_COLUMN (-1), appends 'RowID' or
    // 'ID' (if ForceNoRowID=TRUE) to Text
    // - on error (i.e. if FieldIndex is out of range) will return TRUE
    // - otherwise, will return FALSE and append the field name to Text
    function AppendFieldName(FieldIndex: Integer; var Text: RawUTF8; ForceNoRowID: boolean): boolean;
    {/ return the first unique property of kind RawUTF8
      - this property is mainly the "Name" property, i.e. the one with
        "stored AS_UNIQUE" (i.e. "stored false") definition on most TSQLRecord
      - if ReturnFirstIfNoUnique is TRUE and no unique property is found,
        the first RawUTF8 property is returned anyway
      - returns '' if no matching field was found }
    function MainFieldName(Table: TSQLRecordClass;
      ReturnFirstIfNoUnique: boolean=false): RawUTF8;
    /// return the SQLite3 field datatype for each specified field
    // - set to '' for fields with no column created in the database (e.g. sftMany)
    // - equals e.g. ' INTEGER, ' or ' TEXT COLLATE SYSTEMNOCASE, '
    function SQLFieldTypeToSQL(Fieldindex: integer): RawUTF8;
    /// set a custom SQlite3 text column collation for a specified field
    // - can be used e.g. to override the default COLLATE SYSTEMNOCASE of RawUTF8
    // - collations defined within our SynSQLite3 unit are named BINARY, NOCASE,
    // RTRIM and our custom SYSTEMNOCASE, ISO8601, WIN32CASE, WIN32NOCASE 
    // - do nothing if FieldIndex is not valid, and returns false
    // - to be set in overridden class procedure
    // TSQLRecord.InternalRegisterCustomProperties() so that it will be common
    // to all database models, for both client and server
    function SetCustomCollation(FieldIndex: integer; const aCollationName: RawUTF8): boolean;
    /// set a custom SQlite3 text column collation for all RawUTF8 fields
    // - can be used e.g. to override ALL default COLLATE SYSTEMNOCASE of RawUTF8,
    // and let the generated SQLite3 file be available outside
    // - collations defined within our SynSQLite3 unit are named BINARY, NOCASE,
    // RTRIM and our custom SYSTEMNOCASE, ISO8601, WIN32CASE, WIN32NOCASE 
    // - to be set in overridden class procedure InternalRegisterCustomProperties()
    // so that it will be common to all database models, for both client and server
    procedure SetCustomCollationForAllRawUTF8(const aCollationName: RawUTF8);
    /// return the UTF-8 encoded SQL statement source to alter the table for
    //  adding the specified field
    function SQLAddField(FieldIndex: integer): RawUTF8;

    /// create a TJSONWriter, ready to be filled with TSQLRecord.GetJSONValues(W)
    // - you can use TSQLRecordProperties.FieldIndexsFromCSV() or
    // TSQLRecordProperties.FieldIndexsFromRawUTF8() to compute aFields
    function CreateJSONWriter(JSON: TStream; Expand: boolean; withID: boolean;
      const aFields: TSQLFieldBits; KnownRowsCount: integer): TJSONSerializer;
    /// initialize the JSON writer parameters with corresponding fields
    // - WrittenFields could be e.g. SimpleFieldsBits[TSQLOccasion]
    // or be computed by TSQLRecordProperties.FieldIndexsFromCSV() or
    // TSQLRecordProperties.FieldIndexsFromRawUTF8()
    // - recreate especially the ColNames[] and other necessary properties
    // - if ForceResetFields is TRUE, all parameters will be recreated
    // - if ForceResetFields is FALSE, WrittenFields will be checked against W.Fields
    // and will recreate all parameters only if needed
    // - is used e.g. in TSQLRestClientURI.BatchUpdate and BatchAdd methods
    procedure SetExpandedJSONWriter(W: TJSONWriter; ForceResetFields: boolean;
      withID: boolean; const WrittenFields: TSQLFieldBits);
    /// set the W.ColNames[] array content + W.AddColumns
    procedure SetJSONWriterColumnNames(W: TJSONSerializer; KnownRowsCount: integer);
    /// save the TSQLRecord RTTI into a binary header
    // - used e.g. by TSQLRestStorageInMemory.SaveToBinary()
    procedure SaveBinaryHeader(W: TFileBufferWriter);
    /// ensure that the TSQLRecord RTTI matches the supplied binary header
    // - used e.g. by TSQLRestStorageInMemory.LoadFromBinary()
    function CheckBinaryHeader(var R: TFileBufferReader): boolean;

    /// register a custom filter or validation rule to the class for a specified
    // field
    // - this will be used by TSQLRecord.Filter and TSQLRecord.Validate
    // methods (in default implementation)
    // - will return the specified associated TSynFilterOrValidate instance
    // - will return nil in case of an invalid field index
    function AddFilterOrValidate(aFieldIndex: integer;
      aFilter: TSynFilterOrValidate): TSynFilterOrValidate; overload;
    /// register a custom filter or Validate to the class for a specified field
    // - this will be used by TSQLRecord.Filter and TSQLRecord.Validate
    // methods (in default implementation)
    // - will return the specified associated TSynFilterOrValidate instance
    function AddFilterOrValidate(const aFieldName: RawUTF8;
      aFilter: TSynFilterOrValidate): TSynFilterOrValidate; overload;
      {$ifdef HASINLINE}inline;{$endif}

    /// add a custom unmanaged fixed-size record property
    // - simple kind of records (i.e. those not containing reference-counted
    // members) do not have RTTI generated, at least in older versions of Delphi
    // - use this method within TSQLRecord.InternalRegisterCustomProperties
    // overridden method to define a custom record property with no
    // reference-counted types within (like strings) - typical use may be TGUID
    // - main parameters are the record size, in bytes, and the property pointer
    // - add an TSQLPropInfoRecordFixedSize instance to the internal list
    // - if aData2Text/aText2Data parameters are not defined, it will fallback
    // to TSQLPropInfo.BinaryToText() simple text Base64 encoding
    // - can be used to override the default TSQLRecord corresponding method:
    // !class procedure TSQLMyRecord.InternalRegisterCustomProperties(
    // !  Props: TSQLRecordProperties);
    // !begin
    // !  Props.RegisterCustomFixedSizeRecordProperty(self,sizeof(TMyRec),'RecField',
    // !    @TSQLMyRecord(nil).fRecField, [], sizeof(TMyRec));
    // !end;
    procedure RegisterCustomFixedSizeRecordProperty(aTable: TClass;
      aRecordSize: cardinal; const aName: RawUTF8;  aPropertyPointer: pointer;
      aAttributes: TSQLPropInfoAttributes; aFieldWidth: integer;
      aData2Text: TOnSQLPropInfoRecord2Text=nil;
      aText2Data: TOnSQLPropInfoRecord2Data=nil);
    /// add a custom record property from its RTTI definition
    // - handle any kind of record with TypeInfo() generated
    // - use this method within InternalRegisterCustomProperties overridden method
    // to define a custom record property containing reference-counted types
    // - main parameters are the record RTTI information, and the property pointer
    // - add an TSQLPropInfoRecordRTTI instance to the internal list
    // - can be used as such:
    // !class procedure TSQLMyRecord.InternalRegisterCustomProperties(
    // !  Props: TSQLRecordProperties);
    // !begin
    // !  Props.RegisterCustomRTTIRecordProperty(self,TypeInfo(TMyRec),'RecField',
    // !    @TSQLMyRecord(nil).fRecField);
    // !end;
    procedure RegisterCustomRTTIRecordProperty(aTable: TClass;
      aRecordInfo: PTypeInfo; const aName: RawUTF8; aPropertyPointer: pointer;
      aAttributes: TSQLPropInfoAttributes=[]; aFieldWidth: integer=0;
      aData2Text: TOnSQLPropInfoRecord2Text=nil;
      aText2Data: TOnSQLPropInfoRecord2Data=nil);
    /// add a custom property from its RTTI definition stored as JSON
    // - handle any kind of record with TypeInfo() generated
    // - use this method within InternalRegisterCustomProperties overridden method
    // to define a custom record property containing reference-counted types
    // - main parameters are the record RTTI information, and the property pointer
    // - add an TSQLPropInfoCustomJSON instance to the internal list
    // - can be used as such:
    // !class procedure TSQLMyRecord.InternalRegisterCustomProperties(
    // !  Props: TSQLRecordProperties);
    // !begin
    // !  Props.RegisterCustomPropertyFromRTTI(self,TypeInfo(TMyRec),'RecField',
    // !    @TSQLMyRecord(nil).fRecField);
    // !end;
    procedure RegisterCustomPropertyFromRTTI(aTable: TClass;
      aTypeInfo: PTypeInfo; const aName: RawUTF8; aPropertyPointer: pointer;
      aAttributes: TSQLPropInfoAttributes=[]; aFieldWidth: integer=0);
    /// add a custom property from its type name, stored as JSON
    // - handle any kind of registered record, including TGUID
    // - use this method within InternalRegisterCustomProperties overridden method
    // to define a custom record property containing reference-counted types
    // - main parameters are the record RTTI information, and the property pointer
    // - add an TSQLPropInfoCustomJSON instance to the internal list
    // - can be used as such:
    // !class procedure TSQLMyRecord.InternalRegisterCustomProperties(
    // !  Props: TSQLRecordProperties);
    // !begin
    // !  Props.RegisterCustomPropertyFromTypeName(self,'TGUID','GUID',
    // !    @TSQLMyRecord(nil).fGUID,[aIsUnique],38);
    // !end;
    procedure RegisterCustomPropertyFromTypeName(aTable: TClass;
      const aTypeName, aName: RawUTF8; aPropertyPointer: pointer;
      aAttributes: TSQLPropInfoAttributes=[]; aFieldWidth: integer=0);
  end;

  TServiceFactoryServer = class;
  PSQLAccessRights = ^TSQLAccessRights;

  /// the available THTTP methods transmitted between client and server
  // - some custom verbs are available in addition to standard REST commands
  TSQLURIMethod = (mNone, mGET, mPOST, mPUT, mDELETE, mHEAD,
                   mBEGIN, mEND, mABORT, mLOCK, mUNLOCK, mSTATE);

  /// store all parameters for a TSQLRestServer.URI() method call
  // - see TSQLRestClient to check how data is expected in our RESTful format
  TSQLRestURIParams = packed record
    /// input parameter containing the caller URI
    Url: RawUTF8;
    /// input parameter containing the caller method
    // - handle enhanced REST codes: LOCK/UNLOCK/BEGIN/END/ABORT
    Method: RawUTF8;
    /// input parameter containing the caller message headers
    // - you can use e.g.
    // ! FindIniNameValue(pointer(Call.InHead),HEADER_CONTENT_TYPE_UPPER)
    // to retrieve the incoming message body content type
    InHead: RawUTF8;
    /// input parameter containing the caller message body
    // - e.g. some GET/POST/PUT JSON data can be specified here
    InBody: RawUTF8;
    /// output parameter to be set to the response message header
    // - it is the right place to set the returned message body content type,
    // e.g. TEXT_CONTENT_TYPE_HEADER or HTML_CONTENT_TYPE_HEADER: if not set,
    // the default JSON_CONTENT_TYPE_HEADER will be returned to the client,
    // meaning that the message is JSON
    OutHead: RawUTF8;
    /// output parameter to be set to the response message body
    OutBody: RawUTF8;
    /// output parameter to be set to the HTTP status integer code
    // - HTML_NOTFOUND=404 e.g. if the url doesn't start with Model.Root (caller
    // can try another TSQLRestServer)
    OutStatus: cardinal;
    /// output parameter to be set to the database internal state
    // - should be the first unpacked 32 bit parameter after OutStatus
    OutInternalState: cardinal;
    /// associated RESTful access rights
    // - AccessRights must be handled by the TSQLRestServer child, according
    // to the Application Security Policy (user logging, authentification and
    // rights management) - making access rights a parameter allows this method
    // to be handled as pure stateless, thread-safe and session-free
    RestAccessRights: PSQLAccessRights;
  end;

  /// used to map set of parameters for a TSQLRestServer.URI() method
  PSQLRestURIParams = ^TSQLRestURIParams;

  /// all commands which may be executed by TSQLRestServer.URI() method
  // - execSOAByMethod for method-based services
  // - execSOAByInterface for interface-based services
  // - execORMGet for ORM reads i.e. Retrieve*() methods
  // - execORMWrite for ORM writes i.e. Add Update Delete TransactionBegin
  // Commit Rollback methods
  TSQLRestServerURIContextCommand = (
    execSOAByMethod, execSOAByInterface, execORMGet, execORMWrite);

  /// class used to define the Client-Server expected routing
  // - most of the internal methods are declared as virtual, so it allows any
  // kind of custom routing or execution scheme
  // - TSQLRestRoutingREST and TSQLRestRoutingJSON_RPC classes
  // are provided in this unit, to allow RESTful and JSON/RPC protocols
  TSQLRestServerURIContextClass = class of TSQLRestServerURIContext;

  /// abstract calling context for a TSQLRestServerCallBack event handler
  // - having a dedicated class avoid changing the implementation methods
  // signature if the framework add some parameters or behavior to it
  // - see TSQLRestServerCallBack for general code use
  // - most of the internal methods are declared as virtual, so it allows any
  // kind of custom routing or execution scheme
  // - instantiated by the TSQLRestServer.URI() method using its ServicesRouting
  // property
  // - see TSQLRestRoutingREST and TSQLRestRoutingJSON_RPC
  // for overridden methods - NEVER set this abstract TSQLRestServerURIContext
  // class on TSQLRest.ServicesRouting property !
  TSQLRestServerURIContext = class
  protected
    fInput: TRawUTF8DynArray; // even items are parameter names, odd are values
    fSessionAccessRights: RawByteString; // session may be deleted meanwhile
    procedure FillInput;
    {$ifndef NOVARIANTS}
    function GetInput(const ParamName: RawUTF8): variant;
    {$endif}
    function GetInputInt(const ParamName: RawUTF8): Int64;
    function GetInputDouble(const ParamName: RawUTF8): Double;
    function GetInputUTF8(const ParamName: RawUTF8): RawUTF8;
    procedure ServiceResultStart(WR: TTextWriter); virtual;
    procedure ServiceResultEnd(WR: TTextWriter; ID: integer); virtual;
    procedure InternalSetTableFromTableName(const TableName: RawUTF8); virtual;
    procedure InternalExecuteSOAByInterface; virtual;
    /// initialize the execution context
    // - this method has been declared as protected, since it shuold never be
    // called outside the TSQLRestServer.URI() method workflow
    // - should set Call, URISessionSignaturePos and URIWithoutSignature members
    // - default constructor will identify trailing SESSION_SIGNATURE=... pattern
    constructor Create(aServer: TSQLRestServer; const aCall: TSQLRestURIParams); virtual;
    /// retrieve RESTful URI routing
    // - should set URI, Table,TableIndex,TableRecordProps,TableEngine,
    // ID, URIBlobFieldName and Parameters members
    // - all Table* members will be set via a InternalSetTableFromTableName() call
    // - default implementation expects an URI encoded with
    // 'ModelRoot[/TableName[/TableID][/BlobFieldName]][?param=...]' format
    // - return FALSE in case of incorrect URI (e.g. does not match Model.Root)
    function URIDecodeREST: boolean; virtual;
    /// retrieve method-based SOA URI routing with optional RESTful mode
    // - should set MethodIndex member
    // - default RESTful implementation expects an URI encoded with
    // 'ModelRoot/MethodName' or 'ModelRoot/TableName[/TableID]/MethodName' formats
    procedure URIDecodeSOAByMethod; virtual;
    /// retrieve interface-based SOA 
    // - should set Service member (and possibly ServiceMethodIndex)
    // - abstract implementation which is to be overridden
    procedure URIDecodeSOAByInterface; virtual; abstract;
    /// process authentication
    // - return FALSE in case of invalid signature, TRUE if authenticated
    function Authenticate: boolean; virtual;
    /// direct launch of a method-based service
    // - URI() will ensure that MethodIndex>=0 before calling it
    procedure ExecuteSOAByMethod; virtual;
    /// direct launch of an interface-based service
    // - URI() will ensure that Service<>nil before calling it
    // - abstract implementation which is to be overridden
    procedure ExecuteSOAByInterface; virtual; abstract;
    /// handle GET/LOCK/UNLOCK/STATE verbs for ORM/CRUD process
    procedure ExecuteORMGet; virtual;
    /// handle POST/PUT/DELETE/BEGIN/END/ABORT verbs for ORM/CRUD process
    // - execution of this method is protected by a critical section
    procedure ExecuteORMWrite; virtual;
    /// launch the corresponding Execute* method in the execution mode
    // set by Server.AcquireExecutionMode/AcquireExecutionLockedTimeOut
    // - this is the main process point from TSQLRestServer.URI()
    procedure Execute(Command: TSQLRestServerURIContextCommand);
  public
    /// the associated TSQLRestServer instance which executes its URI method
    Server: TSQLRestServer;
    /// the used Client-Server method (matching the corresponding HTTP Verb)
    // - this property will be set from incoming URI, even if RESTful
    // authentication is not enabled
    Method: TSQLURIMethod;
    /// the URI address, excluding ?par1=.... parameters
    // - can be either the table name (in RESTful protocol), or a service name
    URI: RawUTF8;
    /// same as URI, but without the &session_signature=... ending
    URIWithoutSignature: RawUTF8;
    /// the optional Blob field name as specified in URI
    // - e.g. retrieved from "ModelRoot/TableName/TableID/BlobFieldName"
    URIBlobFieldName: RawUTF8;
    /// position of the &session_signature=... text in URI
    URISessionSignaturePos: integer;
    /// the Table as specified at the URI level (if any)
    Table: TSQLRecordClass;
    /// the index in the Model of the Table specified at the URI level (if any)
    TableIndex: integer;
    /// the RTTI properties of the Table specified at the URI level (if any)
    TableRecordProps: TSQLModelRecordProperties;
    /// the RESTful instance implementing the Table specified at the URI level (if any)
    // - equals TSQLRestServer most of the time, but may be an TSQLRestStorage
    // for any in-memory/MongoDB/virtual instance
    TableEngine: TSQLRest;
    /// the associated TSQLRecord.ID, as decoded from URI scheme
    // - this property will be set from incoming URI, even if RESTful
    // authentication is not enabled
    TableID: integer;
    /// the index of the callback published method within the internal class list
    MethodIndex: integer;
    /// the service identified by an interface-based URI
    Service: TServiceFactoryServer;
    /// the method index for an interface-based service
    // - Service member has already be retrieved from URI (so is not nil)
    // - 0..2 are the internal _free_/_contract_/_signature_ pseudo-methods
    ServiceMethodIndex: integer;
    /// the JSON array of parameters for an the interface-based service
    // - Service member has already be retrieved from URI (so is not nil)
    ServiceParameters: PUTF8Char;
    /// the instance ID for interface-based services instance
    // - can be e.g. the client session ID for sicPerSession or the thread ID for
    // sicPerThread
    ServiceInstanceID: cardinal;
    /// force the interface-based service methods to return a JSON object
    // - default behavior is to follow Service.ResultAsJSONObject property value
    // (which own default is to return a more convenient JSON array)
    // - if set to TRUE, this execution context will FORCE the method to return
    // a JSON object, even if Service.ResultAsJSONObject=false: this may be
    // handy when the method is executed from a JavaScript content
    ForceServiceResultAsJSONObject: boolean;
    /// URI inlined parameters
    // - use UrlDecodeValue*() functions to retrieve the values
    Parameters: PUTF8Char;
    /// access to all input/output parameters at TSQLRestServer.URI() level
    // - process should better call Results() or Success() methods to set the
    // appropriate answer or Error() method in case of an error
    // - low-level access to the call parameters can be made via this pointer
    Call: PSQLRestURIParams;
    /// the corresponding session TAuthSession.IDCardinal value
    // - equals 0 (CONST_AUTHENTICATION_SESSION_NOT_STARTED) if the session
    // is not started yet - i.e. if still in handshaking phase
    // - equals 1 (CONST_AUTHENTICATION_NOT_USED) if authentication mode
    // is not enabled - i.e. if TSQLRestServer.HandleAuthentication = FALSE
    Session: cardinal;
    /// the corresponding TAuthSession.User.ID value
    // - is undefined if Session is 0 or 1 (no authentication running)
    SessionUser: integer;
    /// the corresponding TAuthSession.User.GroupRights.ID value
    // - is undefined if Session is 0 or 1 (no authentication running)
    SessionGroup: integer;
    /// the static instance corresponding to the associated Table (if any)
    Static: TSQLRest;
    /// the kind of static instance corresponding to the associated Table (if any)
    StaticKind: TSQLRestServerKind;
    /// optional error message which will be transmitted as JSON error (if set)
    CustomErrorMsg: RawUTF8;
    {$ifdef WITHLOG}
    /// associated logging instance
    // - you can use it to log some process on the server side
    Log: TSynLog;
    {$endif}
    /// retrieve one input parameter from its URI name as Int64
    // - slower than the direct UrlDecodeValue*() process, but more
    // convenient to use
    // - raise an EParsingException if the parameter is not found
    property InputInt[const ParamName: RawUTF8]: Int64 read GetInputInt;
    /// retrieve one input parameter from its URI name as double
    // - slower than the direct UrlDecodeValue*() process, but more
    // convenient to use
    // - raise an EParsingException if the parameter is not found
    property InputDouble[const ParamName: RawUTF8]: double read GetInputDouble;
    /// retrieve one input parameter from its URI name as RawUTF8
    // - slower than the direct UrlDecodeValue*() process, but more
    // convenient to use
    // - raise an EParsingException if the parameter is not found
    property InputUTF8[const ParamName: RawUTF8]: RawUTF8 read GetInputUTF8;
    {$ifndef NOVARIANTS}
    /// retrieve one input parameter from its URI name as variant
    // - slower than the direct UrlDecodeValue*() process, but more
    // convenient to use
    // - if the parameter value is text, it is stored in the variant as
    // a generic VCL string content: so before Delphi 2009, you may loose
    // some characters at decoding from UTF-8 input buffer
    // - raise an EParsingException if the parameter is not found
    property Input[const ParamName: RawUTF8]: variant read GetInput;
    {$endif}
    /// use this method to send back directly a result value to the caller
    // - expects Status to be either HTML_SUCCESS, HTML_NOTMODIFIED or
    // HTML_CREATED, and will return as answer the supplied Result content
    // with no transformation
    // - if Status is an error code, it will call Error() method
    // - CustomHeader optional parameter can be set e.g. to
    // TEXT_CONTENT_TYPE_HEADER if the default JSON_CONTENT_TYPE is not OK
    // - if Handle304NotModified is TRUE and Status is HTML_SUCCESS, the Result
    // content will be hashed (using crc32c) and in case of no modification
    // will return HTML_NOTMODIFIED to the browser, without the actual result
    // content (to save bandwidth)
    procedure Returns(const Result: RawUTF8; Status: integer=HTML_SUCCESS;
      const CustomHeader: RawUTF8=''; Handle304NotModified: boolean=false); overload;
    /// use this method to send back a JSON object to the caller
    // - this method will encode the supplied values e.g. as
    // ! JSONEncode(['name','John','year',1972]) = '{"name":"John","year":1972}'
    // - implementation is just a wrapper around Returns(JSONEncode([]))
    // - note that cardinal values should be type-casted to Int64() (otherwise
    // the integer mapped value will be transmitted, therefore wrongly)
    // - expects Status to be either HTML_SUCCESS or HTML_CREATED
    // - caller can set Handle304NotModified=TRUE for Status=HTML_SUCCESS 
    procedure Returns(const NameValuePairs: array of const; Status: integer=HTML_SUCCESS;
      Handle304NotModified: boolean=false); overload;
    /// use this method to send back a file to the caller
    // - this method will let the HTTP server return the file content
    // - if Handle304NotModified is TRUE, will check the file age to ensure
    // that the file content will be sent back to the server only if it changed 
    // - if ContentType is left to default '', method will guess the expected
    // mime-type from the file name extension 
    procedure ReturnFile(const FileName: TFileName;
      Handle304NotModified: boolean=false; const ContentType: RawUTF8='');
    /// use this method to send back a JSON object with a "result" field
    // - this method will encode the supplied values as a {"result":"...}
    // JSON object, as such for one value:
    // $ {"result":"OneValue"}
    // (with one value, you can just call TSQLRestClientURI.CallBackGetResult
    // method to call and decode this value)
    // or as a JSON object containing an array of values:
    // $ {"result":["One","two"]}
    // - expects Status to be either HTML_SUCCESS or HTML_CREATED
    // - caller can set Handle304NotModified=TRUE for Status=HTML_SUCCESS
    procedure Results(const Values: array of const; Status: integer=HTML_SUCCESS;
      Handle304NotModified: boolean=false);
    /// use this method if the caller expect no data, just a status
    // - just wrap the overloaded Returns() method with no result value
    // - if Status is an error code, it will call Error() method
    // - by default, calling this method will mark process as successfull
    procedure Success(Status: integer=HTML_SUCCESS);
    /// use this method to send back an error to the caller
    // - expects Status to not be HTML_SUCCESS neither HTML_CREATED,
    // and will send back a JSON error message to the caller, with the
    // supplied error text
    // - if no ErrorMessage is specified, will return a default text
    // corresponding to the Status code
    procedure Error(const ErrorMessage: RawUTF8='';
      Status: integer=HTML_BADREQUEST); overload;
    /// use this method to send back an error to the caller
    // - implementation is just a wrapper over Error(FormatUTF8(Format,Args))
    procedure Error(Format: PUTF8Char; const Args: array of const;
      Status: integer=HTML_BADREQUEST); overload;

    /// at Client Side, compute URI and BODY according to the routing scheme
    // - abstract implementation which is to be overridden
    // - as input, method should be the method name to be executed,
    // params should contain the incoming parameters as JSON CSV (without []),
    // and clientDriven ID should contain the optional Client ID value 
    // - at output, should update the HTTP uri corresponding to the proper
    // routing, and should return the corresponding HTTP body within sent
    class procedure ClientSideInvoke(var uri: RawUTF8;
      const method, params, clientDrivenID: RawUTF8; out sent: RawUTF8); virtual; abstract;
  end;

  /// calling context for a TSQLRestServerCallBack using simple REST for
  // interface-based services
  // - this class will use RESTful routing for interface-based services:
  // method name will be identified within the URI, as
  // $ /Model/Interface.Method[/ClientDrivenID]
  // e.g. for ICalculator.Add:
  // $ POST /root/Calculator.Add
  // $ (...)
  // $ [1,2]
  // or, for a sicClientDriven mode service:
  // $ POST /root/ComplexNumber.Add/1234
  // $ (...)
  // $ [20,30]
  // in this case, the sent content will be a JSON array of [parameters...]
  // - as an alternative, input parameters may be encoded at URI level (with
  // a size limit depending on the HTTP routers, whereas there is no such
  // limitation when they are transmitted as message body)
  // - one benefit of having .../ClientDrivenID encoded at URI is that it will
  // be more secured in our RESTful authentication scheme: each method and even
  // client driven session will be signed individualy
  TSQLRestRoutingREST = class(TSQLRestServerURIContext)
  protected
    /// retrieve interface-based SOA with URI RESTful routing
    // - should set Service member (and possibly ServiceMethodIndex)
    // - this overridden implementation expects an URI encoded with
    // '/Model/Interface.Method[/ClientDrivenID]' for this class, and
    // will set ServiceMethodIndex for next ExecuteSOAByInterface method call
    procedure URIDecodeSOAByInterface; override;
    /// direct launch of an interface-based service with URI RESTful routing
    // - this overridden implementation expects parameters to be sent as one JSON
    // array body (Delphi/AJAX way) or optionally with URI decoding (HTML way):
    // ! function TServiceCalculator.Add(n1, n2: integer): integer;
    // would accept such requests:
    // !  URL='root/Calculator.Add' and InBody='[ 1,2 ]'
    // !  URL='root/Calculator.Add?+%5B+1%2C2+%5D' // decoded as ' [ 1,2 ]'
    // !  URL='root/Calculator.Add?n1=1&n2=2'      // in any order, even missing
    procedure ExecuteSOAByInterface; override;
  public
    /// at Client Side, compute URI and BODY according to RESTful routing scheme
    // - e.g. on input uri='root/Calculator', method='Add', params='1,2' and
    // clientDrivenID='1234' -> on output uri='root/Calculator.Add/1234' and
    // sent='[1,2]'
    class procedure ClientSideInvoke(var uri: RawUTF8;
      const method, params, clientDrivenID: RawUTF8; out sent: RawUTF8); override;
  end;

  /// calling context for a TSQLRestServerCallBack using JSON/RPC for
  // interface-based services
  // - in this routing scheme, the URI will define the interface, then the
  // method name will be inlined with parameters, e.g.
  // $ POST /root/Calculator
  // $ (...)
  // $ {"method":"Add","params":[1,2]}
  // or, for a sicClientDriven mode service:
  // $ POST /root/ComplexNumber
  // $ (...)
  // $ {"method":"Add","params":[20,30],"id":1234}
  TSQLRestRoutingJSON_RPC = class(TSQLRestServerURIContext)
  protected
    /// retrieve interface-based SOA with URI JSON/RPC routing
    // - this overridden implementation expects an URI encoded with
    // '/Model/Interface' as for the JSON/RPC routing scheme, and won't
    // set ServiceMethodIndex at this level (but in ExecuteSOAByInterface)
    procedure URIDecodeSOAByInterface; override;
    /// direct launch of an interface-based service with URI JSON/RPC routing
    // - URI() will ensure that Service<>nil before calling it
    // - this overridden implementation expects parameters to be sent as part
    // of a JSON object body:
    // $ {"method":"Add","params":[20,30],"id":1234}
    procedure ExecuteSOAByInterface; override;
  public
    /// at Client Side, compute URI and BODY according to JSON/RPC routing scheme
    // - e.g. on input uri='root/Calculator', method='Add', params='1,2' and
    // clientDrivenID='1234' -> on output uri='root/Calculator' and
    // sent={"method":"Add","params":[1,2],"id":1234}
    class procedure ClientSideInvoke(var uri: RawUTF8;
      const method, params, clientDrivenID: RawUTF8; out sent: RawUTF8); override;
  end;

  /// method prototype to be used on Server-Side for method-based services
  // - will be routed as ModelRoot/[TableName/TableID/]MethodName RESTful requests
  // - this mechanism is able to handle some custom Client/Server request, similar
  // to the DataSnap technology, but in a KISS way; it's fully integrated in the
  // Client/Server architecture of our framework
  // - just add a published method of this type to any TSQLRestServer descendant
  // - when TSQLRestServer.URI receive a request for ModelRoot/MethodName
  // or ModelRoot/TableName/TableID/MethodName, it will check for a published method
  // in its self instance named MethodName which MUST be of TSQLRestServerCallBack
  // type (not checked neither at compile time neither at runtime: beware!) and
  // call it to handle the request
  // - important warning: the method implementation MUST be thread-safe
  // - when TSQLRestServer.URI receive a request for ModelRoot/MethodName,
  // it calls the corresponding published method with aRecord set to nil
  // - when TSQLRestServer.URI receive a request for ModelRoot/TableName/TableID/MethodName,
  // it calls the corresponding published method with aRecord pointing to a
  // just created instance of the corresponding class,  with its field ID set;
  // note that the only set field is ID: other fields of aRecord are not set, but
  // must secificaly be retrieved on purpose
  // - for ModelRoot/TableName/TableID/MethodName, the just created instance will
  // be freed by TSQLRestServer.URI when the method returns
  // - Ctxt.Parameters values are set from incoming URI, and each parameter can be
  // retrieved with a loop like this:
  // !  if not UrlDecodeNeedParameters(Ctxt.Parameters,'SORT,COUNT') then
  // !    exit;
  // !  while Ctxt.Parameters<>nil do begin
  // !    UrlDecodeValue(Ctxt.Parameters,'SORT=',aSortString);
  // !    UrlDecodeValueInteger(Ctxt.Parameters,'COUNT=',aCountInteger,@Ctxt.Parameters);
  // !  end;
  // - Ctxt.Call is set with low-level incoming and outgoing data from client
  // (e.g. Ctxt.Call.InBody contain POST/PUT data message)
  // - Ctxt.Session* will identify to the authentication session of the remote client
  // (CONST_AUTHENTICATION_NOT_USED=1 if authentication mode is not enabled or
  // CONST_AUTHENTICATION_SESSION_NOT_STARTED=0 if the session not started yet) -
  // code may use SessionGetUser() method to retrieve the user details
  // - Ctxt.Method will indicate the used HTTP verb (e.g. GET/POST/PUT..)
  // - if process succeeded, implementation shall call Ctxt.Results([]) method to
  // set a JSON response object with one "result" field name or Ctxt.Returns([])
  // with a JSON object described in Name/Value pairs; if the returned value is
  // not JSON_CONTENT_TYPE, use Ctxt.Returns() and its optional CustomHeader
  // parameter can specify a custom header like TEXT_CONTENT_TYPE_HEADER
  // - if process succeeded, and no data is expected to be returned to the caller,
  // implementation shall call overloaded Ctxt.Success() method with the
  // expected status (i.e. just Ctxt.Success will return HTML_SUCCESS)
  // - if process failed, implementation shall call Ctxt.Error() method to
  // set the corresponding error message and error code number
  // - a typical implementation may be:
  // ! procedure TSQLRestServerTest.Sum(Ctxt: TSQLRestServerURIContext);
  // ! var a,b: Extended;
  // ! begin
  // !   if UrlDecodeNeedParameters(Ctxt.Parameters,'A,B') then begin
  // !     while Ctxt.Parameters<>nil do begin
  // !       UrlDecodeExtended(Ctxt.Parameters,'A=',a);
  // !       UrlDecodeExtended(Ctxt.Parameters,'B=',b,@Ctxt.Parameters);
  // !     end;
  // !     Ctxt.Results([a+b]);
  // !     // same as: Ctxt.Returns(JSONEncode(['result',a+b]));
  // !     // same as: Ctxt.Returns(['result',a+b]);
  // !   end else
  // !     Ctxt.Error('Missing Parameter');
  // ! end;
  // - Client-Side can be implemented as you wish. By convention, it could be
  // appropriate to define in either TSQLRestServer (if to be called as
  // ModelRoot/MethodName), either TSQLRecord (if to be called as
  // ModelRoot/TableName[/TableID]/MethodName) a custom public or protected method,
  // calling TSQLRestClientURI.URL with the appropriate parameters, and named
  // (by convention) as MethodName; TSQLRestClientURI has dedicated methods
  // like CallBackGetResult, CallBackGet, and CallBackPut; see also
  // TSQLModel.getURICallBack and JSONDecode function
  // ! function TSQLRecordPeople.Sum(aClient: TSQLRestClientURI; a, b: double): double;
  // ! var err: integer;
  // ! begin
  // !   val(aClient.CallBackGetResult('sum',['a',a,'b',b]),result,err);
  // ! end;
  TSQLRestServerCallBack = procedure(Ctxt: TSQLRestServerURIContext) of object;

  /// description of a method-based service
  TSQLRestServerMethod = record
    /// the method name
    Name: RawUTF8;
    /// the event which will be executed for this method
    CallBack: TSQLRestServerCallBack;
    /// set to TRUE disable Authentication check for this method
    // - use TSQLRestServer.ServiceMethodByPassAuthentication() method
    ByPassAuthentication: boolean;
  end;

  /// used to store all method-based services of a TSQLRestServer instance 
  TSQLRestServerMethods = array of TSQLRestServerMethod;

  /// pointer to a description of a method-based service
  PSQLRestServerMethod = ^TSQLRestServerMethod;
  
  /// the possible options for handling table names
  TSQLCheckTableName = (ctnNoCheck,ctnMustExist,ctnTrimExisting);

  /// internal data used by TSQLRecord.FillPrepare()/FillPrepareMany() methods
  // - using a dedicated class will reduce memory usage for each TSQLRecord
  // instance (which won't need these properties most of the time)
  TSQLRecordFill = class
  protected
    /// associated table
    fTable: TSQLTable;
    /// current retrieved row
    fFillCurrentRow: integer;
    {/ number of used items in TableMap[] array
      - calculated in FillPrepare() or FillPrepareMany() methods }
    fTableMapCount: integer;
    /// set by TSQLRecord.FillPrepareMany() to release M.fDestID^ instances
    fTableMapRecordManyInstances: array of TSQLRecordMany;
    /// map the published fields index
    // - calculated in FillPrepare() or FillPrepareMany() methods
    fTableMap: array of record
      /// the class instance to be filled from the TSQLTable
      // - can be a TSQLRecordMany instance after FillPrepareMany() method call
      Dest: TSQLRecord;
      /// the published property RTTI to be filled from the TSQLTable
      // - is nil for the RowID/ID field
      DestField: TSQLPropInfo;
      /// the column index in TSQLTable
      TableIndex: integer;
    end;
    /// mark all mapped or TModTime fields
    fTableMapFields: TSQLFieldBits;
    /// if Joined instances were initialized via TSQLRecord.CreateJoined()
    fJoinedFields: boolean;
    /// return fJoinedFields or false if self=nil
    function GetJoinedFields: boolean;
      {$ifdef HASINLINE}inline;{$endif}
    /// add a property to the fTableMap[] array
    // - aIndex is the column index in TSQLTable
    procedure AddMap(aRecord: TSQLRecord; aField: TSQLPropInfo; aIndex: integer); overload;
    /// add a property to the fTableMap[] array
    // - aIndex is the column index in TSQLTable
    procedure AddMap(aRecord: TSQLRecord; const aFieldName: RawUTF8; aIndex: integer); overload;
    /// add all simple property names, with  to the fTableMap[] array
    // - will map ID/RowID, then all simple fields of this TSQLRecord
    // - aIndex is the column index in TSQLTable
    procedure AddMapSimpleFields(aRecord: TSQLRecord; const aProps: array of TSQLPropInfo;
      var aIndex: integer);
  public
    /// finalize the mapping
    destructor Destroy; override;
    /// map all columns of a TSQLTable to a record mapping
    procedure Map(aRecord: TSQLRecord; aTable: TSQLTable; aCheckTableName: TSQLCheckTableName);
    /// reset the mapping
    // - is called e.g. by TSQLRecord.FillClose
    // - will free any previous Table if necessary
    // - will release TSQLRecordMany.Dest instances as set by TSQLRecord.FillPrepareMany()
    procedure UnMap;
    /// fill a TSQLRecord published properties from a TSQLTable row
    // - use the mapping prepared with Map() method
    function Fill(aRow: integer): Boolean; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// fill a TSQLRecord published properties from a TSQLTable row
    // - use the mapping prepared with Map() method
    // - aTableRow will point to the first column of the matching row
    procedure Fill(aTableRow: PPUtf8CharArray); overload;
    /// fill a TSQLRecord published properties from a TSQLTable row
    // - overloaded method using a specified destination record to be filled
    // - won't work with cross-reference mapping (FillPrepareMany)
    // - use the mapping prepared with Map() method
    // - aTableRow will point to the first column of the matching row
    procedure Fill(aTableRow: PPUtf8CharArray; aDest: TSQLRecord); overload;
    /// fill a TSQLRecord published properties from a TSQLTable row
    // - overloaded method using a specified destination record to be filled
    // - won't work with cross-reference mapping (FillPrepareMany)
    // - use the mapping prepared with Map() method
    function Fill(aRow: integer; aDest: TSQLRecord): Boolean; overload;
      {$ifdef HASINLINE}inline;{$endif}

    {/ the TSQLTable stated as FillPrepare() parameter
      - the internal temporary table is stored here for TSQLRecordMany
      - this instance is freed by TSQLRecord.Destroy if fTable.OwnerMustFree=true }
    property Table: TSQLTable read fTable;
    /// the current Row during a Loop
    property FillCurrentRow: integer read fFillCurrentRow;
    /// equals TRUE if the instance was initialized via TSQLRecord.CreateJoined()
    // TSQLRecord.CreateAndFillPrepareJoined()
    // - it means that all nested TSQLRecord are pre-allocated instances,
    // not trans-typed pointer(IDs)
    property JoinedFields: boolean read GetJoinedFields;
  end;

  /// root class for defining and mapping database records
  // - inherits a class from TSQLRecord, and add published properties to describe
  // the table columns (see TPropInfo for SQL and Delphi type mapping/conversion)
  // - this published properties can be auto-filled from TSQLTable answer with
  // FillPrepare() and FillRow(), or FillFrom() with TSQLTable or JSON data
  // - this published properties can be converted back into UTF-8 encoded SQL
  // source with GetSQLValues or GetSQLSet or into JSON format with GetJSONValues
  // - BLOB fields are decoded to auto-freeing TSQLRawBlob properties
  TSQLRecord = class(TObject)
  { note that every TSQLRecord has an Instance size of 20 bytes for private and
    protected fields (such as fID or fProps e.g.) }
  protected
    /// used by FillPrepare() and corresponding Fill*() methods
    fFill: TSQLRecordFill;
    /// internal properties getters (using fProps data for speed)
    function GetHasBlob: boolean;
    function GetSimpleFieldCount: integer;
    function GetFillCurrentRow: integer;
    function GetTable: TSQLTable;
  protected
    fInternalState: cardinal;
    fID: integer;
  {$ifdef HASINLINE}public{$endif}
    /// trick to get the ID even in case of a sftID published property
    function GetID: integer;
     {$ifdef HASINLINE}inline;{$endif}
    /// trick to typecast the ID on 64 bit platform
    function GetIDAsPointer: pointer;
      {$ifdef HASINLINE}inline;{$endif}
    /// virtual method to be overridden to register some custom properties
    // - do nothing by default, but allow inherited classes to define some
    // properties, by adding some TSQLPropInfo instances to Props.Fields list,
    // or calling Props.RegisterCustomFixedSizeRecordProperty() or
    // Props.RegisterCustomRTTIRecordProperty() methods
    // - can also be used to specify a custom text collation, by calling
    // Props.SetCustomCollationForAllRawUTF8() or SetCustomCollation() methods
    class procedure InternalRegisterCustomProperties(Props: TSQLRecordProperties); virtual;
  public
    /// direct access to the TSQLRecord properties from RTTI
    // - TSQLRecordProperties is faster than e.g. the class function FieldProp()
    // - use internal the unused vmtAutoTable VMT entry to fast retrieve of a
    // class variable which is unique for each class ("class var" is unique only
    // for the class within it is defined, and we need a var for each class:
    // so even Delphi XE syntax is not powerful enough for our purpose, and the
    // vmtAutoTable trick if very fast, and works with all versions of Delphi -
    // including 64 bit target)
    class function RecordProps: TSQLRecordProperties;
      {$ifdef PUREPASCAL}{$ifdef HASINLINE}inline;{$endif}{$endif}
    {/ the Table name in the database, associated with this TSQLRecord class
     - 'TSQL' or 'TSQLRecord' chars are trimmed at the beginning of the ClassName
     - or the ClassName is returned as is, if no 'TSQL' or 'TSQLRecord' at first
     - is just a wrapper around RecordProps.SQLTableName }
    class function SQLTableName: RawUTF8;
      {$ifdef HASINLINE}inline;{$endif}
    /// register a custom filter or Validate to the class for a specified field
    // - this will be used by TSQLRecord.Filter and TSQLRecord.Validate
    // methods (in default implementation)
    // - will return the specified associated TSynFilterOrValidate instance
    // - this function is just a wrapper around RecordProps.AddFilterOrValidate
    class function AddFilterOrValidate(const aFieldName: RawUTF8;
      aFilter: TSynFilterOrValidate): TSynFilterOrValidate;
        {$ifdef HASINLINE}inline;{$endif}

    {/ get the captions to be used for this class
     - if Action is nil, return the caption of the table name
     - if Action is not nil, return the caption of this Action (lowercase left-trimed)
     - return "string" type, i.e. UnicodeString for Delphi 2009+
     - internally call UnCamelCase() then System.LoadResStringTranslate() if available
     - ForHint is set to TRUE when the record caption name is to be displayed inside
       the popup hint of a button (i.e. the name must be fully qualified, not
       the default short version)
     - is not part of TSQLRecordProperties because has been declared as virtual }
    class function CaptionName(Action: PRawUTF8=nil; ForHint: boolean=false): string; virtual;
    {/ get the captions to be used for this class
     - just a wrapper calling CaptionName() virtual method, from a ShortString pointer }
    class function CaptionNameFromRTTI(Action: PShortString): string;
    {/ virtual method called when the associated table is created in the database
      - if FieldName is '', initialization regarding all fields must be made;
        if FieldName is specified, initialization regarding this field must be processed
      - override this method in order to initialize indexs or create default records
      - by default, create indexes for all TRecordReference properties, and
        for all TSQLRecord inherited properties (i.e. of sftID type, that is
        an INTEGER field containing the ID of the pointing record)
     - is not part of TSQLRecordProperties because has been declared as virtual }
    class procedure InitializeTable(Server: TSQLRestServer; const FieldName: RawUTF8); virtual;

    {/ filter the specified fields values of the current TSQLRecord instance
    - by default, this will perform all TSynFilter as registered by
      [RecordProps.]AddFilterOrValidate()
    - inherited classes may add some custom filtering here, if it's not needed
      nor mandatory to create a new TSynFilter class type: in this case, the
      function has to return TRUE if the filtering took place, and FALSE if
      any default registered TSynFilter must be processed
    - the default aFields parameter will process all fields }
    function Filter(const aFields: TSQLFieldBits=[0..MAX_SQLFIELDS-1]): boolean; overload; virtual;
    {/  filter the specified fields values of the current TSQLRecord instance
    - this version will call the overloaded Filter() method above
    - return TRUE if all field names were correct and processed, FALSE otherwise }
    function Filter(const aFields: array of RawUTF8): boolean; overload;
    {/ validate the specified fields values of the current TSQLRecord instance
    - by default, this will perform all TSynValidate as registered by
      [RecordProps.]AddFilterOrValidate()
    - it will also check if any UNIQUE field value won't be duplicated
    - inherited classes may add some custom validation here, if it's not needed
      nor mandatory to create a new TSynValidate class type: in this case, the
      function has to return an explicit error message (as a generic VCL string)
      if the custom validation failed, or '' if the validation was successful:
      in this later case, all default registered TSynValidate are processed
    - the default aFields parameter will process all fields
    - if aInvalidFieldIndex is set, it will contain the first invalid field
      index found
     - caller SHOULD always call the Filter() method before calling Validate() }
    function Validate(aRest: TSQLRest; const aFields: TSQLFieldBits=[0..MAX_SQLFIELDS-1];
      aInvalidFieldIndex: PInteger=nil): string; overload; virtual;
    {/  validate the specified fields values of the current TSQLRecord instance
    - this version will call the overloaded Validate() method above
    - returns '' if all field names were correct and processed, or an
      explicit error message (translated in the current language) on error
    - if aInvalidFieldIndex is set, it will contain the first invalid field
      index }
    function Validate(aRest: TSQLRest; const aFields: array of RawUTF8;
      aInvalidFieldIndex: PInteger=nil): string; overload;
    /// should modify the record content before writing to the Server
    // - this default implementation will update any sftModTime / TModTime and
    // sftCreateTime / TCreateTime properties content with the exact server time stamp
    // - you may override this method e.g. for custom calculated fields
    // - note that this is computed only on the Client side, before sending
    // back the content to the remote Server: therefore, TModTime / TCreateTime
    // fields are a pure client ORM feature - it won't work directly at REST level
    procedure ComputeFieldsBeforeWrite(aRest: TSQLRest; aOccasion: TSQLEvent); virtual;

    /// this constructor initializes the record
    // - auto-instanciate any TSQLRecordMany instance defined in published properties
    // - override this method if you want to use some internal objects (e.g.
    // TStringList or TCollection as published property)
    constructor Create; overload; virtual;
    /// this constructor initializes the record and set the simple fields
    // with the supplied values
    // - the aSimpleFields parameters must follow explicitely the order of
    // published properties of the aTable class, excepting the TSQLRawBlob and
    // TSQLRecordMany kind (i.e. only so called "simple fields") - in
    // particular, parent properties must appear first in the list
    // - the aSimpleFields must have exactly the same count of parameters as
    // there are "simple fields" in the published properties
    // - will raise an EORMException in case of wrong supplied values
    constructor Create(const aSimpleFields: array of const; aID: integer); overload;
    {/ this constructor initializes the object as above, and fills its content
      from a client or server connection
     - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
      the corresponding record, then retrieve its content; caller has to call
      UnLock() method after Value usage, to release the record }
    constructor Create(aClient: TSQLRest; aID: integer;
      ForUpdate: boolean=false); overload;
    {/ this constructor initializes the object and fills its content from a client
      or server connection, from a TSQLRecord published property content
     - is just a wrapper around Create(aClient,PtrInt(aPublishedRecord))
       or Create(aClient,aPublishedRecord.ID)
     - a published TSQLRecord property is not a class instance, but a typecast to
       TObject(RecordID) - you can also use its ID property
     - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
      the corresponding record, then retrieve its content; caller has to call
      UnLock() method after Value usage, to release the record }
    constructor Create(aClient: TSQLRest; aPublishedRecord: TSQLRecord;
      ForUpdate: boolean=false); overload;
    /// this constructor initializes the object as above, and fills its content
    //  from a client or server connection, using a specified WHERE clause
    //  - the WHERE clause should use inlined parameters (like 'Name=:('Arnaud'):')
    //  for better server speed - note that you can use FormatUTF8() as such:
    //  ! aRec := TSQLMyRec.Create(Client,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
    //  or call the overloaded contructor with BoundsSQLWhere array of parameters 
    constructor Create(aClient: TSQLRest; const aSQLWhere: RawUTF8); overload;
    {/ this constructor initializes the object as above, and fills its content
      from a client or server connection, using a specified WHERE clause
      with parameters
    - for better server speed, the WHERE clause should use bound parameters
      identified as '?' in the FormatSQLWhere statement, which is expected to
      follow the order of values supplied in BoundsSQLWhere open array - use
      DateToSQL/DateTimeToSQL for TDateTime, or directly any integer / double /
      currency / RawUTF8 values to be bound to the request as parameters
    - note that this method prototype changed with revision 1.17 of the
      framework: array of const used to be ParamsSQLWhere and '%' in the
      FormatSQLWhere statement, whereas it now expects bound parameters as '?' }
    constructor Create(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const); overload;
    {/ this constructor initializes the object as above, and fills its content
      from a client or server connection, using a specified WHERE clause
      with parameters
      - the FormatSQLWhere clause will replace all '%' chars with the supplied
      ParamsSQLWhere[] values, and all '?' chars with BoundsSQLWhere[] values,
      as :(...): inlined parameters - you should either call:
      ! Rec := TSQLMyRecord.Create(aClient,'Count=:(%):'[aCount],[]);
      or (letting the inlined parameters being computed by FormatUTF8)
      !  Rec := TSQLMyRecord.Create(aClient,'Count=?',[],[aCount]);
      or even better, using the other Create overloaded constructor:
      !  Rec := TSQLMyRecord.Create(aClient,'Count=?',[aCount]);
      - using '?' and BoundsSQLWhere[] is perhaps more readable in your code, and
      will in all case create a request with :(..): inline parameters, with
      automatic RawUTF8 quoting if necessary }
    constructor Create(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const ParamsSQLWhere, BoundsSQLWhere: array of const); overload;

    {/ this constructor initializes the object as above, and prepares itself to
      loop through a statement using a specified WHERE clause
      - this method creates a TSQLTableJSON, retrieves all records corresponding
        to the WHERE clause, then call FillPrepare - previous Create(aClient)
        methods retrieve only one record, this one more multiple rows
      - you should then loop for all rows using 'while Rec.FillOne do ...'
      - the TSQLTableJSON will be freed by TSQLRecord.Destroy
      - the WHERE clause should use inlined parameters (like 'Name=:('Arnaud'):')
        for better server speed - note that you can use FormatUTF8() as such:
        ! aRec := TSQLMyRec.CreateAndFillPrepare(Client,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
        or call the overloaded CreateAndFillPrepare() contructor directly with
        BoundsSQLWhere array of parameters
      - aCustomFieldsCSV can be used to specify which fields must be retrieved
      - default aCustomFieldsCSV='' will retrieve all simple table fields
      - if aCustomFieldsCSV='*', it will retrieve all fields, including BLOBs
      - aCustomFieldsCSV can also be set to a CSV field list to retrieve only
        the needed fields, and save remote bandwidth - note that any later
        Update() will update all simple fields, so potentially with wrong
        values; but BatchUpdate() can be safely used since it will  }
    constructor CreateAndFillPrepare(aClient: TSQLRest; const aSQLWhere: RawUTF8;
      const aCustomFieldsCSV: RawUTF8=''); overload;
    {/ this constructor initializes the object as above, and prepares itself to
      loop through a statement using a specified WHERE clause
      - this method creates a TSQLTableJSON, retrieves all records corresponding
        to the WHERE clause, then call FillPrepare - previous Create(aClient)
        methods retrieve only one record, this one more multiple rows
      - you should then loop for all rows using 'while Rec.FillOne do ...'
      - the TSQLTableJSON will be freed by TSQLRecord.Destroy
      - for better server speed, the WHERE clause should use bound parameters
        identified as '?' in the FormatSQLWhere statement, which is expected to
        follow the order of values supplied in BoundsSQLWhere open array - use
        DateToSQL/DateTimeToSQL for TDateTime, or directly any integer / double /
        currency / RawUTF8 values to be bound to the request as parameters
      - note that this method prototype changed with revision 1.17 of the
        framework: array of const used to be ParamsSQLWhere and '%' in the
        FormatSQLWhere statement, whereas it now expects bound parameters as '?'
      - aCustomFieldsCSV can be used to specify which fields must be retrieved
      - default aCustomFieldsCSV='' will retrieve all simple table fields, but
        you may need  to access only one or several fields, and will save remote
        bandwidth by specifying the needed fields
      - if aCustomFieldsCSV='*', it will retrieve all fields, including BLOBs
      - note that you should not use this aCustomFieldsCSV optional parameter if
        you want to Update the retrieved record content later, since any
        missing fields will be left with previous values - but BatchUpdate() can be
        safely used after FillPrepare (will set only ID, TModTime and mapped fields) }
    constructor CreateAndFillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8=''); overload;
    {/ this constructor initializes the object as above, and prepares itself to
      loop through a statement using a specified WHERE clause
      - this method creates a TSQLTableJSON, retrieves all records corresponding
        to the WHERE clause, then call FillPrepare - previous Create(aClient)
        methods retrieve only one record, this one more multiple rows
      - you should then loop for all rows using 'while Rec.FillOne do ...'
      - the TSQLTableJSON will be freed by TSQLRecord.Destroy
      - the FormatSQLWhere clause will replace all '%' chars with the supplied
        ParamsSQLWhere[] supplied values, and bind all '?' chars as parameters
        with BoundsSQLWhere[] values
      - aCustomFieldsCSV can be used to specify which fields must be retrieved
      - default aCustomFieldsCSV='' will retrieve all simple table fields, but
        you may need  to access only one or several fields, and will save remote
        bandwidth by specifying the needed fields
      - if aCustomFieldsCSV='*', it will retrieve all fields, including BLOBs
      - note that you should not use this aCustomFieldsCSV optional parameter if
        you want to Update the retrieved record content later, since any
        missing fields will be left with previous values - but BatchUpdate() can be
        safely used after FillPrepare (will set only ID, TModTime and mapped fields) }
    constructor CreateAndFillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const ParamsSQLWhere, BoundsSQLWhere: array of const;
      const aCustomFieldsCSV: RawUTF8=''); overload;
    {/ this constructor initializes the object as above, and prepares itself to
      loop through a given list of IDs
      - this method creates a TSQLTableJSON, retrieves all records corresponding
        to the specified IDs, then call FillPrepare - previous Create(aClient)
        methods retrieve only one record, this one more multiple rows
      - you should then loop for all rows using 'while Rec.FillOne do ...'
      - the TSQLTableJSON will be freed by TSQLRecord.Destroy
      - aCustomFieldsCSV can be used to specify which fields must be retrieved
      - default aCustomFieldsCSV='' will retrieve all simple table fields, but
        you may need  to access only one or several fields, and will save remote
        bandwidth by specifying the needed fields
      - if aCustomFieldsCSV='*', it will retrieve all fields, including BLOBs
      - note that you should not use this aCustomFieldsCSV optional parameter if
        you want to Update the retrieved record content later, since any
        missing fields will be left with previous values - but BatchUpdate() can be
        safely used after FillPrepare (will set only ID, TModTime and mapped fields) }
    constructor CreateAndFillPrepare(aClient: TSQLRest; const aIDs: array of integer;
      const aCustomFieldsCSV: RawUTF8=''); overload;
    {/ this constructor initializes the object, and prepares itself to loop
       through a specified JSON table
      - this method creates a TSQLTableJSON, fill it with the supplied JSON buffer,
        then call FillPrepare - previous Create(aClient) methods retrieve only
        one record, this one more multiple rows
      - you should then loop for all rows using 'while Rec.FillOne do ...'
      - the TSQLTableJSON will be freed by TSQLRecord.Destroy }
    constructor CreateAndFillPrepare(const aJSON: RawUTF8); overload;

    /// this constructor initializes the object from its ID, including all
    // nested TSQLRecord properties, through a JOINed statement
    // - by default, Create(aClient,aID) will return only the one-to-one
    // nested TSQLRecord published properties IDs trans-typed as pointer - this
    // constructor allow to retrieve the nested values in one statement
    // - use this constructor if you want all TSQLRecord published properties to
    // be allocated, and loaded with the corresponding values
    // - Free/Destroy will release these instances
    // - warning: if you call Update() after it, only the main object will be
    // updated, not the nested TSQLRecord properties
    constructor CreateJoined(aClient: TSQLRest; aID: integer);
    /// this constructor initializes the object, and prepares itself to loop
    // nested TSQLRecord properties, through a JOINed statement and a WHERE clause
    // - by default, CreateAndFillPrepare() will return only the one-to-one
    // nested TSQLRecord published properties IDs trans-typed as pointer - this
    // constructor allow to retrieve the nested values in one statement
    //  - this method creates a TSQLTableJSON, fill it with the supplied JSON buffer,
    // then call FillPrepare - previous CreateJoined() method retrieve only
    // one record, this one more multiple rows
    // - you should then loop for all rows using 'while Rec.FillOne do ...'
    // - use this constructor if you want all TSQLRecord published properties to
    // be allocated, and loaded with the corresponding values
    // - Free/Destroy will release these instances
    // - warning: if you call Update() after it, only the main object will be
    // updated, not the nested TSQLRecord properties
    constructor CreateAndFillPrepareJoined(aClient: TSQLRest;
      const aFormatSQLJoin: RawUTF8; const aParamsSQLJoin, aBoundsSQLJoin: array of const);

    {/ this constructor initializes the object including all TSQLRecordMany properties,
      and prepares itself to loop through a JOINed statement
      - the created instance will have all its TSQLRecordMany Dest property allocated
        with proper instance (and not only pointer(DestID) e.g.), ready to be
        consumed during a while FillOne do... loop (those instances will be
        freed by TSQLRecord.FillClose or Destroy) - and the Source property
        won't contain pointer(SourceID) but the main TSQLRecord instance
      - the aFormatSQLJoin clause will define a WHERE clause for an automated
        JOINed statement, including TSQLRecordMany published properties (and
        their nested properties)
      - a typical use could be the following:
        ! aProd := TSQLProduct.CreateAndFillPrepareMany(Database,
        !   'Owner=? and Categories.Dest.Name=? and (Sizes.Dest.Name=? or Sizes.Dest.Name=?)',[],
        !   ['mark','for boy','small','medium']);
        ! if aProd<>nil then
        ! try
        !   while aProd.FillOne do
        !     // here e.g. aProd.Categories.Dest are instantied (and Categories.Source=aProd)
        !     writeln(aProd.Name,' ',aProd.Owner,' ',aProd.Categories.Dest.Name,' ',aProd.Sizes.Dest.Name);
        !   // you may also use aProd.FillTable to fill a grid, e.g.
        !   // (do not forget to set aProd.FillTable.OwnerMustFree := false)
        ! finally
        !   aProd.Free; // will also free aProd.Categories/Sizes instances
        ! end;
        this will execute a JOINed SELECT statement similar to the following:
        $ select p.*, c.*, s.*
        $ from Product p, Category c, Categories cc, Size s, Sizes ss
        $ where c.id=cc.dest and cc.source=p.id and
        $  s.id=ss.dest and ss.source=p.id and
        $  p.Owner='mark' and c.Name='for boy' and (s.Name='small' or s.Name='medium')
      - you SHALL call explicitely the FillClose method before using any
        methods of nested TSQLRecordMany instances which may override the Dest
        instance content (e.g. ManySelect) to avoid any GPF
      - the aFormatSQLJoin clause will replace all '%' chars with the supplied
        aParamsSQLJoin[] supplied values, and bind all '?' chars as bound
        parameters with aBoundsSQLJoin[] values }
    constructor CreateAndFillPrepareMany(aClient: TSQLRest; aFormatSQLJoin: PUTF8Char;
      const aParamsSQLJoin, aBoundsSQLJoin: array of const);

    {/ this method create a clone of the current record, with same ID and properties
      - copy all COPIABLE_FIELDS, i.e. all fields excluding tftMany (because
        those fields don't contain any data, but a TSQLRecordMany instance
        which allow to access to the pivot table data)
      - you can override this method to allow custom copy of the object,
        including (or not) published properties copy }
    function CreateCopy: TSQLRecord; virtual;
    /// release the associated memory
    // - in particular, release all TSQLRecordMany instance created by the
    // constructor of this TSQLRecord
    destructor Destroy; override;

    {/ return the UTF-8 encoded SQL source to create the table containing the
      published fields of a TSQLRecord child
     - a 'ID INTEGER PRIMARY KEY' field is always created first (mapping
       SQLite3 RowID)
     - AnsiString are created as TEXT COLLATE NOCASE (fast SQLite3 7bits compare)
     - RawUnicode and RawUTF8 are created as TEXT COLLATE SYSTEMNOCASE
       (i.e. use our fast UTF8IComp() for comparaison)
     - TDateTime are created as TEXT COLLATE ISO8601
      (which calls our very fast ISO TEXT to Int64 conversion routine)
     - an individual bit set in UniqueField forces the corresponding field to
      be marked as UNIQUE (an unique index is automaticaly created on the specified
      column); use TSQLModel fIsUnique[] array, which set the bits values
      to 1 if a property field was published with "stored AS_UNIQUE"
      (i.e. "stored false")
     - this method will handle TSQLRecordFTS* classes like FTS* virtual tables,
       TSQLRecordRTree as RTREE virtual table, and TSQLRecordVirtualTable*ID
       classes as corresponding Delphi designed virtual tables
     - is not part of TSQLRecordProperties because has been declared as virtual
       so that you could specify a custom SQL statement, per TSQLRecord type
     - anyway, don't call this method directly, but use TSQLModel.GetSQLCreate()
     - the aModel parameter is used to retrieve the Virtual Table module name,
       and can be ignored for regular (not virtual) tables }
    class function GetSQLCreate(aModel: TSQLModel): RawUTF8; virtual;
    {/ return the Class Type of the current TSQLRecord }
    function RecordClass: TSQLRecordClass;
      {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    {/ return the RTTI property information for this record }
    function ClassProp: PClassProp;
      {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    {/ return the TRecordReference pointing to this record }
    function RecordReference(Model: TSQLModel): TRecordReference;

    {/ return the UTF-8 encoded SQL source to INSERT the values contained
      in the current published fields of a TSQLRecord child
      - only simple fields name (i.e. not TSQLRawBlob/TSQLRecordMany) are updated:
        BLOB fields are ignored (use direct update via dedicated methods instead)
      - format is '(COL1, COL2) VALUES ('VAL1', 'VAL2')' if some column was ignored (BLOB e.g.)
      - format is 'VALUES ('VAL1', 'VAL2')' if all columns values are available
      - is not used by the ORM (do not use prepared statements) - only here
        for conveniency }
    function GetSQLValues: RawUTF8;
    {/ return the UTF-8 encoded SQL source to UPDATE the values contained
      in the current published fields of a TSQLRecord child
      - only simple fields name (i.e. not TSQLRawBlob/TSQLRecordMany) are retrieved:
        BLOB fields are ignored (use direct access via dedicated methods instead)
      - format is 'COL1='VAL1', COL2='VAL2''
      - is not used by the ORM (do not use prepared statements) - only here
        for conveniency }
    function GetSQLSet: RawUTF8;
    /// return the UTF-8 encoded JSON objects for the values of this TSQLRecord
    // - layout and fields are set at TJSONSerializer construction
    procedure GetJSONValues(W : TJSONSerializer); overload;
    /// return the UTF-8 encoded JSON objects for the values of this TSQLRecord
    // - layout and fields are set at TJSONSerializer construction
    // - the JSON buffer will be finalized if needed (e.g. non expanded mode), 
  	// and the supplied TJSONSerializer instance will be freed by this method
    procedure GetJSONValuesAndFree(JSON : TJSONSerializer); overload;
    (** return the UTF-8 encoded JSON objects for the values contained
      in the current published fields of a TSQLRecord child
      - only simple fields (i.e. not TSQLRawBlob/TSQLRecordMany) are retrieved:
        BLOB fields are ignored (use direct access via dedicated methods instead)
      - if Expand is true, JSON data is an object, for direct use with any Ajax or .NET client:
      ! {"col1":val11,"col2":"val12"}
      - if Expand is false, JSON data is serialized (as used in TSQLTableJSON)
      ! { "fieldCount":1,"values":["col1","col2",val11,"val12",val21,..] }
      - if withID is true, then the first ID field value is included *)
    procedure GetJSONValues(JSON: TStream; Expand: boolean; withID: boolean;
      Occasion: TSQLOccasion); overload;
    /// same as overloaded GetJSONValues(), but returning result into a RawUTF8
    // - if UsingStream is not set, it will use a temporary THeapMemoryStream instance
    function GetJSONValues(Expand: boolean; withID: boolean; Occasion: TSQLOccasion;
      UsingStream: TCustomMemoryStream=nil): RawUTF8; overload;
    /// same as overloaded GetJSONValues(), but allowing to set the fields to
    // be retrieved, and returning result into a RawUTF8
    function GetJSONValues(Expand: boolean; withID: boolean;
      const Fields: TSQLFieldBits): RawUTF8; overload;
    /// write the field values into the binary buffer
    // - won't write the ID field (should be stored before, with the Count e.g.)
    procedure GetBinaryValues(W: TFileBufferWriter); overload;
    /// write the field values into the binary buffer
    // - won't write the ID field (should be stored before, with the Count e.g.)
    procedure GetBinaryValues(W: TFileBufferWriter; const aFields: TSQLFieldBits); overload;
    /// write the simple field values (excluding ID) into the binary buffer
    procedure GetBinaryValuesSimpleFields(W: TFileBufferWriter);
    /// set the field values from a binary buffer
    // - won't read the ID field (should be read before, with the Count e.g.)
    // - returns true on success, or false in case of invalid content in P^ e.g.
    // - P is updated to the next pending content after the read values
    function SetBinaryValues(var P: PAnsiChar): Boolean;
    /// set the simple field values from a binary buffer
    // - won't read the ID field (should be read before, with the Count e.g.)
    // - returns true on success, or false in case of invalid content in P^ e.g.
    // - P is updated to the next pending content after the read values
    function SetBinaryValuesSimpleFields(var P: PAnsiChar): Boolean;
    /// write the record fields into RawByteString a binary buffer
    // - same as GetBinaryValues(), but also writing the ID field first
    function GetBinary: RawByteString;
    /// set the record fields from a binary buffer saved by GetBinary()
    // - same as SetBinaryValues(), but also reading the ID field first
    function SetBinary(P: PAnsiChar): Boolean;
    /// set all field values from a supplied array of TSQLVar values
    // - Values[] array must match the RecordProps.Field[] order: will return
    // false if the Values[].VType does not match RecordProps.FieldType[]
    function SetFieldSQLVars(const Values: TSQLVarDynArray): boolean;
    {/ retrieve a field value from a given property name, as encoded UTF-8 text
      - you should use strong typing and direct property access, following
        the ORM approach of the framework; but in some cases (a custom Grid
        display, for instance), it could be useful to have this method available
      - will return '' in case of wrong property name
      - BLOB and dynamic array fields are returned as '\uFFF0base64encodedbinary'  }
    function GetFieldValue(const PropName: RawUTF8): RawUTF8;
    {/ set a field value of a given property name, from some encoded UTF-8 text
      - you should use strong typing and direct property access, following
        the ORM approach of the framework; but in some cases (a custom Grid
        display, for instance), it could be useful to have this method available
       - won't do anything in case of wrong property name 
       - expect BLOB and dynamic array fields encoded as SQlite3 BLOB literals
        ("x'01234'" e.g.) or '\uFFF0base64encodedbinary' }
    procedure SetFieldValue(const PropName: RawUTF8; Value: PUTF8Char);
    {$ifndef NOVARIANTS}
    /// retrieve the published property value into a Variant
    // - will set the Variant type to the best matching kind according to the
    // property type
    // - will return a null variant in case of wrong property name
    // - BLOB fields are returned as SQlite3 BLOB literals ("x'01234'" e.g.)
    // - dynamic array fields are returned as a Variant array
    function GetFieldVariant(const PropName: string): Variant;
    /// set the published property value from a Variant value
    // - will convert from the variant type into UTF-8 text before setting the
    // value (so will work with any kind of Variant)
    // - won't do anything in case of wrong property name
    // - expect BLOB fields encoded as SQlite3 BLOB literals ("x'01234'" e.g.)
    procedure SetFieldVariant(const PropName: string; const Source: Variant);
    {$endif}

    {/ prepare to get values from a TSQLTable result
     - then call FillRow(1..Table.RowCount) to get any row value
     - or you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - the specified TSQLTable is stored in an internal fTable protected field
     - set aCheckTableName if you want e.g. the Field Names from the Table
       any pending 'TableName.' trimmed before matching to the current record }
    procedure FillPrepare(Table: TSQLTable; aCheckTableName: TSQLCheckTableName=ctnNoCheck); overload;
    {/ prepare to get values from a SQL where statement
     - returns true in case of success, false in case of an error during SQL request
     - then call FillRow(1..Table.RowCount) to get any row value
     - or you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - a temporary TSQLTable is created then stored in an internal fTable protected field
     - if aSQLWhere is left to '', all rows are retrieved as fast as possible
       (e.g. by-passing SQLite3 virtual table modules for external databases)
     - the WHERE clause should use inlined parameters (like 'Name=:('Arnaud'):')
       for better server speed - note that you can use FormatUTF8() as such:
       ! aRec.FillPrepare(Client,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
       or call the overloaded FillPrepare() method directly with  BoundsSQLWhere
       array of parameters
     - aCustomFieldsCSV can be used to specify which fields must be retrieved
     - default aCustomFieldsCSV='' will retrieve all simple table fields, but
       you may need  to access only one or several fields, and will save remote
       bandwidth by specifying the needed fields
     - if aCustomFieldsCSV='*', it will retrieve all fields, including BLOBs 
     - note that you should not use this aCustomFieldsCSV optional parameter if
       you want to Update the retrieved record content later, since any
       missing fields will be left with previous values - but BatchUpdate() can be
       safely used after FillPrepare (will set only ID, TModTime and mapped fields) }
    function FillPrepare(aClient: TSQLRest; const aSQLWhere: RawUTF8='';
      const aCustomFieldsCSV: RawUTF8=''; aCheckTableName: TSQLCheckTableName=ctnNoCheck): boolean; overload;
    {/ prepare to get values using a specified WHERE clause with '%' parameters
     - returns true in case of success, false in case of an error during SQL request
     - then call FillRow(1..Table.RowCount) to get any row value
     - or you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - a temporary TSQLTable is created then stored in an internal fTable protected field
     - for better server speed, the WHERE clause should use bound parameters
       identified as '?' in the FormatSQLWhere statement, which is expected to
       follow the order of values supplied in BoundsSQLWhere open array - use
       DateToSQL/DateTimeToSQL for TDateTime, or directly any integer / double /
       currency / RawUTF8 values to be bound to the request as parameters
     - note that this method prototype changed with revision 1.17 of the
       framework: array of const used to be ParamsSQLWhere and '%' in the
       FormatSQLWhere statement, whereas it now expects bound parameters as '?'
     - aCustomFieldsCSV can be used to specify which fields must be retrieved
     - default aCustomFieldsCSV='' will retrieve all simple table fields, but
       you may need  to access only one or several fields, and will save remote
       bandwidth by specifying the needed fields
     - if aCustomFieldsCSV='*', it will retrieve all fields, including BLOBs 
     - note that you should not use this aCustomFieldsCSV optional parameter if
       you want to Update the retrieved record content later, since any
       missing fields will be left with previous values - but BatchUpdate() can be
       safely used after FillPrepare (will set only ID, TModTime and mapped fields) }
    function FillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8=''): boolean; overload;
    {/ prepare to get values using a specified WHERE clause with '%' and '?' parameters
     - returns true in case of success, false in case of an error during SQL request
     - then call FillRow(1..Table.RowCount) to get any row value
     - or you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - a temporary TSQLTable is created then stored in an internal fTable
       protected field
     - the FormatSQLWhere clause will replace all '%' chars with the supplied
       ParamsSQLWhere[] supplied values, and bind all '?' chars as bound
       parameters with BoundsSQLWhere[] values
     - aCustomFieldsCSV can be used to specify which fields must be retrieved
     - default aCustomFieldsCSV='' will retrieve all simple table fields, but
       you may need  to access only one or several fields, and will save remote
       bandwidth by specifying the needed fields
     - if aCustomFieldsCSV='*', it will retrieve all fields, including BLOBs 
     - note that you should not use this aCustomFieldsCSV optional parameter if
       you want to Update the retrieved record content later, since any
       missing fields will be left with previous values - but BatchUpdate() can be
       safely used after FillPrepare (will set only ID, TModTime and mapped fields) }
    function FillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const ParamsSQLWhere, BoundsSQLWhere: array of const;
      const aCustomFieldsCSV: RawUTF8=''): boolean; overload;
    {/ prepare to get values from a list of IDs
     - returns true in case of success, false in case of an error during SQL request
     - then call FillRow(1..Table.RowCount) to get any row value
     - or you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - a temporary TSQLTable is created then stored in an internal fTable protected field
     - aCustomFieldsCSV can be used to specify which fields must be retrieved
     - default aCustomFieldsCSV='' will retrieve all simple table fields, but
       you may need  to access only one or several fields, and will save remote
       bandwidth by specifying the needed fields
     - if aCustomFieldsCSV='*', it will retrieve all fields, including BLOBs 
     - note that you should not use this aCustomFieldsCSV optional parameter if
       you want to Update the retrieved record content later, since any
       missing fields will be left with previous values - but BatchUpdate() can be
       safely used after FillPrepare (will set only ID, TModTime and mapped fields) }
    function FillPrepare(aClient: TSQLRest; const aIDs: array of integer;
      const aCustomFieldsCSV: RawUTF8=''): boolean; overload;
    {/ prepare to loop through a JOINed statement including TSQLRecordMany fields
     - all TSQLRecordMany.Dest published fields will now contain a true TSQLRecord
       instance, ready to be filled with the JOINed statement results (these
       instances will be released at FillClose) - the same for Source which will
       point to the self instance
     - the aFormatSQLJoin clause will define a WHERE clause for an automated
       JOINed statement, including TSQLRecordMany published properties (and
       their nested properties)
     - returns true in case of success, false in case of an error during SQL request
     - a typical use could be the following:
       ! if aProd.FillPrepareMany(Database,
       !    'Owner=? and Categories.Dest.Name=? and (Sizes.Dest.Name=? or Sizes.Dest.Name=?)',[],
       !    ['mark','for boy','small','medium']) then
       !   while aProd.FillOne do
       !     // here e.g. aProd.Categories.Dest are instantied (and Categories.Source=aProd)
       !     writeln(aProd.Name,' ',aProd.Owner,' ',aProd.Categories.Dest.Name,' ',aProd.Sizes.Dest.Name);
       !   // you may also use aProd.FillTable to fill a grid, e.g.
       !   // (do not forget to set aProd.FillTable.OwnerMustFree := false)
       this will execute a JOINed SELECT statement similar to the following:
       $ select p.*, c.*, s.*
       $ from Product p, Category c, Categories cc, Size s, Sizes ss
       $ where c.id=cc.dest and cc.source=p.id and
       $  s.id=ss.dest and ss.source=p.id and
       $  p.Owner='mark' and c.Name='for boy' and (s.Name='small' or s.Name='medium')
     - the FormatSQLWhere clause will replace all '%' chars with the supplied
       ParamsSQLWhere[] supplied values, and bind all '?' chars as parameters
       with BoundsSQLWhere[] values
     - you SHALL call explicitely the FillClose method before using any
       methods of nested TSQLRecordMany instances which may override the Dest
       instance content (e.g. ManySelect) to avoid any GPF
     - is used by TSQLRecord.CreateAndFillPrepareMany constructor }
    function FillPrepareMany(aClient: TSQLRest; aFormatSQLJoin: PUTF8Char;
      const aParamsSQLJoin, aBoundsSQLJoin: array of const): boolean;
    {/ fill all published properties of an object from a TSQLTable prepared row
      - FillPrepare() must have been called before
      - if Dest is nil, this object values are filled
      - if Dest is not nil, this object values will be filled, but it won't
        work with TSQLRecordMany properties (i.e. after FillPrepareMany call)
      - ID field is updated if first Field Name is 'ID'
      - Row number is from 1 to Table.RowCount
      - setter method (write Set*) is called if available
      - handle UTF-8 SQL to Delphi values conversion (see TPropInfo mapping)
      - this method has been made virtual e.g. so that a calculated value can be
        used in a custom field }
    procedure FillRow(aRow: integer; aDest: TSQLRecord=nil); virtual;
    {/ fill all published properties of this object from the next available
      TSQLTable prepared row
      - FillPrepare() must have been called before
      - the Row number is taken from property FillCurrentRow
      - return true on success, false if no more Row data is available
      - internally call FillRow() to update published properties values }
    function FillOne: boolean;
    {/ go to the first prepared row, ready to loop through all rows with FillOne()
      - the Row number (property FillCurrentRow) is reset to 1
      - return true on success, false if no Row data is available
      - you can use it e.g. as:
      ! while Rec.FillOne do
      !   dosomethingwith(Rec);
      ! if Rec.FillRewind then
      ! repeat
      !   dosomeotherthingwith(Rec);
      ! until not Rec.FillOne;
    }
    function FillRewind: boolean;
    {/ close any previous FillPrepare..FillOne loop
     - is called implicitely by FillPrepare() call to release any previous loop
     - release the internal hidden TSQLTable instance if necessary
     - is not mandatory if the TSQLRecord is released just after, since
       TSQLRecord.Destroy will call it
     - used e.g. by FillFrom methods below to avoid any GPF/memory confusion }
    procedure FillClose;

    {/ fill all published properties of this object from a TSQLTable result row
      - call FillPrepare() then FillRow(Row) }
    procedure FillFrom(Table: TSQLTable; Row: integer); overload;
    {/ fill all published properties of this object from a JSON result row
     - create a TSQLTable from the JSON data
     - call FillPrepare() then FillRow(Row) }
    procedure FillFrom(const JSONTable: RawUTF8; Row: integer); overload;
    {/ fill all published properties of this object from a JSON object result
      - use JSON data, as exported by GetJSONValues()
      - JSON data may be expanded or not
      - make an internal copy of the JSONTable RawUTF8 before calling
       FillFrom() below}
    procedure FillFrom(const JSONRecord: RawUTF8); overload;
    {/ fill all published properties of this object from a JSON result
      - the data inside P^ is modified (unescaped and transformed): don't call
       FillFrom(pointer(JSONRecordUTF8)) but FillFrom(JSONRecordUTF8) which makes
       a temporary copy of the JSONRecordUTF8 text
      - use JSON data, as exported by GetJSONValues()
      - JSON data may be expanded or not }
    procedure FillFrom(P: PUTF8Char); overload;
    {/ fill all published properties of this object from another object
      - source object must be a parent or of the same class as the current record
      - copy all COPIABLE_FIELDS, i.e. all fields excluding tftMany (because
        those fields don't contain any data, but a TSQLRecordMany instance
        which allow to access to the pivot table data) }
    procedure FillFrom(aRecord: TSQLRecord); overload;
    {/ fill a published property value of this object from a UTF-8 encoded value
     - see TPropInfo about proper Delphi / UTF-8 type mapping/conversion
     - use this method to fill a BLOB property, i.e. a property defined with
       type TSQLRawBlob, since by default all BLOB properties are not
       set by the standard Retrieve() method (to save bandwidth) }
    procedure FillValue(PropName, Value: PUTF8Char; wasString: boolean);

    {/ return true if all published properties values in Other are identical to
     the published properties of this object
      - work with different classes: Reference properties name must just be
      present in the calling object
      - only simple fields (i.e. not TSQLRawBlob/TSQLRecordMany) are compared
      - compare the text representation of the values: fields may be of different
      type, encoding or precision, but still have same values }
    function SameValues(Reference: TSQLRecord): boolean;
    {/ return true if all published properties values in Other are identical to
      the published properties of this object
      - instances must be of the same class type
      - only simple fields (i.e. not TSQLRawBlob/TSQLRecordMany) are compared
      - comparaison is much faster than SameValues() above }
    function SameRecord(Reference: TSQLRecord): boolean;
    /// clear the values of all published properties, and also the ID property
    procedure ClearProperties;
    /// set the simple fields with the supplied values
    // - the aSimpleFields parameters must follow explicitely the order of published
    // properties of the supplied aTable class, excepting the TSQLRawBlob and
    // TSQLRecordMany kind (i.e. only so called "simple fields") - in particular,
    // parent properties must appear first in the list
    // - the aSimpleFields must have exactly the same count of parameters as there are
    // "simple fields" in the published properties
    // - return true on success, but be aware that the field list must match
    // the field layout, otherwise if may return true but will corrupt data
    function SimplePropertiesFill(const aSimpleFields: array of const): boolean;
    /// initialize a TDynArray wrapper to map dynamic array property values
    // - if the field name is not existing or not a dynamic array, result.IsVoid
    // will be TRUE
    function DynArray(const DynArrayFieldName: RawUTF8): TDynArray; overload;
    /// initialize a TDynArray wrapper to map dynamic array property values
    // - this overloaded version expect the dynamic array to have been defined
    // with a not null index attribute, e.g.
    // ! published
    // !   property Ints: TIntegerDynArray index 1 read fInts write fInts;
    // !   property Currency: TCurrencyDynArray index 2 read fCurrency write fCurrency;
    // - if the field index is not existing or not a dynamic array, result.IsVoid
    // will be TRUE
    function DynArray(DynArrayFieldIndex: integer): TDynArray; overload;

    {/ this property stores the record's integer ID
      - if this TSQLRecord is not a instance, but a field value in a published
        property of type sftID (i.e. TSQLRecord(aID)), this method will try
        to retrieve it; but prefered method is to typecast it via PtrInt(aProperty),
        because GetID() relies on some low-level Windows memory mapping trick, and
        will recognize an ID value up to 1,048,576 (i.e. $100000)
      - notice: the Setter should not be used usualy; you should not have to write
        aRecord.ID := someID in your code, since the ID is set during Retrieve or
        Add of the record }
    property ID: integer read GetID write fID;
    /// this read-only property can be used to retrieve the ID as a TSQLRecord object
    // - published properties of type TSQLRecord (one-to-many relationship) do not
    // store real class instances (only exception is if they inherit from
    // TSQLRecordMany) - you can use this value to assign a TSQLRecord instance
    // to a published property, as such:
    // ! Main := TSQLRecordMain.Create;
    // ! Client.Add(Main);
    // ! Detail := TSQLRecordDetail.Create;
    // ! Detail.Main := Main.AsTSQLRecord; // will store Main.ID in MAIN column
    // ! Client.Add(Detail);
    // - is especially useful on 64 bit plaform, since on 32 bit:
    // ! Detail.Main := pointer(Main.ID)
    // compiles (whereas it won't on 64 bit) and is the same than platform-independent
    // ! Detail.Main := Main.AsTSQLRecord;
    // - using Main.AsTSQLRecord will ensure that the ID is retrieved, even
    // if Main itself is not a true instance
    property AsTSQLRecord: pointer read GetIDAsPointer;
    {/ this property is set to true, if any published property is a BLOB (TSQLRawBlob) }
    property HasBlob: boolean read GetHasBlob;
    {/ this property returns the published property count with any valid
      database field except TSQLRawBlob/TSQLRecordMany
    - by default, the TSQLRawBlob (BLOB) fields are not included into this set:
      they must be read specificaly (in order to spare bandwidth)
    - TSQLRecordMany fields are not accessible directly, but as instances
      created by TSQLRecord.Create }
    property SimpleFieldCount: integer read GetSimpleFieldCount;
    {/ this property contains the TSQLTable after a call to FillPrepare() }
    property FillTable: TSQLTable read GetTable;
    {/ this property contains the current row number (beginning with 1),
      initialized to 1 by FillPrepare(), which will be read by FillOne }
    property FillCurrentRow: integer read GetFillCurrentRow;
    {/ this property contains the internal state counter of the server database
      when the data was retrieved from it
      - can be used to check if retrieved data may be out of date }
    property InternalState: cardinal read fInternalState;
  published
    { published properties in inherited classes will be interpreted as SQL fields }
  end;

  /// wrapper to an ORM result table, staticaly stored as UTF-8 text
  // - contain all result in memory, until destroyed
  // - first row contains the field names
  // - following rows contains the data itself
  // - GetString() can be used in a TDrawString
  // - will be implemented as TSQLTableJSON for remote access through optimized
  // JSON content
  TSQLTable = class
  private
    fQueryTables: TSQLRecordClassDynArray;
    fQueryColumnTypes: array of TSQLFieldType;
    fQuerySQL: RawUTF8;
    fFieldNames: TRawUTF8DynArray;
    fFieldLengthMean: TIntegerDynArray;
    fFieldLengthMeanSum: integer;
  protected
    fRowCount,
    fFieldCount: integer;
    /// contains the data, as returned by sqlite3_get_table()
    fResults: PPUTF8CharArray;
    /// contains the TSQLFieldType and TypeInfo(enumerate), after calculation
    // from the fQueryTables values
    fFieldType: array of record
      // the field kind
      ContentType: TSQLFieldType;
      // the field size in bytes; -1 means not computed yet
      ContentSize: integer;
      // initialized for both sftEnumerate and sftSet field kinds
      EnumTypeInfo: pointer;
      // the corresponding index in fQueryTables[]
      TableIndex: integer;
    end;
    /// used by FieldIndex() for fast binary search
    fFieldNameOrder: TCardinalDynArray;
    /// contain the fResults[] pointers, after a IDColumnHide() call
    fIDColumn, fNotIDColumn: array of PUTF8Char;
    /// bit set at parsing to mark was a string value (e.g. "..." in JSON)
    fFieldParsedAsString: set of 0..255;
    /// index of a 'ID' field, -1 if none (e.g. after IDColumnHide method call)
    fFieldIndexID: integer;
    /// the internal state counter of the database when the data was retrieved
    fInternalState: cardinal;
    /// contains the parameters used for sorting
    fSortParams: TSQLTableSortParams;
    /// contains the TSQLRecord instances created by NewRecord method
    fOwnedRecords: TObjectList;
    /// if the TSQLRecord is the owner of this table, i.e. if it must free it
    fOwnerMustFree: Boolean;
    /// current cursor row (1..RowCount), as set by the Step() method
    fStepRow: integer;
    /// fill the fFieldType[] array (from fQueryTables[] or fResults[] content)
    procedure InitFieldTypes;
    /// fill the fFieldNames[] array
    procedure InitFieldNames;
  public
    /// initialize the result table
    // - you can optionaly associate the corresponding TSQLRecordClass types,
    // by which the results were computed (it will use RTTI for column typing)
    constructor Create(const aSQL: RawUTF8);
    /// initialize the result table
    // - you can associate the corresponding TSQLRecordClass types,
    // by which the results were computed (it will use RTTI for column typing)
    constructor CreateFromTables(const Tables: array of TSQLRecordClass; const aSQL: RawUTF8);
    /// initialize the result table
    // - you can set the expected column types matching the results column layout
    constructor CreateWithColumnTypes(const ColumnTypes: array of TSQLFieldType; const aSQL: RawUTF8);
    /// free associated memory and owned records
    destructor Destroy; override;
    {/ read-only access to a particular field value, as UTF-8 encoded buffer
     - points to memory buffer allocated by Init() }
    function Get(Row,Field: integer): PUTF8Char;
    {/ read-only access to a particular field value, as RawUTF8 text }
    function GetU(Row,Field: integer): RawUTF8;
    {/ read-only access to a particular field value, as Win Ansi text }
    function GetA(Row,Field: integer): WinAnsiString;
    {/ read-only access to a particular field value, as Win Ansi text shortstring}
    function GetS(Row,Field: integer): shortstring;
    {$ifndef NOVARIANTS}
    {/ read-only access to a particular field value, as a Variant
     - text will be stored as RawUTF8 (as varString type)
     - will try to use the most approriate Variant type for conversion (will
       use e.g. TDateTime for sftDateTime, or a TDocVariant for JSON objects
       in a sftVariant column) - so you should better set the exact field types
       (e.g. from ORM) before calling this method }
    function GetVariant(Row,Field: integer; Client: TObject): variant; overload;
    {/ read-only access to a particular field value, as a Variant
     - text will be stored as RawUTF8 (as varString type)
     - will try to use the most approriate Variant type for conversion (will
       use e.g. TDateTime for sftDateTime, or a TDocVariant for JSON objects
       in a sftVariant column) - so you should better set the exact field types
       (e.g. from ORM) before calling this method }
    procedure GetVariant(Row,Field: integer; Client: TObject; var result: variant); overload;
    {$endif}
    {/ read-only access to a particular field value, as VCL string text
     - the global UTF8ToString() function will be used for the conversion:
     for proper i18n handling before Delphi 2009, you should use the
     overloaded method with aUTF8ToString=Language.UTF8ToString }
    function GetString(Row,Field: integer): string;
    /// read-only access to a particular field value, as fast Unicode string text
    // - SynUnicode is either WideString, either UnicodeString, depending on the
    // Delphi compiler revision, to ensure fastest native Unicode process available
    function GetSynUnicode(Row,Field: integer): SynUnicode;
    {/ fill a unicode buffer with a particular field value
      - return number of wide characters written in Dest^ }
    function GetWP(Row,Field: integer; Dest: PWideChar; MaxDestChars: cardinal): integer;
    {/ read-only access to a particular field value, as UTF-16 Unicode text
      - Raw Unicode is WideChar(zero) terminated
      - its content is allocated to contain all WideChars (not trimed to 255,
        like GetWP() above }
    function GetW(Row,Field: integer): RawUnicode;
    {/ read-only access to a particular field value, as integer value }
    function GetAsInteger(Row,Field: integer): integer;
      {$ifdef HASINLINE}inline;{$endif}
    {/ read-only access to a particular field value, as Int64 value }
    function GetAsInt64(Row,Field: integer): Int64;
      {$ifdef HASINLINE}inline;{$endif}
    {/ read-only access to a particular field value, as extended value }
    function GetAsFloat(Row,Field: integer): extended;
      {$ifdef HASINLINE}inline;{$endif}
    {/ read-only access to a particular field value, as TDateTime value
    - explicit sftDateTime will be converted from ISO-8601 text
    - sftTimeLog, sftModTime, sftCreateTime will expect the content to be
      encoded as a TTimeLog Int64 value - as sftInteger may have been
      identified by TSQLTable.InitFieldTypes
    - for sftTimeLog, sftModTime, sftCreateTime fields, you may have to force
      the column type, since it may be identified as sftCurrency by default
      from its JSON number content, e.g. via:
      ! aTable.SetFieldType('FieldName',sftModTime);
    - sftCurrency,sftFloat will return the corresponding double value
    - any other types will try to convert ISO-8601 text }
    function GetAsDateTime(Row,Field: integer): TDateTime;
    {/ read-only access to a particular field value, as currency value }
    function GetAsCurrency(Row,Field: integer): currency;
      {$ifdef HASINLINE}inline;{$endif}
    {/ read-only access to a particular field value, ready to be displayed
      - mostly used with Row=0, i.e. to get a display value from a field name
      - use "string" type, i.e. UnicodeString for Delphi 2009+
      - value is first un-camel-cased: 'OnLine' value will return 'On line' e.g.
      - then System.LoadResStringTranslate() is called if available }
    function GetCaption(Row,Field: integer): string;
    {/ read-only access to a particular Blob value
     - a new TSQLRawBlob is created
     - Blob data is converted from SQLite3 BLOB literals (X'53514C697465' e.g.)
       or Base-64 encoded content ('\uFFF0base64encodedbinary')
     - prefered manner is to directly use REST protocol to retrieve a blob field }
    function GetBlob(Row,Field: integer): TSQLRawBlob;
    {/ read-only access to a particular Blob value
     - a new TBytes is created
     - Blob data is converted from SQLite3 BLOB literals (X'53514C697465' e.g.)
       or Base-64 encoded content ('\uFFF0base64encodedbinary')
     - prefered manner is to directly use REST protocol to retrieve a blob field }
    function GetBytes(Row,Field: integer): TBytes;
    {/ read-only access to a particular Blob value
     - a new TCustomMemoryStream is created - caller shall free its instance
     - Blob data is converted from SQLite3 BLOB literals (X'53514C697465' e.g.)
       or Base-64 encoded content ('\uFFF0base64encodedbinary')
     - prefered manner is to directly use REST protocol to retrieve a blob field }
    function GetStream(Row,Field: integer): TStream;
    {/ read-only access to a particular field value, as VCL text
     - Client is one TSQLClient instance (used to display TRecordReference via
       the associated TSQLModel)
     - returns the Field Type
     - return generic string Text, i.e. UnicodeString for Delphi 2009+,
       ready to be displayed to the VCL, for sftEnumerate, sftTimeLog
       and sftRecord/sftID
     - returns '' as string Text, if text can by displayed directly
       with Get*() methods above
     - returns '' for other properties kind, if UTF8ToString is nil,
       or the ready to be displayed value if UTF8ToString event is set
       (to be used mostly with Language.UTF8ToString)
      - CustomFormat can optionaly set a custom format string, e.g. '%f' or '%n'
        or complex FormatFloat()/FormatCurr() syntax (as '#,##0.00') for sftFloat
        and sftCurrency columns (instead of plain JSON float value), or
        date/time format as expected by FormatDateTime() for all date time kind
        of fields (as sftDateTime, sftTimeLog, sftModTime, sftCreateTime) }
    function ExpandAsString(Row,Field: integer; Client: TObject; out Text: string;
      const CustomFormat: string=''): TSQLFieldType;
    {/ read-only access to a particular field value, as VCL text
     - this method is just a wrapper around ExpandAsString method, returning
       the content as a SynUnicode string type (i.e. UnicodeString since Delphi
       2009, and WideString for non Unicode versions of Delphi)
     - it is used by the reporting layers of the framework (e.g. TSQLRibbon.AddToReport) }
    function ExpandAsSynUnicode(Row,Field: integer; Client: TObject; out Text: SynUnicode): TSQLFieldType;
    {/ read-only access to a particular DateTime field value
     - expect SQLite3 TEXT field in ISO 8601 'YYYYMMDD hhmmss' or
      'YYYY-MM-DD hh:mm:ss' format }
    function GetDateTime(Row,Field: integer): TDateTime;
      {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    {/ read-only access to a particular TTimeLog field value
      - return the result as TTimeLogBits.Text() Iso-8601 encoded text }
    function GetTimeLog(Row,Field: integer; Expanded: boolean; FirstTimeChar: AnsiChar = 'T'): RawUTF8;
    {/ widechar length (UTF-8 decoded) of a particular field value }
    function LengthW(Row,Field: integer): integer;
    {/ get all values for a specified field into a dynamic RawUTF8 array
     - don't perform any conversion, but just create an array of raw PUTF8Char data }
    procedure GetRowValues(Field: integer; out Values: TRawUTF8DynArray); overload;
    {/ get all values for a specified field into a dynamic Integer array }
    procedure GetRowValues(Field: integer; out Values: TIntegerDynArray); overload;
    {/ get all values for a specified field as CSV
     - don't perform any conversion, but create a CSV from raw PUTF8Char data }
    function GetRowValues(Field: integer; Sep: AnsiChar=','): RawUTF8; overload;
    {$ifndef NOVARIANTS}
    {/ retrieve a row value as a variant, ready to be accessed via late-binding
    - Row parameter numbering starts from 1 to RowCount
    - this method will return a TDocVariant containing a copy of all
      field values of this row, uncoupled to the TSQLTable instance life time }
    procedure ToDocVariant(Row: integer; out doc: variant); overload;
    {/ retrieve all row values as a dynamic array of variants, ready to be
      accessed via late-binding
    - if readonly is TRUE, will contain an array of TSQLTableRowVariant, which
      will point directly to the TSQLTable, which should remain allocated
    - if readonly is FALSE, will contain an array of TDocVariant, containing
      a copy of all field values of this row, uncoupled to the TSQLTable instance
    - readonly=TRUE is faster to allocate (around 4 times for 10,000 rows), but
      may be slightly slower to access than readonly=FALSE, if all values are
      likely be accessed later in the process }
    procedure ToDocVariant(out docs: TVariantDynArray; readonly: boolean); overload;
    {/ retrieve all row values as a TDocVariant of kind dvArray, ready to be
      accessed via late-binding
    - if readonly is TRUE, will contain an array of TSQLTableRowVariant, which
      will point directly to the TSQLTable, which should remain allocated
    - if readonly is FALSE, will contain an array of TDocVariant, containing
      a copy of all field values of this row, uncoupled to the TSQLTable instance
    - readonly=TRUE is faster to allocate (around 4 times for 10,000 rows), but
      may be slightly slower to access than readonly=FALSE, if all values are
      likely be accessed later in the process }
    procedure ToDocVariant(out docarray: variant; readonly: boolean); overload;
      {$ifdef HASINLINE}inline;{$endif}
    {$endif NOVARIANTS}

    /// save the table values in JSON format
    // - JSON data is added to TStream, with UTF-8 encoding
    // - if Expand is true, JSON data is an array of objects, for direct use
    // with any Ajax or .NET client:
    // & [ {"col1":val11,"col2":"val12"},{"col1":val21,... ]
    // - if Expand is false, JSON data is serialized (used in TSQLTableJSON)
    // & { "fieldCount":1,"values":["col1","col2",val11,"val12",val21,..] }
    // - RowFirst and RowLast can be used to ask for a specified row extent
    // of the returned data (by default, all rows are retrieved)
    procedure GetJSONValues(JSON: TStream; Expand: boolean;
      RowFirst: integer=0; RowLast: integer=0); overload;
    /// same as above, but returning result into a RawUTF8
    function GetJSONValues(Expand: boolean): RawUTF8; overload;
    /// save the table in CSV format
    // - if Tab=TRUE, will use TAB instead of ',' between columns
    // - you can customize the ',' separator - use e.g. the global ListSeparator
    // variable (from SysUtils) to reflect the current system definition (some
    // country use ',' as decimal separator, for instance our "douce France")
    // - AddBOM will add a UTF-8 Byte Order Mark at the beginning of the content
    procedure GetCSVValues(Dest: TStream; Tab: boolean; CommaSep: AnsiChar=',';
      AddBOM: boolean=false);

    {/ get the Field index of a FieldName
     - return -1 if not found, index (0..FieldCount-1) if found }
    function FieldIndex(FieldName: PUTF8Char): integer; overload;
    {/ get the Field index of a FieldName
     - return -1 if not found, index (0..FieldCount-1) if found }
    function FieldIndex(const FieldName: RawUTF8): integer; overload;
      {$ifdef HASINLINE}inline;{$endif}
    {/ get the Field content (encoded as UTF-8 text) from a property name
     - return nil if not found }
    function FieldValue(const FieldName: RawUTF8; Row: integer): PUTF8Char;
    {/ sort result Rows, according to a specific field
     - default is sorting by ascending order (Asc=true)
     - you can specify a Row index to be updated during the sort in PCurrentRow
     - sort is very fast, even for huge tables (more faster than any indexed
       SQL query): 500,000 rows are sorted instantly
     - this optimized sort implementation does the comparaison first by the
     designed field, and, if the field value is identical, the ID value is
     used (it will therefore sort by time all identical values) }
    procedure SortFields(Field: integer; Asc: boolean=true;
      PCurrentRow: PInteger=nil; FieldType: TSQLFieldType=sftUnknown;
      CustomCompare: TUTF8Compare=nil); overload;
    /// sort result Rows, according to some specific fields
    // - is able to make multi-field sort
    // - both Fields[] and Asc[] array should have the same count, otherwise
    // default Asc[]=true value will be assumed
    // - set any Fields[]=-1 to identify the ID column (even if is hidden)
    procedure SortFields(const Fields: array of integer;
      const Asc: array of boolean); overload;
    {/ sort result Rows, according to the Bits set to 1 first }
    procedure SortBitsFirst(var Bits);
    {/ guess the field type from first non null data row
     - if QueryTables[] are set, exact field type and enumerate TypeInfo() is
       retrieved from the Delphi RTTI; otherwise, get from the cells content
     - return sftUnknown is all data fields are null
     - sftBlob is returned if the field is encoded as SQLite3 BLOB literals
       (X'53514C697465' e.g.)
     - since TSQLTable data is PUTF8Char, string type is sftUTF8Text only }
    function FieldType(Field: integer): TSQLFieldType; overload;
    {/ guess the field type from first non null data row
     - if QueryTables[] are set, exact field type and enumerate TypeInfo() is
       retrieved from the Delphi RTTI; otherwise, get from the cells content
     - return sftUnknown is all data fields are null
     - sftBlob is returned if the field is encoded as SQLite3 BLOB literals
       (X'53514C697465' e.g.)
     - since TSQLTable data is PUTF8Char, string type is sftUTF8Text only }
    function FieldType(Field: integer; EnumTypeInfo: PPointer): TSQLFieldType; overload;
    {/ get the appropriate Sort comparaison function for a field,
      nil if not available (bad field index or field is blob)
      - field type is guessed from first data row }
    function SortCompare(Field: integer): TUTF8Compare;
    /// get the mean of characters length of all fields
    // - the character length is for the first line of text only (stop counting
    // at every newline character, i.e. #10 or #13 char)
    // - return the sum of all mean of character lengths
    function CalculateFieldLengthMean(var aResult: TIntegerDynArray;
      FromDisplay: boolean=false): integer;
    /// get the mean of characters length of this field
    // - the character length is for the first line of text only (stop counting
    // at every newline character, i.e. #10 or #13 char)
    // - very fast: calculated only once for all fields
    function FieldLengthMean(Field: integer): cardinal;
    /// get the sum of all mean of characters length of all fields
    // - very fast: calculated only once for all fields
    function FieldLengthMeanSum: cardinal;
    /// get the maximum number of characters of this field
    function FieldLengthMax(Field: integer; NeverReturnsZero: boolean=false): cardinal;
    /// get the record class (i.e. the table) associated to a field
    // - is nil if this table has no QueryTables property
    // - very fast: calculated only once for all fields
    function FieldTable(Field: integer): TSQLRecordClass;
    /// force the mean of characters length for every field
    // - expect as many parameters as fields in this table
    // - override internal fFieldLengthMean[] and fFieldLengthMeanSum values
    procedure SetFieldLengthMean(const Lengths: array of cardinal);
    /// set the exact type of a given field
    // - by default, column types and sizes will be retrieved from JSON content
    // - you can define a specific type for a given column, and optionally
    // a maximum column size
    procedure SetFieldType(Field: integer; FieldType: TSQLFieldType;
       aEnumTypeinfo: pointer=nil; FieldSize: integer=-1); overload;
    /// set the exact type of a given field
    // - by default, column types and sizes will be retrieved from JSON content
    // - you can define a specific type for a given column, and optionally
    // a maximum column size
    procedure SetFieldType(const FieldName: RawUTF8; FieldType: TSQLFieldType;
       aEnumTypeinfo: pointer=nil; FieldSize: integer=-1); overload;
    /// increase a particular Field Length Mean value
    // - to be used to customize the field appareance (e.g. for adding of left
    // checkbox for Marked[] fields)
    procedure FieldLengthMeanIncrease(aField, aIncrease: integer);

    {/ copy the parameters of a TSQLTable into this instance
     - the fResults remain in the source TSQLTable: source TSQLTable has not to
      be destroyed before this TSQLTable }
    procedure Assign(source: TSQLTable);

    /// search a text value inside the table data in a specified field
    // - the text value must already be uppercased 7-bits ANSI encoded
    // - return the Row on success, 0 on error
    // - search only in the content of FieldIndex data
    // - you can specify a Soundex pronunciation to use, or leave as sndxNone for
    // standard case insensitive character match; aUpperValue can optional
    // indicate a Soundex search, by predeceding the searched text with % for
    // English, %% for French or %%% for Spanish (only works with WinAnsi
    // char set - i.e. code page 1252)
    // - if UnicodeComparison is set to TRUE, search will use low-level Windows
    // API for Unicode-level conversion - it will be much slower, but accurate
    // for the whole range of UTF-8 encoding
    // - if UnicodeComparison is left to FALSE, UTF-8 decoding will be done only
    // if necessary: it will work only with standard western-occidental alphabet
    // (i.e. WinAnsi - code page 1252), but it will be very fast
    function SearchValue(const aUpperValue: RawUTF8; StartRow, FieldIndex: integer;
      Client: TObject; Lang: TSynSoundExPronunciation=sndxNone;
      UnicodeComparison: boolean=false): integer; overload;
    /// search a text value inside the table data in all fields
    // - the text value must already be uppercased 7-bits ANSI encoded
    // - return the Row on success, 0 on error
    // - search on all fields, returning field found in FieldIndex (if not nil)
    // - you can specify a Soundex pronunciation to use, or leave as sndxNone for
    // standard case insensitive character match; aUpperValue can optional
    // indicate a Soundex search, by predeceding the searched text with % for
    // English, %% for French or %%% for Spanish (only works with WinAnsi
    // char set - i.e. code page 1252)
    // - if UnicodeComparison is set to TRUE, search will use low-level Windows
    // API for Unicode-level conversion - it will be much slower, but accurate
    // for the whole range of UTF-8 encoding
    // - if UnicodeComparison is left to FALSE, UTF-8 decoding will be done only
    // if necessary: it will work only with standard western-occidental alphabet
    // (i.e. WinAnsi - code page 1252), but it will be very fast
    function SearchValue(const aUpperValue: RawUTF8; StartRow: integer;
      FieldIndex: PInteger; Client: TObject; Lang: TSynSoundExPronunciation=sndxNone;
      UnicodeComparison: boolean=false): integer; overload;
    /// search for a value inside the raw table data
    // - returns 0 if not found, or the matching Row number otherwise
    function SearchFieldEquals(const aValue: RawUTF8; FieldIndex: integer): integer;

    /// if the ID column is available, hides it from fResults[]
    // - useful for simplier UI, with a hidden ID field
    // - use IDColumnHiddenValue() to get the ID of a specific row
    // - return true is ID was succesfully hidden, false if not possible
    function IDColumnHide: boolean;
    /// return the (previously hidden) ID value, 0 on error
    function IDColumnHiddenValue(Row: integer): integer;
    /// return all (previously hidden) ID values
    procedure IDColumnHiddenValues(var IDs: TIntegerDynArray);
    /// get all IDs where individual bit in Bits are set
    procedure IDArrayFromBits(const Bits; var IDs: TIntegerDynArray);
    /// get all individual bit in Bits corresponding to the supplied IDs
    // - warning: IDs integer array will be sorted within this method call
    procedure IDArrayToBits(var Bits; var IDs: TIntegerDynArray);
    /// get the Row index corresponding to a specified ID
    // - return the Row number, from 1 to RowCount
    // - return RowCount (last row index) if this ID was not found or no
    // ID field is available
    function RowFromID(aID: integer): integer;

    /// delete the specified data Row from the Table
    // - only overwrite the internal fResults[] pointers, don't free any memory,
    // nor modify the internal DataSet
    procedure DeleteRow(Row: integer);
    /// delete the specified Column text from the Table
    // - don't delete the Column: only delete UTF-8 text in all rows for this field
    procedure DeleteColumnValues(Field: integer);

    /// retrieve QueryTables[0], if existing
    function QueryRecordType: TSQLRecordClass;

    /// create a new TSQLRecord instance for a specific Table
    // - use the specified TSQLRecord class or create one instance
    // of the first associated record class (from internal QueryTables[])
    // - use this method to create a working copy of a table's record, e.g.
    // - the record will be freed when the TSQLTable will be destroyed:
    // you don't need to make a Try..Finally..Free..end block with it
    function NewRecord(RecordType: TSQLRecordClass=nil): TSQLRecord;
    /// create a TObjectList with TSQLRecord instances corresponding to this
    // TSQLTable result set
    // - use the specified TSQLRecord class or create instances
    // of the first associated record class (from internal QueryTables[])
    // - always returns an instance, even if the TSQLTable is nil or void
    function ToObjectList(RecordType: TSQLRecordClass=nil): TObjectList; overload;
    /// fill an existing TObjectList with TSQLRecord instances corresponding
    // to this TSQLTable result set
    // - use the specified TSQLRecord class or create instances
    // of the first associated record class (from internal QueryTables[])
    procedure ToObjectList(DestList: TObjectList; RecordType: TSQLRecordClass=nil); overload;
    {$ifdef ISDELPHI2010} // Delphi 2009 generics are buggy
    /// create a TObjectList<TSQLRecord> with TSQLRecord instances corresponding
    // to this TSQLTable result set
    // - use the specified TSQLRecord class or create instances
    // of the first associated record class (from internal QueryTables[])
    // - always returns an instance, even if the TSQLTable is nil or void
    function ToObjectList<T: TSQLRecord>: TObjectList<T>; overload;
    {$endif}

    {/ After a TSQLTable has been initialized, this method can be called
      one or more times to iterate through all data rows
     - you shall call this method before calling FieldBuffer()/Field() methods
     - return TRUE on success, with data ready to be retrieved by Field*()
     - return FALSE if no more row is available (i.e. exceeded RowCount)
     - if SeekFirst is TRUE, will put the cursor on the first row of results,
       otherwise, it will fetch one row of data, to be called within a loop
     - you can specify a variant instance (e.g. allocated on the stack) in
       optional RowVariant parameter, to access field values using late binding
     - typical use may be:
       ! while TableCustomers.Step do
       !   writeln(Field('name'));
     - or, when using a variant and late-binding:
       ! var customer: variant;
       ! ...
       !   while TableCustomers.Step(false,@customer) do
       !     writeln(customer.Name);
     }
    function Step(SeekFirst: boolean=false; RowVariant: PVariant=nil): boolean;
    /// read-only access to a particular field value, as UTF-8 encoded buffer
    // - raise an ESQLTableException if called outside valid Step() sequence
    // - similar to Get() method, but for the current Step
    function FieldBuffer(FieldIndex: Integer): PUTF8Char; overload;
    /// read-only access to a particular field value, as UTF-8 encoded buffer
    // - raise an ESQLTableException if called outside valid Step() sequence
    // - similar to Get() method, but for the current Step
    function FieldBuffer(const FieldName: RawUTF8): PUTF8Char; overload;
    {$ifndef NOVARIANTS}
    /// read-only access to a particular field value, as a variant
    // - raise an ESQLTableException if called outside valid Step() sequence
    // - will call GetVariant() method for appropriate data conversion
    function Field(FieldIndex: integer): variant; overload;
    /// read-only access to a particular field value, as a variant
    // - raise an ESQLTableException if called outside valid Step() sequence
    // - will call GetVariant() method for appropriate data conversion
    function Field(const FieldName: RawUTF8): variant; overload;
    {$endif}

    /// contains the associated record class on Query
    property QueryTables: TSQLRecordClassDynArray read fQueryTables;
    /// contains the associated SQL statement on Query
    property QuerySQL: RawUTF8 read fQuerySQL;
    {/ read-only access to the number of data Row in this table
     - first row contains field name
     - then 1..RowCount rows contain the data itself }
    property RowCount: integer read fRowCount;
    {/ read-only access to the number of fields for each Row in this table }
    property FieldCount: integer read fFieldCount;
    /// read-only acccess to the current Row number, after a Step() call
    // - contains 0 if accessed outside valid Step() sequence call
    // - contains 1..RowCount after a valid Step() iteration
    property StepRow: integer read fStepRow;
    {/ this property contains the internal state counter of the server database
      when the data was retrieved from it
      - can be used to check if retrieved data may be out of date }
    property InternalState: cardinal read fInternalState write fInternalState;
    /// if the TSQLRecord is the owner of this table, i.e. if it must free it
    property OwnerMustFree: Boolean read fOwnerMustFree write fOwnerMustFree;
  end;

{$ifndef NOVARIANTS}
  /// memory structure used for our TSQLTableRowVariant custom variant type
  // used to have direct access to TSQLTable content
  // - the associated TSQLTable must stay allocated as long as this variant
  // is used, otherwise random GPF issues may occur
  TSQLTableRowVariantData = packed record
    /// the custom variant type registered number
    VType: TVarType;
    VFiller: array[1..sizeof(TVarData)-sizeof(TVarType)-sizeof(TSQLTable)
      -sizeof(integer)] of byte;
    /// reference to the associated TSQLTable
    VTable: TSQLTable;
    /// the row number corresponding to this value
    // - equals -1 if should follow StepRow property value
    VRow: integer;
  end;

  /// pointer to the memory structure used for TSQLTableRowVariant storage
  PSQLTableRowVariantData = ^TSQLTableRowVariantData;

  /// a custom variant type used to have direct access to TSQLTable content
  // - use TSQLTable.Step(..,@Data) method to initialize such a Variant
  // - the variant members/fields are read-only by design
  // - the associated TSQLTable must stay allocated as long as this variant
  // is used, otherwise random GPF issues may occur
  TSQLTableRowVariant = class(TSynInvokeableVariantType)
  protected
    procedure IntGet(var Dest: TVarData; const V: TVarData; Name: PAnsiChar); override;
    procedure IntSet(const V, Value: TVarData; Name: PAnsiChar); override;
    procedure ToJSON(W: TTextWriter; const Value: variant; Escape: TTextWriterKind); override;
  public
    /// handle type conversion to string
    procedure Cast(var Dest: TVarData; const Source: TVarData); override;
    /// handle type conversion to string
    procedure CastTo(var Dest: TVarData; const Source: TVarData;
      const AVarType: TVarType); override;
  end;
{$endif NOVARIANTS}


  /// get a SQL result from a JSON message, and store it into its own memory
  TSQLTableJSON = class(TSQLTable)
  protected
    /// used if a private copy of the JSON buffer is needed
    fPrivateCopy: RawUTF8;
    /// contains the pointers of start of every field value in JSONData
    fJSONResults: array of PUTF8Char;
    /// contain the hash value of the last JSON data sent to ContentChanged()
    // - used to don't repeat parsing if data has not been changed
    fPrivateCopyHash: cardinal;
    /// fill the result table content from a JSON-formated Data message
    // - returns TRUE on parsing success
    // - returns FALSE if no valid JSON data was found
    // - update all content fields (fResults[], fRowCount, fFieldCount, etc...)
    // - expect the UTF-8 Buffer in either TSQLRequest.EngineExecute(DB,SQL,JSON)
    // format (i.e. expanded) or either in a not expanded format (as an
    // AJAX-ready array of objects)
    // - the conversion into PPUTF8CharArray is made inplace and is very fast
    // (no additional memory buffer is allocated)
    function ParseAndConvert(Buffer: PUTF8Char; BufferLen: integer): boolean;
    /// will check then set (if needed) internal fPrivateCopy[Hash] values
    // - returns TRUE if content changed (then fPrivateCopy+fPrivateCopyHash
    // will be updated using crc32c hash)
    function PrivateCopyChanged(aJSON: PUTF8Char; aLen: integer): boolean;
  public
    /// create the result table from a JSON-formated Data message
    // - the JSON data is parsed and formatted in-place
    // - please note that the supplied JSON buffer content will be changed:
    // if you want to reuse this JSON content, you shall make a private copy
    // before calling this constructor and you shall NOT release the corresponding
    // variable (fResults/JSONResults[] will point inside this memory buffer):
    // use instead the overloaded Create constructor expecting aJSON parameter
    // making a private copy of the data
    constructor Create(const aSQL: RawUTF8;
      JSONBuffer: PUTF8Char; JSONBufferLen: integer); reintroduce; overload;
    /// create the result table from a JSON-formated Data message
    // - the JSON data is parsed and formatted in-place, after having been
    // copied in the protected fPrivateCopy variable
    constructor Create(const aSQL, aJSON: RawUTF8); reintroduce; overload; 
    /// create the result table from a JSON-formated Data message
    // - the JSON data is parsed and formatted in-place
    // - you can specify a set of TSQLRecord classes which will be used to
    // retrieve the column exact type information
    // - please note that the supplied JSON buffer content will be changed
    constructor CreateFromTables(const Tables: array of TSQLRecordClass;
      const aSQL: RawUTF8; JSONBuffer: PUTF8Char; JSONBufferLen: integer); reintroduce; overload;
    /// create the result table from a JSON-formated Data message
    // - you can specify a set of TSQLRecord classes which will be used to
    // retrieve the column exact type information
    // - the JSON data is parsed and formatted in-place, after having been
    // copied in the protected fPrivateCopy variable
    constructor CreateFromTables(const Tables: array of TSQLRecordClass;
      const aSQL, aJSON: RawUTF8); reintroduce; overload;
    /// initialize the result table from a JSON-formated Data message
    // - you can set the expected column types matching the results column layout
    // - the JSON data is parsed and formatted in-place
    constructor CreateWithColumnTypes(const ColumnTypes: array of TSQLFieldType;
      const aSQL: RawUTF8; JSONBuffer: PUTF8Char; JSONBufferLen: integer); reintroduce; overload;
    /// initialize the result table from a JSON-formated Data message
    // - you can set the expected column types matching the results column layout
    // - the JSON data is parsed and formatted in-place, after having been
    // copied in the protected fPrivateCopy variable
    constructor CreateWithColumnTypes(const ColumnTypes: array of TSQLFieldType;
      const aSQL, aJSON: RawUTF8); reintroduce; overload;

    /// update the result table content from a JSON-formated Data message
    // - return true on parsing success, false if no valid JSON data was found
    // - set Refreshed to true if the content changed
    // - update all content fields (fResults[], fRowCount, fFieldCount, etc...)
    // - call SortFields() or IDColumnHide if was already done for this TSQLTable
    // - the conversion into PPUTF8CharArray is made inplace and is very fast
    // (only one memory buffer is allocated for the whole data)
    function UpdateFrom(const aJSON: RawUTF8; var Refreshed: boolean;
      PCurrentRow: PInteger): boolean;

    /// the private copy of the processed data buffer
    // - available e.g. for Create constructor using aJSON parameter,
    // or after the UpdateFrom() process
    // - this buffer is not to be access directly: this won't be a valid JSON
    // content, but a processed buffer, on which fResults[] elements point to -
    // it will contain unescaped text and numerical values, ending with #0 
    property PrivateInternalCopy: RawUTF8 read fPrivateCopy;
  end;

  PSQLLocks = ^TSQLLocks;
  /// used to store the locked record list, in a specified table
  // - the maximum count of the locked list if fixed to 512 by default,
  // which seems correct for common usage
  TSQLLocks = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// the number of locked records stored in this object
    Count: integer;
    /// contains the locked record ID
    // - an empty position is marked with 0 after UnLock()
    IDs: TIntegerDynArray;
    /// contains the time and date of the lock
    // - filled internally by the fast GetTickCount64() function (faster than
    // TDateTime or TSystemTime/GetLocalTime)
    // - used to purge to old entries - see PurgeOlderThan() method below
    Ticks64s: TInt64DynArray;
    /// lock a record, specified by its ID
    // - returns true on success, false if was already locked
    function Lock(aID: integer): boolean;
    /// unlock a record, specified by its ID
    // - returns true on success, false if was not already locked
    function UnLock(aID: integer): boolean;
    /// return true if a record, specified by its ID, is locked
    function isLocked(aID: integer): boolean;
    /// delete all the locked IDs entries, after a specified time
    // - to be used to release locked records if the client crashed
    // - default value is 30 minutes, which seems correct for common database usage
    procedure PurgeOlderThan(MinutesFromNow: cardinal=30);
  end;

  TSQLLocksDynArray = array of TSQLLocks;

  /// UI Query comparison operators
  // - these operators are e.g. used to mark or unmark some lines in a UI Grid
  // or for TInterfaceStub.ExpectsCount() methods
  TSQLQueryOperator =
    (qoNone,
     qoEqualTo,
     qoNotEqualTo,
     qoLessThan,
     qoLessThanOrEqualTo,
     qoGreaterThan,
     qoGreaterThanOrEqualTo,
     qoEqualToWithCase,
     qoNotEqualToWithCase,
     qoContains,
     qoBeginWith,
     qoSoundsLikeEnglish,
     qoSoundsLikeFrench,
     qoSoundsLikeSpanish);

  /// set of UI Query comparison operators
  TSQLQueryOperators = set of TSQLQueryOperator;

  /// User Interface Query action evaluation function prototype
  // - Operator is ord(TSQLQueryOperator) by default (i.e. for class function
  // TSQLRest.QueryIsTrue), or is a custom enumeration index for custom queries
  // (see TSQLQueryCustom.EnumIndex below, and TSQLRest.QueryAddCustom() method)
  // - for default Operator as ord(TSQLQueryOperator), qoContains and qoBeginWith
  // expect the Reference to be already uppercase
  // - qoEqualTo to qoGreaterThanOrEqualTo apply to all field kind (work with
  // either numeric either UTF-8 values)
  // - qoEqualToWithCase to qoSoundsLikeSpanish handle the field as UTF-8 text,
  // and make the comparison using the phonetic algorithm corresponding to
  // a language family
  // - for default Operator as ord(TSQLQueryOperator), qoSoundsLike* operators
  // expect the Reference not to be a PUTF8Char, but a typecast of a prepared
  // TSynSoundEx object instance (i.e. pointer(@SoundEx)) by the caller
  // - for custom query (from TSQLQueryCustom below), the event must
  // handle a special first call with Value=nil to select if this custom
  // Operator/Query is available for the specified aTable: in this case,
  // returning true indicates that this custom query is available for this table
  // - for custom query (from TSQLQueryCustom below), the event is called with
  // FieldType := TSQLFieldType(TSQLQueryCustom.EnumIndex)+64
  TSQLQueryEvent = function(aTable: TSQLRecordClass; aID: integer;
    FieldType: TSQLFieldType; Value: PUTF8Char; Operator: integer;
    Reference: PUTF8Char): boolean of object;

  /// store one custom query parameters
  // - add custom query by using the TSQLRest.QueryAddCustom() method
  // - use EnumType^.GetCaption(EnumIndex) to retrieve the caption associated
  // to this custom query
  TSQLQueryCustom = record
    /// the associated enumeration type
    EnumType: PEnumType;
    /// the associated enumeration index in EnumType
    // - will be used to fill the Operator parameter for the Event call
    EnumIndex: integer;
    /// the associated evaluation Event handler
    // - the Operator parameter will be filled with the EnumIndex value
    Event: TSQLQueryEvent;
    /// User Interface Query action operators
    Operators: TSQLQueryOperators;
  end;

  /// standard actions for User Interface generation
  TSQLAction = (
    /// action not defined
    actNoAction,
    /// Mark rows (standard action)
    // - display sub-menu with actmarkAllEntries..actmarkBeforeOneYear items
    actMark,
    /// UnMark all rows (standard action)
    actUnmarkAll,
    /// Mark all rows
    actmarkAllEntries,
    /// Mark rows After one day
    actmarkOlderThanOneDay,
    /// Mark rows older than one week
    actmarkOlderThanOneWeek,
    /// Mark rows older than one month
    actmarkOlderThanOneMonth,
    /// Mark rows older than one half year
    actmarkOlderThanSixMonths,
    /// Mark rows older than one year
    actmarkOlderThanOneYear,
    /// Inverse Mark values (ON->OFF, OFF->ON)
    actmarkInverse);

  /// set of standard actions for User Interface generation
  TSQLActions = set of TSQLAction;

  /// defines the way the TDrawGrid is displayed by User Interface generation
  TSQLListLayout = (llLeft, llUp, llClient, llLeftUp);

  PSQLRibbonTabParameters = ^TSQLRibbonTabParameters;

  /// defines the settings for a Tab for User Interface generation
  // - used in mORMotToolBar.pas unit and TSQLModel.Create() overloaded method
  TSQLRibbonTabParameters = object
  public
    /// the Table associated to this Tab
    Table: TSQLRecordClass;
    /// the caption of the Tab, to be translated on the screen
    // - by default, Tab name is taken from TSQLRecord.Caption(nil) method
    // - but you can override this value by setting a pointer to a resourcestring
    CustomCaption: PResStringRec;
    /// the hint type of the Tab, to be translated on the screen
    // - by default, hint will replace all %s instance by the Tab name, as taken
    // from TSQLRecord.Caption(nil) method
    // - but you can override this value by setting a pointer to a resourcestring
    CustomHint: PResStringRec;
    /// SQL fields to be displayed on the data lists
    // 'ID,' is always added at the beginning
    Select: RawUTF8;
     /// Tab Group number (index starting at 0)
    Group: integer;
    /// displayed field length mean, one char per field (A=1,Z=26)
    // - put lowercase character in order to center the field data
    FieldWidth: RawUTF8;
    /// if set, the ID column is shown
    ShowID: boolean;
    /// index of field used for displaying order
    OrderFieldIndex: integer;
    /// if set, the list is displayed in reverse order (i.e. decreasing)
    ReverseOrder: boolean;
    /// layout of the List, below the ribbon
    Layout: TSQLListLayout;
    /// width of the List, in percent of the client area
    // - default value (as stated in TSQLRibbonTab.Create) is 30%  
    ListWidth: integer;
    /// by default, the detail are displayed as a report (TGDIPages component)
    // - set this property to true to customize the details display
    // - this property is ignored if Layout is llClient (i.e. details hidden)
    NoReport: boolean;
    /// by default, the screens are not refreshed automaticaly
    // - but you can enable the auto-refresh feature by setting this
    // property to TRUE, and creating a WM_TIMER message handler for the form,
    // which will handle both WM_TIMER_REFRESH_SCREEN and WM_TIMER_REFRESH_REPORT
    // timers:
    // !procedure TMainForm.WMRefreshTimer(var Msg: TWMTimer);
    // !begin
    // !  Ribbon.WMRefreshTimer(Msg);
    // !end;
    AutoRefresh: boolean;
    /// the associated hints to be displayed during the edition of this table
    // - every field hint must be separated by a '|' character
    // (e.g. 'The First Name|Its Company Name')
    // - all fields need to be listed in this text resource, even if it won't
    // be displayed on screen (enter a void item like ||)
    // - you can define some value by setting a pointer to a resourcestring
    EditFieldHints: PResStringRec;
    /// write hints above field during the edition of this table
    // - if EditExpandFieldHints is TRUE, the hints are written as text on the
    // dialog, just above the field content; by default, hints are displayed as
    // standard delayed popup when the mouse hover the field editor
    EditExpandFieldHints: boolean;
    /// the associated field name width (in pixels) to be used for creating
    // the edition dialog for this table
    EditFieldNameWidth: integer;
    /// a CSV list of field names to be hidden in both editor and default report
    // - handy to hide fields containing JSON data or the name of another
    // sftRecord/sftID (i.e. TRecordReference/TSQLRecord published propet) fields
    // - list is to be separated by commas (e.g. "RunLogJSON,OrdersJSON" or
    // "ConnectionName")
    EditFieldNameToHideCSV: RawUTF8;
    /// if the default report must contain the edit field hints
    // - i.e. if the resourcestring pointed by EditFieldHints must be used
    // to display some text above every property value on the reports
    EditFieldHintsToReport: boolean;
  end;

  /// parent of all virtual classes
  // - you can define a plain TSQLRecord class as virtual if needed  - e.g.
  // inheriting from TSQLRecordMany then calling VirtualTableExternalRegister() -
  // but using this class will seal its state to be virtual
  TSQLRecordVirtual = class(TSQLRecord);

  TSQLVirtualTable = class;
  TSQLVirtualTableClass = class of TSQLVirtualTable;

  /// pre-computed SQL statements for ORM operations for a given
  // TSQLModelRecordProperties instance
  TSQLModelRecordPropertiesSQL = record
    {/ the simple field names in a SQL SELECT compatible format: 'COL1,COL2' e.g.
     - format is
     ! SQL.TableSimpleFields[withID: boolean; withTableName: boolean]
     - returns '*' if no field is of TSQLRawBlob/TSQLRecordMany kind
     - returns 'COL1,COL2' with all COL* set to simple field names if withID is false
     - returns 'ID,COL1,COL2' with all COL* set to simple field names if withID is true
     - returns 'Table.ID,Table.COL1,Table.COL2' if withTableName and withID are true }
    TableSimpleFields: array[boolean,boolean] of RawUTF8;
    /// the SQL statement for reading all simple fields and RowID
    // - to be checked if we may safely call EngineList()
    SelectAllWithRowID: RawUTF8;
    /// the SQL statement for reading all simple fields with ID
    // - to be checked if we may safely call EngineList()
    SelectAllWithID: RawUTF8;
    /// the JOINed SQL statement for reading all fields with ID, including
    // nested TSQLRecord pre-allocated instances
    // - is '' if there is no nested TSQLRecord
    SelectAllJoined: RawUTF8;
    /// the updated simple fields exposed as 'COL1=?,COL2=?'
    // - excluding ID (but including TCreateTime fields - as used in
    // TSQLVirtualTableExternal.Update method)
    // - to be used e.g. for UPDATE statements
    UpdateSetSimple: RawUTF8;
    /// all updated fields exposed as 'COL1=?,COL2=?'
    // - excluding ID (but including TCreateTime fields - as used in
    // TSQLVirtualTableExternal.Update method)
    // - to be used e.g. for UPDATE statements
    UpdateSetAll: RawUTF8;
    /// all fields, excluding the ID field, exposed as 'COL1,COL2'
    // - to be used e.g. in TSQLVirtualTableExternal.Insert()
    InsertSet: RawUTF8;
  end;

  /// pointer to external database properties for ORM
  // - is used e.g. to allow a "fluent" interface for MapField() method
  PSQLModelRecordPropertiesExternal = ^TSQLModelRecordPropertiesExternal;

  /// external database properties for ORM operations for a given
  // TSQLModelRecordProperties instance
  TSQLModelRecordPropertiesExternal = {$ifdef UNICODE}
    record private {$else}
    object protected {$endif}
    /// storage of main read-only properties
    fProps: TSQLModelRecordProperties;
    fConnectionProperties: TObject;
    fTableName: RawUTF8;
    fRowIDFieldName: RawUTF8;
    fFieldNames: TRawUTF8DynArray;
    fSQL: TSQLModelRecordPropertiesSQL;
    fFieldNamesMatchInternal: TSQLFieldBits;
    /// fill fRowIDFieldName/fSQL with the current information
    procedure ComputeSQL;
  public
    /// add a custom field mapping
    // - will re-compute all needed SQL statements as needed, and initialize
    // fSortedFieldsName[] and fSortedFieldsIndex[] internal sorted arrays
    // - can be used e.g. as
    // ! aModel.Props[TSQLMyExternal].ExternalDB.MapField('IntField','ExtField');
    // - since it returns a PSQLModelRecordPropertiesExternal instance, you can
    // chain MapField().MapField().MapField(); calls to map several fields
    function MapField(const InternalName, ExternalName: RawUTF8): PSQLModelRecordPropertiesExternal;
    /// add several custom field mappings
    // - will re-compute all needed SQL statements as needed, and initialize
    // fSortedFieldsName[] and fSortedFieldsIndex[] internal sorted arrays
    // - is slightly faster than several chained MapField() calls, since SQL
    // will be computed only once
    procedure MapFields(const InternalExternalPairs: array of RawUTF8);
  public
    /// fill external DB properties for a given TSQLRecord / TSQLModel pair
    // - will compute all needed SQL from the corresponding information
    // - will left void fSortedFieldsName[] and fSortedFieldsIndex[], to disable
    // custom field mapping
    procedure Init(Props: TSQLModelRecordProperties; const ExternalTableName: RawUTF8;
      ExternalDataBase: TObject);
    /// map a field name from its internal name to its external name
    // - raise an EORMException if the supplied field name is not defined in
    // the TSQLRecord as ID or a published property
    function InternalToExternal(const FieldName: RawUTF8): RawUTF8;
    /// map a CSV list of field names from its internals to its externals values
    // - raise an EORMException if any of the supplied field name is not defined
    // in the TSQLRecord as ID or as property (RowIDFieldName or FieldNames[])
    // - to be used for a simple CSV (e.g. for INSERT/SELECT statements):
    // ! ExtCSV := InternalCSVToExternalCSV('ID,Name');
    // - or for a more complex CSV (e.g. for UPDATE statements);
    // ! ExtCSV := InternalCSVToExternalCSV('ID=?,Name=?','=?,'=?');
    function InternalCSVToExternalCSV(const CSVFieldNames: RawUTF8;
      const Sep: RawUTF8=','; const SepEnd: RawUTF8=''): RawUTF8;
    /// create a list of external field names, from the internal field names
    // - raise an EORMException if any of the supplied field name is not defined
    // in the TSQLRecord as ID or a published property
    procedure InternalToExternalDynArray(const IntFieldNames: array of RawUTF8;
      out result: TRawUTF8DynArray);
    /// map an external field name into its internal field name
    // - return '' if the external field name is not RowIDFieldName nor in
    // FieldNames[]
    function ExternalToInternalOrNull(const ExtFieldName: RawUTF8): RawUTF8;
    /// map an external field name into its internal field index
    // - returns the index >=0 in FieldNames[] for a matching external field
    // - returns -1 if the field name is RowIDFieldName
    // - returns -2 if the field name is not mapped
    function ExternalToInternalIndex(const ExtFieldName: RawUTF8): integer;
    /// append a field name to a RawUTF8 Text buffer
    // - if FieldIndex=VIRTUAL_TABLE_ROWID_COLUMN (-1), appends RowIDFieldName
    // - on error (i.e. if FieldIndex is out of range) will return TRUE
    // - otherwise, will return FALSE and append the external field name to Text
    function AppendFieldName(FieldIndex: Integer; var Text: RawUTF8): boolean;
    /// return the field name as RawUTF8 value
    // - if FieldIndex=VIRTUAL_TABLE_ROWID_COLUMN (-1), appends RowIDFieldName
    // - otherwise, will return the external field name 
    function FieldNameByIndex(FieldIndex: Integer): RawUTF8;

    /// opaque structure used on the Server side to specify e.g. the DB connection
    // - will define such a generic TObject, to avoid any unecessary dependency
    // to the SynDB unit in mORMot.pas
    // - in practice, will be assigned by VirtualTableExternalRegister() to
    // a TSQLDBConnectionProperties instance in mORMotDB.pas
    // - or by StaticMongoDBRegister() to a TMongoCollection instance
    property ConnectionProperties: TObject read fConnectionProperties;
    /// the associated TSQLModelRecordProperties
    property Properties: TSQLModelRecordProperties read fProps;
    /// used on the Server side to specify the external DB table name
    // - e.g. for including a schema name or an existing table name, with an
    // OleDB/MSSQL/Oracle/MySQL/PostgreSQL/Jet/SQLite3 backend
    // - equals SQLTableName by default (may be overridden e.g. by mORMotDB's
    // VirtualTableExternalRegister procedure)
    property TableName: RawUTF8 read fTableName;
    /// pre-computed SQL statements for this external TSQLRecord in this model
    // - you can use those SQL statements directly with the external engine
    property SQL: TSQLModelRecordPropertiesSQL read fSQL;
    /// the ID/RowID customized external field name, if any
    // - is 'ID' by default, since 'RowID' is a reserved column name for some
    // database engines (e.g. Oracle)
    // - can be customized e.g. via
    // ! aModel.Props[TSQLMyExternal].ExternalDB.MapField('ID','ExternalID');
    property RowIDFieldName: RawUTF8 read fRowIDFieldName;
    /// the external field names, following fProps.Props.Field[] order
    // - excluding ID/RowID field, which is stored in RowIDFieldName
    property FieldNames: TRawUTF8DynArray read fFieldNames;
    /// each bit set, following fProps.Props.Field[]+1 order (i.e. 0=ID,
    // 1=Field[0], ...), indicates that this external field name
    // has not been mapped
    property FieldNamesMatchInternal: TSQLFieldBits read fFieldNamesMatchInternal;
  end;

  /// dynamic array of TSQLModelRecordProperties
  // - used by TSQLModel to store the non-shared information of all its tables
  TSQLModelRecordPropertiesDynArray = array of TSQLModelRecordProperties;

  /// ORM properties associated to a TSQLRecord within a given model
  // - "stable" / common properties derivated from RTTI are shared in the
  // TSQLRecordProperties instance
  // - since the same TSQLRecord can be defined in several models, with diverse
  // implementation patterns (e.g. internal in one, external in another),
  // this class is used to regroup all model-specific settings, like SQL
  // pre-generated patterns or external DB properties
  TSQLModelRecordProperties = class
  protected
    fProps: TSQLRecordProperties;
    fKind: TSQLRecordVirtualKind;
    fModel: TSQLModel;
    fTableIndex: integer;
    procedure SetKind(Value: TSQLRecordVirtualKind);
  public
    /// pre-computed SQL statements for this TSQLRecord in this model
    // - those statements will work for internal tables, not for external
    // tables with mapped table or fields names
    SQL: TSQLModelRecordPropertiesSQL;
    /// allow SQL process for one external TSQLRecord in this model
    ExternalDB: TSQLModelRecordPropertiesExternal;

    /// initialize the ORM properties from the TSQLRecord RTTI and the supplied
    // TSQLModel
    constructor Create(aModel: TSQLModel; aTable: TSQLRecordClass; aKind: TSQLRecordVirtualKind);
    /// clone ORM properties from an existing TSQLModelRecordProperties to
    // another model
    constructor CreateFrom(aModel: TSQLModel; aSource: TSQLModelRecordProperties);

    /// compute the SQL statement to be executed for a specific SELECT
    // - non simple fields (e.g. BLOBs) will be excluded if SelectFields='*'
    // - by default, will return the SELECT statement to be used for internal
    // virtual SQLite3 table - but if ExternalTable is TRUE, then it will
    // compute a SELECT matching ExternalDB settings
    function SQLFromSelectWhere(const SelectFields, Where: RawUTF8): RawUTF8;

    /// the shared TSQLRecordProperties information of this TSQLRecord
    // - as retrieved from RTTI
    property Props: TSQLRecordProperties read fProps;
    /// the table index of this TSQLRecord in the associated Model
    property TableIndex: Integer read fTableIndex;
    /// define if is a normal table (rSQLite3), an FTS3/FTS4/R-Tree virtual
    // table or a custom TSQLVirtualTable*ID (rCustomForcedID/rCustomAutoID)
    // - when set, all internal SQL statements will be (re)created, depending of
    // the expected ID/RowID column name expected (i.e. SQLTableSimpleFields[]
    // and SQLSelectAll[] - SQLUpdateSet and SQLInsertSet do not include ID)
    property Kind: TSQLRecordVirtualKind read fKind write SetKind;
  end;

  /// a Database Model (in a MVC-driven way), for storing some tables types
  // as TSQLRecord classes
  // - share this Model between TSQLRest Client and Server
  // - use this class to access the table properties: do not rely on the
  // low-level database methods (e.g. TSQLDataBase.GetTableNames), since the
  // tables may not exist in the main SQLite3 database, but in-memory or external
  // - don't modify the order of Tables inside this Model, if you publish
  // some TRecordReference property in any of your tables
  TSQLModel = class(TObject)
  private
    fTables: TSQLRecordClassDynArray;
    fRoot: RawUTF8;
    fRootUpper: RawUTF8;
    fTablesMax: integer;
    fActions: PEnumType;
    fEvents: PEnumType;
    fTableProps: TSQLModelRecordPropertiesDynArray;
    fCustomCollationForAllRawUTF8: RawUTF8;
    /// contains the caller of CreateOwnedStream()
    fRestOwner: TSQLRest;
    /// for every table, contains a locked record list
    // - very fast, thanks to the use of a dynamic array with one entry by table
    fLocks: TSQLLocksDynArray;
    /// for fastest SQL Table name lookup via binary search
    fSortedTablesName: TRawUTF8DynArray;
    fSortedTablesNameIndex: TIntegerDynArray;
    /// will contain the registered virtual table modules
    fVirtualTableModule: array of TSQLVirtualTableClass;
    /// this array contain all TRecordReference and TSQLRecord properties
    // existing in the database model
    // - used in TSQLRestServer.Delete() to enforce relational database coherency
    // after deletion of a record: all other records pointing to it will be
    // reset to 0 by TSQLRestServer.AfterDeleteForceCoherency
    fRecordReferences: array of record
      TableIndex: integer;
      FieldType: TSQLPropInfoRTTIInstance;
    end;
    procedure SetTableProps(aIndex: integer);
    function GetTableProps(aClass: TSQLRecordClass): TSQLModelRecordProperties;
    /// get the enumerate type information about the possible actions to be
    function GetLocks(aTable: TSQLRecordClass): PSQLLocks;
    function GetTable(const SQLTableName: RawUTF8): TSQLRecordClass;
    function GetTableExactIndex(const TableName: RawUTF8): integer;
    function GetTableExactClass(const TableName: RawUTF8): TSQLRecordClass;
    function getURI(aTable: TSQLRecordClass): RawUTF8;
    function getURIID(aTable: TSQLRecordClass; aID: integer): RawUTF8;
    function getURICallBack(const aMethodName: RawUTF8; aTable: TSQLRecordClass; aID: integer): RawUTF8;
  public
    /// initialize the Database Model
    // - set the Tables to be associated with this Model, as TSQLRecord classes
    // - set the optional Root URI path of this Model
    // - initialize the fIsUnique[] array from "stored AS_UNIQUE" (i.e. "stored
    // false") published properties of every TSQLRecordClass
    constructor Create(const Tables: array of TSQLRecordClass; const aRoot: RawUTF8='root'); reintroduce; overload;
    /// clone an existing Database Model
    // - all supplied classes won't be redefined as non-virtual:
    // VirtualTableExternalRegister explicit calls are not mandatory here
    constructor Create(CloneFrom: TSQLModel); overload;
    /// initialize the Database Model from an User Interface parameter structure
    // - this constructor will reset all supplied classes to be defined as
    // non-virtual (i.e. Kind=rSQLite3): VirtualTableExternalRegister explicit
    // calls are to be made if tables should be managed as external
    constructor Create(Owner: TSQLRest; TabParameters: PSQLRibbonTabParameters;
      TabParametersCount, TabParametersSize: integer;
      const NonVisibleTables: array of TSQLRecordClass;
      Actions: PTypeInfo=nil; Events: PTypeInfo=nil;
      const aRoot: RawUTF8='root'); overload;
    /// release associated memory
    destructor Destroy; override;
    /// add the class if it doesn't exist yet
    // - return index in Tables[] if not existing yet and successfully added (in this case,
    // aTableIndexCreated^ is set to the newly created index in Tables[])
    // - supplied class will be redefined as non-virtual: VirtualTableExternalRegister
    // explicit call is to be made if table should be managed as external
    function AddTable(aTable: TSQLRecordClass; aTableIndexCreated: PInteger=nil): boolean;
    /// get the index of aTable in Tables[]
    // - returns -1 if the table is not in the model
    function GetTableIndex(aTable: TSQLRecordClass): integer; overload;
    /// get the index of any class inherithing from aTable in Tables[]
    // - returns -1 if no table is matching in the model
    function GetTableIndexInheritsFrom(aTable: TSQLRecordClass): integer;
    /// get the index of aTable in Tables[]
    // - raise an EModelException if the table is not in the model
    function GetTableIndexExisting(aTable: TSQLRecordClass): integer;
    /// get the index of a table in Tables[]
    // - expects SQLTableName to be SQL-like formated (i.e. without TSQL[Record])
    function GetTableIndex(const SQLTableName: RawUTF8): integer; overload;
    /// get the index of a table in Tables[]
    // - expects SQLTableName to be SQL-like formated (i.e. without TSQL[Record])
    function GetTableIndex(SQLTableName: PUTF8Char): integer; overload;
    /// return the UTF-8 encoded SQL source to create the table
    function GetSQLCreate(aTableIndex: integer): RawUTF8;
    /// return the UTF-8 encoded SQL source to add the corresponding field
    // via a "ALTER TABLE" statement
    function GetSQLAddField(aTableIndex, aFieldIndex: integer): RawUTF8;
    {/ return the TRecordReference pointing to the specified record }
    function RecordReference(Table: TSQLRecordClass; ID: integer): TRecordReference;
    /// return TRUE if the specified field of this class was marked as unique
    // - an unique field is defined as "stored AS_UNIQUE" (i.e. "stored false")
    // in its property definition
    // - reflects the internal private fIsUnique propery
    function GetIsUnique(aTable: TSQLRecordClass; aFieldIndex: integer): boolean;
    /// try to retrieve a table index from a SQL statement
    // - naive search of '... FROM TableName' pattern in the supplied SQL
    // - if EnsureUniqueTableInFrom is TRUE, it will check that only one Table
    // is in the FROM clause, otherwise it will return the first Table specified
    function GetTableIndexFromSQLSelect(const SQL: RawUTF8; EnsureUniqueTableInFrom: boolean): integer;
    /// returns TRUE if the supplied URI matches the model's Root property
    // - allows sub-domains, e.g. if Root='root/sub1', then '/root/sub1/toto' and
    // '/root/sub1?n=1' will match, whereas '/root/sub1nope/toto' won't 
    function URIMatch(const URI: RawUTF8): boolean;

    /// compute the SQL statement to be executed for a specific SELECT on Tables
    // - you can set multiple Table class in Tables: the statement will contain the
    // table name ('SELECT T1.F1,T1.F2,T1.F3,T2.F1,T2.F2 FROM T1,T2 WHERE ..' e.g.)
    function SQLFromSelectWhere(const Tables: array of TSQLRecordClass;
      const SQLSelect, SQLWhere: RawUTF8): RawUTF8;
    /// set a custom SQlite3 text column collation for all RawUTF8 fields of
    // all TSQLRecord of this model
    // - can be used e.g. to override ALL default COLLATE SYSTEMNOCASE of RawUTF8,
    // and let the generated SQLite3 file be available outside
    // - collations defined within our SynSQLite3 unit are named BINARY, NOCASE,
    // RTRIM and our custom SYSTEMNOCASE, ISO8601, WIN32CASE, WIN32NOCASE: if
    // you want to use the slow but Unicode ready Windows API, set for each model:
    // ! SetCustomCollationForAllRawUTF8('WIN32CASE');
    // - shall be set on both Client and Server sides, otherwise some issues
    // may occur
    procedure SetCustomCollationForAllRawUTF8(const aCollationName: RawUTF8);
    
    /// assign an enumeration type to the possible actions to be performed
    // with this model
    // - call with the TypeInfo() pointer result of an enumeration type
    // - actions are handled by TSQLRecordForList in the mORMotToolBar.pas unit
    procedure SetActions(aActions: PTypeInfo);
    /// assign an enumeration type to the possible events to be triggered
    // with this class model
    // - call with the TypeInfo() pointer result of an enumeration type
    procedure SetEvents(aEvents: PTypeInfo);
    /// get the text conversion of a given Action, ready to be displayed
    function ActionName(const Action): string;
    /// get the text conversion of a given Event, ready to be displayed
    function EventName(const Event): string;

    /// register a Virtual Table module for a specified class
    // - to be called server-side only (Client don't need to know the virtual
    // table implementation details, and it will increase the code size)
    // - aClass parameter could be either a TSQLRecordVirtual class, either
    // a TSQLRecord class which has its kind set to rCustomForcedID or
    // rCustomAutoID (e.g. TSQLRecordMany calling VirtualTableExternalRegister)
    // - optional aExternalTableName and aExternalDataBase can be used to
    // specify e.g. connection parameters as expected by mORMotDB
    // - call it before TSQLRestServer.Create()
    function VirtualTableRegister(aClass: TSQLRecordClass;
      aModule: TSQLVirtualTableClass; const aExternalTableName: RawUTF8='';
      aExternalDataBase: TObject=nil): boolean;
    /// retrieve a Virtual Table module associated to a class
    function VirtualTableModule(aClass: TSQLRecordClass): TSQLVirtualTableClass;

    /// create a New TSQLRecord instance for a specific Table
    // - expects SQLTableName to be SQL-like formated (i.e. without TSQL[Record])
    // - use this to create a working copy of a table's record, e.g.
    // - don't forget to Free it when not used any more (use a try...finally
    // block)
    // - it's prefered in practice to directly call TSQLRecord*.Create()
    // in your code
    function NewRecord(const SQLTableName: RawUTF8): TSQLRecord;

    /// lock a record
    // - returns true on success, false if was already locked
    function Lock(aTable: TSQLRecordClass; aID: integer): boolean; overload;
    /// lock a record
    // - returns true on success, false if was already locked
    function Lock(aTableIndex, aID: integer): boolean; overload;
    /// lock a record
    // - returns true on success, false if was already locked
    function Lock(aRec: TSQLRecord): boolean; overload;
    /// unlock a specified record
    // - returns true on success, false if was not already locked
    function UnLock(aTable: TSQLRecordClass; aID: integer): boolean; overload;
    /// unlock a specified record
    // - returns true on success, false if was not already locked
    function UnLock(aTableIndex: integer; aID: integer): boolean; overload;
    /// unlock a specified record
    // - returns true on success, false if was not already locked
    function UnLock(aRec: TSQLRecord): boolean; overload;
    /// unlock all previously locked records
    procedure UnLockAll;
    /// return true if a specified record is locked
    function isLocked(aTable: TSQLRecordClass; aID: integer): boolean; overload;
    /// return true if a specified record is locked
    function isLocked(aRec: TSQLRecord): boolean; overload;
    /// delete all the locked IDs entries, after a specified time
    // - to be used to release locked records if the client crashed
    // - default value is 30 minutes, which seems correct for common usage
    procedure PurgeOlderThan(MinutesFromNow: cardinal=30);

    /// the Root URI path of this Database Model
    property Root: RawUTF8 read fRoot;
    /// get the classes list (TSQLRecord descendent) of all available tables
    property Tables: TSQLRecordClassDynArray read fTables;
    /// get a class from a table name
    // - expects SQLTableName to be SQL-like formated (i.e. without TSQL[Record])
    property Table[const SQLTableName: RawUTF8]: TSQLRecordClass read GetTable; default;
    /// get a class from a table TableName (don't truncate TSQLRecord* if necessary)
    property TableExact[const TableName: RawUTF8]: TSQLRecordClass read GetTableExactClass;
    /// get the URI for a class in this Model, as 'ModelRoot/SQLTableName'
    property URI[aClass: TSQLRecordClass]: RawUTF8 read getURI;
    /// the associated ORM information for a given TSQLRecord class
    // - raise an EModelException if aClass is not declared within this model
    // - returns the corresponding TableProps[] item if the class is known
    property Props[aClass: TSQLRecordClass]: TSQLModelRecordProperties read GetTableProps;
    /// the associated ORM information about all handled TSQLRecord class properties
    // - this TableProps[] array will map the Tables[] array, and will allow
    // fast direct access to the Tables[].RecordProps values
    property TableProps: TSQLModelRecordPropertiesDynArray read fTableProps;
    // performed with this model
    // - Actions are e.g. linked to some buttons in the User Interface
    property Actions: PEnumType read fActions;
    /// get the enumerate type information about the possible Events to be
    // performed with this model
    // - Events can be linked to actions and custom status, to provide a
    // centralized handling of logging (e.g. in an Audit Trail table)
    property Events: PEnumType read fEvents;
    /// this property value is used to auto free the database Model class
    // - set this property after Owner.Create() in order to have
    // Owner.Destroy autofreeing it
    property Owner: TSQLRest read fRestOwner write fRestOwner;
    /// for every table, contains a locked record list
    // - very fast, thanks to the use one TSQLLocks entry by table
    property Locks: TSQLLocksDynArray read fLocks;
  end;

  PRecordRef = ^RecordRef;
  
  /// useful object to type cast TRecordReference type value into explicit
  // TSQLRecordClass and ID
  // - use RecordRef(Reference).TableIndex/Table/ID/Text methods to retrieve
  // the details of a TRecordReference encoded value
  // - use TSQLRest.Retrieve(Reference) to get a record content from DB
  // - but since Value is a copied member, do not use RecordRef(Reference).From()
  // but rather TSQLRecord.RecordReference(Model) or TSQLModel.RecordReference()
  // methods or RecordReference() function to encode the value
  // - don't change associated TSQLModel tables order, since TRecordReference
  // depends on it to store the Table type
  // - since 6 bits are used for the table index, the corresponding table
  // MUST appear in the first 64 items of the associated TSQLModel.Tables[]
  RecordRef = {$ifndef ISDELPHI2010}object{$else}record{$endif}
  public
    /// the value itself
    // - (value and 63) is the TableIndex in the current database Model
    // - (value shr 6) is the ID of the record in this table
    // - value=0 means no reference stored
    // - we use this coding and not the opposite (Table in MSB) to minimize
    // integer values; but special UTF8CompareRecord() function has to be used
    // for sorting
    // - type definition matches TRecordReference (i.e. PtrUInt) to allow
    // typecast as such:
    // ! aClass := RecordRef(Reference).Table(Model);
    Value: PtrUInt;
    /// return the index of the content Table in the TSQLModel
    function TableIndex: integer;
    /// return the class of the content in a specified TSQLModel
    function Table(Model: TSQLModel): TSQLRecordClass;
    /// return the ID of the content
    function ID: integer;
    /// fill Value with the corresponding parameters
    // - since 6 bits are used for the table index, aTable MUST appear in the
    // first 64 items of the associated TSQLModel.Tables[] array
    procedure From(Model: TSQLModel; aTable: TSQLRecordClass; aID: integer);
    /// get a ready to be displayed text from the stored Table and ID
    // - display 'Record 2301' e.g.
    function Text(Model: TSQLModel): RawUTF8; overload;
    /// get a ready to be displayed text from the stored Table and ID
    // - display 'Record "RecordName"' e.g.
    function Text(Rest: TSQLRest): RawUTF8; overload;
  end;

  /// this kind of record array can be used for direct coordinates storage
  TSQLRecordTreeCoords = array[0..RTREE_MAX_DIMENSION-1] of packed record
    min, max: double; end;

  {/ a base record, corresponding to an R-Tree table
    - an R-Tree is a special index that is designed for doing range queries.
      R-Trees are most commonly used in geospatial systems where each entry is a
      rectangle with minimum and maximum X and Y coordinates. Given a query
      rectangle, an R-Tree is able to quickly find all entries that are contained
      within the query rectangle or which overlap the query rectangle. This idea
      is easily extended to three dimensions for use in CAD systems. R-Trees also
      find use in time-domain range look-ups. For example, suppose a database
      records the starting and ending times for a large number of events. A R-Tree
      is able to quickly find all events, for example, that were active at any
      time during a given time interval, or all events that started during a
      particular time interval, or all events that both started and ended within
      a given time interval. And so forth. See http://www.sqlite.org/rtree.html
    - any record which inherits from this class must have only sftFloat
      (double) fields, grouped by pairs, each as minimum- and maximum-value,
      up to 5 dimensions (i.e. 11 columns, including the ID property)
    - the ID: integer property must be set before adding a TSQLRecordRTree to
      the database, e.g. to link a R-Tree representation to a regular
      TSQLRecord table
    - queries against the ID or the coordinate ranges are almost immediate: so
      you can e.g. extract some coordinates box from the regular TSQLRecord
      table, then use a TSQLRecordRTree joined query to make the process faster;
      this is exactly what the TSQLRestClient.RTreeMatch method offers }
  TSQLRecordRTree = class(TSQLRecordVirtual)
  public
    { override this class function to implement a custom box coordinates
      from a given BLOB content
      - by default, the BLOB array will contain a simple array of double
      - but you can override this method to handle a custom BLOB field content,
        intended to hold some kind of binary representation of the precise
        boundaries of the object, and convert it into box coordinates as
        understood by the ContainedIn() class function
      - the number of pairs in OutCoord will be taken from the current number
        of published double properties
      - used e.g. by the TSQLRestClient.RTreeMatch method }
    class procedure BlobToCoord(const InBlob; var OutCoord: TSQLRecordTreeCoords); virtual;
    { override this class function to implement a custom SQL *_in() function
      - by default, the BLOB array will be decoded via the BlobToCoord class
        procedure, and will create a SQL function from the class name 
      - for instance, the following class will define a 2 dimensional
        MapBox_in() function
      ! TSQLRecordMapBox = class(TSQLRecordRTree)
      ! protected
      !   fMinX, fMaxX, fMinY, fMaxY: double;
      ! published
      !   property MinX: double read fMinX write fMinX;
      !   property MaxX: double read fMaxX write fMaxX;
      !   property MinY: double read fMinY write fMinY;
      !   property MaxY: double read fMaxY write fMaxY;
      ! end;
      - used e.g. by the TSQLRestClient.RTreeMatch method   }
    class function ContainedIn(const BlobA,BlobB): boolean; virtual;
    /// will return 'MapBox_in' e.g. for TSQLRecordMapBox
    class function RTreeSQLFunctionName: RawUTF8;
  end;

  {/ a base record, corresponding to a FTS3 table, i.e. implementing full-text
    - FTS3/FTS4 table are SQLite virtual tables which allow users to perform
      full-text searches on a set of documents. The most common (and effective)
      way to describe full-text searches is "what Google, Yahoo and Altavista do
      with documents placed on the World Wide Web". Users input a term, or
      series of terms, perhaps connected by a binary operator or grouped together
      into a phrase, and the full-text query system finds the set of documents
      that best matches those terms considering the operators and groupings the
      user has specified. See http://sqlite.org/fts3.html
    - any record which inherits from this class must have only sftUTF8Text
      (RawUTF8) fields - with Delphi 2009+, you can have string fields
    - this record has its fID: integer property which may be published
      as DocID, to be consistent with SQLite3 praxis, and reflect that it
      points to an ID of another associated TSQLRecord
    - a good approach is to store your data in a regular TSQLRecord table, then
      store your text content in a separated FTS3 table, associated to this
      TSQLRecordFTS3 table via its ID/DocID
    - the ID/DocID property can be set when the record is added, to retrieve any
      associated TSQLRecord (note that for a TSQLRecord record,
      the ID property can't be set at adding, but is calculated by the engine)
    - static tables don't handle TSQLRecordFTS3 classes
    - by default, the FTS3 engine ignore all characters >= #80, but handle
      low-level case insentivity (i.e. 'A'..'Z') so you must keep your
      request with the same range for upper case
    - by default, the "simple" tokenizer is used, but you can inherits from
      TSQLRecordFTS3Porter class if you want a better English matching, using
      the Porter Stemming algorithm - see http://sqlite.org/fts3.html#tokenizer
    - you can select either the FTS3 engine, or the more efficient (and new)
      FTS4 engine (available since version 3.7.4), by using the TSQLRecordFTS4 type
    - in order to make FTS3/FTS4 queries, use the dedicated TSQLRest.FTSMatch
      method, with the MATCH operator (you can use regular queries, but you must
      specify 'RowID' instead of 'DocID' or 'ID' because of FTS3 Virtual
      table specificity):
       ! var IDs: TIntegerDynArray;
       ! if FTSMatch(TSQLMyFTS3Table,'text MATCH "linu*"',IDs) then
       !  // you've all matching IDs in IDs[]  }
  TSQLRecordFTS3 = class(TSQLRecordVirtual)
  public
     {/ optimize the FTS3 virtual table
     - this causes FTS3 to merge all existing index b-trees into a single large
       b-tree containing the entire index. This can be an expensive operation,
       but may speed up future queries. See http://sqlite.org/fts3.html#section_1_2
     - this method must be called server-side
     - returns TRUE on success }
     class function OptimizeFTS3Index(Server: TSQLRestServer): boolean;
     /// this DocID property map the internal Row_ID property
     // - but you can set a value to this property before calling the Add()
     // method, to associate this TSQLRecordFTS3 to another TSQLRecord
     // - ID property is read-only, but this DocID property can be written/set
     // - internaly, we use RowID in the SQL statements, which is compatible
     // with both TSQLRecord and TSQLRecordFTS3 kind of table
     property DocID: integer read GetID write fID;
  end;

  /// this base class will create a FTS3 table using the Porter Stemming algorithm
  // - see http://sqlite.org/fts3.html#tokenizer
  TSQLRecordFTS3Porter = class(TSQLRecordFTS3);

  TSQLRecordFTS3Class = class of TSQLRecordFTS3;

  TSQLRecordRTreeClass = class of TSQLRecordRTree;

  {/ a base record, corresdonding to a FTS4 table, which is an enhancement to FTS3
  - FTS3 and FTS4 are nearly identical. They share most of their code in common,
   and their interfaces are the same. The only difference is that FTS4 stores
   some additional information about the document collection in two of new FTS
   shadow tables. This additional information allows FTS4 to use certain
   query performance optimizations that FTS3 cannot use. And the added information
   permits some additional useful output options in the matchinfo() function.
  - For newer applications, TSQLRecordFTS4 is recommended; though if minimal disk
   usage or compatibility with older versions of SQLite are important, then
   TSQLRecordFTS3 will usually serve just as well.
  - see http://sqlite.org/fts3.html#section_1_1 }
  TSQLRecordFTS4 = class(TSQLRecordFTS3);
  /// this base class will create a FTS4 table using the Porter Stemming algorithm
  // - see http://sqlite.org/fts3.html#tokenizer
  TSQLRecordFTS4Porter = class(TSQLRecordFTS4);

  /// the kind of fields to be available in a Table resulting of
  // a TSQLRecordMany.DestGetJoinedTable() method call
  // - Source fields are not available, because they will be always the same for
  // a same SourceID, and they should be available from the TSQLRecord which
  // hold the TSQLRecordMany instance
  // - jkDestID and jkPivotID will retrieve only DestTable.ID and PivotTable.ID
  // - jkDestFields will retrieve DestTable.* simple fields, or the fields
  // specified by aCustomFieldsCSV (the Dest table name will be added: e.g.
  // for aCustomFieldsCSV='One,Two', will retrieve DestTable.One, DestTable.Two)
  // - jkPivotFields will retrieve PivotTable.* simple fields, or the fields
  // specified by aCustomFieldsCSV (the Pivot table name will be added: e.g.
  // for aCustomFieldsCSV='One,Two', will retrieve PivotTable.One, PivotTable.Two)
  // - jkPivotAndDestAllFields for PivotTable.* and DestTable.* simple fields,
  // or will retrieve the specified aCustomFieldsCSV fields (with
  // the table name associated: e.g. 'PivotTable.One, DestTable.Two')
  TSQLRecordManyJoinKind = (
    jkDestID, jkPivotID, jkDestFields, jkPivotFields, jkPivotAndDestFields);

  {/ handle "has many" and "has many through" relationships
   - many-to-many relationship is tracked using a table specifically for that
     relationship, turning the relationship into two one-to-many relationships
     pointing in opposite directions
   - by default, only two TSQLRecord (i.e. INTEGER) fields must be created,
     named "Source" and "Dest", the first pointing to the source record (the one
     with a TSQLRecordMany published property) and the second to the destination record
   - you should first create a type inheriting from TSQLRecordMany, which
     will define the pivot table, providing optional "through" parameters if needed
     ! TSQLDest = class(TSQLRecord);
     ! TSQLSource = class;
     ! TSQLDestPivot = class(TSQLRecordMany)
     ! private
     !  fSource: TSQLSource;
     !  fDest: TSQLDest;
     !  fTime: TDateTime;
     ! published
     !   property Source: TSQLSource read fSource; // map Source column
     !   property Dest: TSQLDest read fDest; // map Dest column
     !   property AssociationTime: TDateTime read fTime write fTime;
     ! end;
     ! TSQLSource = class(TSQLRecord)
     ! private
     !   fDestList: TSQLDestPivot;
     ! published
     !   DestList: TSQLDestPivot read fDestList;
     ! end;
   - in all cases, at leat two 'Source' and 'Dest' published properties must
     be declared as TSQLRecord children in any TSQLRecordMany descendant
     because they will always be needed for the 'many to many' relationship
   - when a TSQLRecordMany published property exists in a TSQLRecord, it is
     initialized automaticaly by TSQLRecord.Create
   - to add some associations to the pivot table, use the ManyAdd() method
   - to retrieve an association, use the ManySelect() method
   - to delete an association, use the ManyDelete() method
   - to read all Dest records IDs, use the DestGet() method
   - to read the Dest records and the associated "through" fields content, use
     FillMany then FillRow, FillOne and FillRewind methods to loop through records
   - to read all Source records and the associaed "through" fields content,
     FillManyFromDest then FillRow, FillOne and FillRewind methods
   - to read all Dest IDs after a join to the pivot table, use DestGetJoined }
  TSQLRecordMany = class(TSQLRecord)
  protected
    // internal fields initialized during TSQLRecord.Create
    // - map to the Source and Dest properties field values in TSQLRecord values
    fSourceID: PPtrInt;
    fDestID: PPtrInt;
    /// retrieve the TSQLRecordMany ID from a given source+dest IDs pair
    function InternalIDFromSourceDest(aClient: TSQLRest; aSourceID, aDestID: integer): integer;
    function InternalFillMany(aClient: TSQLRest; aID: integer;
      const aAndWhereSQL: RawUTF8; isDest: boolean): integer;
  public
    /// initialize this instance, and needed internal fields
    // - will set protected fSourceID/fDestID fields
    constructor Create; override;
    /// retrieve all records associated to a particular source record, which
    // has a TSQLRecordMany property
    // - returns the Count of records corresponding to this aSource record
    // - the records are stored in an internal TSQLTable, refered in the private
    // fTable field, and initialized via a FillPrepare call: all Dest items
    // are therefore accessible with standard FillRow, FillOne and FillRewind methods
    // - use a "for .." loop or a "while FillOne do ..." loop to iterate
    // through all Dest items, getting also any additional 'through' columns
    // - if source ID parameter is 0, the ID is taken from the fSourceID field
    // (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please specify aSourceID parameter with
    // the one just added/created
    // - the optional aAndWhereSQL parameter can be used to add any additional
    // condition to the WHERE statement (e.g. 'Salary>:(1000): AND Salary<:(2000):')
    // according to TSQLRecordMany properties - note that you should better use
    // inlined parameters for faster processing on server, so you may call e.g.
    // ! aRec.FillMany(Client,0,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
    function FillMany(aClient: TSQLRest; aSourceID: integer=0;
      const aAndWhereSQL: RawUTF8=''): integer;
    /// retrieve all records associated to a particular Dest record, which
    // has a TSQLRecordMany property
    // - returns the Count of records corresponding to this aSource record
    // - use a "for .." loop or a "while FillOne do ..." loop to iterate
    // through all Dest items, getting also any additional 'through' columns
    // - the optional aAndWhereSQL parameter can be used to add any additional
    // condition to the WHERE statement (e.g. 'Salary>:(1000): AND Salary<:(2000):')
    // according to TSQLRecordMany properties - note that you should better use
    // inlined parameters for faster processing on server, so you may call e.g.
    // ! aRec.FillManyFromDest(Client,DestID,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
    function FillManyFromDest(aClient: TSQLRest; aDestID: integer;
      const aAndWhereSQL: RawUTF8=''): integer;
    /// retrieve all Dest items IDs associated to the specified Source
    function DestGet(aClient: TSQLRest; aSourceID: integer; out DestIDs: TIntegerDynArray): boolean; overload;
    /// retrieve all Dest items IDs associated to the current Source ID
    // - source ID is taken from the fSourceID field (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please call the other overloaded method
    function DestGet(aClient: TSQLRest; out DestIDs: TIntegerDynArray): boolean; overload;
    /// retrieve all Source items IDs associated to the specified Dest ID
    function SourceGet(aClient: TSQLRest; aDestID: integer; out SourceIDs: TIntegerDynArray): boolean;
    /// retrieve all Dest items IDs associated to the current or
    // specified Source ID, adding a WHERE condition against the Dest rows
    // - if aSourceID is 0, the value is taken from current fSourceID field
    // (set by TSQLRecord.Create)
    // - aDestWhereSQL can specify the Dest table name in the statement, e.g.
    //  'Salary>:(1000): AND Salary<:(2000):' - note that you should better use
    // inlined parameters for faster processing on server, so you may use the
    // more convenient function
    // ! FormatUTF8('Salary>? AND Salary<?',[],[1000,2000])
    // - this is faster than a manual FillMany() then loading each Dest,
    // because the condition is executed in the SQL statement by the server
    function DestGetJoined(aClient: TSQLRest; const aDestWhereSQL: RawUTF8;
      aSourceID: Integer; out DestIDs: TIntegerDynArray): boolean; overload;
    /// create a Dest record, then FillPrepare() it to retrieve all Dest items
    // associated to the current or specified Source ID, adding a WHERE condition
    // against the Dest rows
    // - if aSourceID is 0, the value is taken from current fSourceID field
    // (set by TSQLRecord.Create)
    // - aDestWhereSQL can specify the Dest table name in the statement, e.g.
    // 'Salary>:(1000): AND Salary<:(2000):') according to TSQLRecordMany
    // properties - note that you should better use such inlined parameters as
    // ! FormatUTF8('Salary>? AND Salary<?',[],[1000,2000])
    function DestGetJoined(aClient: TSQLRest; const aDestWhereSQL: RawUTF8;
      aSourceID: Integer): TSQLRecord; overload;
    /// create a TSQLTable, containing all specified Fields, after a JOIN
    // associated to the current or specified Source ID
    // - the Table will have the fields specified by the JoinKind parameter
    // - aCustomFieldsCSV can be used to specify which fields must be retrieved
    // (for jkDestFields, jkPivotFields, jkPivotAndDestFields) - default is all
    // - if aSourceID is 0, the value is taken from current fSourceID field
    // (set by TSQLRecord.Create)
    // - aDestWhereSQL can specify the Dest table name in the statement, e.g.
    // 'Salary>:(1000): AND Salary<:(2000):') according to TSQLRecordMany
    // properties - note that you should better use such inlined parameters as
    // ! FormatUTF8('Salary>? AND Salary<?',[],[1000,2000])
    function DestGetJoinedTable(aClient: TSQLRest; const aDestWhereSQL: RawUTF8;
      aSourceID: Integer; JoinKind: TSQLRecordManyJoinKind;
      const aCustomFieldsCSV: RawUTF8=''): TSQLTable;
    /// add a Dest record to the Source record list
    // - returns TRUE on success, FALSE on error
    // - if NoDuplicates is TRUE, the existence of this Source/Dest ID pair
    // is first checked
    // - current Source and Dest properties are filled with the corresponding
    // TRecordReference values corresponding to the supplied IDs
    // - any current value of the additional fields are used to populate the
    // newly created content (i.e. all published properties of this record)
    function ManyAdd(aClient: TSQLRest; aSourceID, aDestID: Integer;
      NoDuplicates: boolean=false): boolean; overload;
    /// add a Dest record to the current Source record list
    // - source ID is taken from the fSourceID field (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please call the other overloaded method
    function ManyAdd(aClient: TSQLRest; aDestID: Integer;
      NoDuplicates: boolean=false): boolean; overload;
    /// will delete the record associated with a particular Source/Dest pair
    // - will return TRUE if the pair was found and successfully deleted
    // - if aUseBatchMode is TRUE, it will use aClient.BatchDelete() instead
    // of the slower aClient.Delete() method - but you shall call it within
    // a BatchStart / BatchSend block
    function ManyDelete(aClient: TSQLRest; aSourceID, aDestID: Integer;
      aUseBatchMode: boolean=false): boolean; overload;
    /// will delete the record associated with the current source and a specified Dest
    // - source ID is taken from the fSourceID field (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please call the other overloaded method
    // - if aUseBatchMode is TRUE, it will use aClient.BatchDelete() instead
    // of the slower aClient.Delete() method - but you shall call it within
    // a BatchStart / BatchSend block
    function ManyDelete(aClient: TSQLRest; aDestID: Integer;
      aUseBatchMode: boolean=false): boolean; overload;
    /// will retrieve the record associated with a particular Source/Dest pair
    // - will return TRUE if the pair was found
    // - in this case, all "through" columns are available in the TSQLRecordMany
    // field instance
    function ManySelect(aClient: TSQLRest; aSourceID, aDestID: Integer): boolean; overload;
    /// will retrieve the record associated with the current source and a specified Dest
    // - source ID is taken from the fSourceID field (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please call the other overloaded method
    function ManySelect(aClient: TSQLRest; aDestID: Integer): boolean; overload;

    // get the SQL WHERE statement to be used to retrieve the associated
    // records according to a specified ID
    // - search for aID as Source ID if isDest is FALSE
    // - search for aID as Dest ID if isDest is TRUE
    // - the optional aAndWhereSQL parameter can be used to add any additional
    // condition to the WHERE statement (e.g. 'Salary>:(1000): AND Salary<:(2000):')
    // according to TSQLRecordMany properties - note that you should better use
    // such inlined parameters e.g. calling
    // ! FormatUTF8('Salary>? AND Salary<?',[],[1000,2000])
    function IDWhereSQL(aClient: TSQLRest; aID: integer; isDest: boolean;
      const aAndWhereSQL: RawUTF8=''): RawUTF8;
  end;

  /// a base record, with a JSON-logging capability
  // - used to store a log of events into a JSON text, easy to be displayed
  // with a TSQLTableToGrid
  // - this log can then be stored as a RawUTF8 field property into a result
  // record, e.g.
  TSQLRecordLog = class(TSQLRecord)
  protected
    /// store the Log Table JSON content
    fLogTableStorage: TMemoryStream;
    /// used by Log() to add the value of OneLog to fLogTableStorage
    fLogTableWriter: TJSONSerializer;
    /// current internal row count
    fLogTableRowCount: integer;
    /// maximum rows count
    fMaxLogTableRowCount: integer;
  public
    /// initialize the internal storage with a supplied JSON content
    // - this JSON content must follow the format retrieved by
    // LogTableJSON and LogTableJSONFrom methods
    constructor CreateFrom(OneLog: TSQLRecord; const aJSON: RawUTF8);
    /// release the private fLogTableWriter and fLogTableStorage objects
    destructor Destroy; override;
    /// add the value of OneLog to the Log Table JSON content
    // - the ID property of the supplied OneLog record is incremented before adding
    procedure Log(OneLog: TSQLRecord);
    /// returns the JSON data as added by previous call to Log()
    // - JSON data is in not-expanded format
    // - this function can be called multiple times
    function LogTableJSON: RawUTF8;
    /// returns the internal position of the Log content
    // - use this value to later retrieve a log range with LogTableJSONFrom()
    function LogCurrentPosition: integer;
    /// returns the log JSON data from a given start position
    // - StartPosition was retrieved previously with LogCurrentPosition
    // - if StartPosition=0, the whole Log content is returned
    // - multiple instances of LogCurrentPosition/LogTableJSONFrom() can be
    // used at once
    function LogTableJSONFrom(StartPosition: integer): RawUTF8;
    /// the current associated Log Table rows count value
    // - is incremented every time Log() method is called
    // - will be never higher than MaxLogTableRowCount below (if set)
    property LogTableRowCount: integer read fLogTableRowCount;
    /// if the associated Log Table rows count reachs this value, the
    // first data row will be trimed
    // - do nothing is value is left to 0 (which is the default)
    // - total rows count won't never be higher than this value
    // - used to spare memory usage
    property MaxLogTableRowCount: integer read fMaxLogTableRowCount;
  end;

  /// common ancestor for tables with digitally signed RawUTF8 content
  // - content is signed according to a specific User Name and the digital
  // signature date and time
  // - internaly uses the very secure SHA-256 hashing algorithm for performing
  // the digital signature
  TSQLRecordSigned = class(TSQLRecord)
  protected
    /// time and date of signature
    fSignatureTime: TTimeLog;
    /// hashed signature
    fSignature: RawUTF8;
  public
    /// time and date of signature
    // - if the signature is invalid, this field will contain numerical 1 value
    // - this property is defined here to allow inherited to just declared the name
    // in its published section:
    // ! property SignatureTime;
    property SignatureTime: TTimeLog read fSignatureTime write fSignatureTime;
    /// as the Content of this record is added to the database,
    // its value is hashed and stored as 'UserName/03A35C92....' into this property
    // - very secured SHA-256 hashing is used internaly
    // - digital signature is allowed only once: this property is written only once
    // - this property is defined here to allow inherited to just declared the name
    // in its published section:
    // ! property SignatureTime;
    property Signature: RawUTF8 read fSignature write fSignature;
  public
    /// use this procedure to sign the supplied Content of this record for a
    // specified UserName, with the current Date and Time  (SHA-256 hashing is used
    // internaly)
    // - returns true if signed successfully (not already signed)
    function SetAndSignContent(const UserName: RawUTF8;
      const Content: RawByteString; ForcedSignatureTime: Int64=0): boolean;
    /// returns true if this record content is correct according to the
    // stored digital Signature
    function CheckSignature(const Content: RawByteString): boolean;
    /// retrieve the UserName who digitally signed this record
    // - returns '' if was not digitally signed
    function SignedBy: RawUTF8;
    /// reset the stored digital signature
    // - SetAndSignContent() can be called after this method
    procedure UnSign;
  end;

  /// common ancestor for tables which should implement any interface
  // - by default, TSQLRecord does not implement any interface: this does make
  // sense for performance and resource use reasons
  // - inherit from this class if you want your class to implement the needed
  // IInterface methods (QueryInterface/AddRef/Release)
  TSQLRecordInterfaced = class(TSQLRecord, IInterface)
  protected
    fRefCount: Integer;
    function QueryInterface(const IID: TGUID; out Obj): HResult; stdcall;
    function _AddRef: Integer; stdcall;
    function _Release: Integer; stdcall;
  public
    class function NewInstance: TObject; override;
    procedure AfterConstruction; override;
    procedure BeforeDestruction; override;
    property RefCount: Integer read fRefCount;
  end;

  /// the possible Server-side instance implementation patterns for
  // interface-based services 
  // - each interface-based service will be implemented by a corresponding
  // class instance on the server: this parameter is used to define how
  // class instances are created and managed
  // - on the Client-side, each instance will be handled depending on the
  // server side implementation (i.e. with sicClientDriven behavior if necessary)
  // - sicSingle: one object instance is created per call - this is the
  // most expensive way of implementing the service, but is safe for simple
  // workflows (like a one-type call); this is the default setting for
  // TSQLRestServer.ServiceRegister method
  // - sicShared: one object instance is used for all incoming calls and is
  // not recycled subsequent to the calls - the implementation should be
  // thread-safe on the server side
  // - sicClientDriven: one object instance will be created in synchronization
  // with the client-side lifetime of the corresponding interface: when the
  // interface will be released on client, it will be released on the server
  // side - a numerical identifier will be transmitted for all JSON requests
  // - sicPerSession, sicPerUser and sicPerGroup modes will maintain one
  // object instance per running session / user / group (only working if
  // RESTful authentication is enabled) - since it may be shared among users or
  // groups, the sicPerUser and sicPerGroup implementation should be thread-safe
  // - sicPerThread will maintain one object instance per calling thread - it
  // may be useful instead of sicShared mode if the service process expects
  // some per-heavy thread initialization, for instance
  TServiceInstanceImplementation = (
    sicSingle, sicShared, sicClientDriven, sicPerSession, sicPerUser, sicPerGroup,
    sicPerThread);

  /// handled kind of parameters for an interface-based service provider method
  // - we do not handle all kind of Delphi variables, but provide some
  // enhanced types handled by JSONToObject/ObjectToJSON functions (smvObject)
  // or TDynArray.LoadFromJSON / TTextWriter.AddDynArrayJSON methods (smvDynArray)
  // - records will be serialized as Base64 string, with our RecordSave/RecordLoad
  // low-level format by default, or as true JSON objects, after registration
  // via a TTextWriter.RegisterCustomJSONSerializer call
  // - smvRawJSON will transmit the raw JSON content, without serialization
  TServiceMethodValueType = (
    smvNone,
    smvSelf,
    smvBoolean,
    smvEnum,
    smvSet,
    smvInteger,
    smvCardinal,
    smvInt64,
    smvDouble,
    smvDateTime,
    smvCurrency,
    smvRawUTF8,
    smvString,
    smvWideString,
    smvRecord,
    {$ifndef NOVARIANTS}
    smvVariant,
    {$endif}
    smvObject,
    smvRawJSON,
    smvDynArray);

  /// handled kind of parameters internal variables for an interface-based method
  // - reference-counted variables will have their own storage
  // - all non referenced-counted variables are stored within some 64 bit content
  // - smvVariant kind of parameter will be handled as a special smvvRecord
  TServiceMethodValueVar = (
    smvvNone, smvvSelf, smvv64, smvvRawUTF8, smvvString, smvvWideString,
    smvvRecord, smvvObject, smvvDynArray);

  /// set of parameters for an interface-based service provider method
  TServiceMethodValueTypes = set of TServiceMethodValueType;

  /// handled kind of parameters direction for an interface-based service method
  // - IN, IN/OUT, OUT directions can be applied to arguments, and will
  // be available through our JSON-serialized remote access: smdVar and smdOut
  // kind of parameters will be returned within the "result": JSON array
  // - smdResult is used for a function method, to handle the returned value
  TServiceMethodValueDirection = (
    smdConst,
    smdVar,
    smdOut,
    smdResult);

  /// describe a service provider method argument
  TServiceMethodArgument = {$ifndef ISDELPHI2010}object{$else}record{$endif}
  public
    /// the argument name, as declared in Delphi
    ParamName: PShortString;
    /// the type name, as declared in Delphi
    TypeName: PShortString;
    /// the low-level RTTI information of this argument
    TypeInfo: PTypeInfo;
    /// we do not handle all kind of Delphi variables
    ValueType: TServiceMethodValueType;
    /// how the variable may be stored
    ValueVar: TServiceMethodValueVar;
    /// the variable direction as defined at code level
    ValueDirection: TServiceMethodValueDirection;
    /// how the variable is to be passed at asm level
    // - vIsString is included for smvRawUTF8, smvString and smvWideString
    // kind of parameter (smvRecord has it to false, even if they are Base-64
    // encoded within the JSON content, and also smvVariant/smvRawJSON)
    // - vPassedByReference is included if the parameter is passed as reference
    // (i.e. defined as var/out, or is a record or a reference-counted type result)
    ValueKindAsm: set of (vIsString, vPassedByReference);
    /// byte offset in the CPU stack of this argument
    // - may be -1 if pure register parameter with no backup on stack (x86) 
    InStackOffset: integer;
    /// used to specify if the argument is passed as register
    // - contains 0 if parameter is not a register
    // - contains 1 for EAX, 2 for EDX and 3 for ECX registers (for x86)
    // - contains 1 for RCX/XMM0L, 2 for RDX/XMM1L, 3 for R8/XMM2L, and
    // 4 for R9/XMM3L, with a backing store on the stack (for x64)
    RegisterIdent: integer;
    /// size (in bytes) of this argument on the stack
    SizeInStack: integer;
    /// size (in bytes) of this smvv64 ordinal value
    // - e.g. depending of the associated kind of enumeration
    SizeInStorage: integer;
    /// index of the associated variable in the local array[ArgsUsedCount[]]
    // - for smdConst argument, contains -1 (no need to a local var: the value
    // will be on the stack only)
    IndexVar: integer;
    /// serialize the argument into the TServiceContainer.Contract JSON format
    // - non standard types (e.g. clas, enumerate, dynamic array or record)
    // are identified by their type identifier - so contract does not extend
    // up to the content of such high-level structures
    procedure SerializeToContract(WR: TTextWriter);
    /// append the JSON value corresponding to this argument
    // - includes a pending ','
    procedure AddJSON(WR: TTextWriter; V: pointer);
    /// append the JSON value corresponding to this argument, from its text value
    // - includes a pending ','
    procedure AddValueJSON(WR: TTextWriter; const Value: RawUTF8);
    /// append the default JSON value corresponding to this argument
    // - includes a pending ','
    procedure AddDefaultJSON(WR: TTextWriter);
  end;

  /// describe a service provider method arguments
  TServiceMethodArgumentDynArray = array of TServiceMethodArgument;

  /// possible service provider method options, e.g. about logging or execution
  // - see TServiceMethodOptions for a description of each available option
  TServiceMethodOption = (
    optExecLockedPerInterface,
    optExecInPerInterfaceThread, optFreeInPerInterfaceThread
    {$ifndef LVCL},
    optExecInMainThread, optFreeInMainThread,
    optVariantCopiedByReference
    {$endif}
  );

  /// set of per-method execution options for an interface-based service provider
  // - by default, mehthod executions are concurrent, for better server
  // responsiveness; if you set optExecLockedPerInterface, all methods of
  // a given interface will be executed with a critical section
  // - optExecInMainThread will force the method to be called within
  // a RunningThread.Synchronize() call - it can be used e.g. if your
  // implementation rely heavily on COM servers - by default, service methods
  // are called within the thread which received them, on multi-thread server
  // instances (e.g. TSQLite3HttpServer or TSQLRestServerNamedPipeResponse),
  // for better response time and CPU use (this is the technical reason why
  // service implementation methods have to handle multi-threading safety
  // carefully, e.g. by using TRTLCriticalSection mutex on purpose)
  // - optFreeInMainThread will force the _Release/Destroy method to be run
  // in the main thread: setting this option for any method will affect the
  // whole service class - is not set by default, for performance reasons
  // - optExecInPerInterfaceThread and optFreeInPerInterfaceThread will allow
  // creation of a per-interface dedicated thread
  TServiceMethodOptions = set of TServiceMethodOption;

  /// describe an interface-based service provider method
  TServiceMethod = {$ifndef UNICODE}object{$else}record{$endif}
  public
    /// the method URI
    // - basicaly the method name as declared in Delphi code (e.g. 'Add' for
    // ICalculator.Add)
    // - this property value is hashed internaly for faster access
    URI: RawUTF8;
    /// the method default result, formatted as a JSON array
    // - example of content may be '[]' for a procedure or '[0]' for a function
    // - any var/out and potential function result will be set as a JSON array
    // of values, with 0 for numerical values, "" for textual values,
    // false for booleans, [] for dynamic arrays, a void record serialized
    // as expected (including customized serialization) and null for objects
    DefaultResult: RawUTF8;
    /// describe expected method arguments
    // - Args[0] always is smvSelf
    // - if method is a function, an additional smdResult argument is appended
    Args: TServiceMethodArgumentDynArray;
    /// the index of the result pseudo-argument in Args[]
    // - is -1 if the method is defined as a (not a function)
    ArgsResultIndex: integer;
    /// the index of the first const / var argument in Args[]
    ArgsInFirst: integer;
    /// the index of the last const / var argument in Args[]
    ArgsInLast: integer;
    /// the index of the first var / out / result argument in Args[]
    ArgsOutFirst: integer;
    /// the index of the last var / out / result argument in Args[]
    ArgsOutLast: integer;
    /// the number of const / var parameters in Args[]
    // - i.e. the number of elements in the input JSON array
    ArgsInputValuesCount: cardinal;
    /// the number of var / out parameters +  in Args[]
    // - i.e. the number of elements in the output JSON array or object
    ArgsOutputValuesCount: cardinal;
    /// true if the result is a TServiceCustomAnswer record
    // - that is, a custom Header+Content BLOB transfert, not a JSON object
    ArgsResultIsServiceCustomAnswer: boolean;
    /// needed CPU stack size (in bytes) for all arguments
    // - under x64, does not include the backup space for the four registers
    ArgsSizeInStack: cardinal;
    /// contains all used kind of arguments
    ArgsUsed: TServiceMethodValueTypes;
    /// contains the count of variables for all used kind of arguments
    ArgsUsedCount: array[TServiceMethodValueVar] of integer;
    /// method index in the original (non emulated) interface
    // - our custom methods start at index 3 (RESERVED_VTABLE_SLOTS), since
    // QueryInterface, _AddRef, and _Release are always defined by default
    // - so it maps TServiceFactory.Interface.Methods[ExecutionMethodIndex-3]
    ExecutionMethodIndex: integer;
    /// execute the corresponding method of a given TInterfacedObject instance
    // - will retrieve a JSON array of parameters from Par
    // - will append a JSON array of results in Res, or set an Error message, or
    // a JSON object (with parameter names) in Res if ResultAsJSONObject is set
    function InternalExecute(Instances: array of pointer; Par: PUTF8Char;
      Res: TTextWriter; out aHead: RawUTF8; out aStatus: cardinal;
      Options: TServiceMethodOptions; ResultAsJSONObject: boolean;
      BackgroundExecutionThread: TSynBackgroundThreadProcedure): boolean;
    /// retrieve a var / out / result argument index in Args[] from its name
    // - search is case insensitive
    // - returns -1 if not found
    function ArgResultIndex(ArgName: PUTF8Char; ArgNameLen: integer): integer;
    /// find the next var / out / result argument index in Args[]
    // - returns true if arg is the new value, false otherwise
    function ArgResultNext(var arg: integer): boolean;
  end;

  /// describe all mtehods of an interface-based service provider
  TServiceMethodDynArray = array of TServiceMethod;

  /// a pointer to an interface-based service provider method description
  // - since TInterfaceFactory instances are shared in a global list, we
  // can safely use such pointers in our code to refer to a particular method
  PServiceMethod = ^TServiceMethod;

  /// a record type to be used as result for a function method for custom content
  // for interface-based services
  // - all answers are pure JSON object by default: using this kind of record
  // as result will allow a response of any type (e.g. binary, HTML or text)
  // - this kind of answer will be understood by our TServiceContainerClient
  // implementation, and it may be used with plain AJAX or HTML requests
  // (via POST), to retrieve some custom content
  TServiceCustomAnswer = record
    /// mandatory response type, as encoded in the HTTP header
    // - useful to set the response mime-type - see e.g. the
    // TEXT_CONTENT_TYPE_HEADER or HTML_CONTENT_TYPE_HEADER constants or
    // GetMimeContentType() function
    // - in order to be handled as expected, this field SHALL be set to NOT ''
    // (otherwise TServiceCustomAnswer will transmitted with as raw JSON)
    Header: RawUTF8;
    /// the response body
    // - corresponding to the response type, as defined in Header
    Content: RawByteString;
    /// the HTML response code
    // - if not overriden, will default to HTML_SUCCESS = 200
    Status: cardinal;
  end;

  PServiceCustomAnswer = ^TServiceCustomAnswer;

  {$ifndef LVCL}
  /// any TCollection used between client and server shall inherit from this class
  // - you should override the GetClass virtual method to provide the
  // expected collection item class to be used on server side
  // - another possibility is to register a TCollection/TCollectionItem pair
  // via a call to TJSONSerializer.RegisterCollectionForJSON()
  TInterfacedCollection = class(TCollection)
  protected
    /// you shall override this abstract method
    class function GetClass: TCollectionItemClass; virtual; abstract;
  public
    /// this constructor which will call GetClass to initialize the collection
    constructor Create; reintroduce; virtual;
  end;

  /// the class of TInterfacedCollection kind
  TInterfacedCollectionClass = class of TInterfacedCollection;
  {$endif LVCL}

  /// event used by TInterfaceFactory.CreateFakeInstance() to run a method
  // - aMethod will specify which method is to be executed
  // - aParams will contain the input parameters, encoded as a JSON array
  // - shall return TRUE on success, or FALSE in case of failure, with
  // a corresponding explanation in aErrorMsg
  // - method results shall be serialized as JSON in aResult;  if
  // aServiceCustomAnswer is not nil, the result shall use this record
  // to set HTTP custom content and headers, and ignore aResult content
  // - aClientDrivenID can be set optionally to specify e.g. an URI-level session
  TOnFakeInstanceInvoke = function (const aMethod: TServiceMethod;
    const aParams: RawUTF8; aResult, aErrorMsg: PRawUTF8;
    aClientDrivenID: PCardinal; aServiceCustomAnswer: PServiceCustomAnswer): boolean of object;

  /// event called when destroying a TInterfaceFactory.CreateFakeInstance()
  /// - this method will be run when the fake class instance is destroyed
  // (e.g. if aInstanceCreation is sicClientDriven, to notify the server
  // than the client life time just finished)
  TOnFakeInstanceDestroy = procedure(aClientDrivenID: cardinal) of object;

  /// class handling interface RTTI and fake implementation class
  // - a thread-safe global list of such class instances is implemented to cache
  // information for better speed: use class function TInterfaceFactory.Get()
  // and not manual TInterfaceFactory.Create / Free
  // - if you want to specify the interfaces by name or TGUID, call once
  // Get(TypeInfo(IMyInterface)) or RegisterInterfaces()
  TInterfaceFactory = class
  protected
    fInterfaceTypeInfo: PTypeInfo;
    fInterfaceIID: TGUID;
    fMethodsCount: cardinal;
    fMethods: TServiceMethodDynArray;
    fMethod: TDynArrayHashed;
    fFakeVTable: array of pointer;
    fFakeStub: PByteArray;
    // contains e.g. [{"method":"Add","arguments":[...]},{"method":"...}]
    fContract: RawUTF8;
    {$ifndef NOVARIANTS}
    fDocVariantOptions: TDocVariantOptions;
    {$endif}
    procedure AddMethodsFromTypeInfo(aInterface: PTypeInfo);
    function GetMethodsVirtualTable: pointer;
  public
    /// this is the main entry point to the global interface factory cache
    // - access to this method is thread-safe
    // - this method will also register the class to further
    class function Get(aInterface: PTypeInfo): TInterfaceFactory; overload;
    /// retrieve an interface factory from cache, from its TGUID
    // - access to this method is thread-safe
    // - you shall have registered the interface by a previous call to the
    // overloaded Get(TypeInfo(IMyInterface)) method or RegisterInterfaces()
    // - if the supplied TGUID has not been previously registered, returns nil
    class function Get(const aGUID: TGUID): TInterfaceFactory; overload;
    /// retrieve an interface factory from cache, from its name (e.g. 'IMyInterface')
    // - access to this method is thread-safe
    // - you shall have registered the interface by a previous call to the
    // overloaded Get(TypeInfo(IMyInterface)) method or RegisterInterfaces()
    // - if the supplied TGUID has not been previously registered, returns nil
    class function Get(const aInterfaceName: RawUTF8): TInterfaceFactory; overload;
    /// register one or several interfaces to the global interface factory cache
    // - so that you can use TInterfaceFactory.Get(aGUID) or Get(
    class procedure RegisterInterfaces(const aInterfaces: array of PTypeInfo);
    /// create a fake class instance implementing the corresponding interface
    // - aInvoke event will be called at method execution
    // - optional aNotifyDestroy event will be called when the fake
    // implementation instance will be released (e.g. for server notification)
    function CreateFakeInstance(aInvoke: TOnFakeInstanceInvoke;
      aNotifyDestroy: TOnFakeInstanceDestroy=nil): TInterfacedObject;

    /// initialize the internal properties from the supplied interface RTTI
    // - it will check and retrieve all methods of the supplied interface,
    // and prepare all internal structures for later use
    // - do not call this constructor directly, but TInterfaceFactory.Get()
    constructor Create(aInterface: PTypeInfo);
    /// find the index of a particular method in internal Methods[] list
    // - won't find the default AddRef/Release/QueryInterface methods
    // - will return -1 if the method is not known
    function FindMethodIndex(const aMethodName: RawUTF8): integer;
    /// find the index of a particular method in internal Methods[] list
    // - won't find the default AddRef/Release/QueryInterface methods
    // - will raise an EInterfaceFactoryException if the method is not known
    function CheckMethodIndex(const aMethodName: RawUTF8): integer; overload;
    /// find the index of a particular method in internal Methods[] list
    // - won't find the default AddRef/Release/QueryInterface methods
    // - will raise an EInterfaceFactoryException if the method is not known
    function CheckMethodIndex(aMethodName: PUTF8Char): integer; overload;
    /// the declared internal methods
    // - list does not contain default AddRef/Release/QueryInterface methods
    // - nor the _free_/_contract_/_signature_ pseudo-methods
    property Methods: TServiceMethodDynArray read fMethods;
    /// the number of internal methods
    // - does not include the default AddRef/Release/QueryInterface methods
    // - nor the _free_/_contract_/_signature_ pseudo-methods
    property MethodsCount: cardinal read fMethodsCount;
    /// the registered Interface low-level Delphi RTTI type
    property InterfaceTypeInfo: PTypeInfo read fInterfaceTypeInfo;
    /// the registered Interface GUID
    property InterfaceIID: TGUID read fInterfaceIID;
    {$ifndef NOVARIANTS}
    /// how this interface will work with variants (including TDocVariant)
    // - by default, contains JSON_OPTIONS[true] for best performance - i.e.
    // [dvoReturnNullForUnknownProperty,dvoValueCopiedByReference]
    property DocVariantOptions: TDocVariantOptions
      read fDocVariantOptions write fDocVariantOptions;
    {$endif}
  end;

  TInterfaceStub = class;

  /// abstract parameters used by TInterfaceStub.Executes() events callbacks
  TOnInterfaceStubExecuteParamsAbstract = class
  private
    function GetSenderAsMockTestCase: TSynTestCase;
  protected
    fSender: TInterfaceStub;
    fMethod: PServiceMethod;
    fParams: RawUTF8;
    fEventParams: RawUTF8;
    fResult: RawUTF8;
    fFailed: boolean;
  public
    /// constructor of one parameters marshalling instance
    constructor Create(aSender: TInterfaceStub; aMethod: PServiceMethod;
      const aParams,aEventParams: RawUTF8); virtual;
    /// call this method if the callback implementation failed
    procedure Error(const aErrorMessage: RawUTF8); overload;
    /// call this method if the callback implementation failed
    procedure Error(Format: PUTF8Char; const Args: array of const); overload;
    /// the stubbing / mocking generator
    property Sender: TInterfaceStub read fSender;
    /// the mocking generator associated test case
    // - will raise an exception if the associated Sender generator is not
    // a TInterfaceMock
    property TestCase: TSynTestCase read GetSenderAsMockTestCase;
    /// pointer to the method which is to be executed
    property Method: PServiceMethod read fMethod;
    /// a custom message, defined at TInterfaceStub.Executes() definition
    property EventParams: RawUTF8 read fEventParams;
  end;

{$ifndef NOVARIANTS}
  /// parameters used by TInterfaceStub.Executes() events callbacks as Variant
  // - this class will expect input and output parameters to specified as
  // variant arrays properties, so is easier (and a bit slower) than the
  // TOnInterfaceStubExecuteParamsJSON class
  TOnInterfaceStubExecuteParamsVariant = class(TOnInterfaceStubExecuteParamsAbstract)
  private
    function GetInput(Index: Integer): variant;
    procedure SetOutput(Index: Integer; const Value: variant);
    function GetInNamed(const aParamName: RawUTF8): variant;
    procedure SetOutNamed(const aParamName: RawUTF8; const Value: variant);
  protected
    fInput: TVariantDynArray;
    fOutput: TVariantDynArray;
    procedure SetResult(var Result: RawUTF8);
  public
    /// constructor of one parameters marshalling instance
    constructor Create(aSender: TInterfaceStub; aMethod: PServiceMethod;
      const aParams,aEventParams: RawUTF8); override;
    /// input parameters when calling the method
    // - order shall follow the method const and var parameters
    // ! Stub.Add(10,20) -> Input[0]=10, Input[1]=20
    // - if the supplied Index is out of range, an EInterfaceStub will be raised
    property Input[Index: Integer]: variant read GetInput;
    /// output parameters returned after method process
    // - order shall follow the method var, out parameters and the function
    // result (if method is not a procedure)
    // - if the supplied Index is out of range, an EInterfaceStub will be raised
    // - can be used as such:
    // !  procedure TFooTestCase.ExecuteBar(var Ctxt: TOnInterfaceStubExecuteParamsVariant);
    // !  begin // Input[0]=i
    // !    Ctxt.Output[0] := Ctxt.Input[0]+1;  // i := i+1;
    // !    Ctxt.Output[1] := 42;               // result := 42;
    // !  end; // Output|0]=i, Output[1]=result
    // to emulate this native implementation:
    // ! function Bar(var i: Integer): Integer;
    // ! begin
    // !    inc(i);
    // !    result := 42;
    // !  end;
    property Output[Index: Integer]: variant write SetOutput;
    /// access to input/output parameters when calling the method
    // - if the supplied name is incorrect, an EInterfaceStub will be raised
    // - is a bit slower than Input[]/Output[] indexed properties, but easier
    // to work with, and safer in case of method signature change (like parameter
    // add or rename)
    // - marked as default property, so you can use it e.g. as such:
    // !  procedure TFooTestCase.ExecuteBar(var Ctxt: TOnInterfaceStubExecuteParamsVariant);
    // !  begin 
    // !    Ctxt['i'] := Ctxt['i']+1;  // i := i+1;
    // !    Ctxt['result'] := 42;      // result := 42;
    // !  end;
    // to emulate this native implementation:
    // ! function Bar(var i: Integer): Integer;
    // ! begin
    // !    inc(i);
    // !    result := 42;
    // !  end;
    // - using this default Named[] property is recommended 
    property Named[const ParamName: RawUTF8]: variant read GetInNamed write SetOutNamed; default;
  end;
{$endif}

  /// parameters used by TInterfaceStub.Executes() events callbacks as JSON
  // - this class will expect input and output parameters to be encoded as
  // JSON arrays, so is faster than TOnInterfaceStubExecuteParamsVariant
  TOnInterfaceStubExecuteParamsJSON = class(TOnInterfaceStubExecuteParamsAbstract)
  public
    /// a method to return an array of values into Result
    // - just a wrapper around JSONEncodeArrayOfConst([...])
    // - can be used as such:
    // !  procedure TFooTestCase.ExecuteBar(var Ctxt: TOnInterfaceStubExecuteParamsJSON);
    // !  begin // Ctxt.Params := '[i]' -> Ctxt.Result := '[i+1,42]'
    // !    Ctxt.Returns([GetInteger(pointer(Ctxt.Params))+1,42]);
    // !  end;
    // to emulate this native implementation:
    // ! function Bar(var i: Integer): Integer;
    // ! begin
    // !    inc(i);
    // !    result := 42;
    // !  end;
    procedure Returns(const Values: array of const);
    /// incoming parameters array encoded as JSON array without braces
    // - order follows the method const and var parameters
    // ! Stub.Add(10,20) -> Params = '10,20';
    property Params: RawUTF8 read fParams;
    /// outgoing values array encoded as JSON
    // - every var, out parameter or the function result shall be encoded as
    // a JSON array into this variable, in the same order than the stubbed
    // method declaration
    // - use Returns() method to create the JSON array directly, from an array
    // of values
    property Result: RawUTF8 write fResult;
  end;

{$ifndef NOVARIANTS}
  /// event called by the TInterfaceStub.Executes() fluent method for variant process
  // - by default Ctxt.Result shall contain the default JSON array result for
  // this method - use Ctxt.Named[] default properties, e.g. as
  // ! Ctxt['result'] := Ctxt['n1']-Ctxt['n2'];
  // or with Input[] / Output[] properties:
  // ! with Ctxt do Output[0] := Input[0]-Input[1];
  // - you can call Ctxt.Error() to notify the caller for an execution error
  TOnInterfaceStubExecuteVariant = procedure(Ctxt: TOnInterfaceStubExecuteParamsVariant) of object;
{$endif}

  /// event called by the TInterfaceStub.Executes() fluent method for JSON process
  // - by default Ctxt.Result shall contain the default JSON array result for
  // this method - use Ctxt.Named[] default properties, e.g. as
  // !  P := pointer(Ctxt.Params);
  // !  Ctxt.Returns([GetNextItemDouble(P)-GetNextItemDouble(P)]);
  // - you can call Ctxt.Error() to notify the caller for an execution error
  TOnInterfaceStubExecuteJSON = procedure(Ctxt: TOnInterfaceStubExecuteParamsJSON)of object;

  /// diverse types of stubbing / mocking rules
  // - isUndefined is the first, since it will be a ExpectsCount() weak rule
  // which may be overwritten by the other real run-time rules
  TInterfaceStubRuleKind =
    (isUndefined, isExecutesJSON, {$ifndef NOVARIANTS}isExecutesVariant, {$endif}
     isRaises, isReturns, isFails);

  /// define a mocking / stubing rule used internaly by TInterfaceStub
  TInterfaceStubRule = record
    /// optional expected parameters, serialized as a JSON array
    // - if equals '', the rule is not parametrized - i.e. it will be the
    // default for this method
    Params: RawUTF8;
    /// values associated to the rule
    // - for TInterfaceStub.Executes(), is the aEventParams parameter transmitted
    // to Execute event handler (could be used to e.g. customize the handler)
    // - for TInterfaceStub.Raises(), is the Exception.Message associated
    // to one ExceptionClass
    // - for TInterfaceStub.Returns(), is the returned result, serialized as a
    // JSON array (including var / out parameters then any function result)
    // - for TInterfaceStub.Fails() is the returned error message for
    // TInterfaceStub exception or TInterfaceMock associated test case
    Values: RawUTF8;
    /// the type of this rule
    // - isUndefined is used for a TInterfaceStub.ExpectsCount() weak rule
    Kind: TInterfaceStubRuleKind;
    /// the event handler to be executed
    // - for TInterfaceStub.Executes(), Values is transmitted as aResult parameter
    // - either a TOnInterfaceStubExecuteJSON, or a TOnInterfaceStubExecuteVariant
    Execute: TMethod;
    /// the exception class to be raised
    // - for TInterfaceStub.Raises(), Values contains Exception.Message
    ExceptionClass: ExceptClass;
    /// the number of times this rule has been executed
    RulePassCount: cardinal;
    /// comparison operator set by TInterfaceStub.ExpectsCount()
    // - only qoEqualTo..qoGreaterThanOrEqualTo are relevant here
    ExpectedPassCountOperator: TSQLQueryOperator;
    /// expected pass count value set by TInterfaceStub.ExpectsCount()
    // - value to be compared to the number of times this rule has been executed
    // - TInterfaceStub/TInterfaceMock will check it in their Destroy destructor,
    // using the comparison stated by ExpectedPassCountOperator
    ExpectedPassCount: cardinal;
    /// log trace value set by TInterfaceStub.ExpectsTrace()
    // - value to be compared to the Hash32() value of the execution log trace
    // - TInterfaceStub/TInterfaceMock will check it in their Destroy destructor,
    // using the fLogs[] content
    ExpectedTraceHash: cardinal;
  end;

  /// define the rules for a given method as used internaly by TInterfaceStub
  TInterfaceStubRules = {$ifdef UNICODE}record{$else}object{$endif}
    /// the mocking / stubing rules associated to this method
    Rules: array of TInterfaceStubRule;
    /// index in Rules[] of the default rule, i.e. the one with Params=''
    DefaultRule: integer;
    /// the number of times this method has been executed
    MethodPassCount: cardinal;
    /// find a rule index from its Params content
    function FindRuleIndex(const aParams: RawUTF8): integer;
    /// find a strong rule index from its Params content
    function FindStrongRuleIndex(const aParams: RawUTF8): integer;
    /// register a rule
    procedure AddRule(Sender: TInterfaceStub; aKind: TInterfaceStubRuleKind;
      const aParams, aValues: RawUTF8; const aEvent: TNotifyEvent=nil;
      aExceptionClass: ExceptClass=nil;
      aExpectedPassCountOperator: TSQLQueryOperator=qoNone; aValue: cardinal=0);
  end;

  /// diverse options available to TInterfaceStub
  // - by default, method execution stack is not recorded - include
  // imoLogMethodCallsAndResults in the options to track all method calls
  // and the returned values; note that ExpectsTrace() method will set it
  // - by default, TInterfaceStub will be released when the stubed/mocked
  // interface is released - include imoFakeInstanceWontReleaseTInterfaceStub
  // in the options to force manual memory handling of TInterfaceStubs
  // - by default, all interfaces will return some default values, unless
  // imoRaiseExceptionIfNoRuleDefined or imoReturnErrorIfNoRuleDefined is
  // included in the options
  // - by default, any TInterfaceMock.Fails() rule execution will notify the
  // TSynTestCase, unless imoMockFailsWillPassTestCase which will let test pass
  TInterfaceStubOption = (
    imoLogMethodCallsAndResults,
    imoFakeInstanceWontReleaseTInterfaceStub,
    imoRaiseExceptionIfNoRuleDefined,
    imoReturnErrorIfNoRuleDefined,
    imoMockFailsWillPassTestCase);

  /// set of options available to TInterfaceStub
  TInterfaceStubOptions = set of TInterfaceStubOption;

  /// every potential part of TInterfaceStubLog.AddAsText() log entry
  TInterfaceStubLogLayout = (wName, wParams, wResults);

  /// set the output layout of TInterfaceStubLog.AddAsText() log entry
  TInterfaceStubLogLayouts = set of TInterfaceStubLogLayout;

  /// used to keep track of one stubbed method call
  TInterfaceStubLog = {$ifdef UNICODE}record{$else}object{$endif}
    /// call timestamp, in milliseconds
    // - under Windows, is filled with GetTickCount64() API returned value
    TimeStamp64: Int64;
    /// set to TRUE if this calls failed
    // - i.e. if EInterfaceFactoryException was raised for TInterfaceStub, or
    // if TInterfaceMock did notify its associated TSynTestCase via a Check()
    // - CustomResults/Results will contain the error message
    WasError: boolean;
    /// the method called
    // - a pointer to the existing information in shared TInterfaceFactory
    Method: PServiceMethod;
    /// the parameters at execution call
    Params: RawUTF8;
    /// any non default result returned after execution
    // - if not set (i.e. if equals ''), Method^.DefaultResult has been returned
    // - if WasError is TRUE, always contain the error message
    CustomResults: RawUTF8;
    /// the result returned after execution
    // - this method will return Method^.DefaultResult
    function Results: RawUTF8;
    /// append the log in textual format
    // - typical output is as such:
    // $ Add(10,20)=[30],
    // or, if WasError is TRUE:
    // $ Divide(20,0) error "divide by zero",
    procedure AddAsText(WR: TTextWriter; aScope: TInterfaceStubLogLayouts);
  end;

  /// used to keep track of all stubbed methods calls
  TInterfaceStubLogDynArray = array of TInterfaceStubLog;

  /// used to stub an interface implementation
  // - define the expected workflow in a fluent interface using Executes /
  // Fails / Returns / Raises
  // - this class will be inherited by TInterfaceMock which will contain some
  // additional methods dedicated to mocking behavior (e.g. including in tests)
  // - each instance of this class will be owned by its generated fake
  // implementation class (retrieved at constructor out parameter): when the
  // stubed/mocked interface is freed, its associated TInterfaceStub will be
  // freed - so you do not need to protect TInterfaceStub.Create with a
  // try..finally clause, since it will be released when no more needed
  TInterfaceStub = class
  protected
    fInterface: TInterfaceFactory;
    fRules: array of TInterfaceStubRules;
    fOptions: TInterfaceStubOptions;
    fHasExpects: set of (eCount,eTrace);
    fLogs: TInterfaceStubLogDynArray;
    fLog: TDynArray;
    fLogCount: integer;
    fInterfaceExpectedTraceHash: cardinal;
    procedure InternalCreate(out aStubbedInterface); virtual;
    function InternalCheck(aValid: boolean; const aErrorMessage: RawUTF8;
      aExpectationFailed: boolean): boolean; virtual;
    // match TOnFakeInstanceInvoke callback signature
    function Invoke(const aMethod: TServiceMethod;
      const aParams: RawUTF8; aResult, aErrorMsg: PRawUTF8;
      aClientDrivenID: PCardinal; aServiceCustomAnswer: PServiceCustomAnswer): boolean;
    // will launch InternalCheck() process if some expectations defined by
    // ExpectsCount() are not met, i.e. raise an exception for TInterfaceStub
    // or notify the associated test case for TInterfaceMock
    procedure InstanceDestroyed(aClientDrivenID: cardinal);
    procedure IntSetOptions(Options: TInterfaceStubOptions); virtual;
    procedure IntCheckCount(aMethodIndex, aComputed: cardinal; aOperator: TSQLQueryOperator; aCount: cardinal);
    function IntGetLogAsText(asmndx: integer; const aParams: RawUTF8;
      aScope: TInterfaceStubLogLayouts): RawUTF8;
    function GetLogAsText: RawUTF8;
    function GetLogHash: cardinal;
  public
    /// initialize an interface stub from TypeInfo(IMyInterface)
    // - assign the fake class instance to the SubbedInterface variable:
    // !var I: ICalculator;
    // !  TInterfaceStub.Create(TypeInfo(ICalculator),I);
    // !  Check(I.Add(10,20)=0,'Default result');
    constructor Create(aInterface: PTypeInfo; out aStubbedInterface); reintroduce; overload;
    /// initialize an interface stub from an interface GUID
    // - you shall have registered the interface by a previous call to
    // TInterfaceFactory.Get(TypeInfo(IMyInterface)) or RegisterInterfaces()
    // - if the supplied TGUID has not been previously registered, raise an Exception
    constructor Create(const aGUID: TGUID; out aStubbedInterface); reintroduce; overload;
    /// initialize an interface stub from an interface name (e.g. 'IMyInterface')
    // - you shall have registered the interface by a previous call to
    // TInterfaceFactory.Get(TypeInfo(IMyInterface)) or RegisterInterfaces()
    // - if the supplied name has not been previously registered, raise an Exception
    constructor Create(const aInterfaceName: RawUTF8; out aStubbedInterface); reintroduce; overload;

    /// add an execution rule for a given method, with JSON marshalling
    // - optional aEventParams parameter will be transmitted to aEvent handler
    // - raise an Exception if the method name does not exist for this interface
    function Executes(const aMethodName: RawUTF8;
      aEvent: TOnInterfaceStubExecuteJSON; const aEventParams: RawUTF8=''): TInterfaceStub; overload;
    /// add an execution rule for a given method and a set of parameters,
    // with JSON marshalling
    // - if execution context matches the supplied aParams value, aEvent is triggered
    // - optional aEventParams parameter will be transmitted to aEvent handler
    // - raise an Exception if the method name does not exist for this interface
    function Executes(const aMethodName, aParams: RawUTF8;
      aEvent: TOnInterfaceStubExecuteJSON; const aEventParams: RawUTF8=''): TInterfaceStub; overload;
    /// add an execution rule for a given method and a set of parameters,
    // with JSON marshalling
    // - if execution context matches the supplied aParams value, aEvent is triggered
    // - optional aEventParams parameter will be transmitted to aEvent handler
    // - raise an Exception if the method name does not exist for this interface
    function Executes(const aMethodName: RawUTF8; const aParams: array of const;
      aEvent: TOnInterfaceStubExecuteJSON; const aEventParams: RawUTF8=''): TInterfaceStub; overload;
{$ifndef NOVARIANTS}
    /// add an execution rule for a given method, with Variant marshalling
    // - optional aEventParams parameter will be transmitted to aEvent handler
    // - raise an Exception if the method name does not exist for this interface
    function Executes(const aMethodName: RawUTF8;
      aEvent: TOnInterfaceStubExecuteVariant; const aEventParams: RawUTF8=''): TInterfaceStub; overload;
    /// add an execution rule for a given method and a set of parameters,
    // with Variant marshalling
    // - if execution context matches the supplied aParams value, aEvent is triggered
    // - optional aEventParams parameter will be transmitted to aEvent handler
    // - raise an Exception if the method name does not exist for this interface
    function Executes(const aMethodName, aParams: RawUTF8;
      aEvent: TOnInterfaceStubExecuteVariant; const aEventParams: RawUTF8=''): TInterfaceStub; overload;
    /// add an execution rule for a given method and a set of parameters,
    // with Variant marshalling
    // - if execution context matches the supplied aParams value, aEvent is triggered
    // - optional aEventParams parameter will be transmitted to aEvent handler
    // - raise an Exception if the method name does not exist for this interface
    function Executes(const aMethodName: RawUTF8; const aParams: array of const;
      aEvent: TOnInterfaceStubExecuteVariant; const aEventParams: RawUTF8=''): TInterfaceStub; overload;
{$endif}

    /// add an exception rule for a given method
    // - will create and raise the specified exception for this method
    // - raise an Exception if the method name does not exist for this interface
    function Raises(const aMethodName: RawUTF8;
      aException: ExceptClass; const aMessage: string): TInterfaceStub; overload;
    /// add an exception rule for a given method and a set of parameters
    // - will create and raise the specified exception for this method, if the
    // execution context matches the supplied aParams value
    // - raise an Exception if the method name does not exist for this interface
    function Raises(const aMethodName, aParams: RawUTF8;
      aException: ExceptClass; const aMessage: string): TInterfaceStub; overload;
    /// add an exception rule for a given method and a set of parameters
    // - will create and raise the specified exception for this method, if the
    // execution context matches the supplied aParams value
    // - raise an Exception if the method name does not exist for this interface
    function Raises(const aMethodName: RawUTF8; const aParams: array of const;
      aException: ExceptClass; const aMessage: string): TInterfaceStub; overload;

    /// add an evaluation rule for a given method
    // - aExpectedResults JSON array will be returned to the caller
    // - raise an Exception if the method name does not exist for this interface
    function Returns(const aMethodName, aExpectedResults: RawUTF8): TInterfaceStub; overload;
    /// add an evaluation rule for a given method
    // - aExpectedResults will be returned to the caller after conversion to
    // a JSON array
    // - raise an Exception if the method name does not exist for this interface
    function Returns(const aMethodName: RawUTF8; const aExpectedResults: array of const): TInterfaceStub; overload;
    /// add an evaluation rule for a given method and a set of parameters
    // - aExpectedResults JSON array will be returned to the caller
    // - raise an Exception if the method name does not exist for this interface
    function Returns(const aMethodName, aParams, aExpectedResults: RawUTF8): TInterfaceStub; overload;
    /// add an evaluation rule for a given method and a set of parameters
    // - aExpectedResults JSON array will be returned to the caller
    // - raise an Exception if the method name does not exist for this interface
    function Returns(const aMethodName: RawUTF8;
      const aParams, aExpectedResults: array of const): TInterfaceStub; overload;

    /// add an error rule for a given method
    // - an error will be returned to the caller, with aErrorMsg as message
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function Fails(const aMethodName, aErrorMsg: RawUTF8): TInterfaceStub; overload;
    /// add an error rule for a given method and a set of parameters
    // - an error will be returned to the caller, with aErrorMsg as message
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function Fails(const aMethodName, aParams, aErrorMsg: RawUTF8): TInterfaceStub; overload;
    /// add an error rule for a given method and a set of parameters
    // - an error will be returned to the caller, with aErrorMsg as message
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function Fails(const aMethodName: RawUTF8; const aParams: array of const;
      const aErrorMsg: RawUTF8): TInterfaceStub; overload;

    /// add a pass count expectation rule for a given method
    // - those rules will be evaluated at Destroy execution
    // - only qoEqualTo..qoGreaterThanOrEqualTo are relevant here
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsCount(const aMethodName: RawUTF8; aOperator: TSQLQueryOperator;
      aValue: cardinal): TInterfaceStub; overload;
    /// add a pass count expectation rule for a given method and a set of parameters
    // - those rules will be evaluated at Destroy execution
    // - only qoEqualTo..qoGreaterThanOrEqualTo are relevant here
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsCount(const aMethodName, aParams: RawUTF8; aOperator: TSQLQueryOperator;
      aValue: cardinal): TInterfaceStub; overload;
    /// add a pass count expectation rule for a given method and a set of parameters
    // - those rules will be evaluated at Destroy execution
    // - only qoEqualTo..qoGreaterThanOrEqualTo are relevant here
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsCount(const aMethodName: RawUTF8; const aParams: array of const;
      aOperator: TSQLQueryOperator; aValue: cardinal): TInterfaceStub; overload;

    /// add a hash-based execution expectation rule for the whole interface
    // - those rules will be evaluated at Destroy execution
    // - supplied aValue is a Hash32() of the trace in LogAsText format
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    function ExpectsTrace(aValue: cardinal): TInterfaceStub; overload;
    /// add a hash-based execution expectation rule for a given method
    // - those rules will be evaluated at Destroy execution
    // - supplied aValue is a Hash32() of the trace in LogAsText format
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsTrace(const aMethodName: RawUTF8; aValue: cardinal): TInterfaceStub; overload;
    /// add a hash-based execution expectation rule for a given method
    // and a set of parameters
    // - those rules will be evaluated at Destroy execution
    // - supplied aValue is a Hash32() of the trace in LogAsText format
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsTrace(const aMethodName, aParams: RawUTF8;
      aValue: cardinal): TInterfaceStub; overload;
    /// add a hash-based execution expectation rule for a given method
    // and a set of parameters
    // - those rules will be evaluated at Destroy execution
    // - supplied aValue is a Hash32() of the trace in LogAsText format
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsTrace(const aMethodName: RawUTF8; const aParams: array of const;
      aValue: cardinal): TInterfaceStub; overload;
    /// add a JSON-based execution expectation rule for the whole interface
    // - those rules will be evaluated at Destroy execution
    // - supplied aValue is the trace in LogAsText format
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    function ExpectsTrace(const aValue: RawUTF8): TInterfaceStub; overload;
    /// add a JSON-based execution expectation rule for a given method
    // - those rules will be evaluated at Destroy execution
    // - supplied aValue is the trace in LogAsText format
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsTrace(const aMethodName, aValue: RawUTF8): TInterfaceStub; overload;
    /// add a JSON-based execution expectation rule for a given method
    // and a set of parameters
    // - those rules will be evaluated at Destroy execution
    // - supplied aValue is the trace in LogAsText format
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsTrace(const aMethodName, aParams, aValue: RawUTF8): TInterfaceStub; overload;
    /// add a JSON-based execution expectation rule for a given method
    // and a set of parameters
    // - those rules will be evaluated at Destroy execution
    // - supplied aValue is the trace in LogAsText format
    // - it will raise EInterfaceFactoryException for TInterfaceStub, but
    // TInterfaceMock will push the failure to the associated test case
    // - raise an Exception if the method name does not exist for this interface
    function ExpectsTrace(const aMethodName: RawUTF8; const aParams: array of const;
      const aValue: RawUTF8): TInterfaceStub; overload;

    /// set the optional stubing/mocking options
    // - same as the Options property, but in a fluent-style interface
    function SetOptions(Options: TInterfaceStubOptions): TInterfaceStub;

    /// access to the registered Interface RTTI information
    property InterfaceFactory: TInterfaceFactory read fInterface;
    /// optional stubing/mocking options
    // - you can use the SetOptions() method in a fluent-style interface
    property Options: TInterfaceStubOptions read fOptions write IntSetOptions;
    /// the stubbed method execution trace items
    property Log: TInterfaceStubLogDynArray read fLogs;
    /// the stubbed method execution trace number of items
    property LogCount: Integer read fLogCount;
    /// the stubbed method execution trace converted as text
    // - typical output is a list of calls separated by commas:
    // $ Add(10,20)=[30],Divide(20,0) error "divide by zero"
    property LogAsText: RawUTF8 read GetLogAsText;
    /// the stubbed method execution trace converted as one numerical hash
    // - returns Hash32(LogAsText)
    property LogHash: cardinal read GetLogHash;
  end;

  /// used to mock an interface implementation via expect-run-verify pattern
  // - TInterfaceStub will raise an exception on Fails(), ExpectsCount() or
  // ExpectsTrace() rule activation, but TInterfaceMock will call
  // TSynTestCase.Check() with no exception with such rules, as expected by
  // a mocked interface
  // - this class will follow the expect-run-verify pattern, i.e. expectations
  // are defined before running the test, and verification is performed
  // when the instance is released - use TInterfaceMockSpy if you prefer the
  // more explicit run-verify pattern
  TInterfaceMock = class(TInterfaceStub)
  protected
    fTestCase: TSynTestCase;
    function InternalCheck(aValid: boolean; const aErrorMessage: RawUTF8;
      aExpectationFailed: boolean): boolean; override;
  public
    /// initialize an interface mock from TypeInfo(IMyInterface)
    // - aTestCase.Check() will be called in case of mocking failure
    constructor Create(aInterface: PTypeInfo; out aMockedInterface;
      aTestCase: TSynTestCase); reintroduce; overload;
    /// initialize an interface mock from an interface GUID
    // - aTestCase.Check() will be called in case of mocking failure
    // - you shall have registered the interface by a previous call to
    // TInterfaceFactory.Get(TypeInfo(IMyInterface)) or RegisterInterfaces()
    // - if the supplied TGUID has not been previously registered, raise an Exception
    constructor Create(const aGUID: TGUID; out aMockedInterface;
      aTestCase: TSynTestCase); reintroduce; overload;
    /// initialize an interface mock from an interface name (e.g. 'IMyInterface')
    // - aTestCase.Check() will be called in case of mocking failure
    // - you shall have registered the interface by a previous call to
    // TInterfaceFactory.Get(TypeInfo(IMyInterface)) or RegisterInterfaces()
    // - if the supplied name has not been previously registered, raise an Exception
    constructor Create(const aInterfaceName: RawUTF8; out aMockedInterface;
      aTestCase: TSynTestCase); reintroduce; overload;
    /// the associated test case
    property TestCase: TSynTestCase read fTestCase;
  end;

  /// how TInterfaceMockSpy.Verify() shall generate the calls trace
  TInterfaceMockSpyCheck = (chkName, chkNameParams, chkNameParamsResults);

  /// used to mock an interface implementation via run-verify pattern
  // - this class will implement a so called "test-spy" mocking pattern, i.e.
  // no expectation is to be declared at first, but all calls are internally
  // logged (i.e. it force imoLogMethodCallsAndResults option to be defined),
  // and can afterwards been check via Verify() calls
  TInterfaceMockSpy = class(TInterfaceMock)
  protected
    /// this will set and force imoLogMethodCallsAndResults option as needed
    procedure InternalCreate(out aStubbedInterface); override;
    procedure IntSetOptions(Options: TInterfaceStubOptions); override;
  public
    /// check that a method has been called a specify number of times
    procedure Verify(const aMethodName: RawUTF8;
      aOperator: TSQLQueryOperator=qoGreaterThan; aCount: cardinal=0); overload;
    /// check a method calls count with a set of parameters
    // - parameters shall be defined as a JSON array of values
    procedure Verify(const aMethodName, aParams: RawUTF8;
      aOperator: TSQLQueryOperator=qoGreaterThan; aCount: cardinal=0); overload;
    /// check a method calls count with a set of parameters
    // - parameters shall be defined as a JSON array of values
    procedure Verify(const aMethodName: RawUTF8; const aParams: array of const;
      aOperator: TSQLQueryOperator=qoGreaterThan; aCount: cardinal=0); overload;
    /// check an execution trace for the global interface
    // - text trace format shall follow method calls, e.g.
    // ! Verify('Multiply,Add',chkName);
    // or may include parameters:
    // ! Verify('Multiply(10,30),Add(2,35)',chkNameParams);
    // or include parameters and function results:
    // ! Verify('Multiply(10,30)=[300],Add(2,35)=[37]',chkNameParamsResults);
    procedure Verify(const aTrace: RawUTF8; aScope: TInterfaceMockSpyCheck); overload;
    /// check an execution trace for a specified method
    // - text trace format will follow specified scope, e.g. 
    // ! Verify('Add','(10,30),(2,35)',chkNameParams);
    // or include parameters and function results:
    // ! Verify('Add','(10,30)=[300],(2,35)=[37]',chkNameParamsResults);
    // - if aMethodName does not exists or aScope=chkName, will raise an exception
    procedure Verify(const aMethodName, aTrace: RawUTF8; aScope: TInterfaceMockSpyCheck); overload;
    /// check an execution trace for a specified method and parameters
    // - text trace format shall contain only results, e.g.
    // ! Verify('Add','2,35','[37]');
    procedure Verify(const aMethodName, aParams, aTrace: RawUTF8); overload;
    /// check an execution trace for a specified method and parameters
    // - text trace format shall contain only results, e.g.
    // ! Verify('Add',[2,35],'[37]');
    procedure Verify(const aMethodName: RawUTF8; const aParams: array of const;
      const aTrace: RawUTF8); overload;
  end;

  /// an abstract service provider, as registered in TServiceContainer
  // - each registered interface has its own TServiceFactory instance, available
  // as one TSQLServiceContainer item from TSQLRest.Services property
  // - this will be either implemented by a registered TInterfacedObject on the
  // server, or by a on-the-fly generated fake TInterfacedObject class
  // communicating via JSON on a client
  // - TSQLRestServer will have to register an interface implementation as:
  // ! Server.ServiceRegister(TServiceCalculator,[TypeInfo(ICalculator)],sicShared);
  // - TSQLRestClientURI will have to register an interface remote access as:
  // ! Client.ServiceRegister([TypeInfo(ICalculator)],sicShared));
  // note that the implementation (TServiceCalculator) remain on the server side
  // only: the client only needs the ICalculator interface
  // - then TSQLRestServer and TSQLRestClientURI will both have access to the
  // service, via their Services property, e.g. as:
  // ! if Services.GUID(IID_ICalculator).Get(I) then
  // !   result := I.Add(10,20);
  TServiceFactory = class
  protected
    fInterface: TInterfaceFactory;
    fInterfaceURI: RawUTF8;
    fInterfaceMangledURI: RawUTF8;
    fInstanceCreation: TServiceInstanceImplementation;
    fRest: TSQLRest;
    fSharedInstance: TInterfacedObject;
    fContract: RawUTF8;
    fContractHash: RawUTF8;
    fContractExpected: RawUTF8;
    // per-method execution rights
    fExecution: array of record
      /// the list of denied TSQLAuthGroup ID(s)
      // - used on server side within TSQLRestServerURIContext.ExecuteSOAByInterface
      // - bit 0 for client TSQLAuthGroup.ID=1 and so on...
      // - is therefore able to store IDs up to 256
      // - void by default, i.e. no denial = all groups allowed for this method
      Denied: set of 0..255;
      /// execution options for this method (about thread safety or logging)
      Options: TServiceMethodOptions;
    end;
    function GetInterfaceTypeInfo: PTypeInfo;
      {$ifdef HASINLINE}inline;{$endif}
    function GetInterfaceIID: TGUID;
      {$ifdef HASINLINE}inline;{$endif}
  public
    /// initialize the service provider parameters
    // - it will check and retrieve all methods of the supplied interface,
    // and prepare all internal structures for its serialized execution
    constructor Create(aRest: TSQLRest; aInterface: PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation;
      const aContractExpected: RawUTF8);
    /// retrieve an instance of this interface
    // - this virtual method will be overridden to reflect the expected
    // behavior of client or server side
    // - can be used as such to resolve an I: ICalculator interface
    // ! if fClient.Services.Info(TypeInfo(ICalculator)).Get(I) then
    // !   ... use I
    function Get(out Obj): Boolean; virtual; abstract;
    /// retrieve the published signature of this interface
    // - is always available on TServiceFactoryServer, but TServiceFactoryClient
    // will be able to retrieve it only if TServiceContainerServer.PublishSignature
    // is set to TRUE (which is not the default setting, for security reasons)
    function RetrieveSignature: RawUTF8; virtual; abstract;
    /// the associated RESTful instance
    property Rest: TSQLRest read fRest;
    /// access to the registered Interface RTTI information
    property InterfaceFactory: TInterfaceFactory read fInterface;
    /// the registered Interface low-level Delphi RTTI type
    // - just maps InterfaceFactory.InterfaceTypeInfo
    property InterfaceTypeInfo: PTypeInfo read GetInterfaceTypeInfo;
    /// the registered Interface GUID
    // - just maps InterfaceFactory.InterfaceIID
    property InterfaceIID: TGUID read GetInterfaceIID;
    /// the registered Interface URI
    // - in fact this is the Interface name without the initial 'I', e.g.
    // 'Calculator' for ICalculator
    property InterfaceURI: RawUTF8 read fInterfaceURI;
    /// the registered Interface mangled URI
    // - in fact this is encoding the GUID using BinToBase64URI(), e.g.
    // ! ['{c9a646d3-9c61-4cb7-bfcd-ee2522c8f633}'] into '00amyWGct0y_ze4lIsj2Mw'
    // - can be substituted to the clear InterfaceURI name
    property InterfaceMangledURI: RawUTF8 read fInterfaceMangledURI;
    /// how each class instance is to be created
    // - only relevant on the server side; on the client side, this class will
    // be accessed only to retrieve a remote access instance, i.e. sicSingle
    property InstanceCreation: TServiceInstanceImplementation read fInstanceCreation;
    (*/ the service contract, serialized as a JSON object
    - a "contract" is in fact the used interface signature, i.e. its
      implementation mode (InstanceCreation) and all its methods definitions
    - a possible value for a one-method interface defined as such:
    ! function ICalculator.Add(n1,n2: integer): integer;
    may be returned as the following JSON object:
    $ {"contract":"Calculator","implementation":"shared",
    $  "methods":[{"method":"Add",
    $  "arguments":[{"argument":"Self","direction":"in","type":"self"},
    $               {"argument":"n1","direction":"in","type":"integer"},
    $               {"argument":"n2","direction":"in","type":"integer"},
    $               {"argument":"Result","direction":"out","type":"integer"}
    $ ]}]} *)
    property Contract: RawUTF8 read fContract;
    /// a hash of the service contract, serialized as a JSON string
    // - this may be used instead of the JSON signature, to enhance security
    // (i.e. if you do not want to publish the available methods, but want
    // to check for the proper synchronization of both client and server)
    // - a possible value may be: "C351335A7406374C"
    property ContractHash: RawUTF8 read fContractHash;
    /// the published service contract, as expected by both client and server
    // - by default, will contain ContractHash property value (for security)
    // - but you can override this value using plain Contract or any custom
    // value (e.g. a custom version number) - in this case, both TServiceFactoryClient
    // and TServiceFactoryServer instances must have a matching ContractExpected
    // - this value is returned by a '_contract_' pseudo-method name, with the URI:
    // $ POST /root/Interface._contract_
    // or (if TSQLRestRoutingJSON_RPC is used):
    // $ POST /root/Interface
    // $ (...)
    // $ {"method":"_contract_","params":[]}
    // (e.g. to be checked in TServiceFactoryClient.Create constructor)
    property ContractExpected: RawUTF8 read fContractExpected write fContractExpected;
  end;

  /// server-side service provider uses this to store one internal instance
  // - used by TServiceFactoryServer in sicClientDriven, sicPerSession,
  // sicPerUser or sicPerGroup mode
  TServiceFactoryServerInstance = {$ifndef ISDELPHI2010}object{$else}record{$endif}
  public
    /// the internal Instance ID, as remotely sent in "id":1
    // - is set to 0 when an entry in the array is free
    InstanceID: Cardinal;
    /// GetTickCount64() time stamp corresponding to the last access of
    // this instance
    LastAccess64: Int64;
    /// the implementation instance itself
    Instance: TInterfacedObject;
    /// used to release the implementation instance
    // - direct FreeAndNil(Instance) may lead to A/V if self has been assigned
    // to an interface to any sub-method on the server side -> dec(RefCount)
    procedure SafeFreeInstance(Factory: TServiceFactoryServer);
  end;

  /// server-side service provider uses this to store its internal instances
  // - used by TServiceFactoryServer in sicClientDriven, sicPerSession,
  // sicPerUser or sicPerGroup mode
  TServiceFactoryServerInstanceDynArray = array of TServiceFactoryServerInstance;

  /// abstract parent class with threadsafe implementation of IInterface and
  // a virtual constructor, ready to be overridden to initialize the instance
  // - you can specify such a class to TSQLRestServer.ServiceRegister() if
  // you need an interfaced object with a virtual constructor
  TInterfacedObjectWithCustomCreate = class(TInterfacedObject)
  protected
    /// just a method used to call _Release within a Synchronize() call
    procedure InternalRelease;
  public
    /// this virtual constructor will be called at instance creation
    constructor Create; virtual;
  end;

  /// abstract parent class with a virtual constructor, ready to be overridden
  // to initialize the instance
  // - you can specify such a class if you need an interfaced object with a
  // virtual constructor
  TPersistentWithCustomCreate = class(TPersistent)
  public
    /// this virtual constructor will be called at instance creation
    constructor Create; virtual;
  end;

  TInterfacedObjectWithCustomCreateClass = class of TInterfacedObjectWithCustomCreate;
  TPersistentWithCustomCreateClass = class of TPersistentWithCustomCreate;

  /// a procedure-based background thread associated to a TSQLRestServer instance
  // - in addition to standard TSynBackgroundThreadProcedure behavior, this
  // inherited class will also notify the Server of this thread, calling
  // BeginCurrentThread and EndCurrentThread methods as required
  // - used e.g. when opt*InPerInterfaceThread is defined in
  // TServiceFactoryServer options
  TSynBackgroundThreadSQLRestServerProcedure = class(TSynBackgroundThreadProcedure)
  protected
    fServer: TSQLRestServer;
    // will call BeginCurrentThread / EndCurrentThread
    procedure Execute; override;
  public
    /// create the thread, ready to execute background process
    constructor Create(aServer: TSQLRestServer);
  end;

  /// a method-based background thread associated to a TSQLRestServer instance
  // - in addition to standard TSynBackgroundThreadMethod behavior, this
  // inherited class will also notify the Server of this thread, calling
  // BeginCurrentThread and EndCurrentThread methods as required
  // - used e.g. for TSQLRestServer.AcquireExecutionMode[] := amBackgroundThread
  TSynBackgroundThreadSQLRestServerMethod = class(TSynBackgroundThreadMethod)
  protected
    fServer: TSQLRestServer;
    // will call BeginCurrentThread / EndCurrentThread
    procedure Execute; override;
  public
    /// create the thread, ready to execute background process
    constructor Create(aServer: TSQLRestServer);
  end;

  /// a service provider implemented on the server side
  // - each registered interface has its own TServiceFactoryServer instance,
  // available as one TSQLServiceContainerServer item from TSQLRest.Services property
  // - will handle the implementation class instances of a given interface
  // - by default, all methods are allowed to execution: you can call AllowAll,
  // DenyAll, Allow or Deny in order to specify your exact security policy
  TServiceFactoryServer = class(TServiceFactory)
  protected
    fInstances: TServiceFactoryServerInstanceDynArray;
    fInstance: TDynArray;
    fInstancesCount: integer;
    fInstanceCurrentID: integer;
    fInstanceTimeOut: cardinal;
    fInstanceLock: TRTLCriticalSection;
    fImplementationClass: TInterfacedClass;
    fImplementationClassWithCustomCreate: Boolean;
    fImplementationClassInterfaceEntry: PInterfaceEntry;
    fSharedInterface: IInterface;
    fByPassAuthentication: boolean;
    fResultAsJSONObject: boolean;
    fBackgroundThread: TSynBackgroundThreadProcedure;
    /// union of all fExecution[].Options
    fAnyOptions: TServiceMethodOptions;
    procedure SetTimeoutSecInt(value: cardinal);
    function GetTimeoutSec: cardinal;
    /// get an implementation Inst.Instance for the given Inst.InstanceID
    // - is called by ExecuteMethod() in sicClientDrive mode
    // - returns true for successfull {"method":"_free_".. call (aMethodIndex=-1)
    // - otherwise, fill Inst.Instance with the matching implementation (or nil)
    function InternalInstanceRetrieve(var Inst: TServiceFactoryServerInstance;
      aMethodIndex: integer): boolean;
    /// call a given method of this service provider
    // - here Ctxt.ServiceMethodIndex should be the index in fInterface.Methods[]
    // (i.e. excluding _free_/_contract_/_signature_ pseudo-methods)
    // - Ctxt.ServiceMethodIndex=-1, then it will free/release corresponding aInstanceID
    // (is called  e.g. from {"method":"_free_", "params":[], "id":1234} )
    // - Ctxt.ServiceParameters is e.g. '[1,2]' i.e. a true JSON array, which
    // will contain the incoming parameters in the same exact order than the
    // corresponding implemented interface method
    // - Ctxt.ID is an optional number, to be used in case of sicClientDriven
    // kind of Instance creation to identify the corresponding client session
    // - returns 200/HTML_SUCCESS on success, or an HTTP error status, with an
    // optional error message in aErrorMsg
    // - on success, Ctxt.Call.OutBody shall contain a serialized JSON object
    // with one nested result property, which may be a JSON array, containing
    // all "var" or "out" parameters values, and then the method main result -
    // for instance, ExecuteMethod(..,'[1,2]') over ICalculator.Add will return:
    // $ {"result":[3],"id":0}
    // the returned "id" number is the Instance identifier to be used for any later
    // sicClientDriven remote call - or just 0 in case of sicSingle or sicShared
    procedure ExecuteMethod(Ctxt: TSQLRestServerURIContext);
    /// this method will create an implementation instance
    // - reference count will be set to one, in order to allow safe passing
    // of the instance into an interface, if AndIncreaseRefCount is TRUE
    function CreateInstance(AndIncreaseRefCount: boolean): TInterfacedObject;
  public
    /// initialize the service provider on the server side
    // - expect an direct server-side implementation class (inheriting from
    // TInterfacedClass or from TInterfacedObjectWithCustomCreate if you need
    // an overridden constructor)
    // - for sicClientDriven, sicPerSession, sicPerUser or sicPerGroup modes,
    // a time out (in seconds) can be defined - if the time out is 0, interface
    // will be forced in sicSingle mode
    // - you should usualy have to call the TSQLRestServer.ServiceRegister()
    // method instead of calling this constructor directly
    constructor Create(aRestServer: TSQLRestServer; aInterface: PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation;
      aImplementationClass: TInterfacedClass; const aContractExpected: RawUTF8='';
      aTimeOutSec: cardinal=30*60; aSharedInstance: TInterfacedObject=nil); reintroduce;
    /// release all used memory
    // - e.g. any internal TServiceFactoryServerInstance instances (any shared
    // instance, and all still living instances in sicClientDrive mode)
    destructor Destroy; override;

    /// allow all methods execution for all TSQLAuthGroup
    // - all Groups will be affected by this method (on both client and server sides)
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowAll: TServiceFactoryServer;
    /// allow all methods execution for the specified TSQLAuthGroup ID(s)
    // - the specified group ID(s) will be used to authorize remote service
    // calls from the client side
    // - you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fServer.MainFieldID(TSQLAuthGroup,'User');
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowAllByID(const aGroupID: array of integer): TServiceFactoryServer;
    /// allow all methods execution for the specified TSQLAuthGroup names
    // - is just a wrapper around the other AllowAllByID() method, retrieving the
    // Group ID from its main field
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowAllByName(const aGroup: array of RawUTF8): TServiceFactoryServer;
    /// deny all methods execution for all TSQLAuthGroup
    // - all Groups will be affected by this method (on both client and server sides)
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyAll: TServiceFactoryServer;
    /// deny all methods execution for the specified TSQLAuthGroup ID(s)
    // - the specified group ID(s) will be used to authorize remote service
    // calls from the client side
    // - you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fServer.MainFieldID(TSQLAuthGroup,'User');
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyAllByID(const aGroupID: array of integer): TServiceFactoryServer;
    /// dent all methods execution for the specified TSQLAuthGroup names
    // - is just a wrapper around the other DenyAllByID() method, retrieving the
    // Group ID from its main field
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyAllByName(const aGroup: array of RawUTF8): TServiceFactoryServer;
    /// allow specific methods execution for the all TSQLAuthGroup
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - all Groups will be affected by this method (on both client and server sides)
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function Allow(const aMethod: array of RawUTF8): TServiceFactoryServer;
    /// allow specific methods execution for the specified TSQLAuthGroup ID(s)
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - the specified group ID(s) will be used to authorize remote service
    // calls from the client side
    // - you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fServer.MainFieldID(TSQLAuthGroup,'User');
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowByID(const aMethod: array of RawUTF8; const aGroupID: array of integer): TServiceFactoryServer;
    /// allow specific methods execution for the specified TSQLAuthGroup name(s)
    // - is just a wrapper around the other AllowByID() method, retrieving the
    // Group ID from its main field
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowByName(const aMethod: array of RawUTF8; const aGroup: array of RawUTF8): TServiceFactoryServer;
    /// deny specific methods execution for the all TSQLAuthGroup
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - all Groups will be affected by this method (on both client and server sides)
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function Deny(const aMethod: array of RawUTF8): TServiceFactoryServer;
    /// deny specific methods execution for the specified TSQLAuthGroup ID(s)
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - the specified group ID(s) will be used to unauthorize remote service
    // calls from the client side
    // - you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fServer.MainFieldID(TSQLAuthGroup,'User');
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyByID(const aMethod: array of RawUTF8; const aGroupID: array of integer): TServiceFactoryServer; overload;
    /// deny specific methods execution for the specified TSQLAuthGroup name(s)
    // - is just a wrapper around the other DenyByID() method, retrieving the
    // Group ID from its main field
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyByName(const aMethod: array of RawUTF8; const aGroup: array of RawUTF8): TServiceFactoryServer;
    /// define execution options for a given set of methods
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - if no method name is given (i.e. []), option will be set for all methods 
    // - include optExecInMainThread will force the method(s) to be called within
    // a RunningThread.Synchronize() call - slower, but thread-safe
    function SetOptions(const aMethod: array of RawUTF8; aOptions: TServiceMethodOptions): TServiceFactoryServer;
    /// define the the instance life time-out, in seconds
    // - for sicClientDriven, sicPerSession, sicPerUser or sicPerGroup modes
    // - raise an exception for other kind of execution
    // - this method returns self in order to allow direct chaining of setting
    // calls for the service, in a fluent interface
    function SetTimeoutSec(value: cardinal): TServiceFactoryServer;

    /// retrieve an instance of this interface from the server side
    // - sicShared mode will retrieve the shared instance
    // - sicPerThread mode will retrieve the instance corresponding to the
    // current running thread
    // - all other kind of instance creation will behave the same as sicSingle
    // when accessed directly from this method, i.e. from server side: in fact,
    // on the server side, there is no notion of client, session, user nor group
    function Get(out Obj): Boolean; override;
    /// retrieve the published signature of this interface
    // - is always available on TServiceFactoryServer, but TServiceFactoryClient
    // will be able to retrieve it only if TServiceContainerServer.PublishSignature
    // is set to TRUE (which is not the default setting, for security reasons)
    function RetrieveSignature: RawUTF8; override;

    /// just typecast the associated TSQLRest instance to a true TSQLRestServer
    function RestServer: TSQLRestServer;
      {$ifdef HASINLINE}inline;{$endif}

    /// the instance life time-out, in seconds
    // - for sicClientDriven, sicPerSession, sicPerUser or sicPerGroup modes
    // - raise an exception for other kind of execution
    // - you can also use the SetTimeOutSec() fluent function instead
    property TimeoutSec: cardinal read GetTimeoutSec write SetTimeoutSecInt;
    /// set to TRUE disable Authentication method check for the whole interface
    // - by default (FALSE), all interface-based services will require valid
    // RESTful authentication (if enabled on the server side); setting TRUE will
    // disable authentication for all methods of this interface
    // (e.g. for returning some HTML content from a public URI, or to implement
    // a public service catalog)
    property ByPassAuthentication: boolean read fByPassAuthentication write fByPassAuthentication;
    /// set to TRUE to return the method result as JSON object
    // - by default (FALSE), method execution will return a JSON array with
    // all VAR/OUT parameters, in order 
    // - TRUE will generate a JSON object instead, with the VAR/OUT parameter
    // names as field names (and "Result" for any function result) - may be
    // useful e.g. when working with JavaScript clients
    // - Delphi clients (i.e. TServiceFactoryClient/TInterfacedObjectFake) will
    // transparently handle both formats
    // - this value can be overridden by setting ForceServiceResultAsJSONObject
    // for a given TSQLRestServerURIContext (e.g. for server-side JavaScript work)
    property ResultAsJSONObject: boolean read fResultAsJSONObject write fResultAsJSONObject;
  end;

  /// a service provider implemented on the client side
  // - each registered interface has its own TServiceFactoryClient instance,
  // available as one TSQLServiceContainerClient item from TSQLRest.Services property
  // - will emulate "fake" implementation class instance of a given interface
  // and call remotely the server to process the actual implementation
  TServiceFactoryClient = class(TServiceFactory)
  protected
    fClient: TSQLRestClientURI;
    function CreateFakeInstance: TInterfacedObject;
    function InternalInvoke(const aMethod: RawUTF8; const aParams: RawUTF8='';
      aResult: PRawUTF8=nil; aErrorMsg: PRawUTF8=nil; aClientDrivenID: PCardinal=nil;
      aServiceCustomAnswer: PServiceCustomAnswer=nil): boolean; virtual;
    // match TOnFakeInstanceInvoke callback signature
    function Invoke(const aMethod: TServiceMethod; const aParams: RawUTF8;
      aResult: PRawUTF8; aErrorMsg: PRawUTF8; aClientDrivenID: PCardinal;
      aServiceCustomAnswer: PServiceCustomAnswer): boolean;
      {$ifdef HASINLINE}inline;{$endif}
    procedure NotifyInstanceDestroyed(aClientDrivenID: cardinal); virtual;
  public
    /// initialize the service provider parameters
    // - it will check and retrieve all methods of the supplied interface,
    // and prepare all internal structures for its serialized execution
    // - also set the inherited TServiceInstanceImplementation property
    // - initialize fSharedInstance if aInstanceCreation is sicShared
    // - it will also ensure that the corresponding TServiceFactory.Contract
    // matches on both client and server sides, either by comparing the default
    // signature (based on methods and arguments), either by using the supplied
    // expected contract (which may be a custom version number)
    constructor Create(aRest: TSQLRest; aInterface: PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation;
      const aContractExpected: RawUTF8='');
    /// finalize the service provider used instance
    // - e.g. the shared fake implementation instance
    destructor Destroy; override;
    /// retrieve an instance of this interface from the server side
    function Get(out Obj): Boolean; override;
    /// retrieve the published signature of this interface
    // - TServiceFactoryClient will be able to retrieve it only if
    // TServiceContainerServer.PublishSignature is set to TRUE (which is not the
    // default setting, for security reasons) - this function is always available
    // on TServiceFactoryServer side
    function RetrieveSignature: RawUTF8; override;
  end;

  /// used to lookup one method in a global list of interface-based services
  TServiceContainerInterfaceMethod = record
    /// one 'service.method' item, as set at URI
    // - e.g.'Calculator.Add','Calculator.Multiply'...
    InterfaceDotMethodName: RawUTF8;
    /// the associated service provider
    InterfaceService: TServiceFactory;
    /// the index of the method for the given service
    // - 0..2 indicates _free_/_contract_/_signature_ pseudo-methods
    // - then points to InterfaceService.Interface.Methods[InterfaceMethodIndex-3]
    InterfaceMethodIndex: integer;
  end;

  /// pointer to one method lookup in a global list of interface-based services
  PServiceContainerInterfaceMethod = ^TServiceContainerInterfaceMethod;

  /// used to store all methods in a global list of interface-based services
  TServiceContainerInterfaceMethods = array of TServiceContainerInterfaceMethod;

  /// a global services provider class
  // - used to maintain a list of interfaces implementation
  TServiceContainer = class
  protected
    fRest: TSQLRest;
    // list of service names ['Calculator',...]
    // - Objects[] = TServiceFactory instance
    fList: TRawUTF8ListHashed;
    // list of service.method ['Calculator.Add','Calculator.Multiply',...]
    fListInterfaceMethod: TServiceContainerInterfaceMethods;
    fListInterfaceMethods: TDynArrayHashed;
    fExpectMangledURI: boolean;
    procedure SetExpectMangledURI(aValue: Boolean);
    procedure CheckInterface(const aInterfaces: array of PTypeInfo);
    function AddServiceInternal(aService: TServiceFactory): integer;
    /// retrieve a service provider from its URI
    function GetService(const aURI: RawUTF8): TServiceFactory;
  public
    /// initialize the list
    constructor Create(aRest: TSQLRest);
    /// release all registered services
    destructor Destroy; override;
    /// return the number of registered service interfaces
    function Count: integer;
    /// method called on the client side to register a service via its interface(s)
    // - will add a TServiceFactoryClient instance to the internal list
    // - is called e.g. by TSQLRestClientURI.ServiceRegister or even by
    // TSQLRestServer.ServiceRegister(aClient: TSQLRest...) for a remote access -
    // use TServiceContainerServer.AddImplementation() instead for normal
    // server side implementation
    // - will raise an exception on error
    // - will return true if some interfaces have been added
    // - will check for the availability of the interfaces on the server side,
    // with an optional custom contract to be used instead of methods signature
    // (only for the first interface)
    function AddInterface(const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation;
      aContractExpected: RawUTF8=''): boolean; overload;
    /// method called on the client side to register a service via one interface
    // - overloaded method returning the corresponding service factory client,
    // or nil on error
    function AddInterface(aInterface: PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation;
      const aContractExpected: RawUTF8=''): TServiceFactoryClient; overload;
    /// retrieve a service provider from its index in the list
    // - returns nil if out of range index
    function Index(aIndex: integer): TServiceFactory; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// retrieve a service provider from its GUID
    // - on match, it  will return the service the corresponding interface factory
    // - returns nil if the GUID does not match any registered interface
    // - can be used as such to resolve an I: ICalculator interface
    // ! if fClient.Services.GUID(IID_ICalculator).Get(I) then
    // !   ... use I
    function GUID(const aGUID: TGUID): TServiceFactory; overload;
    /// retrieve a service provider from its type information
    // - on match, it  will return the service the corresponding interface factory
    // - returns nil if the type information does not match any registered interface
    // - can be used as such to resolve an I: ICalculator interface
    // ! if fClient.Services.Info(TypeInfo(ICalculator)).Get(I) then
    // !   ... use I
    function Info(aTypeInfo: PTypeInfo): TServiceFactory; overload; virtual;
    /// retrieve a service provider from its URI
    // - it expects the supplied URI variable  to be e.g. '00amyWGct0y_ze4lIsj2Mw'
    // or 'Calculator', depending on the ExpectMangledURI property
    // - on match, it  will return the service the corresponding interface factory
    // - returns nil if the URI does not match any registered interface
    property Services[const aURI: RawUTF8]: TServiceFactory read GetService; default;
    /// the associated RESTful instance
    property Rest: TSQLRest read fRest;
    /// set if the URI is expected to be mangled from the GUID
    // - by default (FALSE), the clear service name is expected to be supplied at
    // the URI level (e.g. 'Calculator')
    // - if this property is set to TRUE, the mangled URI value will be expected
    // instead (may enhance security) - e.g. '00amyWGct0y_ze4lIsj2Mw'
    property ExpectMangledURI: boolean read fExpectMangledURI write SetExpectMangledURI;
  end;

  /// a services provider class to be used on the server side
  // - this will maintain a list of true implementation classes
  TServiceContainerServer = class(TServiceContainer)
  protected
    fPublishSignature: boolean;
    /// make some garbage collection when session is finished
    procedure OnCloseSession(aSessionID: cardinal); virtual;
  public
    /// method called on the server side to register a service via its
    // interface(s) and a specified implementation class or a shared
    // instance (for sicShared mode)
    // - will add a TServiceFactoryServer instance to the internal list
    // - will raise an exception on error
    // - will return the first of the registered TServiceFactoryServer created
    // on success (i.e. the one corresponding to the first item of the aInterfaces
    // array), or nil if registration failed (e.g. if any of the supplied interfaces
    // is not implemented by the given class)
    // - the same implementation class can be used to handle several interfaces
    // (just as Delphi allows to do natively)
    function AddImplementation(aImplementationClass: TInterfacedClass;
      const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation;
      aSharedImplementation: TInterfacedObject): TServiceFactoryServer;
    /// defines if the "method":"_signature_" or /root/Interface._signature
    // pseudo method is available to retrieve the whole interface signature,
    // encoded as a JSON object
    // - is set to FALSE by default, for security reasons: only "_contract_"
    // pseudo method is available - see TServiceContainer.ContractExpected
    property PublishSignature: boolean read fPublishSignature write fPublishSignature;
  end;

  /// a services provider class to be used on the client side
  // - this will maintain a list of fake implementation classes, which will
  // remotely call the server to make the actual process
  TServiceContainerClient = class(TServiceContainer)
  protected
  public
    /// retrieve a service provider from its type information
    // - this overridden method will register the interface, if was not yet made
    // - in this case, the interface will be registered with sicClientDriven
    // implementation method
    function Info(aTypeInfo: PTypeInfo): TServiceFactory; overload; override;
  end;

  /// for TSQLRestCache, stores a table values
  TSQLRestCacheEntryValue = packed record
    /// corresponding ID
    ID: integer;
    /// JSON encoded UTF-8 serialization of the record
    JSON: RawUTF8;
    /// GetTickCount64() value when this cached value was stored
    // - equals 0 when there is no JSON value cached
    TimeStamp64: Int64;
  end;

  /// for TSQLRestCache, stores all tables values
  TSQLRestCacheEntryValueDynArray = array of TSQLRestCacheEntryValue;

  /// for TSQLRestCache, stores a table settings and values
  TSQLRestCacheEntry = {$ifndef UNICODE}object{$else}record{$endif}
  public
    /// TRUE if this table should use caching
    // - i.e. if was not set, or worth it for this table (e.g. in-memory table)
    CacheEnable: boolean;
    /// the whole specified Table content will be cached
    CacheAll: boolean;
    /// time out value (in ms)
    // - if 0, caching will never expire
    TimeOutMS: Cardinal;
    /// the number of entries stored in Values[]
    Count: integer;
    /// all cached IDs and JSON content
    Values: TSQLRestCacheEntryValueDynArray;
    /// TDynArray wrapper around the Values[] array
    Value: TDynArray;
    /// used to lock the table cache for multi thread safety
    Mutex: TRTLCriticalSection;
    /// flush cache for a given Value[] index
    procedure FlushCacheEntry(Index: Integer);
    /// flush cache for all Value[]
    procedure FlushCacheAllEntries;
    /// update/refresh the cached JSON serialization of a given ID 
    procedure SetJSON(aID: integer; const aJSON: RawUTF8); overload;
    /// update/refresh the cached JSON serialization of a supplied Record
    procedure SetJSON(aRecord: TSQLRecord); overload;
    /// retrieve a JSON serialization of a given ID from cache
    function RetrieveJSON(aID: integer; var aJSON: RawUTF8): boolean; overload;
    /// unserialize a JSON cached record of a given ID
    function RetrieveJSON(aID: integer; aValue: TSQLRecord): boolean; overload;
  end;

  {/ implement a fast cache content at the TSQLRest level
   - purpose of this caching mechanism is to speed up retrieval of some common
     values at either Client or Server level (like configuration settings)
   - only caching synchronization is about the following RESTful basic commands:
     RETRIEVE, ADD, DELETION and UPDATE (that is, a complex direct SQL UPDATE
     or via TSQLRecordMany pattern won't be taken in account)
   - only Simple fields are cached: e.g. the BLOB fields are not stored
   - this cache is thread-safe (access is locked per table)
   - this caching will be located at the TSQLRest level, that is no automated
     synchronization is implemented between TSQLRestClient and TSQLRestServer:
     you shall ensure that your code won't fail due to this restriction }
  TSQLRestCache = class(TObject)
  protected
    fRest: TSQLRest;
    /// fCache[] follows fModel.Tables[] array
    fCache: array of TSQLRestCacheEntry;
    /// retrieve a record specified by its ID from cache into JSON content
    // - return '' if the item is not in cache
    function Retrieve(aTableIndex, aID: integer): RawUTF8; overload;
    /// fill a record specified by its ID from cache into a new TSQLRecord instance
    // - return false if the item is not in cache
    // - this method will call RetrieveJSON method, unserializing the cached
    // JSON content into the supplied aValue instance
    function Retrieve(aID: Integer; aValue: TSQLRecord): boolean; overload;
  public
    /// create a cache instance
    // - the associated TSQLModel will be used internaly
    constructor Create(aRest: TSQLRest); reintroduce;
    /// release the cache instance
    destructor Destroy; override;
    /// flush the cache
    // - this will flush all stored JSON content, but keep the settings
    // (SetCache/SetTimeOut) as before
    procedure Flush; overload; 
    /// flush the cache for a given table
    // - this will flush all stored JSON content, but keep the settings
    // (SetCache/SetTimeOut) as before for this table
    procedure Flush(aTable: TSQLRecordClass); overload; 
    /// flush the cache for a given record
    // - this will flush the stored JSON content for this record (and table
    // settings will be kept)
    procedure Flush(aTable: TSQLRecordClass; aID: integer); overload;
    /// flush the cache, and destroy all settings
    // - this will flush all stored JSON content, AND destroy the settings
    // (SetCache/SetTimeOut) to default (i.e. no cache enabled)
    procedure Clear;
    {/ activate the internal caching for a whole Table
     - any cached item of this table will be flushed
     - return true on success }
    function SetCache(aTable: TSQLRecordClass): boolean; overload;
     {/ activate the internal caching for a given TSQLRecord
     - if this item is already cached, do nothing
     - return true on success }
    function SetCache(aTable: TSQLRecordClass; aID: Integer): boolean; overload;
     {/ activate the internal caching for a given TSQLRecord
     - will cache the specified aRecord.ID item
     - if this item is already cached, do nothing
     - return true on success }
    function SetCache(aRecord: TSQLRecord): boolean; overload;
    {/ set the internal caching time out delay (in ms) for a given table
     - time out setting is common to all items of the table
     - if aTimeOut is left to its default 0 value, caching will never expire
     - return true on success }
    function SetTimeOut(aTable: TSQLRecordClass; aTimeoutMS: cardinal): boolean;
    /// returns the number of JSON serialization records within this cache
    function CachedEntries: cardinal;
    /// returns the memory used by JSON serialization records within this cache
    function CachedMemory: cardinal;
    /// read-only access to the associated TSQLRest instance
    property Rest: TSQLRest read fRest;
  public { TSQLRest low level methods which are not to be called usualy: } 
    /// TSQLRest instance shall call this method when a record is added or updated
    // - this overloaded method expects the content to be specified as JSON object
    procedure Notify(aTable: TSQLRecordClass; aID: integer; const aJSON: RawUTF8;
     aAction: TSQLOccasion); overload;
    /// TSQLRest instance shall call this method when a record is retrieved,
    // added or updated
    // - this overloaded method expects the content to be specified as JSON object,
    // and TSQLRecordClass to be specified as its index in Rest.Model.Tables[]
    procedure Notify(aTableIndex: integer; aID: integer; const aJSON: RawUTF8;
      aAction: TSQLOccasion); overload;
    /// TSQLRest instance shall call this method when a record is added or updated
    // - this overloaded method will call the other Trace method, serializing
    // the supplied aRecord content as JSON (not in the case of seDelete)
    procedure Notify(aRecord: TSQLRecord; aAction: TSQLOccasion); overload;
    /// TSQLRest instance shall call this method when a record is deleted
    // - this method is dedicated for a record deletion
    procedure NotifyDeletion(aTable: TSQLRecordClass; aID: integer); overload;
    /// TSQLRest instance shall call this method when a record is deleted
    // - this method is dedicated for a record deletion
    // - TSQLRecordClass to be specified as its index in Rest.Model.Tables[]
    procedure NotifyDeletion(aTableIndex, aID: integer); overload;
  end;

  /// how a TSQLRest class may execute read or write operations
  // - used e.g. for TSQLRestServer.AcquireWriteMode or
  // TSQLRestServer.AcquireExecutionMode/AcquireExecutionLockedTimeOut
  TSQLRestServerAcquireMode = (
    amUnlocked, amLocked, amBackgroundThread
    {$ifndef LVCL}, amMainThread{$endif});

  TSQLRestClass = class of TSQLRest;

  /// a dynamic array of TSQLREST instances
  TSQLRestDynArray = array of TSQLRest;

  /// a generic REpresentational State Transfer (REST) client/server class
  TSQLRest = class
  protected
    fModel: TSQLModel;
    fCache: TSQLRestCache;
    fTransactionActiveSession: cardinal;
    fTransactionTable: TSQLRecordClass;
    fServerTimeStampOffset: TDateTime;
    fServerTimeStampCacheTix: cardinal;
    fServerTimeStampCacheValue: TTimeLogBits;
    fServices: TServiceContainer;
    fRoutingClass: TSQLRestServerURIContextClass;
    fAcquireExecution: array[TSQLRestServerURIContextCommand] of record
      Mode: TSQLRestServerAcquireMode;
      LockedTimeOut: cardinal;
      Thread: TSynBackgroundThreadSQLRestServerMethod;
      Lock: TRTLCriticalSection;
      // see http://www.delphitools.info/2011/11/30/fixing-tcriticalsection
      PaddingForLock: array[0..95-sizeof(cardinal)*2-sizeof(pointer)-sizeof(TRTLCriticalSection)] of byte;
    end;
    fBatch: TJSONSerializer;
    fBatchTable, fBatchTablePreviousSendData: TSQLRecordClass;
    fBatchCount: integer;
    /// log the corresponding text (if logging is enabled)
    procedure InternalLog(const Text: RawUTF8; Level: TSynLogInfo);
      {$ifdef HASINLINE}inline;{$endif}
    procedure SetRoutingClass(aServicesRouting: TSQLRestServerURIContextClass);
    /// override this method to guess if this record can be updated or deleted
    // - this default implementation returns always true
    // - e.g. you can add digital signature to a record to disallow record editing
    // - the ErrorMsg can be set to a variable, which will contain an explicit
    // error message
    function RecordCanBeUpdated(Table: TSQLRecordClass; ID: integer; Action: TSQLEvent;
      ErrorMsg: PRawUTF8 = nil): boolean; virtual;
    /// internal method used by Delete(Table,SQLWhere) method
    function InternalDeleteNotifyAndGetIDs(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
      var IDs: TIntegerDynArray): boolean; 
    /// retrieve the server time stamp
    // - default implementation will use fServerTimeStampOffset to compute
    // the value from PC time (i.e. Now+fServerTimeStampOffset as TTimeLog)
    // - inherited classes may override this method, or set the appropriate
    // value in fServerTimeStampOffset protected field
    function GetServerTimeStamp: TTimeLog; virtual;
    /// compute the server time stamp offset from the given
    procedure SetServerTimeStamp(const Value: TTimeLog);
    /// handle Client or Server side fast in-memory cache
    // - creates the internal fCache instance, if necessary
    function GetCache: TSQLRestCache;
    /// returns TRUE if this table is worth caching (e.g. not in memory)
    // - this default implementation always returns TRUE (always allow cache)
    function CacheWorthItForTable(aTableIndex: cardinal): boolean; virtual;
    /// wrapper methods to access fAcquireExecution[]
    function GetAcquireExecutionMode(Cmd: TSQLRestServerURIContextCommand): TSQLRestServerAcquireMode;
    procedure SetAcquireExecutionMode(Cmd: TSQLRestServerURIContextCommand; Value: TSQLRestServerAcquireMode);
    function GetAcquireExecutionLockedTimeOut(Cmd: TSQLRestServerURIContextCommand): cardinal;
    procedure SetAcquireExecutionLockedTimeOut(Cmd: TSQLRestServerURIContextCommand; Value: cardinal);
    /// internal method called by TSQLRestServer.Batch() to process fast sending
    // to remote database engine (e.g. Oracle bound arrays or MS SQL Bulk insert)
    // - returns TRUE if this method is handled by the engine, or FALSE if
    // individual calls to Engine*() are expected
    // - this default implementation returns FALSE
    // - an overridden method returning TRUE shall ensure that calls to
    // EngineAdd / EngineUpdate / EngineDelete (depending of supplied Method)
    // will properly handle operations until InternalBatchStop() is called
    function InternalBatchStart(Method: TSQLURIMethod): boolean; virtual;
    /// internal method called by TSQLRestServer.Batch() to process fast sending
    // to remote database engine (e.g. Oracle bound arrays or MS SQL Bulk insert)
    // - this default implementation will raise an EORMException (since
    // InternalBatchStart returns always FALSE at this TSQLRest level)
    // - InternalBatchStart/Stop may safely use a lock for multithreading:
    // implementation in TSQLRestServer.Batch use a try..finally block
    procedure InternalBatchStop; virtual;
 protected // these abstract methods must be inherited by real database engine
    /// retrieve a list of members as JSON encoded data
    // - implements REST GET collection
    // - returns '' on error, or JSON data, even with no result rows
    // - override this method for direct data retrieval from the database engine
    // and direct JSON export, avoiding a TSQLTable which allocates memory for every
    // field values before the JSON export
    // - can be called for a single Table (ModelRoot/Table), or with low level SQL
    // query (ModelRoot + SQL sent as request body)
    // - if ReturnedRowCount points to an integer variable, it must be filled with
    // the number of row data returned (excluding field names)
    // - this method must be implemented in a thread-safe manner
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false;
      ReturnedRowCount: PPtrInt=nil): RawUTF8; virtual; abstract;
    /// get a member from its ID
    // - implements REST GET member
    // - returns the data of this object as JSON
    // - override this method for proper data retrieval from the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8; virtual; abstract;
    /// create a new member
    // - implements REST POST collection
    // - SentData can contain the JSON object with field values to be added
    // - class is taken from Model.Tables[TableModelIndex]
    // - returns the TSQLRecord ID/ROWID value, 0 on error
    // - is a "RowID":.. or "ID":.. member is set in SentData, it shall force its
    // value as insertion ID
    // - override this method for proper calling the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineAdd(TableModelIndex: integer; const SentData: RawUTF8): integer; virtual; abstract;
    /// update a member
    // - implements REST PUT collection
    // - SentData can contain the JSON object with field values to be added
    // - returns true on success
    // - override this method for proper calling the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineUpdate(TableModelIndex, ID: integer; const SentData: RawUTF8): boolean; virtual; abstract;
    /// delete a member
    // - implements REST DELETE collection
    // - returns true on success
    // - override this method for proper calling the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineDelete(TableModelIndex, ID: integer): boolean; virtual; abstract;
    /// delete several members, from a WHERE clause
    // - IDs[] contains the already-computed matching IDs for SQLWhere
    // - returns true on success
    // - override this method for proper calling the database engine, i.e.
    // using either IDs[] or a faster SQL statement
    // - this method must be implemented in a thread-safe manner
    function EngineDeleteWhere(TableModelIndex: integer; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; virtual; abstract;
    /// get a blob field content from its member ID and field name
    // - implements REST GET member with a supplied blob field name
    // - returns TRUE on success
    // - returns the data of this blob as raw binary (not JSON) in BlobData
    // - override this method for proper data retrieval from the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineRetrieveBlob(TableModelIndex, aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; virtual; abstract; 
    /// update a blob field content from its member ID and field name
    // - implements REST PUT member with a supplied blob field name
    // - returns TRUE on success
    // - the data of this blob must be specified as raw binary (not JSON) in BlobData
    // - override this method for proper data retrieval from the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineUpdateBlob(TableModelIndex, aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; virtual; abstract;
    /// update an individual record field value from a specified ID or Value
    // - return true on success
    // - will allow execution of requests like
    // $ UPDATE tablename SET setfieldname=setvalue WHERE wherefieldname=wherevalue
    // - SetValue and WhereValue parameters must match our inline format, i.e.
    // by double quoted with " for strings, or be plain text for numbers - e.g.
    // $ Client.EngineUpdateField(TSQLMyRecord,'FirstName','"Smith"','RowID','10')
    // but you should better use the UpdateField() overload methods instead
    // - WhereFieldName and WhereValue must be set: for security reasons,
    // implementations of this method will reject an UPDATE without any WHERE
    // clause, so you won't be able to use it to execute such statements:
    // $ UPDATE tablename SET setfieldname=setvalue
    // - this method must be implemented in a thread-safe manner
    function EngineUpdateField(TableModelIndex: integer;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; virtual; abstract;
    /// send/execute the supplied JSON BATCH content, and return the expected array
    // - this method will be implemented for TSQLRestClient and TSQLRestServer only
    // - this default implementation will trigger an EORMException
    function EngineBatchSend(Table: TSQLRecordClass; const Data: RawUTF8;
      var Results: TIntegerDynArray): integer; virtual;
  public
    /// initialize the class, and associate it to a specified database Model
    constructor Create(aModel: TSQLModel); virtual;
    /// release internal used instances
    // - e.g. release associated TSQLModel or TServiceContainer
    destructor Destroy; override;
    /// the Database Model associated with this REST Client or Server
    property Model: TSQLModel read fModel;
  public
    /// get the row count of a specified table
    // - return -1 on error
    // - return the row count of the table on success
    // - calls internaly the "SELECT Count(*) FROM TableName;" SQL statement
    function TableRowCount(Table: TSQLRecordClass): integer; virtual;
    /// check if there is some data rows in a specified table
    // - calls internaly a "SELECT RowID FROM TableName LIMIT 1" SQL statement,
    // which is much faster than testing if "SELECT count(*)" equals 0 - see
    // @http://stackoverflow.com/questions/8988915
    function TableHasRows(Table: TSQLRecordClass): boolean; virtual;
    /// get the UTF-8 encoded value of an unique field with a Where Clause
    // - example of use - including inlined parameters via :(...):
    // ! aClient.OneFieldValue(TSQLRecord,'Name','ID=:(23):')
    // you should better call the corresponding overloaded method as such:
    // ! aClient.OneFieldValue(TSQLRecord,'Name','ID=?',[aID])
    // which is the same as calling:
    // ! aClient.OneFieldValue(TSQLRecord,'Name',FormatUTF8('ID=?',[],[23]))
    // - call internaly ExecuteList() to get the value
    function OneFieldValue(Table: TSQLRecordClass;
      const FieldName, WhereClause: RawUTF8): RawUTF8; overload;
    /// get the UTF-8 encoded value of an unique field with a Where Clause
    // - this overloaded function will call FormatUTF8 to create the Where Clause
    // from supplied parameters, binding all '?' chars with Args[] values
    // - example of use:
    // ! aClient.OneFieldValue(TSQLRecord,'Name','ID=?',[aID])
    // - call internaly ExecuteList() to get the value
    // - note that this method prototype changed with revision 1.17 of the
    // framework: array of const used to be Args and '%' in the FormatSQLWhere
    // statement, whereas it now expects bound parameters as '?'
    function OneFieldValue(Table: TSQLRecordClass; const FieldName: RawUTF8;
      FormatSQLWhere: PUTF8Char; const BoundsSQLWhere: array of const): RawUTF8; overload;
    /// get the UTF-8 encoded value of an unique field with a Where Clause
    // - this overloaded function will call FormatUTF8 to create the Where Clause
    // from supplied parameters, replacing all '%' chars with Args[], and all '?'
    // chars with Bounds[] (inlining them with :(...): and auto-quoting strings)
    // - example of use:
    // ! OneFieldValue(TSQLRecord,'Name','%=?',['ID'],[aID])
    // - call internaly ExecuteList() to get the value
    function OneFieldValue(Table: TSQLRecordClass; const FieldName: RawUTF8;
      WhereClauseFmt: PUTF8Char; const Args, Bounds: array of const): RawUTF8; overload;
    /// get the UTF-8 encoded value of an unique field from its ID
    // - example of use: OneFieldValue(TSQLRecord,'Name',23)
    // - call internaly ExecuteList() to get the value
    function OneFieldValue(Table: TSQLRecordClass;
      const FieldName: RawUTF8; WhereID: integer): RawUTF8; overload;
    /// get the UTF-8 encoded value of some fields with a Where Clause
    // - example of use: MultiFieldValue(TSQLRecord,['Name'],Name,'ID=:(23):')
    // (using inlined parameters via :(...): is always a good idea)
    // - FieldValue[] will have the same length as FieldName[]
    // - return true on success, false on SQL error or no result
    // - call internaly ExecuteList() to get the list
    function MultiFieldValue(Table: TSQLRecordClass;
      const FieldName: array of RawUTF8; var FieldValue: array of RawUTF8;
      const WhereClause: RawUTF8): boolean; overload;
    /// get the UTF-8 encoded value of some fields from its ID
    // - example of use: MultiFieldValue(TSQLRecord,['Name'],Name,23)
    // - FieldValue[] will have the same length as FieldName[]
    // - return true on success, false on SQL error or no result
    // - call internaly ExecuteList() to get the list
    function MultiFieldValue(Table: TSQLRecordClass;
      const FieldName: array of RawUTF8; var FieldValue: array of RawUTF8;
      WhereID: integer): boolean; overload;
    /// get the UTF-8 encoded values of an unique field with a Where Clause
    // - example of use: OneFieldValue(TSQLRecord,'FirstName','Name=:("Smith"):',Data)
    // (using inlined parameters via :(...): is always a good idea)
    // - leave WhereClause void to get all records
    // - call internaly ExecuteList() to get the list
    // - returns TRUE on success, FALSE if no data was retrieved
    function OneFieldValues(Table: TSQLRecordClass; const FieldName: RawUTF8;
      const WhereClause: RawUTF8; var Data: TRawUTF8DynArray): boolean; overload;
    /// get the integer value of an unique field with a Where Clause
    // - example of use: OneFieldValue(TSQLRecordPeople,'ID','Name=:("Smith"):',Data)
    // (using inlined parameters via :(...): is always a good idea)
    // - leave WhereClause void to get all records
    // - call internaly ExecuteList() to get the list
    function OneFieldValues(Table: TSQLRecordClass; const FieldName: RawUTF8;
      const WhereClause: RawUTF8; var Data: TIntegerDynArray; SQL: PRawUTF8=nil): boolean; overload;
    /// dedicated method used to retrieve free-text matching DocIDs
    // - this method will work for both TSQLRecordFTS3 and TSQLRecordFTS4
    // - this method expects the column/field names to be supplied in the MATCH
    // statement clause
    // - example of use:  FTSMatch(TSQLMessage,'Body MATCH :("linu*"):',IntResult)
    // (using inlined parameters via :(...): is always a good idea)
    function FTSMatch(Table: TSQLRecordFTS3Class; const WhereClause: RawUTF8;
      var DocID: TIntegerDynArray): boolean; overload;
    /// dedicated method used to retrieve free-text matching DocIDs with
    // enhanced ranking information
    // - this method will work for both TSQLRecordFTS3 and TSQLRecordFTS4
    // - this method will search in all FTS3 columns, and except some floating-point
    // constants for weigthing each column (there must be the same number of
    // PerFieldWeight parameters as there are columns in the TSQLRecordFTS3 table)
    // - example of use:  FTSMatch(TSQLDocuments,'"linu*"',IntResult,[1,0.5])
    // which will sort the results by the rank obtained with the 1st column/field
    // beeing given twice the weighting of those in the 2nd (and last) column
    // - FTSMatch(TSQLDocuments,'linu*',IntResult,[1,0.5]) will perform a
    // SQL query as such, which is the fastest way of ranking according to
    // http://www.sqlite.org/fts3.html#appendix_a
    // $ SELECT RowID FROM Documents WHERE Documents MATCH 'linu*'
    // $ ORDER BY rank(matchinfo(Documents),1.0,0.5) DESC
    function FTSMatch(Table: TSQLRecordFTS3Class; const MatchClause: RawUTF8;
      var DocID: TIntegerDynArray; const PerFieldWeight: array of double): boolean; overload;
    /// get the CSV-encoded UTF-8 encoded values of an unique field with a Where Clause
    // - example of use: OneFieldValue(TSQLRecord,'FirstName','Name=:("Smith")',Data)
    // (using inlined parameters via :(...): is always a good idea)
    // - leave WhereClause void to get all records
    // - call internaly ExecuteList() to get the list
    // - using inlined parameters via :(...): in WhereClause is always a good idea
    function OneFieldValues(Table: TSQLRecordClass; const FieldName: RawUTF8;
      const WhereClause: RawUTF8=''; const Separator: RawUTF8=','): RawUTF8; overload;
    /// get the string-encoded values of an unique field into some TStrings
    // - Items[] will be filled with string-encoded values of the given field)
    // - Objects[] will be filled with pointer(ID)
    // - call internaly ExecuteList() to get the list
    // - returns TRUE on success, FALSE if no data was retrieved
    // - if IDToIndex is set, its value will be replaced with the index in
    // Strings.Objects[] where ID=IDToIndex^
    // - using inlined parameters via :(...): in WhereClause is always a good idea
    function OneFieldValues(Table: TSQLRecordClass;
      const FieldName, WhereClause: RawUTF8; Strings: TStrings;
      IDToIndex: PInteger=nil): Boolean; overload;
    /// Execute directly a SQL statement, expecting a list of resutls
    // - return a result table on success, nil on failure
    // - FieldNames can be the CSV list of field names to be retrieved
    // - if FieldNames is '', will get all simple fields, excluding BLOBs
    // - if FieldNames is '*', will get ALL fields, including ID and BLOBs
    // - call internaly ExecuteList() to get the list
    // - using inlined parameters via :(...): in WhereClause is always a good idea
    function MultiFieldValues(Table: TSQLRecordClass; const FieldNames: RawUTF8;
       const WhereClause: RawUTF8=''): TSQLTableJSON; overload; virtual;
    /// Execute directly a SQL statement, expecting a list of resutls
    // - return a result table on success, nil on failure
    // - FieldNames can be the CSV list of field names to be retrieved
    // - if FieldNames is '', will get all simple fields, excluding BLOBs
    // - if FieldNames is '*', will get ALL fields, including ID and BLOBs
    // - this overloaded function will call FormatUTF8 to create the Where Clause
    // from supplied parameters, binding all '?' chars with Args[] values
    // - example of use:
    // ! aList := aClient.MultiFieldValues(TSQLRecord,'Name,FirstName','Salary>=?',[aMinSalary]);
    // - call overloaded MultiFieldValues() / ExecuteList() to get the list
    // - note that this method prototype changed with revision 1.17 of the
    // framework: array of const used to be Args and '%' in the WhereClauseFormat
    // statement, whereas it now expects bound parameters as '?'
    function MultiFieldValues(Table: TSQLRecordClass; const FieldNames: RawUTF8;
      WhereClauseFormat: PUTF8Char; const BoundsSQLWhere: array of const): TSQLTableJSON; overload;
    /// Execute directly a SQL statement, expecting a list of results
    // - return a result table on success, nil on failure
    // - FieldNames can be the CSV list of field names to be retrieved
    // - if FieldNames is '', will get all simple fields, excluding BLOBs
    // - if FieldNames is '*', will get ALL fields, including ID and BLOBs
    // - in this version, the WHERE clause can be created with the same format
    // as FormatUTF8() function, replacing all '%' chars with Args[], and all '?'
    // chars with Bounds[] (inlining them with :(...): and auto-quoting strings)
    // - example of use:
    // ! Table := MultiFieldValues(TSQLRecord,'Name','%=?',['ID'],[aID]);
    // - call overloaded MultiFieldValues() / ExecuteList() to get the list
    function MultiFieldValues(Table: TSQLRecordClass; const FieldNames: RawUTF8;
      WhereClauseFormat: PUTF8Char; const Args, Bounds: array of const): TSQLTableJSON; overload;
    /// retrieve the main field (mostly 'Name') value of the specified record
    // - use GetMainFieldName() method to get the main field name
    // - use OneFieldValue() method to get the field value
    // - return '' if no such field or record exists
    // - if ReturnFirstIfNoUnique is TRUE and no unique property is found,
    // the first RawUTF8 property is returned anyway
    function MainFieldValue(Table: TSQLRecordClass; ID: Integer;
      ReturnFirstIfNoUnique: boolean=false): RawUTF8;
    /// return the ID of the record which main field match the specified value
    // - search field is mainly the "Name" property, i.e. the one with
    // "stored AS_UNIQUE" (i.e. "stored false") definition on most TSQLRecord
    // - returns 0 if no matching record was found }
    function MainFieldID(Table: TSQLRecordClass; const Value: RawUTF8): integer;
    /// return the IDs of the record which main field match the specified values
    // - search field is mainly the "Name" property, i.e. the one with
    // "stored AS_UNIQUE" (i.e. "stored false") definition on most TSQLRecord
    // - if any of the Values[] is not existing, then no ID will appear in the
    // IDs[] array - e.g. it will return [] if no matching record was found
    // - returns TRUE if any matching ID was found (i.e. if length(IDs)>0) }
    function MainFieldIDs(Table: TSQLRecordClass; const Values: array of RawUTF8;
      var IDs: TIntegerDynArray): boolean;
  public // here are REST basic direct calls (works with Server or Client)
    /// get a member from a SQL statement
    // - implements REST GET collection
    // - return true on success
    // - Execute 'SELECT * FROM TableName WHERE SQLWhere LIMIT 1' SQL Statememt
    // (using inlined parameters via :(...): in SQLWhere is always a good idea)
    // - since no record is specified, locking is pointless here
    // - default implementation call ExecuteList(), and fill Value from a
    // temporary TSQLTable
    // - the TSQLRawBlob (BLOB) fields are not retrieved by this method, to
    // preserve bandwidth: use the RetrieveBlob() methods for handling
    // BLOB fields, or set either the TSQLRestClientURI.ForceBlobTransfert
    // or TSQLRestClientURI.ForceBlobTransfertTable[] properties
    // - the TSQLRecordMany fields are not retrieved either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
    function Retrieve(const SQLWhere: RawUTF8; Value: TSQLRecord): boolean; overload; virtual;
    /// get a member from a SQL statement
    // - implements REST GET collection
    // - return true on success
    // - same as Retrieve(const SQLWhere: RawUTF8; Value: TSQLRecord) method, but
    // this overloaded function will call FormatUTF8 to create the Where Clause
    // from supplied parameters, replacing all '%' chars with Args[], and all '?'
    // chars with Bounds[] (inlining them with :(...): and auto-quoting strings)
    function Retrieve(WhereClauseFmt: PUTF8Char; const Args,Bounds: array of const;
      Value: TSQLRecord): boolean; overload;
    /// get a member from its ID
    // - return true on success
    // - Execute 'SELECT * FROM TableName WHERE ID=:(aID): LIMIT 1' SQL Statememt
    // - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
    // the corresponding record, then retrieve its content; caller has to call
    // UnLock() method after Value usage, to release the record
    // - this method will call EngineRetrieve() abstract method
    // - the TSQLRawBlob (BLOB) fields are not retrieved by this method, to
    // preserve bandwidth: use the RetrieveBlob() methods for handling
    // BLOB fields, or set either the TSQLRestClientURI.ForceBlobTransfert
    // or TSQLRestClientURI.ForceBlobTransfertTable[] properties
    // - the TSQLRecordMany fields are not retrieved either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
   function Retrieve(aID: integer; Value: TSQLRecord;
      ForUpdate: boolean=false): boolean; overload; virtual; 
    /// get a member from its TRecordReference property content
    // - instead of the other Retrieve() methods, this implementation Create an
    // instance, with the appropriated class stored in Reference
    // - returns nil on any error (invalid Reference e.g.)
    // - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
    // the corresponding record, then retrieve its content; caller has to call
    // UnLock() method after Value usage, to release the record
    // - the TSQLRawBlob (BLOB) fields are not retrieved by this method, to
    // preserve bandwidth: use the RetrieveBlob() methods for handling
    // BLOB fields, or set either the TSQLRestClientURI.ForceBlobTransfert
    // or TSQLRestClientURI.ForceBlobTransfertTable[] properties
    // - the TSQLRecordMany fields are not retrieved either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
    function Retrieve(Reference: TRecordReference;
      ForUpdate: boolean=false): TSQLRecord; overload; virtual;
    /// get a member from a published property TSQLRecord
    // - those properties are not class instances, but TObject(aRecordID)
    // - is just a wrapper around Retrieve(aPublishedRecord.ID,aValue)
    // - return true on success
    function Retrieve(aPublishedRecord, aValue: TSQLRecord): boolean; overload;
    /// get a list of members from a SQL statement
    // - implements REST GET collection
    // - for better server speed, the WHERE clause should use bound parameters
    // identified as '?' in the FormatSQLWhere statement, which is expected to
    // follow the order of values supplied in BoundsSQLWhere open array - use
    // DateToSQL()/DateTimeToSQL() for TDateTime, or directly any integer,
    // double, currency, RawUTF8 values to be bound to the request as parameters
    // - aCustomFieldsCSV can be the CSV list of field names to be retrieved
    // - if aCustomFieldsCSV is '', will get all simple fields, excluding BLOBs
    // - if aCustomFieldsCSV is '*', will get ALL fields, including ID and BLOBs
    // - return a TObjectList on success (possibly with Count=0) - caller is
    // responsible of freeing the instance
    // - this TObjectList will contain a list of all matching records
    // - return nil on error
    function RetrieveList(Table: TSQLRecordClass; FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const;
      const aCustomFieldsCSV: RawUTF8=''): TObjectList; overload;
    {$ifndef NOVARIANTS}
    /// get a list of all members from a SQL statement as a TDocVariant
    // - implements REST GET collection
    // - if ObjectName='', it will return a TDocVariant of dvArray kind
    // - if ObjectName is set, it will return a TDocVariant of dvObject kind,
    // with one property containing the array of values: this returned variant
    // can be pasted e.g. directly as parameter to TSynMustache.Render() 
    // - aCustomFieldsCSV can be the CSV list of field names to be retrieved
    // - if aCustomFieldsCSV is '', will get all simple fields, excluding BLOBs
    // - if aCustomFieldsCSV is '*', will get ALL fields, including ID and BLOBs
    function RetrieveDocVariantArray(Table: TSQLRecordClass;
      const ObjectName, CustomFieldsCSV: RawUTF8): variant; overload;
      {$ifdef HASINLINE}inline;{$endif}
    /// get a list of members from a SQL statement as a TDocVariant
    // - implements REST GET collection over a specified WHERE clause
    // - if ObjectName='', it will return a TDocVariant of dvArray kind
    // - if ObjectName is set, it will return a TDocVariant of dvObject kind,
    // with one property containing the array of values: this returned variant
    // can be pasted e.g. directly as parameter to TSynMustache.Render()
    // - for better server speed, the WHERE clause should use bound parameters
    // identified as '?' in the FormatSQLWhere statement, which is expected to
    // follow the order of values supplied in BoundsSQLWhere open array - use
    // DateToSQL()/DateTimeToSQL() for TDateTime, or directly any integer,
    // double, currency, RawUTF8 values to be bound to the request as parameters
    // - aCustomFieldsCSV can be the CSV list of field names to be retrieved
    // - if aCustomFieldsCSV is '', will get all simple fields, excluding BLOBs
    // - if aCustomFieldsCSV is '*', will get ALL fields, including ID and BLOBs
    function RetrieveDocVariantArray(Table: TSQLRecordClass;
      const ObjectName: RawUTF8;
      FormatSQLWhere: PUTF8Char; const BoundsSQLWhere: array of const;
      const CustomFieldsCSV: RawUTF8): variant; overload;
    {$endif}

    /// Execute directly a SQL statement, expecting a list of results
    // - return a result table on success, nil on failure
    // - will call EngineList() abstract method to retrieve its JSON content
    function ExecuteList(const Tables: array of TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON; virtual;
    /// unlock the corresponding record
    // - record should have been locked previously e.g. with Retrieve() and
    // forupdate=true, i.e. retrieved not via GET with LOCK REST-like verb
    // - use our custom UNLOCK REST-like verb
    // - returns true on success
    function UnLock(Table: TSQLRecordClass; aID: integer): boolean; overload; virtual; abstract;
    /// unlock the corresponding record
    // - record should have been locked previously e.g. with Retrieve() and
    // forupdate=true, i.e. retrieved not via GET with LOCK REST-like verb
    // - use our custom UNLOCK REST-like method
    // - calls internally UnLock() above
    // - returns true on success
    function UnLock(Rec: TSQLRecord): boolean; overload;
    /// create a new member
    // - implements REST POST collection
    // - if SendData is true, client sends the current content of Value with the
    // request, otherwise record is created with default values
    // - if ForceID is true, client sends the Value.ID field to use this ID for
    // adding the record (instead of a database-generated ID)
    // - on success, returns the new ROWID value; on error, returns 0
    // - on success, Value.ID is updated with the new ROWID
    // - the TSQLRawBlob(BLOB) fields values are not set by this method, to
    // preserve bandwidth
    // - the TSQLRecordMany fields are not set either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
    // - this method will call EngineAdd() to perform the request
    function Add(Value: TSQLRecord; SendData: boolean; ForceID: boolean=false): integer; overload; virtual;
    /// create a new member, from a supplied list of field values
    // - implements REST POST collection
    // - the aSimpleFields parameters must follow explicitely the order of published
    // properties of the supplied aTable class, excepting the TSQLRawBlob and
    // TSQLRecordMany kind (i.e. only so called "simple fields")
    // - the aSimpleFields must have exactly the same count of parameters as
    // there are "simple fields" in the published properties
    // - if ForcedID is set to non null, client sends this ID to be used
    // when adding the record (instead of a database-generated ID)
    // - on success, returns the new ROWID value; on error, returns 0
    // - call internaly the Add virtual method above
    function Add(aTable: TSQLRecordClass; const aSimpleFields: array of const; ForcedID: integer=0): integer; overload;
    /// update a member from Value simple fields content
    // - implements REST PUT collection
    // - return true on success
    // - the TSQLRawBlob(BLOB) fields values are not updated by this method, to
    // preserve bandwidth: use the UpdateBlob() methods for handling BLOB fields
    // - the TSQLRecordMany fields are not set either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
    // - if CustomFields is left void, the  simple fields will be used, or the
    // fields retrieved via a previous FillPrepare() call; otherwise, you can
    // specify your own set of fields to be transmitted (including BLOBs, even
    // if they will be Base64-encoded within the JSON content) - CustomFields
    // could be computed by TSQLRecordProperties.FieldIndexsFromCSV()
    // or TSQLRecordProperties.FieldIndexsFromRawUTF8()
    // - this method will always compute and send any TModTime fields
    // - this method will call EngineUpdate() to perform the request
    function Update(Value: TSQLRecord; const CustomFields: TSQLFieldBits=[]): boolean; overload; virtual;
    /// update a member from Value simple fields content
    // - implements REST PUT collection
    // - return true on success
    // - is an overloaded method to Update(Value,FieldIndexsFromCSV())
    function Update(Value: TSQLRecord; const CustomCSVFields: RawByteString): boolean; overload;
    /// update a member from a supplied list of simple field values
    // - implements REST PUT collection
    // - the aSimpleFields parameters MUST follow explicitely both count and
    // order of published properties of the supplied aTable class, excepting the
    // TSQLRawBlob and TSQLRecordMany kind (i.e. only so called "simple fields")
    // - return true on success
    // - call internaly the Update() / EngineUpdate() virtual methods 
    function Update(aTable: TSQLRecordClass; aID: integer; const aSimpleFields: array of const): boolean; overload;
    /// update one field/column value a given member
    // - implements REST PUT collection with one field value
    // - only one single field shall be specified in FieldValue, but could
    // be of any kind of value - for BLOBs, you should better use UpdateBlob()
    // - return true on success
    // - call internaly the EngineUpdateField() abstract method
    // - note that this method won't update the TModTime properties: you should
    // rather use a classic Retrieve()/FillPrepare() followed by Update()
    function UpdateField(Table: TSQLRecordClass; ID: integer;
      const FieldName: RawUTF8; const FieldValue: array of const): boolean; overload; virtual;
    /// update one field in one or several members, depending on a WHERE clause
    // - implements REST PUT collection with one field value on a one where value
    // - only one single field shall be specified in FieldValue, but could
    // be of any kind of value - for BLOBs, you should better use UpdateBlob()
    // - only one single field shall be specified in WhereFieldValue, but could
    // be of any kind of value - for security reasons, void WHERE clause will
    // be rejected
    // - return true on success
    // - call internaly the EngineUpdateField() abstract method
    // - note that this method won't update the TModTime properties: you should
    // rather use a classic Retrieve()/FillPrepare() followed by Update()
    function UpdateField(Table: TSQLRecordClass;
      const WhereFieldName: RawUTF8; const WhereFieldValue: array of const;
      const FieldName: RawUTF8; const FieldValue: array of const): boolean; overload; virtual;
{$ifndef NOVARIANTS}
    /// update one field in a given member with a value specified as variant
    // - implements REST PUT collection with one field value
    // - any value can be set in FieldValue, but for BLOBs, you should better
    // use UpdateBlob()
    // - return true on success
    // - call internaly the EngineUpdateField() abstract method
    // - note that this method won't update the TModTime properties: you should
    // rather use a classic Retrieve()/FillPrepare() followed by Update()
    function UpdateField(Table: TSQLRecordClass; ID: integer;
      const FieldName: RawUTF8; const FieldValue: variant): boolean; overload; virtual;
    /// update one field in one or several members, depending on a WHERE clause,
    // with both update and where values specified as variant
    // - implements REST PUT collection with one field value on a one where value
    // - any value can be set in FieldValue, but for BLOBs, you should better
    // use UpdateBlob()
    // - for security reasons, void WHERE clause will be rejected
    // - return true on success
    // - call internaly the EngineUpdateField() abstract method
    // - note that this method won't update the TModTime properties: you should
    // rather use a classic Retrieve()/FillPrepare() followed by Update()
    function UpdateField(Table: TSQLRecordClass;
      const WhereFieldName: RawUTF8; const WhereFieldValue: variant;
      const FieldName: RawUTF8; const FieldValue: variant): boolean; overload; virtual;
{$endif NOVARIANTS}
    /// delete a member
    // - implements REST DELETE collection
    // - return true on success
    // - call internaly the EngineDelete() abstract method
    function Delete(Table: TSQLRecordClass; ID: integer): boolean; overload; virtual;
    /// delete a member with a WHERE clause
    // - implements REST DELETE collection
    // - return true on success
    // - this default method call OneFieldValues() to retrieve all matching IDs,
    // then will delete each row using protected EngineDeleteWhere() virtual method
    function Delete(Table: TSQLRecordClass; const SQLWhere: RawUTF8): boolean; overload; virtual;
    /// delete a member with a WHERE clause
    // - implements REST DELETE collection
    // - return true on success
    // - for better server speed, the WHERE clause should use bound parameters
    // identified as '?' in the FormatSQLWhere statement, which is expected to
    // follow the order of values supplied in BoundsSQLWhere open array - use
    // DateToSQL/DateTimeToSQL for TDateTime, or directly any integer / double /
    // currency / RawUTF8 values to be bound to the request as parameters
    // - is a simple wrapper around:
    // ! Delete(Table,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere))
    function Delete(Table: TSQLRecordClass; FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const): boolean; overload;

    /// access the internal caching parameters for a given TSQLRecord
    // - purpose of this caching mechanism is to speed up retrieval of some
    // common values at either Client or Server level (like configuration settings)
    // - only caching synchronization is about the direct RESTful/CRUD commands:
    // RETRIEVE, ADD, UPDATE and DELETE (that is, a complex direct SQL UPDATE or
    // via TSQLRecordMany pattern won't be taken in account - only exception is
    // TSQLRestStorage tables accessed as SQLite3 virtual table)
    // - this caching will be located at the TSQLRest level, that is no automated
    // synchronization is implemented between TSQLRestClient and TSQLRestServer:
    // you shall ensure that your code won't fail due to this restriction
    // - use Cache.SetCache() and Cache.SetTimeOut() methods to set the appropriate
    // configuration for this particular TSQLRest instance 
    property Cache: TSQLRestCache read GetCache;

    /// get a blob field content from its record ID and supplied blob field name
    // - implements REST GET collection with a supplied member ID and a blob field name
    // - return true on success
    // - this method is defined as abstract, i.e. there is no default implementation:
    // it must be implemented 100% RestFul with a
    // GET ModelRoot/TableName/TableID/BlobFieldName request for example
    // - this method retrieve the blob data as a TSQLRawBlob string using
    // EngineRetrieveBlob()
    function RetrieveBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; out BlobData: TSQLRawBlob): boolean; overload; virtual;
    /// get a blob field content from its record ID and supplied blob field name
    // - implements REST GET collection with a supplied member ID and field name
    // - return true on success
    // - this method will create a TStream instance (which must be freed by the
    // caller after use) and fill it with the blob data
    function RetrieveBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; out BlobStream: THeapMemoryStream): boolean; overload;
    /// update a blob field from its record ID and supplied blob field name
    // - implements REST PUT collection with a supplied member ID and field name
    // - return true on success
    // - call internaly the EngineUpdateBlob() abstract method
    // - this method expect the Blob data to be supplied as TSQLRawBlob, using
    // EngineUpdateBlob()
    function UpdateBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; const BlobData: TSQLRawBlob): boolean; overload; virtual;
    /// update a blob field from its record ID and blob field name
    // - implements REST PUT collection with a supplied member ID and field name
    // - return true on success
    // - call internaly the EngineUpdateBlob() abstract method
    // - this method expect the Blob data to be supplied as a TStream: it will
    // send the whole stream content (from its beginning position upto its
    // current size) to the database engine
    function UpdateBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; BlobData: TStream): boolean; overload;
    /// update a blob field from its record ID and blob field name
    // - implements REST PUT collection with a supplied member ID and field name
    // - return true on success
    // - call internaly the EngineUpdateBlob() abstract method
    // - this method expect the Blob data to be supplied as direct memory pointer
    // and size
    function UpdateBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; BlobData: pointer; BlobSize: integer): boolean; overload;
    /// update all BLOB fields of the supplied Value
    // - call several REST PUT collection (one for each BLOB) for the member
    // - uses the UpdateBlob() method to send the BLOB properties content to the Server
    // - called internaly by Add and Update methods when ForceBlobTransfert /
    // ForceBlobTransertTable[] is set
    // - you can use this method by hand, to avoid several calls to UpdateBlob()
    // - returns TRUE on success (or if there is no BLOB field)
    // - returns FALSE on error (e.g. if Value is invalid or with db/transmission)
    function UpdateBlobFields(Value: TSQLRecord): boolean; virtual;
    /// get all BLOB fields of the supplied value from the remote server
    // - call several REST GET collection (one for each BLOB) for the member
    // - call internaly e.g. by TSQLRestClient.Retrieve method when
    // ForceBlobTransfert / ForceBlobTransertTable[] is set
    function RetrieveBlobFields(Value: TSQLRecord): boolean; virtual;

    /// begin a transaction
    // - implements REST BEGIN collection
    // - may be used to speed up CRUD statements like Add/Update/Delete
    // - in the current implementation, nested transactions are not allowed
    // - must be ended with Commit on success
    // - must be aborted with Rollback if any SQL statement failed
    // - default implementation just handle the protected fTransactionActiveSession flag
    // - return true if no transaction is active, false otherwise
    // - in aClient-Server environment with multiple Clients connected at the
    // same time, you should better use BATCH process, specifying a positive
    // AutomaticTransactionPerRow parameter to BatchStart() 
    // - in a multi-threaded or Client-Server with multiple concurrent Client
    // connections, you may check the returned value, as such:
    //  !if Client.TransactionBegin(TSQLRecordPeopleObject) then
    //  !try
    //  !  //.... modify the database content, raise exceptions on error
    //  !  Client.Commit;
    //  !except
    //  !  Client.RollBack; // in case of error
    //  !end;
    // or use the TransactionBeginRetry() method
    // - the supplied SessionID will allow multi-user transaction safety on the
    // Server-Side: all database modification from another session will wait
    // for the global transaction to be finished; on Client-side, the SessionID
    // is just ignored (TSQLRestClient will override this method with a default
    // SessionID=CONST_AUTHENTICATION_NOT_USED=1 parameter)
    // - if you have an external database engine which expect transactions to
    // take place in the same thread, ensure TSQLRestServer force execution of
    // this method when accessed from RESTful clients in the same thread, e.g.:
    // ! AcquireExecutionMode[execORMWrite] := amBackgroundThread;
    // ! AcquireWriteMode := amBackgroundThread; // same as previous
    function TransactionBegin(aTable: TSQLRecordClass; SessionID: cardinal): boolean; virtual;
    /// check current transaction status
    // - returns the session ID if a transaction is active
    // - returns 0 if no transaction is active
    function TransactionActiveSession: cardinal;
    /// end a transaction
    // - implements REST END collection
    // - write all pending SQL statements to the disk
    // - default implementation just reset the protected fTransactionActiveSession flag
    // - the supplied SessionID will allow multi-user transaction safety on the
    // Server-Side: all database modification from another session will wait
    // for the global transaction to be finished; on Client-side, the SessionID
    // is just ignored (TSQLRestClient will override this method with a default
    // SessionID=CONST_AUTHENTICATION_NOT_USED=1 parameter)
    // - if you have an external database engine which expect transactions to
    // take place in the same thread, ensure TSQLRestServer force execution of
    // this method when accessed from RESTful clients in the same thread, e.g.:
    // ! AcquireExecutionMode[execORMWrite] := amBackgroundThread;
    // ! AcquireWriteMode := amBackgroundThread; // same as previous
    procedure Commit(SessionID: cardinal); virtual;
    /// abort a transaction
    // - implements REST ABORT collection
    // - restore the previous state of the database, before the call to TransactionBegin
    // - default implementation just reset the protected fTransactionActiveSession flag
    // - the supplied SessionID will allow multi-user transaction safety on the
    // Server-Side: all database modification from another session will wait
    // for the global transaction to be finished; on Client-side, the SessionID
    // is just ignored (TSQLRestClient will override this method with a default
    // SessionID=CONST_AUTHENTICATION_NOT_USED=1 parameter)
    // - if you have an external database engine which expect transactions to
    // take place in the same thread, ensure TSQLRestServer force execution of
    // this method when accessed from RESTful clients in the same thread, e.g.:
    // ! AcquireExecutionMode[execORMWrite] := amBackgroundThread;
    // ! AcquireWriteMode := amBackgroundThread; // same as previous
    procedure RollBack(SessionID: cardinal); virtual;

    {/ begin a BATCH sequence to speed up huge database change
     - each call to normal Add/Update/Delete methods will create a Server request,
       therefore can be slow (e.g. if the remote server has bad ping timing)
     - start a BATCH sequence using this method, then call BatchAdd() BatchUpdate()
       or BatchDelete() methods to make some changes to the database
     - when BatchSend will be called, all the sequence transactions will be sent
       as one to the remote server, i.e. in one URI request
     - if BatchAbort is called instead, all pending BatchAdd/Update/Delete
       transactions will be aborted, i.e. ignored
     - expect one TSQLRecordClass as parameter, which will be used for the whole
       sequence (in this case, you can't mix classes in the same BATCH sequence)
     - if no TSQLRecordClass is supplied, the BATCH sequence will allow any
       kind of individual record in BatchAdd/BatchUpdate/BatchDelete
     - return TRUE on success, FALSE if aTable is incorrect or a previous BATCH
       sequence was already initiated
     - should normally be used inside a Transaction block: there is no automated
       TransactionBegin..Commit/RollBack generated in the BATCH sequence if
       you leave the default AutomaticTransactionPerRow=0 parameter - but
       this may be a concern with a lot of concurrent clients
     - you should better set AutomaticTransactionPerRow > 0 to execute all 
       BATCH processes within an unique transaction grouped by a given number 
       of rows, on the server side - set AutomaticTransactionPerRow=maxInt if 
       you want one huge transaction, or set a convenient value (e.g. 10000) 
	   depending on the back-end database engine abilities, if you want to 
	   retain the transaction log file small enough for the database engine }
    function BatchStart(aTable: TSQLRecordClass;
      AutomaticTransactionPerRow: cardinal=0): boolean; virtual;
    /// create a new member in current BATCH sequence
    // - work in BATCH mode: nothing is sent to the server until BatchSend call
    // - returns the corresponding index in the current BATCH sequence, -1 on error
    // - if SendData is true, content of Value is sent to the server as JSON
    // - if ForceID is true, client sends the Value.ID field to use this ID for
    // adding the record (instead of a database-generated ID)
    // - if Value is TSQLRecordFTS3, Value.ID is stored to the virtual table
    // - Value class MUST match the TSQLRecordClass used at BatchStart,
    // or may be of any kind if no class was specified
    // - BLOB fields are NEVER transmitted here, even if ForceBlobTransfert=TRUE
    // - if CustomFields is left void, the simple fields will be used; otherwise,
    // you can specify your own set of fields to be transmitted when SendData=TRUE
    // (including BLOBs, even if they will be Base64-encoded within JSON content) -
    // CustomFields could be computed by TSQLRecordProperties.FieldIndexsFromCSV()
    // or TSQLRecordProperties.FieldIndexsFromRawUTF8(), or by setting ALL_FIELDS
    // - this method will always compute and send TCreateTime/TModTime fields
    function BatchAdd(Value: TSQLRecord; SendData: boolean; ForceID: boolean=false;
      const CustomFields: TSQLFieldBits=[]): integer;
    /// update a member in current BATCH sequence
    // - work in BATCH mode: nothing is sent to the server until BatchSend call
    // - returns the corresponding index in the current BATCH sequence, -1 on error
    // - Value class MUST match the TSQLRecordClass used at BatchStart,
    // or may be of any kind if no class was specified
    // - BLOB fields are NEVER transmitted here, even if ForceBlobTransfert=TRUE
    // - if Value has an opened FillPrepare() mapping, only the mapped fields
    // will be updated (and also ID and TModTime fields) - FillPrepareMany() is
    // not handled yet (all simple fields will be updated)
    // - if CustomFields is left void, the  simple fields will be used, or the
    // fields retrieved via a previous FillPrepare() call; otherwise, you can
    // specify your own set of fields to be transmitted (including BLOBs, even
    // if they will be Base64-encoded within the JSON content) - CustomFields
    // could be computed by TSQLRecordProperties.FieldIndexsFromCSV()
    // or TSQLRecordProperties.FieldIndexsFromRawUTF8()
    // - this method will always compute and send any TModTime fields
    function BatchUpdate(Value: TSQLRecord; const CustomFields: TSQLFieldBits=[]): integer; virtual;
    /// delete a member in current BATCH sequence
    // - work in BATCH mode: nothing is sent to the server until BatchSend call
    // - returns the corresponding index in the current BATCH sequence, -1 on error
    // - deleted record class is the TSQLRecordClass used at BatchStart()
    // call: it will fail if no class was specified for this BATCH sequence
    function BatchDelete(ID: integer): integer; overload;
    /// delete a member in current BATCH sequence
    // - work in BATCH mode: nothing is sent to the server until BatchSend call
    // - returns the corresponding index in the current BATCH sequence, -1 on error
    // - with this overloaded method, the deleted record class is specified:
    // no TSQLRecordClass shall have been set at BatchStart() call
    function BatchDelete(Table: TSQLRecordClass; ID: integer): integer; overload;
    /// retrieve the current number of pending transactions in the BATCH sequence
    // - every call to BatchAdd/Update/Delete methods increases this count
    function BatchCount: integer;
    {/ execute a BATCH sequence started by BatchStart method
     - send all pending BatchAdd/Update/Delete statements to the remote server
     - URI is 'ModelRoot/TableName/0' with POST method
     - will return the URI Status value, i.e. 200/HTML_SUCCESS OK on success
     - a dynamic array of integers will be created in Results,
       containing all ROWDID created for each BatchAdd call, 200 (=HTML_SUCCESS)
       for all successfull BatchUpdate/BatchDelete, or 0 on error
     - any error during server-side process MUST be checked against Results[]
       (the main URI Status is 200 if about communication success, and won't
       imply that all statements in the BATCH sequence were successfull }
    function BatchSend(var Results: TIntegerDynArray): integer;
    {/ abort a BATCH sequence started by BatchStart method
     - in short, nothing is sent to the remote server, and current BATCH sequence
       is closed }
    procedure BatchAbort;

    {$ifdef ISDELPHI2010} // Delphi 2009 generics support is buggy :(
    /// get an instance of one interface-based service
    // - may return nil if this service interface is not available
    function Service<T: IInterface>: T;
    /// get a list of members from a SQL statement
    // - implements REST GET collection
    // - aCustomFieldsCSV can be the CSV list of field names to be retrieved
    // - if aCustomFieldsCSV is '', will get all simple fields, excluding BLOBs
    // - if aCustomFieldsCSV is '*', will get ALL fields, including ID and BLOBs
    // - return a TObjectList<T> on success (possibly with Count=0) - caller is
    // responsible of freeing the instance
    // - return nil on error
    // - you can write for instance:
    // !var List: TObjectList<TSQLRecordTest>;
    // !    R: TSQLRecordTest;
    // ! ...
    // !    List := Client.RetrieveList<TSQLRecordTest>('ID,Test');
    // !    if List<>nil then
    // !    try
    // !      for R in List do
    // !        writeln(R.ID,'=',R.Test);
    // !    finally
    // !      List.Free;
    // !    end;
    function RetrieveList<T: TSQLRecord>(const aCustomFieldsCSV: RawUTF8=''): TObjectList<T>; overload;
       {$ifdef HASINLINE}inline;{$endif}
    /// get a list of members from a SQL statement
    // - implements REST GET collection with a WHERE clause
    // - for better server speed, the WHERE clause should use bound parameters
    // identified as '?' in the FormatSQLWhere statement, which is expected to
    // follow the order of values supplied in BoundsSQLWhere open array - use
    // DateToSQL()/DateTimeToSQL() for TDateTime, or directly any integer,
    // double, currency, RawUTF8 values to be bound to the request as parameters
    // - aCustomFieldsCSV can be the CSV list of field names to be retrieved
    // - if aCustomFieldsCSV is '', will get all simple fields, excluding BLOBs
    // - if aCustomFieldsCSV is '*', will get ALL fields, including ID and BLOBs
    // - return a TObjectList<T> on success (possibly with Count=0) - caller is
    // responsible of freeing the instance
    // - return nil on error
    function RetrieveList<T: TSQLRecord>(FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const;
      const aCustomFieldsCSV: RawUTF8=''): TObjectList<T>; overload;
    {$endif}

    /// how this class execute its internal commands
    // - by default, TSQLRestServer.URI() will lock for Write ORM according to
    // AcquireWriteMode (i.e. AcquireExecutionMode[execORMWrite]=amLocked) and
    // other operations won't be protected (for better scaling)
    // - you can tune this behavior by setting this property to the expected
    // execution mode, e.g. execute all method-based services in a dedicated
    // thread via AcquireExecutionMode[execSOAByMethod] := amBackgroundThread
    property AcquireExecutionMode[Cmd: TSQLRestServerURIContextCommand]: TSQLRestServerAcquireMode
      read GetAcquireExecutionMode write SetAcquireExecutionMode;
    /// the time (in mili seconds) to try locking internal commands of this class
    // - this value is used only for AcquireExecutionMode[*]=amLocked
    // - by default, TSQLRestServer.URI() will lock for Write ORM according to
    // AcquireWriteTimeOut  (i.e. AcquireExecutionLockedTimeOut[execORMWrite])
    // and other operations won't be locked nor have any time out set
    property AcquireExecutionLockedTimeOut[Cmd: TSQLRestServerURIContextCommand]: cardinal
      read GetAcquireExecutionLockedTimeOut write SetAcquireExecutionLockedTimeOut;
    /// how this class will handle write access to the database
    // - is a common wrapper to AcquireExecutionMode[execORMWrite] property
    // - default amLocked mode will wait up to AcquireWriteTimeOut mili seconds
    // to have a single access to the server write ORM methods
    // - amBackgroundThread will execute the write methods in a queue, in a
    // dedicated unique thread (which can be convenient, especially for
    // external database transaction process)
    // - a slower alternative to amBackgroundThread may be amMainThread
    // - you can set amUnlocked for a concurrent write access, but be aware
    // that it may lead into multi-thread race condition issues, depending on
    // the database engine used
    property AcquireWriteMode: TSQLRestServerAcquireMode index execORMWrite
      read GetAcquireExecutionMode write SetAcquireExecutionMode;
    /// the time (in mili seconds) which the class will wait for acquiring a
    // write acccess to the database, when AcquireWriteMode is amLocked
    // - is a common wrapper to AcquireExecutionLockedTimeOut[execORMWrite] 
    // - in order to handle safe transactions and multi-thread safe writing, the
    // server will identify transactions using the client Session ID: this
    // property will set the time out wait period
    // - default value is 2000, i.e. TSQLRestServer.URI will wait up to 2 seconds
    // in order to acquire the right to write on the database before returning
    // a "408 Request Time-out" status error 
    property AcquireWriteTimeOut: cardinal index execORMWrite
      read GetAcquireExecutionLockedTimeOut write SetAcquireExecutionLockedTimeOut;
    /// the current Date and Time, as retrieved from the server
    // - this property will return the timestamp as TTimeLog / Int64
    // after correction from the Server returned time-stamp (if any)
    // - is used e.g. by TSQLRecord.ComputeFieldsBeforeWrite to update TModTime
    // and TCreateTime published fields
    // - default implementation will return the executable time, i.e. TimeLogNow
    // - you can set the server-side time offset by setting a value to this
    // property (e.g. using TSQLDBConnection.ServerTimeStamp property for
    // Oracle, MSSQL, MySQL, PostgreSQL, JET or even SQLite3 external databases)
    // - you can use this value in a WHERE clause for a query, as such:
    // ! aRec.CreateAndFillPrepare(Client,'Datum<=?',[TimeLogToSQL(Client.ServerTimeStamp)]);
    // - or you could use ServerTimeStamp everywhere in your code, when you need
    // a reference time base
    property ServerTimeStamp: TTimeLog read GetServerTimeStamp write SetServerTimeStamp;
    /// access to the interface-based services list
    // - may be nil if no service interface has been registered yet: so be
    // aware that the following line may trigger an access violation if
    // no ICalculator is defined on server side:
    // ! if fServer.Services['Calculator'].Get(Calc)) then
    // !   ...
    property Services: TServiceContainer read fServices;
    /// the routing classs of the service remote request
    // - by default, will use TSQLRestRoutingREST, i.e. an URI-based
    // layout which is secure (since will use our RESTful authentication scheme),
    // and also very fast
    // - but TSQLRestRoutingJSON_RPC can e.g. be set (on BOTH client and
    // server sides), if the client would rather use JSON/RPC alternative pattern
    // - NEVER set the abstract TSQLRestServerURIContext class on this property
    property ServicesRouting: TSQLRestServerURIContextClass
      read fRoutingClass write SetRoutingClass;
  public
    /// the custom queries parameters for User Interface Query action
    QueryCustom: array of TSQLQueryCustom;
    /// evaluate a basic operation for implementing User Interface Query action
    // - expect both Value and Reference to be UTF-8 encoded (as in TSQLTable
    // or TSQLTableToGrid)
    // - aID parameter is ignored in this function implementation (expect only
    // this parameter to be not equal to 0)
    // - is TSQLQueryEvent prototype compatible
    // - for qoContains and qoBeginWith, the Reference is expected to be
    // already uppercase
    // - for qoSoundsLike* operators, Reference is not a PUTF8Char, but a
    // typecase of a prepared TSynSoundEx object instance (i.e. pointer(@SoundEx))
    class function QueryIsTrue(aTable: TSQLRecordClass; aID: integer;
      FieldType: TSQLFieldType; Value: PUTF8Char; Operator: integer;
      Reference: PUTF8Char): boolean;
    /// add a custom query
    // - one event handler with an enumeration type containing all available
    // query names
    // - and associated operators
    procedure QueryAddCustom(aTypeInfo: pointer; aEvent: TSQLQueryEvent;
      const aOperators: TSQLQueryOperators);
  end;

{$ifdef MSWINDOWS}
  /// Server thread accepting connections from named pipes
  TSQLRestServerNamedPipe = class(TThread)
  private
  protected
    fServer: TSQLRestServer;
    fChild: TList;
    fChildCount: integer;
    fPipeName: TFileName;
    procedure Execute; override;
  public
    /// create the server thread
    constructor Create(aServer: TSQLRestServer; const PipeName: TFileName);
    /// release all associated memory, and wait for all
    // TSQLRestServerNamedPipeResponse children to be terminated
    destructor Destroy; override;
    /// the associated pipe name
    property PipeName: TFileName read fPipeName;
  end;

  /// Server child thread dealing with a connection through a named pipe
  TSQLRestServerNamedPipeResponse = class(TThread)
  private
  protected
    fServer: TSQLRestServer;
    fPipe: cardinal;
    fMasterThread: TSQLRestServerNamedPipe;
    fMasterThreadChildIndex: Integer;
    procedure Execute; override;
    {$ifndef LVCL}
    // will release any thread-specific resource (e.g. external DB connection)
    procedure DoTerminate; override;
    {$endif}
  public
    /// create the child connection thread
    constructor Create(aServer: TSQLRestServer; aMasterThread: TSQLRestServerNamedPipe;
      aPipe: cardinal);
    /// release all associated memory, and decrement fMasterThread.fChildCount
    destructor Destroy; override;
  end;

{$ifdef FPC}
  TWMCopyData = packed record
    Msg: Cardinal;
    From: HWND;
    CopyDataStruct: PCopyDataStruct;
    Result: Longint;
  end;
{$endif}
{$endif}

  /// function prototype for remotely calling a TSQLRestServer
  // - use PUTF8Char instead of string: no need to share a memory manager, and can
  // be used with any language (even C or .NET, thanks to the cdecl calling convention)
  // - you can specify some POST/PUT data in SendData (leave as nil otherwise)
  // - returns in result.Lo the HTTP STATUS integer error or success code
  // - returns in result.Hi the server database internal status
  // - on success, allocate and store the resulting JSON body into Resp^, headers in Head^
  // - use a GlobalFree() function to release memory for Resp and Head responses
  TURIMapRequest = function(url, method, SendData: PUTF8Char; Resp, Head: PPUTF8Char): Int64Rec; cdecl;

{$ifdef MSWINDOWS}
  {$define WITHSTATPROCESS}
  // if defined, the server statistics will contain precise working time process
{$endif}

  /// structure used to specify custom request paging parameters for TSQLRestServer
  // - default values are the one used for YUI component paging (i.e.
  // PAGINGPARAMETERS_YAHOO constant, as set by TSQLRestServer.Create)
  // - warning: using paging can be VERY expensive on Server side, especially
  // when used with external databases (since all data is retrieved before
  // paging, when SQLite3 works in virtual mode)
  TSQLRestServerURIPagingParameters = record
    /// parameter name used to specify the request sort order
    // - default value is 'SORT='
    Sort: PAnsiChar;
    /// parameter name used to specify the request sort direction
    // - default value is 'DIR='
    Dir: PAnsiChar;
    /// parameter name used to specify the request starting offset
    // - default value is 'STARTINDEX='
    StartIndex: PAnsiChar;
    /// parameter name used to specify the request the page size (LIMIT clause)
    // - default value is 'RESULTS='
    Results: PAnsiChar;
    /// parameter name used to specify the request field names
    // - default value is 'SELECT='
    Select: PAnsiChar;
    /// parameter name used to specify the request WHERE clause
    // - default value is 'WHERE='
    Where: PAnsiChar;
    /// returned JSON field value of optional total row counts
    // - default value is nil, i.e. no total row counts field
    // - computing total row counts can be very expensive, depending on the
    // database back-end used (especially for external databases)
    // - can be set e.g. to ',"totalRows":%' value (note that the initial "," is
    // expected by the produced JSON content, and % will be set with the value)
    SendTotalRowsCountFmt: PUTF8Char;
  end;

  /// used for statistics update in TSQLRestServer.URI()
  TSQLRestServerStats = class(TPersistent)
  private
    /// used to determine if something changed
    fLastIncomingBytes: QWord;
    /// current count of connected clients
    fClientsCurrent,
    /// max count of connected clients
    fClientsMax,
    /// count of invalid request
    fInvalid,
    /// count of valid responses (returned status code 200/HTML_SUCCESS or 201/HTML_CREATED)
    fResponses,
    /// count of requests which modified the data
    fModified,
    /// size of data requests processed in bytes (without the transfert protocol overhead)
    fIncomingBytes,
    /// size of data responses generated in bytes (without the transfert protocol overhead)
    fOutcomingBytes,
    /// count of the remote service calls
    fServices,
    /// count of files transmitted via STATICFILE_CONTENT_TYPE/HTTP_RESP_STATICFILE
    fOutcomingFiles: QWord;
    /// current thread counts
    fCurrentThreadCount: integer;
{$ifdef WITHSTATPROCESS}
    /// time used to process the requests, with appended unit ('0.13 ms' e.g.)
    function GetProcessTimeString: RawUTF8;
{$endif}
  public
{$ifdef WITHSTATPROCESS}
    /// high-resolution performance counter of the time used to process the requests
    // - this value depend on the high-resolution performance counter frequency
    // - use ProcessTime property below to get the time in seconds
    ProcessTimeCounter: Int64;
{$endif}
    /// update ClientsCurrent and ClientsMax
    procedure ClientConnect;
    /// update ClientsCurrent and ClientsMax
    procedure ClientDisconnect;
    /// get a standard message to be displayed with the above statistics
    // - return the published properties of this class as a JSON object
    function DebugMessage: RawUTF8;
    /// percent (0..100) of request which modified the data
    function ModifPercent: cardinal;
    /// return true if IncomingBytes value changed since last call
    function Changed: boolean;
  published
    /// current count of connected clients
    property ClientsCurrent: QWord read fClientsCurrent;
    /// max count of connected clients
    property ClientsMax: QWord read fClientsMax;
    /// count of invalid request
    property Invalid: QWord read fInvalid;
    /// count of valid responses (returned status code 200/HTML_SUCCESS or 201/HTML_CREATED)
    property Responses: QWord read fResponses;
    /// count of requests which modified the data
    property Modified: QWord read fModified;
    /// size of data requests processed in bytes (without the transfert protocol overhead)
    property IncomingBytes: QWord read fIncomingBytes;
    /// size of data responses generated in bytes (without the transfert protocol overhead)
    property OutcomingBytes: QWord read fOutcomingBytes;
    /// count of files transmitted directly (not part of OutcomingBytes)
    // - i.e. when the service uses STATICFILE_CONTENT_TYPE/HTTP_RESP_STATICFILE
    // as content type to let the HTTP server directly serve the file content
    property OutcomingFiles: QWord read fOutcomingFiles;
    /// count of the remote service calls
    property ServiceCalls: QWord read fServices;
    /// number of current declared thread counts
    // - as registered by BeginCurrentThread/EndCurrentThread
    property CurrentThreadCount: integer read fCurrentThreadCount;
{$ifdef WITHSTATPROCESS}
    /// the global time spent in the server process
    property ProcessTime: RawUTF8 read GetProcessTimeString;
{$endif}
  end;

  TAuthSession = class;

  ///  used to define how to trigger Events on record update
  // - see TSQLRestServer.OnUpdateEvent property and InternalUpdateEvent() method
  // - returns true on success, false if an error occured (but action must continue)
  // - to be used only server-side, not to synchronize some clients: the framework
  // is designed around a stateless RESTful architecture (like HTTP/1.1), in which
  // clients ask the server for refresh (see TSQLRestClientURI.UpdateFromServer)
  TNotifySQLEvent = function(Sender: TSQLRestServer; Event: TSQLEvent;
    aTable: TSQLRecordClass; aID: integer): boolean of object;
  ///  used to define how to trigger Events on record field update
  // - see TSQLRestServer.OnBlobUpdateEvent property and InternalUpdateEvent() method
  // - returns true on success, false if an error occured (but action must continue)
  // - to be used only server-side, not to synchronize some clients: the framework
  // is designed around a stateless RESTful architecture (like HTTP/1.1), in which
  // clients ask the server for refresh (see TSQLRestClientURI.UpdateFromServer)
  TNotifyFieldSQLEvent = function(Sender: TSQLRestServer; Event: TSQLEvent;
    aTable: TSQLRecordClass; aID: integer; const aAffectedFields: TSQLFieldBits): boolean of object;
  /// session-related callbacks triggered by TSQLRestServer
  // - for OnSessionCreate, returning TRUE will abort the session creation -
  // and you can set Ctxt.Call^.OutStatus to a corresponding error code
  TNotifySQLSession = function(Sender: TSQLRestServer; Session: TAuthSession;
    Ctxt: TSQLRestServerURIContext): boolean of object;

  /// a set of potential actions to be executed from the server
  // - reSQL will indicate the right to execute any POST SQL statement (not only
  // SELECT statements)
  // - reService will indicate the right to execute the interface-based JSON-RPC
  // service implementation
  // - reUrlEncodedSQL will indicate the right to execute a SQL query encoded
  // at the URI level, for a GET (to be used e.g. with XMLHTTPRequest, which
  // forced SentData='' by definition), encoded as sql=.... inline parameter
  // - reUrlEncodedDelete will indicate the right to delete items using a
  // WHERE clause for DELETE verb at /root/TableName?WhereClause
  // - reOneSessionPerUser will force that only one session may be created
  // for one user, even if connection comes from the same IP: in this case,
  // you may have to set the SessionTimeOut to a small value, in case the
  // session is not closed gracefully 
  TSQLAllowRemoteExecute = set of (
    reSQL, reService, reUrlEncodedSQL, reUrlEncodedDelete, reOneSessionPerUser);

  /// set the User Access Rights, for each Table
  // - one property for every and each URI method (GET/POST/PUT/DELETE)
  // - one bit for every and each Table in Model.Tables[]
  {$ifdef UNICODE}
  TSQLAccessRights = record
  {$else}
  TSQLAccessRights = object
  {$endif}
    /// set of allowed actions on the server side
    AllowRemoteExecute: TSQLAllowRemoteExecute;
    /// GET method (retrieve record) table access bits
    // - note that a GET request with a SQL statement without a table (i.e.
    // on 'ModelRoot' URI with a SQL statement as SentData, as used in
    // TSQLRestClientURI.UpdateFromServer) is always valid, whatever the bits
    // here are: since TSQLRestClientURI.UpdateFromServer() is called only
    // for refreshing a direct statement, it will be OK; you can improve this
    // by overriding the TSQLRestServer.URI() method
    // - if the REST request is LOCK, the PUT access bits will be read instead
    // of the GET bits value
    GET: TSQLFieldTables;
    /// POST method (create record) table access bits
    POST: TSQLFieldTables;
    /// PUT method (update record) table access bits
    // - if the REST request is LOCK, the PUT access bits will be read instead
    // of the GET bits value
    PUT: TSQLFieldTables;
    /// DELETE method (delete record) table access bits
    DELETE: TSQLFieldTables;
    /// wrapper method which can be used to set the CRUD abilities over a table
    // - C=Create, R=Read, U=Update, D=Delete rights
    procedure Edit(aTableIndex: integer; C, R, U, D: Boolean); overload;
    /// wrapper method which can be used to set the CRUD abilities over a table
    // - use TSQLOccasion set as parameter
    procedure Edit(aTableIndex: integer; aRights: TSQLOccasions); overload;
    /// serialize the content as TEXT
    // - use the TSQLAuthGroup.AccessRights CSV format
    function ToString: RawUTF8;
    /// unserialize the content from TEXT
    // - use the TSQLAuthGroup.AccessRights CSV format
    procedure FromString(P: PUTF8Char);
  end;

  TSQLRestStorageClass = class of TSQLRestStorage;
  TSQLRestStorageInMemory = class;
  TSQLVirtualTableModule = class;


  {/ table containing the available user access rights for authentication
    - this class should be added to the TSQLModel, together with TSQLAuthUser,
      to allow authentication support
    - you can inherit from it to add your custom properties to each user info:
      TSQLModel will search for any class inheriting from TSQLAuthGroup to
      manage per-group authorization data
    - by default, it won't be accessible remotely by anyone }
  TSQLAuthGroup = class(TSQLRecord)
  private
    fIdent: RawUTF8;
    fSessionTimeOut: integer;
    fAccessRights: RawUTF8;
    function GetSQLAccessRights: TSQLAccessRights;
    procedure SetSQLAccessRights(const Value: TSQLAccessRights);
  public
    /// called when the associated table is created in the database
    // - on a new database, if TSQLAuthUser and TSQLAuthGroup tables are defined
    // in the associated TSQLModel, it this will add 'Admin', 'Supervisor',
    // and 'User' rows in the AuthUser table (with 'synopse' as default password),
    // and associated 'Admin', 'Supervisor', 'User' and 'Guest' groups, with the
    // following access rights to the AuthGroup table:
    // $           POST SQL  Service  Auth R  Auth W  Tables R  Tables W
    // $ Admin        Yes      Yes     Yes     Yes      Yes      Yes
    // $ Supervisor   No       Yes     Yes     No       Yes      Yes
    // $ User         No       Yes     No      No       Yes      Yes
    // $ Guest        No       No      No      No       Yes      No
    // 'Admin' will be the only able to execute remote not SELECT SQL statements
    // for POST commands (reSQL in TSQLAccessRights.AllowRemoteExecute) and
    // modify the Auth tables (i.e. AuthUser and AuthGroup), and Guest won't have
    // access to the interface-based remote JSON-RPC service (no reService)
    // - you MUST override those default 'synopse' password to a custom value
    // - of course, you can change and tune the settings of the AuthGroup and
    // AuthUser tables, but only 'Admin' group users will be able to remotly
    // modify the content of those table
    class procedure InitializeTable(Server: TSQLRestServer; const FieldName: RawUTF8); override;
    /// corresponding TSQLAccessRights for this authentication group
    // - content is converted into/from text format via AccessRight DB property
    // (so it will be not fixed e.g. by the binary TSQLFieldTables layout, i.e.
    // the MAX_SQLTABLES constant value)
    property SQLAccessRights: TSQLAccessRights read GetSQLAccessRights write SetSQLAccessRights;
  published
    /// the access right identifier, ready to be displayed
    // - the same identifier can be used only once (this column is marked as
    // unique via a "stored AS_UNIQUE" (i.e. "stored false") attribute)
    // - so you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fClient.MainFieldID(TSQLAuthGroup,'User');
    property Ident: RawUTF8 index 50 read fIdent write fIdent stored AS_UNIQUE;
    /// the number of minutes a session is kept alive
    property SessionTimeout: integer read fSessionTimeOut write fSessionTimeOut;
    /// a textual representation of a TSQLAccessRights buffer
    property AccessRights: RawUTF8 index 1600 read fAccessRights write fAccessRights;
  end;

  /// class of the table containing the available user access rights for authentication
  TSQLAuthGroupClass = class of TSQLAuthGroup;

  {/ table containing the Users registered for authentication
    - this class should be added to the TSQLModel, together with TSQLAuthGroup,
      to allow authentication support
    - you can inherit from it to add your custom properties to each user info:
      TSQLModel will search for any class inheriting from TSQLAuthUser to manage
      per-user authorization data
    - by default, it won't be accessible remotely by anyone; to enhance security,
      you could use the TSynValidatePassWord filter to this table  }
  TSQLAuthUser = class(TSQLRecord)
  protected
    fLogonName: RawUTF8;
    fPasswordHashHexa: RawUTF8;
    fDisplayName: RawUTF8;
    fGroup: TSQLAuthGroup;
    fData: TSQLRawBlob;
    procedure SetPasswordPlain(const Value: RawUTF8);
  public
    /// able to set the PasswordHashHexa field from a plain password content
    // - in fact, PasswordHashHexa := SHA256('salt'+PasswordPlain) in UTF-8
    property PasswordPlain: RawUTF8 write SetPasswordPlain;
  published
    /// the User identification Name, as entered at log-in
    // - the same identifier can be used only once (this column is marked as
    // unique via a "stored AS_UNIQUE" - i.e. "stored false" - attribute), and
    // therefore indexed in the database (e.g. hashed in TSQLRestStorageInMemory)
    property LogonName: RawUTF8 index 20 read fLogonName write fLogonName stored AS_UNIQUE;
    /// the User Name, as may be displayed or printed
    property DisplayName: RawUTF8 index 50 read fDisplayName write fDisplayName;
    /// the hexa encoded associated SHA-256 hash of the password
    property PasswordHashHexa: RawUTF8 index 64 read fPasswordHashHexa write fPasswordHashHexa;
    /// the associated access rights of this user
    // - access rights are managed by group
    // - in TAuthSession.User instance, GroupRights property will contain a
    // REAL TSQLAuthGroup instance for fast retrieval in TSQLRestServer.URI
    // - note that 'Group' field name is not allowed by SQLite
    property GroupRights: TSQLAuthGroup read fGroup write fGroup;
    /// some custom data, associated to the User
    // - Server application may store here custom data
    // - its content is not used by the framework but 'may' be used by your
    // application
    property Data: TSQLRawBlob read fData write fData;
  end;

  /// class of the table containing the Users registered for authentication
  TSQLAuthUserClass = class of TSQLAuthUser;

  {/ class used to maintain in-memory sessions
    - this is not a TSQLRecord table so won't be remotely accessible, for
      performance and security reasons
    - the User field is a true instance, copy of the corresponding database
      content (for better speed)
    - you can inherit from this class, to add custom session process }
  TAuthSession = class
  private
    fUser: TSQLAuthUser;
    fLastAccess64: Int64;
    fID: RawUTF8;
    fIDCardinal: cardinal;
    fTimeOutMS: cardinal;
    fAccessRights: TSQLAccessRights;
    fPrivateKey: RawUTF8;
    fPrivateSalt: RawUTF8;
    fSentHeaders: RawUTF8;
    fRemoteIP: RawUTF8;
    fConnectionID: RawUTF8;
    fPrivateSaltHash: Cardinal;
    fLastTimeStamp: Cardinal;
  public
    /// initialize a session instance with the supplied TSQLAuthUser instance
    // - this aUser instance will be handled by the class until Destroy
    // - raise an exception on any error
    // - on success, will also retrieve the aUser.Data BLOB field content
    constructor Create(aCtxt: TSQLRestServerURIContext; aUser: TSQLAuthUser);
    /// will release the User and User.GroupRights instances
    destructor Destroy; override;
    /// check if the session_signature=... parameter is correct
    // - session_signature=... is expected at the end of the URL, i.e.
    // aURL[aURLLength+1] will point e.g. to '?session_signature=...':
    // the caller must ensure that aURL[] follows this expected layout
    // - will expect the format as generated by TSQLRestClientURI.SessionSign()
    function IsValidURL(Ctxt: TSQLRestServerURIContext): boolean; virtual;
  public
    /// the session ID number, as text
    property ID: RawUTF8 read fID;
    /// the session ID number, as numerical value
    // - never equals to 1 (CONST_AUTHENTICATION_NOT_USED, i.e. authentication
    // mode is not enabled), nor 0 (CONST_AUTHENTICATION_SESSION_NOT_STARTED,
    // i.e. session still in handshaking phase)
    property IDCardinal: cardinal read fIDCardinal;
    /// the associated User
    // - this is a true TSQLAuthUser instance, and User.GroupRights will contain
    // also a true TSQLAuthGroup instance
    property User: TSQLAuthUser read fUser;
    /// set by the Access() method to the current GetTickCount64() time stamp
    property LastAccess64: Int64 read fLastAccess64;
    /// copy of the associated user access rights
    // - extracted from User.TSQLAuthGroup.SQLAccessRights
    property AccessRights: TSQLAccessRights read fAccessRights;
    /// the number of milliseconds a session is kept alive
    // - extracted from User.TSQLAuthGroup.SessionTimeout
    // - allow direct comparison with GetTickCount64() API call
    property TimeoutMS: cardinal read fTimeOutMS;
    /// the hexadecimal private key as returned to the connected client
    // as 'SessionID+PrivateKey'
    property PrivateKey: RawUTF8 read fPrivateKey;
    /// the transmitted HTTP headers, if any
    // - can contain e.g. 'RemoteIp: 127.0.0.1' or 'User-Agent: Mozilla/4.0'
    property SentHeaders: RawUTF8 read fSentHeaders;
    /// the remote IP, if any
    // - is extracted from SentHeaders properties
    property RemoteIP: RawUTF8 read fRemoteIP;
    /// a remote connection identifier, if any
    // - is extracted from SentHeaders properties
    property ConnectionID: RawUTF8 read fConnectionID;
  end;

  /// used to define overridden session instances
  // - this all sessions remain in memory, ensure they are not taking too
  // much resource (memory or process time)
  TAuthSessionClass = class of TAuthSession;

  TSQLRestServerAuthentication = class;

  /// used to define an authentication scheme by its implementation class
  TSQLRestServerAuthenticationClass = class of TSQLRestServerAuthentication;

  /// maintain a list of TSQLRestServerAuthentication instances
  TSQLRestServerAuthenticationDynArray = array of TSQLRestServerAuthentication;

  /// define how TSQLRestServerAuthentication.ClientSetUser() should interpret
  // the supplied password
  // - passClear means that the password is not encrypted, e.g. as entered
  // by the user in the login screen
  // - passHashed means that the passwod is already hashed as in
  // TSQLAuthUser.PasswordHashHexa i.e. SHA256('salt'+Value)
  // - passKerberosSPN indicates that the password is the Kerberos SPN domain
  TSQLRestServerAuthenticationClientSetUserPassword = (
    passClear, passHashed, passKerberosSPN);

  /// abstract class used to implement server-side authentication in TSQLRestServer
  // - inherit from this class to implement expected authentication scheme
  TSQLRestServerAuthentication = class
  protected
    fServer: TSQLRestServer;
    // GET ModelRoot/auth?UserName=...&Session=... -> release session
    function AuthSessionRelease(Ctxt: TSQLRestServerURIContext): boolean;
    /// retrieve an User instance from its logon name
    // - should return nil if not found
    // - this default implementation will retrieve it from ORM
    // - you can override this method and return an on-the-fly created value
    // as a TSQLRestServer.SQLAuthUserClass instance (i.e. not persisted
    // in database nor retrieved by ORM), but the resulting TSQLAuthUser
    // must have its ID and LogonName properties set with unique values (which
    // will be used to identify it for a later call and session owner
    // identification), and its GroupRights property must contain a REAL
    // TSQLAuthGroup instance for fast retrieval in TSQLRestServer.URI 
    function GetUser(Ctxt: TSQLRestServerURIContext;
      const aUserName: RawUTF8): TSQLAuthUser; virtual;
    /// create a session on the server for a given user
    // - this default implementation will call fServer.SessionCreate() and
    // return a '{"result":"HEXASALT","logonname":"UserName"}' JSON content
    // and will always call User.Free
    procedure SessionCreate(Ctxt: TSQLRestServerURIContext; var User: TSQLAuthUser); virtual;
    /// abstract method which will be called by ClientSetUser() to process the
    // authentication step on the client side
    // - at call, a TSQLAuthUser instance will be supplied, with LogonName set
    // with aUserName and PasswordHashHexa with a SHA-256 hash of aPassword
    // - override with the expected method, returning the session key on success
    class function ClientComputeSessionKey(Sender: TSQLRestClientURI; User: TSQLAuthUser): RawUTF8;
      virtual; abstract;
  public
    /// initialize the authentication method to a specified server
    // - you can define several authentication schemes for the same server
    constructor Create(aServer: TSQLRestServer); virtual;
    /// called by the Server to implement the Auth RESTful method
    // - overridden method shall return TRUE if the request has been handled
    // - returns FALSE to let the next registered TSQLRestServerAuthentication
    // class to try implementing the content
    // - Ctxt.Parameters has been tested to contain an UserName=... value
    // - method execution is protected by TSQLRestServer.fSessionCriticalSection
    function Auth(Ctxt: TSQLRestServerURIContext): boolean; virtual; abstract;
    /// called by the Server to check if the execution context match a session
    // - returns a session instance corresponding to the remote request
    // - returns nil if this remote request does not match this authentication
    // - method execution is protected by TSQLRestServer.fSessionCriticalSection
    function RetrieveSession(Ctxt: TSQLRestServerURIContext): TAuthSession; virtual; abstract;
    /// class method to be used on client side to create a remote session
    // - call this method instead of TSQLRestClientURI.SetUser() if you need
    // a custom authentication class
    // - will call the ModelRoot/Auth service, i.e. call TSQLRestServer.Auth()
    // published method to create a session for this user
    // - returns true on success
    class function ClientSetUser(Sender: TSQLRestClientURI; const aUserName, aPassword: RawUTF8;
      aPassworKind: TSQLRestServerAuthenticationClientSetUserPassword=passClear): boolean; virtual; 
    /// class method to be called on client side to sign an URI
    // - used by TSQLRestClientURI.URI()
    // - shall match the method as expected by RetrieveSession() virtual method
    class function ClientSessionSign(Sender: TSQLRestClientURI;
      const url: RawUTF8): RawUTF8; virtual; abstract;
  end;

  /// weak authentication scheme using URL-level parameter
  TSQLRestServerAuthenticationURI = class(TSQLRestServerAuthentication)
  public
    /// will check URI-level signature
    // - retrieve the session ID from 'session_signature=...' parameter 
    function RetrieveSession(Ctxt: TSQLRestServerURIContext): TAuthSession; override;
    /// class method to be called on client side to add the SessionID to the URI
    // - append '&session_signature=SessionID' to the url
    class function ClientSessionSign(Sender: TSQLRestClientURI;
      const url: RawUTF8): RawUTF8; override;
  end;

  /// secure authentication scheme using URL-level digital signature
  TSQLRestServerAuthenticationSignedURI = class(TSQLRestServerAuthenticationURI)
  public
    /// will check URI-level signature
    // - check session_signature=... parameter to be a valid digital signature
    function RetrieveSession(Ctxt: TSQLRestServerURIContext): TAuthSession; override;
    /// class method to be called on client side to sign an URI
    // - generate the digital signature as expected by overridden RetrieveSession()
    // - will use the TAuthSession.IsValidURL() format; in particular, timestamp
    // resolution is about 256 ms in the current implementation
    // - append '&session_signature=SessionID+....' to the url
    class function ClientSessionSign(Sender: TSQLRestClientURI;
      const url: RawUTF8): RawUTF8; override;
  end;

  /// mORMot secure RESTful authentication scheme
  // - this method will use a password stored via safe SHA-256 hashing in the
  // TSQLAuthUser ORM table
  TSQLRestServerAuthenticationDefault = class(TSQLRestServerAuthenticationSignedURI)
  protected
    /// check a supplied password content
    // - will match ClientComputeSessionKey() algorithm as overridden here, i.e.
    // a SHA-256 based signature with a 10 minutes activation window
    function CheckPassword(Ctxt: TSQLRestServerURIContext;
      User: TSQLAuthUser; const aClientNonce, aPassWord: RawUTF8): boolean; virtual;
    /// class method used on client side to create a remote session
    // - will call the ModelRoot/Auth service, i.e. call TSQLRestServer.Auth()
    // published method to create a session for this user: so
    // TSQLRestServerAuthenticationDefault should be registered on server side
    // - User.LogonName and User.PasswordHashHexa will be checked
    class function ClientComputeSessionKey(Sender: TSQLRestClientURI; User: TSQLAuthUser): RawUTF8; override;
  public
    /// will try to handle the Auth RESTful method with mORMot authentication
    // - to be called in a two pass "challenging" algorithm:
    // $ GET ModelRoot/auth?UserName=...
    // $  -> returns an hexadecimal nonce contents (valid for 5 minutes)
    // $ GET ModelRoot/auth?UserName=...&PassWord=...&ClientNonce=...
    // $ -> if password is OK, will open the corresponding session
    // $    and return 'SessionID+HexaSessionPrivateKey'
    // The Password parameter as sent for the 2nd request will be computed as
    // ! Sha256(ModelRoot+Nonce+ClientNonce+UserName+Sha256('salt'+PassWord))
    // - the returned HexaSessionPrivateKey content will identify the current
    // user logged and its corresponding session (the same user may have several
    // sessions opened at once, each with its own private key)
    // - then the private session key must be added to every query sent to
    // the server as a session_signature=???? parameter, which will be computed
    // as such:
    // $ ModelRoot/url?A=1&B=2&session_signature=012345670123456701234567
    // were the session_signature= parameter will be computed as such:
    // ! Hexa8(SessionID)+Hexa8(TimeStamp)+
    // ! Hexa8(crc32('SessionID+HexaSessionPrivateKey'+Sha256('salt'+PassWord)+
    // !  Hexa8(TimeStamp)+url))
    // ! with url='ModelRoot/url?A=1&B=2'
    // this query authentication uses crc32 for hashing instead of SHA-256 in
    // in order to lower the Server-side CPU consumption; the salted password
    // (i.e. TSQLAuthUser.PasswordHashHexa) and client-side TimeStamp are
    // inserted inside the session_signature calculation to prevent naive
    // man-in-the-middle attack (MITM)
    // - the session ID will be used to retrieve the rights associated with the
    // user which opened the session via a successful call to the Auth service
    // - when you don't need the session any more (e.g. if the TSQLRestClientURI
    // instance is destroyed), you can call the service as such:
    // $ GET ModelRoot/auth?UserName=...&Session=...
    // - for a way of computing SHA-256 in JavaScript, see for instance
    // @http://www.webtoolkit.info/javascript-sha256.html
    function Auth(Ctxt: TSQLRestServerURIContext): boolean; override;
  end;

  /// mORMot weak RESTful authentication scheme
  // - this method will authenticate with a given username, but no signature
  // - on client side, this scheme is not called by TSQLRestClientURI.SetUser()
  // method - so you have to write:
  // ! TSQLRestServerAuthenticationNone.ClientSetUser(Client,'User','');
  TSQLRestServerAuthenticationNone = class(TSQLRestServerAuthenticationURI)
  protected
    /// class method used on client side to create a remote session
    // - will call the ModelRoot/Auth service, i.e. call TSQLRestServer.Auth()
    // published method to create a session for this user: so
    // TSQLRestServerAuthenticationNone should be registered on server side
    // - will check User.LogonName, but User.PasswordHashHexa will be ignored
    class function ClientComputeSessionKey(Sender: TSQLRestClientURI; User: TSQLAuthUser): RawUTF8; override;
  public
    /// will check URI-level signature
    // - retrieve the session ID from 'session_signature=...' parameter
    function RetrieveSession(Ctxt: TSQLRestServerURIContext): TAuthSession; override;
    /// will try to handle the Auth RESTful method with mORMot authentication
    // - to be called in a weak one pass request:
    // $ GET ModelRoot/auth?UserName=...
    // $ -> if the specified user name exists, will open the corresponding
    // $    session and return 'SessionID+HexaSessionPrivateKey'
    function Auth(Ctxt: TSQLRestServerURIContext): boolean; override;
  end;

  {$ifdef SSPIAUTH}
  /// authentication using Windows Security Support Provider Interface (SSPI)
  // - is able to authenticate using either NTLM or Kerberos
  // - ClientSetUser() will ignore aUserName, and expect aPassword to be either
  // '' if you expect NTLM authentication to take place, or contain the SPN
  // registration (e.g. 'mymormotservice/myserver.mydomain.tld') for Kerberos
  // authentication
  TSQLRestServerAuthenticationSSPI = class(TSQLRestServerAuthenticationSignedURI)
  protected
    /// Windows built-in authentication
    // - holds information between calls to ServerSSPIAuth
    fSSPIAuthContexts: TSecContextDynArray;
    /// class method used on client side to create a remote session
    // - will call the ModelRoot/Auth service, i.e. call TSQLRestServer.Auth()
    // published method to create a session for this user: so
    // TSQLRestServerAuthenticationSSPI should be registered on server side
    // - Windows SSPI authentication will be performed - in this case,
    // table TSQLAuthUser shall contain an entry for the logged Windows user,
    // with the LoginName in form 'DomainName\UserName'
    // - here User.LogonName is ignored, and User.PasswordHashHexa is '' for
    // NTLM authentication, or the SPN registration for Kerberos authentication
    class function ClientComputeSessionKey(Sender: TSQLRestClientURI; User: TSQLAuthUser): RawUTF8; override;
  public
    /// initialize the authentication method to a specified server
    constructor Create(aServer: TSQLRestServer); override;
    /// finalize internal memory structures
    destructor Destroy; override;
    /// will try to handle the Auth RESTful method with Windows SSPI API
    // - to be called in a two pass "challenging" algorithm, as implemented by
    // TSQLRestServerAuthenticationSignedURI.Auth method
    // - the client-side logged user will be identified as valid, according
    // to a Windows SSPI API secure challenge
    function Auth(Ctxt: TSQLRestServerURIContext): boolean; override;
  end;
  {$endif}

  /// common ancestor for tracking changes on TSQLRecord tables
  // - used by TSQLRestServer.TrackChanges() method for simple fields history
  // - TSQLRestServer.InternalUpdateEvent will use this table to store individual
  // row changes as SentDataJSON, then will compress them in History BLOB
  // - note that any layout change of the tracked TSQLRecord table (e.g. adding
  // a new property) would break the internal data format, so will void the table
  TSQLRecordHistory = class(TSQLRecord)
  protected
    fModifiedRecord: PtrInt;
    fEvent: TSQLEvent;
    fSentData: RawUTF8;
    fTimeStamp: TModTime;
    fHistory: TSQLRawBlob;
    // BLOB storage layout is: RTTIheader + offsets + recordsdata
    fHistoryModel: TSQLModel;
    fHistoryTable: TSQLRecordClass;
    fHistoryTableIndex: integer;
    fHistoryUncompressed: RawByteString;
    fHistoryUncompressedCount: integer;
    fHistoryUncompressedOffset: TIntegerDynArray;
    fHistoryAdd: TFileBufferWriter;
    fHistoryAddCount: integer;
    fHistoryAddOffset: TIntegerDynArray;
  public
    /// load the change history of a given record
    // - then you can use HistoryGetLast, HistoryCount or HistoryGet() to access
    // all previous stored versions
    constructor CreateHistory(aClient: TSQLRest; aTable: TSQLRecordClass; aID: integer);
    /// finalize any internal memory
    destructor Destroy; override;
    /// returns the modified record table, as stored in ModifiedRecord
    function ModifiedTable(Model: TSQLModel): TSQLRecordClass;
    /// returns the record table index in the TSQLModel, as stored in ModifiedRecord
    function ModifiedTableIndex: integer;
    /// returns the modified record ID, as stored in ModifiedRecord
    function ModifiedID: PtrInt;
    /// called when the associated table is created in the database
    // - create index on History(ModifiedRecord,History) for process speed-up
    class procedure InitializeTable(Server: TSQLRestServer; const FieldName: RawUTF8); override;
  public
    /// prepare to access the History BLOB content
    // - ModifiedRecord should have been set to a proper value
    // - returns FALSE if the History BLOB is incorrect (e.g. TSQLRecord
    // layout changed): caller shall flush all previous history
    function HistoryOpen(Model: TSQLModel): boolean;
    /// returns how many revisions are stored in the History BLOB
    // - HistoryOpen() or CreateHistory() should have been called before 
    // - this method will ignore any previous HistoryAdd() call
    function HistoryCount: integer;
    /// retrieve an historical version
    // - HistoryOpen() or CreateHistory() should have been called before 
    // - this method will ignore any previous HistoryAdd() call
    // - if Rec=nil, will only retrieve Event and TimeStamp
    // - if Rec is set, will fill all simple properties of this TSQLRecord  
    function HistoryGet(Index: integer; out Event: TSQLEvent;
      out TimeStamp: TModTime; Rec: TSQLRecord): boolean;
    /// retrieve the latest stored historical version
    // - HistoryOpen() or CreateHistory() should have been called before 
    // - this method will ignore any previous HistoryAdd() call
    // - you should not have to use it, since a TSQLRest.Retrieve() is faster
    function HistoryGetLast(Rec: TSQLRecord): boolean; overload;
    /// retrieve the latest stored historical version
    // - HistoryOpen() or CreateHistory() should have been called before,
    // otherwise it will return nil 
    // - this method will ignore any previous HistoryAdd() call
    // - you should not have to use it, since a TSQLRest.Retrieve() is faster
    function HistoryGetLast: TSQLRecord; overload;
    /// add a record content to the History BLOB
    // - HistoryOpen() should have been called before using this method -
    // CreateHistory() won't allow history modification
    // - use then HistorySave() to compress and replace the History field
    procedure HistoryAdd(Rec: TSQLRecord; Hist: TSQLRecordHistory);
    /// update the History BLOB field content
    // - HistoryOpen() should have been called before using this method -
    // CreateHistory() won't allow history modification
    // - if HistoryAdd() has not been used, returns false
    // - ID field should have been set for proper persistence on Server
    // - otherwise compress the data into History BLOB, deleting the oldest
    // versions if resulting size is biggger than expected, and returns true
    // - if Server is set, write save the History BLOB to database 
    // - if Server and LastRec are set, its content will be compared with the
    // current record in DB (via a Retrieve() call) and stored: it will allow
    // to circumvent any issue about inconsistent use of tracking, e.g. if the
    // database has been modified directly, by-passing the ORM
    function HistorySave(Server: TSQLRestServer;
      LastRec: TSQLRecord=nil): boolean;
  published
    /// identifies the modified record
    // - ID and table index in TSQLModel is stored as one RecordRef integer
    // - you can use ModifiedTable/ModifiedID to retrieve the TSQLRecord item
    // - in case of the record deletion, all matching TSQLRecordHistory won't
    // be touched by TSQLRestServer.AfterDeleteForceCoherency(): so this
    // property is a plain integer, not a TRecordReference field
    property ModifiedRecord: PtrInt read fModifiedRecord;
    /// the kind of modification stored
    // - seUpdateBlob is never tracked here
    property Event: TSQLEvent read fEvent;
    /// for seAdd/seUpdate, the data stored as JSON
    // - note that we defined a default maximum size of 4KB for this column,
    // to avoid using a CLOB here
    property SentDataJSON: RawUTF8 index 4000 read fSentData;
    /// when the modification was recorded
    property TimeStamp: TModTime read fTimeStamp;
    /// after some events are written as individual SentData content, they
    // will be gathered and compressed within one BLOB field
    // - use HistoryOpen/HistoryCount/HistoryGet to access the stored data
    // - as any BLOB field, this one won't be retrieved by default: use
    // explicitly TSQLRest.RetrieveBlobFields(aRecordHistory) to get it
    property History: TSQLRawBlob read fHistory;
  end;

  /// specifies the storage table to be used for tracking TSQLRecord changes
  // - you can create your custom type from TSQLRecordHistory, even for a
  // particular table, to split the tracked changes storage in several tables:
  // ! type
  // !  TSQLRecordMyHistory = class(TSQLRecordHistory);
  // - as expected by TSQLRestServer.TrackChanges() method 
  TSQLRecordHistoryClass = class of TSQLRecordHistory;

  { we need the RTTI information to be compiled for the published methods
    of this TSQLRestServer class and its children (like TPersistent), to
    enable Server-Side ModelRoot/[TableName/[TableID/]]MethodName requests
      -> see TSQLRestServerCallBack }

  /// a generic REpresentational State Transfer (REST) server
  // - descendent must implement the protected EngineList() Retrieve() Add()
  // Update() Delete() methods
  // - automatic call of this methods by a generic URI() RESTful function
  // - any published method of descendants must match TSQLRestServerCallBack
  // prototype, and is expected to be thread-safe
  TSQLRestServer = class(TSQLRest)
  protected
    fStats: TSQLRestServerStats;
    fVirtualTableDirect: boolean;
    fNoAJAXJSON: boolean;
    fHandleAuthentication: boolean;
    fAfterCreation: boolean;
    /// the TSQLAuthUser and TSQLAuthGroup classes, as defined in model
    fSQLAuthUserClass: TSQLAuthUserClass;
    fSQLAuthGroupClass: TSQLAuthGroupClass;
    /// how in-memory sessions are handled
    fSessionClass: TAuthSessionClass;
    /// will contain the in-memory representation of some static tables
    // - this array has the same length as the associated Model.Tables[]
    // - fStaticData[] will contain pure in-memory tables, not declared as
    // SQLite3 virtual tables, therefore not available from joined SQL statements
    fStaticData: TSQLRestDynArray;
    /// map TSQLRestStorageInMemory or TSQLRestStorageExternal engines
    // - this array has the same length as the associated Model.Tables[]
    // - fStaticVirtualTable[] will contain in-memory or external tables declared
    // as SQLite3 virtual tables, therefore available from joined SQL statements
    fStaticVirtualTable: TSQLRestDynArray;
    /// in-memory storage of TAuthSession instances
    fSessions: TObjectList;
    /// used to compute genuine TAuthSession.ID cardinal value
    fSessionCounter: cardinal;
    /// mutex used to make fSessions[] use thread-safe
    fSessionCriticalSection: TRTLCriticalSection;
    fSessionAuthentications: IObjectDynArray; // must be defined before the array
    fSessionAuthentication: TSQLRestServerAuthenticationDynArray;
{$ifdef MSWINDOWS}
    /// thread initialized by ExportServerNamedPipe() to response to client through a pipe
    fExportServerNamedPipeThread: TSQLRestServerNamedPipe;
    /// internal server window handle, initialized by ExportServerMessage() method
    fServerWindow: HWND;
    /// internal server window class name, initialized by ExportServerMessage() method
    // - use "string" type, i.e. UnicodeString for Delphi 2009+, in order
    // to call directly the correct FindWindow?()=FindWindow Win32 API
    fServerWindowName: string;
{$endif}
    fPublishedMethod: TSQLRestServerMethods;
    fPublishedMethods: TDynArrayHashed;
    // TSQLRecordHistory.ModifiedRecord handles up to 64 (=1 shl 6) tables 
    fTrackChangesHistoryTableIndex: TIntegerDynArray;
    fTrackChangesHistory: array of record
      CurrentRow: integer;
      MaxSentDataJsonRow: integer;
      MaxRevisionJSON: integer;
      MaxUncompressedBlobSize: integer;
    end;
    /// fast get the associated static server, if any
    function GetStaticDataServer(aClass: TSQLRecordClass): TSQLRest;
    /// retrieve a TSQLRestStorage instance associated to a Virtual Table
    // - is e.g. TSQLRestStorageInMemory instance associated to a
    // TSQLVirtualTableBinary or TSQLVirtualTableJSON class
    // - may be a TSQLRestStorageExternal (as defined in mORMotDB unit)
    // for a virtual table giving access to an external database
    function GetVirtualTable(aClass: TSQLRecordClass): TSQLRest;
    /// fast get the associated static server or Virtual table, if any
    // - this can be used to call directly the TSQLRestStorage instance
    // on the server side
    // - same as a dual call to StaticDataServer[aClass] + StaticVirtualTable[aClass]
    // - TSQLRestServer.URI will make a difference between the a static server
    // or a TSQLVirtualTable, but this method won't - you can set a reference
    // to a TSQLRestServerKind variable to retrieve the database server type
    function GetStaticDataServerOrVirtualTable(aClass: TSQLRecordClass): TSQLRest; overload;
       {$ifdef HASINLINE}inline;{$endif}
    /// overloaded method using table index in associated Model
    function GetStaticDataServerOrVirtualTable(aTableIndex: integer): TSQLRest;
      overload; {$ifdef HASINLINE}inline;{$endif}
    function GetStaticDataServerOrVirtualTable(aTableIndex: integer;
      out Kind: TSQLRestServerKind): TSQLRest; overload;
       {$ifdef HASINLINE}inline;{$endif}
    /// retrieve a list of members as JSON encoded data - used by OneFieldValue()
    // and MultiFieldValue() public functions
    function InternalAdaptSQL(TableIndex: integer; var SQL: RawUTF8): TSQLRest;
    function InternalListRawUTF8(TableIndex: integer; const SQL: RawUTF8): RawUTF8;
    /// this method is overridden for setting the NoAJAXJSON field
    // of all associated TSQLRestStorage servers
    procedure SetNoAJAXJSON(const Value: boolean); virtual;
    /// add a new session to the internal session list
    // - do not use this method directly: this callback is to be used by
    // TSQLRestServerAuthentication* classes
    // - will check that the logon name is valid
    procedure SessionCreate(var User: TSQLAuthUser; Ctxt: TSQLRestServerURIContext;
      out Session: TAuthSession); virtual;
    /// fill the supplied context from the supplied aContext.Session ID
    // - returns nil if not found, or fill aContext.User/Group values if matchs
    // - this method will also check for outdated sessions, and delete them
    // - this method is not thread-safe: caller should use fSessionCriticalSection
    function SessionAccess(Ctxt: TSQLRestServerURIContext): TAuthSession;
    /// delete a session from its index in fSessions[]
    // - will perform any needed clean-up, and log the event
    // - this method is not thread-safe: caller should use fSessionCriticalSection
    procedure SessionDelete(aSessionIndex: integer; Ctxt: TSQLRestServerURIContext);
    /// returns TRUE if this table is worth caching (e.g. already in memory)
    // - this overridden implementation returns FALSE for TSQLRestStorageInMemory
    function CacheWorthItForTable(aTableIndex: cardinal): boolean; override;
    /// overridden methods which will perform CRUD operations
    // - will call any static TSQLRestStorage, or call MainEngine*() virtual methods
    function EngineAdd(TableModelIndex: integer; const SentData: RawUTF8): integer; override;
    function EngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8; override;
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8; override; 
    function EngineUpdate(TableModelIndex, ID: integer; const SentData: RawUTF8): boolean; override;
    function EngineDelete(TableModelIndex, ID: integer): boolean; override;
    function EngineDeleteWhere(TableModelIndex: integer; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; override;
    function EngineRetrieveBlob(TableModelIndex, aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateBlob(TableModelIndex, aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateField(TableModelIndex: integer;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
    function EngineBatchSend(Table: TSQLRecordClass; const Data: RawUTF8;
       var Results: TIntegerDynArray): integer; override;

    /// virtual methods which will perform CRUD operations on the main DB
    function MainEngineAdd(TableModelIndex: integer; const SentData: RawUTF8): integer; virtual; abstract;
    function MainEngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8; virtual; abstract;
    function MainEngineList(const SQL: RawUTF8; ForceAJAX: Boolean; ReturnedRowCount: PPtrInt): RawUTF8; virtual; abstract;
    function MainEngineUpdate(TableModelIndex, ID: integer; const SentData: RawUTF8): boolean; virtual; abstract;
    function MainEngineDelete(TableModelIndex, ID: integer): boolean; virtual; abstract;
    function MainEngineDeleteWhere(TableModelIndex: integer; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; virtual; abstract;
    function MainEngineRetrieveBlob(TableModelIndex, aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; virtual; abstract;
    function MainEngineUpdateBlob(TableModelIndex, aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; virtual; abstract;
    function MainEngineUpdateField(TableModelIndex: integer;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; virtual; abstract;
  public
    /// this integer property is incremented by the database engine when any SQL
    // statement changes the database contents (i.e. on any not SELECT statement)
    // - its value can be published to the client on every remote request
    // - it may be used by client to avoid retrieve data only if necessary
    // - if its value is 0, this feature is not activated on the server, and the
    // client must ignore it and always retrieve the content
    InternalState: Cardinal;
    /// a method can be specified here to trigger events after any table update
    // - is called BEFORE deletion, and AFTER insertion or update
    // - to be used only server-side, not to synchronize some clients: the framework
    // is designed around a stateless RESTful architecture (like HTTP/1.1), in which
    // clients ask the server for refresh (see TSQLRestClientURI.UpdateFromServer)
    OnUpdateEvent: TNotifySQLEvent;
    /// a method can be specified here to trigger events after any blob update
    // - is called AFTER update of one or several blobs, never on delete nor insert
    // - to be used only server-side, not to synchronize some clients: the framework
    // is designed around a stateless RESTful architecture (like HTTP/1.1), in which
    // clients ask the server for refresh (see TSQLRestClientURI.UpdateFromServer)
    OnBlobUpdateEvent: TNotifyFieldSQLEvent;
    /// a method can be specified to be notified when a session is created
    // - for OnSessionCreate, returning TRUE will abort the session creation -
    // and you can set Ctxt.Call^.OutStatus to a corresponding error code
    OnSessionCreate: TNotifySQLSession;
    /// a method can be specified to be notified when a session is closed
    // - for OnSessionClosed, the returning boolean value is ignored
    // - Ctxt is nil if the session is closed due to a timeout
    // - Ctxt is not nil if the session is closed explicitly by the client 
    OnSessionClosed: TNotifySQLSession;
    /// this property can be used to specify the URI parmeters to be used
    // for query paging
    // - is set by default to PAGINGPARAMETERS_YAHOO constant by
    // TSQLRestServer.Create() constructor
    URIPagingParameters: TSQLRestServerURIPagingParameters;

    /// implement Server-Side TSQLRest deletion
    // - uses internally EngineDelete() function for calling the database engine
    // - call corresponding fStaticData[] if necessary
    // - this record is also erased in all available TRecordReference properties
    // in the database Model, for relational database coherency
    function Delete(Table: TSQLRecordClass; ID: integer): boolean; override;
    /// implement Server-Side TSQLRest deletion with a WHERE clause
    // - will process all ORM-level validation, coherency checking and
    // notifications together with a low-level SQL deletion work (if possible)
    function Delete(Table: TSQLRecordClass; const SQLWhere: RawUTF8): boolean; override;
    /// overridden method for direct static class call (if any)
    function TableRowCount(Table: TSQLRecordClass): integer; override;
    /// overridden method for direct static class call (if any)
    function TableHasRows(Table: TSQLRecordClass): boolean; override;
    /// virtual method called when a record is updated
    // - default implementation will call the OnUpdateEvent/OnBlobUpdateEvent
    // methods, if defined
    // - will also handle TSQLRecordHistory tables, as defined by TrackChanges() 
    // - returns true on success, false if an error occured (but action must continue)
    // - you can override this method to implement a server-wide notification,
    // but be aware it may be the first step to break the stateless architecture
    // of the framework
    function InternalUpdateEvent(aEvent: TSQLEvent; aTableIndex, aID: integer;
      const aSentData: RawUTF8; aIsBlobFields: PSQLFieldBits): boolean; virtual;
    /// initialize change tracking for the given tables
    // - by default, it will use the TSQLRecordHistory table to store the
    // changes - you can specify a dedicated class as aTableHistory parameter
    // - if aTableHistory is not already part of the TSQLModel, it will be added
    // - note that this setting should be consistent in time: if you disable
    // tracking for a while, or did not enable tracking before adding a record,
    // then the content history won't be consistent (or disabled) for this record
    // - at every change, aTableHistory.SentDataJSON records will be added, up
    // to aMaxHistoryRowBeforeBlob items - then aTableHistory.History will store
    // a compressed version of all previous changes
    // - aMaxHistoryRowBeforeBlob is the maximum number of JSON rows per Table
    // before compression into BLOB is triggerred
    // - aMaxHistoryRowPerRecord is the maximum number of JSON rows per record,
    // above which the versions will be compressed as BLOB
    // - aMaxUncompressedBlobSize is the maximum BLOB size per record
    // - you can specify aMaxHistoryRowBeforeBlob=0 to disable change tracking
    // - you should call this method after the CreateMissingTables call
    // - note that change tracking may slow down the writing process, and
    // may increase storage space a lot (even if BLOB maximum size can be set),
    // so should be defined only when necessary
    procedure TrackChanges(const aTable: array of TSQLRecordClass;
      aTableHistory: TSQLRecordHistoryClass=nil; aMaxHistoryRowBeforeBlob: integer=1000;
      aMaxHistoryRowPerRecord: integer=10; aMaxUncompressedBlobSize: integer=64*1024); virtual;
    /// force compression of all aTableHistory.SentDataJson into History BLOB
    // - by default, this will take place in InternalUpdateEvent() when
    // aMaxHistoryRowBeforeBlob - as set by TrackChanges() method - is reached
    // - you can manually call this method to force History BLOB update, e.g.
    // when the server is in Idle state, and ready for process
    procedure TrackChangesFlush(aTableHistory: TSQLRecordHistoryClass); virtual;
    /// check if OnUpdateEvent or change tracked has been defined for this table 
    function InternalUpdateEventNeeded(aTableIndex: integer): boolean;
    /// this method is called internally after any successfull deletion to
    // ensure relational database coherency
    // - reset all matching TRecordReference properties in the database Model,
    // for database coherency, into 0
    // - delete all records containing a matched TRecordReferenceToBeDeleted
    // property value in the database Model (e.g. TSQLRecordHistory)
    // - reset all matching TSQLRecord properties in the database Model,
    // for database coherency, into 0
    // - important notice: we don't use FOREIGN KEY constraints in this framework,
    // and handle all integrity check within this method (it's therefore less
    // error-prone, and more cross-database engine compatible)
    function AfterDeleteForceCoherency(Table: TSQLRecordClass; aID: integer): boolean; virtual;
    /// update all BLOB fields of the supplied Value
    // - this overridden method will execute the direct static class, if any
    function UpdateBlobFields(Value: TSQLRecord): boolean; override;
    /// get all BLOB fields of the supplied value from the remote server
    // - this overridden method will execute the direct static class, if any
    function RetrieveBlobFields(Value: TSQLRecord): boolean; override;
    /// implement Server-Side TSQLRest unlocking
    // - to be called e.g. after a Retrieve() with forupdate=TRUE
    // - implements our custom UNLOCK REST-like verb
    // - locking is handled by TSQLServer.Model
    // - returns true on success
    function UnLock(Table: TSQLRecordClass; aID: integer): boolean; override;
    {/ end a transaction
     - implements REST END collection
     - write all pending TSQLVirtualTableJSON data to the disk }
    procedure Commit(SessionID: cardinal); override;
    /// Execute directly all SQL statement (POST SQL on ModelRoot URI)
    // - return true on success
    // - override this method for proper calling the database engine
    // - don't call this method in normal cases
    // - this method must be implemented to be thread-safe
    function EngineExecuteAll(const aSQL: RawUTF8): boolean; virtual; abstract;

{$ifdef MSWINDOWS}
    /// declare the server on the local machine as a Named Pipe: allows
    // TSQLRestClientURINamedPipe local or remote client connection
    // - ServerApplicationName ('DBSERVER' e.g.) will be used to create a named
    // pipe server identifier, it is of UnicodeString type since Delphi 2009
    // (use of Unicode FileOpen() version)
    // - this server identifier is appended to '\\.\pipe\mORMot_' to obtain
    // the full pipe name to initiate ('\\.\pipe\mORMot_DBSERVER' e.g.)
    // - this server identifier may also contain a fully qualified path
    // ('\\.\pipe\ApplicationName' e.g.)
    // - allows only one ExportServer*() by running process
    // - returns true on success, false otherwise (ServerApplicationName already used?)
    function ExportServerNamedPipe(const ServerApplicationName: TFileName): boolean;
    /// end any currently initialized named pipe server
    function CloseServerNamedPipe: boolean;
    /// grant access to this database content from a dll using the global
    // URIRequest() function
    // - returns true if the URIRequest() function is set to this TSQLRestServer
    // - returns false if a TSQLRestServer was already exported
    // - client must release all memory acquired by URIRequest() with GlobalFree()
    function ExportServer: boolean; overload;
    /// declare the server on the local machine to be accessible for local
    // client connection, by using Windows messages
    // - the data is sent and received by using the standard and fast WM_COPYDATA message
    // - Windows messages are very fast (faster than named pipe and much faster
    // than HTTP), but only work localy on the same computer
    // - create a new Window Class with the supplied class name (UnicodeString
    // since Delphi 2009 for direct use of Wide Win32 API), and instanciate
    // a window which will handle pending WM_COPYDATA messages
    // - the main server instance has to process the windows messages regularely
    // (e.g. with Application.ProcessMessages)
    // - ServerWindowName ('DBSERVER' e.g.) will be used to create a
    // Window name identifier
    // - allows only one ExportServer*() by running process
    // - returns true on success, false otherwise (ServerWindowName already used?)
    function ExportServerMessage(const ServerWindowName: string): boolean;
    /// implement a message-based server response
    // - this method is called automaticaly if ExportServerMessage() method
    // was initilialized
    // - you can also call this method from the WM_COPYDATA message handler
    // of your main form, and use the TSQLRestClientURIMessage class to access
    // the server instance from your clients
    // - it will answer to the Client with another WM_COPYDATA message
    // - message oriented architecture doesn't need any thread, but will use
    // the main thread of your application
    procedure AnswerToMessage(var Msg: TWMCopyData); message WM_COPYDATA;
    /// end any currently initialized message-oriented server
    function CloseServerMessage: boolean;
{$endif}
    /// Server initialization with a specified Database Model
    // - if HandleUserAuthentication is false, will set URI access rights to
    // 'Supervisor' (i.e. all R/W access) by default
    // - if HandleUserAuthentication is true, will add TSQLAuthUser and
    // TSQLAuthGroup to the TSQLModel (if not already there)
    constructor Create(aModel: TSQLModel; aHandleUserAuthentication: boolean=false); reintroduce;
    /// release memory and any existing pipe initialized by ExportServer()
    destructor Destroy; override;

    /// Missing tables are created if they don't exist yet for every TSQLRecord
    // class of the Database Model
    // - you must call explicitely this before having called StaticDataCreate()
    // - all table description (even Unique feature) is retrieved from the Model
    // - this method should also create additional fields, if the TSQLRecord definition
    // has been modified; only field adding is mandatory, field renaming or
    // field deleting are not allowed in the FrameWork (in such cases, you must
    // create a new TSQLRecord type)
    // - this virtual method do nothing by default - overridden versions should
    // implement it as expected by the underlying storage engine (e.g. SQLite3
    // or TSQLRestServerFullInMemory)
    procedure CreateMissingTables(user_version: cardinal=0); virtual;
    /// create an external static in-memory database for a specific class
    // - call it just after Create, before TSQLRestServerDB.CreateMissingTables;
    // warning: if you don't call this method before CreateMissingTable method
    // is called, the table will be created as a regular table by the main
    // database engine, and won't be static
    // - can load the table content from a file if a file name is specified
    // (could be either JSON or compressed Binary format on disk)
    // - you can define a particular external engine by setting a custom class -
    // by default, it will create a TSQLRestStorageInMemory instance
    // - this data handles basic REST commands, since no complete SQL interpreter
    // can be implemented by TSQLRestStorage; to provide full SQL process,
    // you should better use a Virtual Table class, inheriting e.g. from
    // TSQLRecordVirtualTableAutoID associated with TSQLVirtualTableJSON/Binary
    // via a Model.VirtualTableRegister() call before TSQLRestServer.Create
    // - return nil on any error, or an EModelException if the class is not in
    // the database model
    function StaticDataCreate(aClass: TSQLRecordClass;
      const aFileName: TFileName = ''; aBinaryFile: boolean=false;
      aServerClass: TSQLRestStorageClass=nil): TSQLRest;
    /// call this method when the internal DB content is known to be invalid
    // - by default, all REST/CRUD requests and direct SQL statements are
    // scanned and identified as potentially able to change the internal SQL/JSON
    // cache used at SQLite3 database level; but some virtual tables (e.g.
    // TSQLRestStorageExternal classes defined in mORMotDB) could flush
    // the database content without proper notification
    // - this default implementation just do nothing, but SQlite3 unit
    // will call TSQLDataBase.CacheFlush method
    procedure FlushInternalDBCache; virtual;
    /// you can call this method in TThread.Execute to ensure that
    // the thread will be taken in account during process
    // - caller must specify the TThread instance running
    // - used e.g. for optExecInMainThread option in TServiceMethod.InternalExecute
    // - this default implementation will call the methods of all its internal
    // TSQLRestStorage instances
    // - this method shall be called from the thread just initiated: e.g.
    // if you call it from the main thread, it may fail to prepare resources
    procedure BeginCurrentThread(Sender: TThread); virtual;
    /// you can call this method just before a thread is finished to ensure
    // e.g. that the associated external DB connection will be released
    // - this default implementation will call the methods of all its internal
    // TSQLRestStorage instances, allowing e.g. TSQLRestStorageExternal
    // instances to clean their thread-specific connections
    // - this method shall be called from the thread about to be terminated: e.g.
    // if you call it from the main thread, it may fail to release resources
    // - it is set e.g. by TSQLite3HttpServer to be called from HTTP threads,
    // or by TSQLRestServerNamedPipeResponse for named-pipe server cleaning
    procedure EndCurrentThread(Sender: TThread); virtual;

    /// implement a generic local, piped or HTTP/1.1 provider
    // - this is the main entry point of the server, from the client side
    // - default implementation calls protected methods EngineList() Retrieve()
    // Add() Update() Delete() UnLock() EngineExecute() above, which must be overridden by
    // the TSQLRestServer child
    // - for 'GET ModelRoot/TableName', url parameters can be either "select" and
    // "where" (to specify a SQL Query, from the SQLFromSelectWhere function),
    // either "sort", "dir", "startIndex", "results", as expected by the YUI
    // DataSource Request Syntax for data pagination - see
    // http://developer.yahoo.com/yui/datatable/#data
    procedure URI(var Call: TSQLRestURIParams); virtual;

    /// create an index for the specific FieldName
    // - will call CreateSQLMultiIndex() internaly
    function CreateSQLIndex(Table: TSQLRecordClass; const FieldName: RawUTF8;
      Unique: boolean; const IndexName: RawUTF8=''): boolean; overload;
    /// create one or multiple index(es) for the specific FieldName(s)
    function CreateSQLIndex(Table: TSQLRecordClass; const FieldNames: array of RawUTF8;
      Unique: boolean): boolean; overload;
    /// create one index for all specific FieldNames at once
    function CreateSQLMultiIndex(Table: TSQLRecordClass; const FieldNames: array of RawUTF8;
      Unique: boolean; IndexName: RawUTF8=''): boolean; virtual;

    /// call this method to add an authentication method to the server
    procedure AuthenticationRegister(aMethod: TSQLRestServerAuthenticationClass); overload;
    /// call this method to add several authentication methods to the server
    // - if TSQLRestServer.Create() constructor is called with aHandleUserAuthentication
    // set to TRUE, it will register the two following classes:
    // ! AuthenticationRegister([TSQLRestServerAuthenticationDefault,TSQLRestServerAuthenticationSSPI]);
    procedure AuthenticationRegister(const aMethods: array of TSQLRestServerAuthenticationClass); overload;
    /// call this method to remove an authentication method to the server
    procedure AuthenticationUnregister(aMethod: TSQLRestServerAuthenticationClass); overload;
    /// call this method to remove several authentication methods to the server
    procedure AuthenticationUnregister(const aMethods: array of TSQLRestServerAuthenticationClass); overload;
    /// add all published methods of a given object instance to the method-based
    // list of services
    // - all those published method signature should match TSQLRestServerCallBack
    procedure ServiceMethodRegisterPublishedMethods(const aPrefix: RawUTF8; aInstance: TObject);
    /// call this method to disable Authentication method check for a given
    // published method name
    // - by default, only Auth and TimeStamp methods do not require the RESTful
    // authentication of the URI; you may call this method to add another method
    // to the list (e.g. for returning some HTML content from a public URI)
    procedure ServiceMethodByPassAuthentication(const aMethodName: RawUTF8);
    /// returns a copy of the user associated to a session ID
    // - returns nil if the session does not exist (e.g. if authentication is
    // disabled)
    // - caller MUST release the TSQLAuthUser instance returned (if not nil)
    // - this method IS thread-safe, and call internaly fSessionCriticalSection
    // (the returned TSQLAuthUser is a private copy from fSessions[].User instance,
    // in order to be really thread-safe)
    // - the returned TSQLAuthUser instance will have GroupRights=nil but will
    // have ID, LogonName, DisplayName, PasswordHashHexa and Data fields available
    function SessionGetUser(aSessionID: Cardinal): TSQLAuthUser;

    /// register a Service class on the server side
    // - this methods expects a class to be supplied, and the exact list of
    // interfaces to be registered to the server (e.g. [TypeInfo(IMyInterface)])
    // and implemented by this class
    // - class can be any TInterfacedObject, but TInterfacedObjectWithCustomCreate
    // can be used if you need an overridden constructor
    // - instance implementation pattern will be set by the appropriate parameter
    // - will return the first of the registered TServiceFactoryServer created
    // on success (i.e. the one corresponding to the first item of the aInterfaces
    // array), or nil if registration failed (e.g. if any of the supplied interfaces
    // is not implemented by the given class)
    // - you can use the returned TServiceFactoryServer instance to set the
    // expected security parameters associated with this interface
    // - the same implementation class can be used to handle several interfaces
    // (just as Delphi allows to do natively)
    function ServiceRegister(aImplementationClass: TInterfacedClass;
      const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation=sicSingle): TServiceFactoryServer; overload; virtual;
    /// register a Service instance on the server side
    // - this methods expects a class instance to be supplied, and the exact list
    // of interfaces to be registered to the server (e.g. [TypeInfo(IMyInterface)])
    // and implemented by this shared instance
    // - as a consequence, instance implementation pattern will always be sicShared
    // - will return the first of the registered TServiceFactoryServer created
    // on success (i.e. the one corresponding to the first item of the aInterfaces
    // array), or nil if registration failed (e.g. if any of the supplied interfaces
    // is not implemented by the given class)
    // - you can use the returned TServiceFactoryServer instance to set the
    // expected security parameters associated with this interface
    // - the same implementation class can be used to handle several interfaces
    // (just as Delphi allows to do natively)
    function ServiceRegister(aSharedImplementation: TInterfacedObject;
      const aInterfaces: array of PTypeInfo): TServiceFactoryServer; overload; virtual;
    /// register a remote Service via its interface
    // - this overloaded method will register a remote Service, accessed via the
    // supplied TSQLRest(ClientURI) instance: it can be available in the main
    // TSQLRestServer.Services property, but execution will take place on a
    // remote server - may be used e.g. for dedicated hosting of services (in
    // a DMZ for instance)
    // - this methods expects a list of interfaces to be registered to the client
    // (e.g. [TypeInfo(IMyInterface)])
    // - instance implementation pattern will be set by the appropriate parameter
    // - will return true on success, false if registration failed (e.g. if any of
    // the supplied interfaces is not correct or is not available on the server)
    // - that is, server side will be called to check for the availability of
    // each interface
    // - you can specify an optional custom contract for the first interface
    function ServiceRegister(aClient: TSQLRest; const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation=sicSingle;
      const aContractExpected: RawUTF8=''): boolean; overload; virtual;

    /// read-only access to the list of registered server-side authentication
    // methods, used for session creation
    property AuthenticationSchemes: TSQLRestServerAuthenticationDynArray
      read fSessionAuthentication;
    /// retrieve the TSQLRestStorage instance used to store and manage
    // a specified TSQLRecordClass in memory
    // - has been associated by the StaticDataCreate method
    property StaticDataServer[aClass: TSQLRecordClass]: TSQLRest
      read GetStaticDataServer;
    /// retrieve a running TSQLRestStorage virtual table
    // - associated e.g. to a 'JSON' or 'Binary' virtual table module, or may
    // return a TSQLRestStorageExternal instance (as defined in mORMotDB)
    // - this property will return nil if there is no Virtual Table associated
    // or if the corresponding module is not a TSQLVirtualTable
    // (e.g. "pure" static tables registered by StaticDataCreate would be
    // accessible only via StaticDataServer[], not via StaticVirtualTable[])
    // - has been associated by the TSQLModel.VirtualTableRegister method or
    // the VirtualTableExternalRegister() global function
    property StaticVirtualTable[aClass: TSQLRecordClass]: TSQLRest
      read GetVirtualTable;
  published
    /// set this property to true to transmit the JSON data in a "not expanded" format
    // - not directly compatible with Javascript object list decode: not to be
    // used in AJAX environnement (like in TSQLite3HttpServer)
    // - but transmitted JSON data is much smaller if set it's set to FALSE, and
    // if you use a Delphi Client, parsing will be also faster and memory usage
    // will be lower
    // - By default, the NoAJAXJSON property is set to TRUE in
    // TSQLRestServer.ExportServerNamedPipe: if you use named pipes for communication,
    // you probably won't use javascript because browser communicates via HTTP!
    // - But otherwise, NoAJAXJSON property is set to FALSE. You could force its
    // value to TRUE and you'd save some bandwidth if you don't use javascript:
    // even the parsing of the JSON Content will be faster with Delphi client
    // if JSON content is not expanded
    // - the "expanded" or standard/AJAX layout allows you to create pure JavaScript
    // objects from the JSON content, because the field name / JavaScript object
    // property name is supplied for every value
    // - the "not expanded" layout, NoAJAXJSON property is set to TRUE,
    // reflects exactly the layout of the SQL request - first line contains the
    // field names, then all next lines are the field content
    property NoAJAXJSON: boolean read fNoAJAXJSON write SetNoAJAXJSON;
    /// set to true if the server will handle per-user authentication and
    // access right management
    // - i.e. if the associated TSQLModel contains TSQLAuthUser and
    // TSQLAuthGroup tables (set by constructor)
    property HandleAuthentication: boolean read fHandleAuthentication;
    /// access to the Server statistics
    property Stats: TSQLRestServerStats read fStats;
    /// this property can be left to its TRUE default value, to handle any
    // TSQLVirtualTableJSON static tables (module JSON or BINARY) with direct
    // calls to the storage instance
    // - is set to TRUE by default to enable faster Direct mode
    // - in Direct mode, GET/POST/PUT/DELETE of individual records (or BLOB fields)
    // from URI() will call directly the corresponding TSQLRestStorage
    // instance, for better speed for most used RESTful operations; but complex
    // SQL requests (e.g. joined SELECT) will rely on the main SQL engine
    // - if set to false, will use the main SQLite3 engine for all statements
    // (should not to be used normaly, because it will add unnecessary overhead)
    property StaticVirtualTableDirect: boolean read fVirtualTableDirect
      write fVirtualTableDirect;
    /// the class inheriting from TSQLAuthUser, as defined in the model
    // - during authentication, this class will be used for every TSQLAuthUser
    // table access
    property SQLAuthUserClass: TSQLAuthUserClass read fSQLAuthUserClass;
    /// the class inheriting from TSQLAuthGroup, as defined in the model
    // - during authentication, this class will be used for every TSQLAuthGroup
    // table access
    property SQLAuthGroupClass: TSQLAuthGroupClass read fSQLAuthGroupClass;
    /// the class inheriting from TAuthSession to handle in-memory sessions
    // - this all sessions remain in memory, ensure they are not taking too
    // much resource (memory or process time)
    property SessionClass: TAuthSessionClass read fSessionClass write fSessionClass;
  published
    /// this method will be accessible from ModelRoot/Stat URI, and
    // will retrieve some statistics as a JSON object
    // - method parameters signature matches TSQLRestServerCallBack type
    procedure Stat(Ctxt: TSQLRestServerURIContext);
    /// this method will be accessible from ModelRoot/Auth URI, and
    // will be called by the client for authentication and session management
    // - method parameters signature matches TSQLRestServerCallBack type
    // - this global callback method is thread-safe
    procedure Auth(Ctxt: TSQLRestServerURIContext);
    /// this method will be accessible from the ModelRoot/TimeStamp URI, and
    // will return the server time stamp TTimeLog/Int64 value as RawUTF8
    // - method parameters signature matches TSQLRestServerCallBack type
    procedure TimeStamp(Ctxt: TSQLRestServerURIContext);
    /// this method will be accessible from the ModelRoot/CacheFlush URI, and
    // will flush the server cache
    // - this method shall be called by the clients when the Server cache could
    // be not refreshed
    // - ModelRoot/CacheFlush URI will flush the whole Server cache, for all tables
    // - ModelRoot/CacheFlush/TableName URI will flush the specified table cache
    // - ModelRoot/CacheFlush/TableName/TableID URI will flush the content of the
    // specified record
    // - method parameters signature matches TSQLRestServerCallBack type
    procedure CacheFlush(Ctxt: TSQLRestServerURIContext);
    /// this method will be accessible from the ModelRoot/Batch URI, and
    // will execute a set of RESTful commands
    // - expect input as JSON commands:
    // & '{"Table":["cmd":values,...]}'
    // or for multiple tables:
    // & '["cmd@Table":values,...]'
    // with cmd in POST/PUT with {object} as value or DELETE with ID
    // - returns an array of integers: '[200,200,...]' or '["OK"]' if all
    // returned status codes are 200 (HTML_SUCCESS)
    // - URI are either 'ModelRoot/TableName/Batch' or 'ModelRoot/Batch'
    procedure Batch(Ctxt: TSQLRestServerURIContext);
  end;

  /// REST class with direct access to an external database engine
  // - you can set an alternate per-table database engine by using this class
  // - this abstract class is to be overridden with a proper implementation (like
  // our TSQLRestStorageInMemory class or TSQLRestStorageExternal
  // as defined in mORMotDB unit)
  TSQLRestStorage = class(TSQLRest)
  protected
    fStoredClass: TSQLRecordClass;
    fStoredClassProps: TSQLModelRecordProperties;
    fStoredClassRecordProps: TSQLRecordProperties;
    fFileName: TFileName;
    fModified: boolean;
    fOwner: TSQLRestServer;
    fStorageCriticalSection: TRTLCriticalSection;
    fStorageCriticalSectionCount: integer;
    fBasicSQLCount: RawUTF8;
    fBasicSQLHasRows: array[boolean] of RawUTF8;
    /// any set bit in this field indicates UNIQUE field value
    fIsUnique: TSQLFieldBits;
    /// allow to force refresh for a given Static table
    // - default FALSE means to return the main TSQLRestServer.InternalState
    // - TRUE indicates that OutInternalState := cardinal(-1) will be returned
    fOutInternalStateForcedRefresh: boolean; 
    procedure StorageLock(WillModifyContent: boolean); virtual;
    procedure StorageUnLock; virtual;
    /// override this method if you want to update the refresh state
    // - returns FALSE if the static table content was not modified (default
    // method implementation is to always return FALSE)
    // - returns TRUE if the table has been refreshed and its content was modified:
    // therefore the client will know he'll need to refresh some content
    function RefreshedAndModified: boolean; virtual;
    /// overridden method calling the owner (if any) to guess if this record
    // can be updated or deleted
    function RecordCanBeUpdated(Table: TSQLRecordClass; ID: integer; Action: TSQLEvent;
      ErrorMsg: PRawUTF8 = nil): boolean; override;
    /// TSQLRestServer.URI use it for Static.EngineList to by-pass virtual table
    // - this default implementation will return TRUE and replace SQL with
    // SQLSelectAll[true] if it SQL equals SQLSelectAll[false] (i.e. 'SELECT *')
    // - this method is called only if the WHERE clause of SQL refers to the
    // static table name only (not needed to check it twice)
    function AdaptSQLForEngineList(var SQL: RawUTF8): boolean; virtual;
  public
    /// initialize the storage data, reading it from a file if necessary
    // - data encoding on file is UTF-8 JSON format by default, or
    // should be some binary format if aBinaryFile is set to true (this virtual
    // method will just ignore this parameter, which will be used for overridden
    // constructor only)
    constructor Create(aClass: TSQLRecordClass; aServer: TSQLRestServer;
      const aFileName: TFileName = ''; aBinaryFile: boolean=false); reintroduce; virtual;
    /// finalize the storage instance
    destructor Destroy; override;
    /// you can call this method in TThread.Execute to ensure that
    // the thread will be taken in account during process
    // - this overridden method will do nothing (should have been already made
    // at TSQLRestServer caller level)
    // - children classes may inherit from this method to notify e.g.
    // a third party process (like proper OLE initialization)
    procedure BeginCurrentThread(Sender: TThread); virtual;
    /// you can call this method just before a thread is finished to ensure
    // e.g. that the associated external DB connection will be released
    // - this overridden method will do nothing (should have been already made
    // at TSQLRestServer caller level)
    // - children classes may inherit from this method to notify e.g.
    // a third party process (like proper OLE initialization)
    procedure EndCurrentThread(Sender: TThread); virtual;

    /// implement TSQLRest unlocking (UNLOCK verb)
    // - to be called e.g. after a Retrieve() with forupdate=TRUE
    // - locking is handled at (Owner.)Model level
    // - returns true on success
    function UnLock(Table: TSQLRecordClass; aID: integer): boolean; override;
    /// overridden method for direct in-memory database engine call
    // - made public since a TSQLRestStorage instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    // - do nothing method: will return FALSE (aka error)
    function EngineUpdateField(TableModelIndex: integer;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
    /// create one index for all specific FieldNames at once
    // - do nothing method: will return FALSE (aka error)
    function CreateSQLMultiIndex(Table: TSQLRecordClass; const FieldNames: array of RawUTF8;
      Unique: boolean; IndexName: RawUTF8=''): boolean; virtual;
    /// search for a numerical field value
    // - return true on success (i.e. if some values have been added to ResultID)
    // - store the results into the ResultID dynamic array
    // - faster than OneFieldValues method, which creates a temporary JSON content
    // - this default implementation will call the overloaded SearchField()
    // value after conversion of the FieldValue into RawUTF8
    function SearchField(const FieldName: RawUTF8; FieldValue: Integer;
      var ResultID: TIntegerDynArray): boolean; overload; virtual;
    /// search for a field value, according to its SQL content representation
    // - return true on success (i.e. if some values have been added to ResultID)
    // - store the results into the ResultID dynamic array
    // - faster than OneFieldValues method, which creates a temporary JSON content
    function SearchField(const FieldName, FieldValue: RawUTF8;
      var ResultID: TIntegerDynArray): boolean; overload; virtual; abstract;
    /// begin a BATCH sequence to speed up huge database change
    // - this overridden method will raise an EORMException since BATCH mode is
    // not supported for TSQLStorageClass: it has no interrest at table level
    function BatchStart(aTable: TSQLRecordClass;
      AutomaticTransactionPerRow: cardinal=0): boolean; override;

    /// read only access to the file name specified by constructor
    // - you can call the TSQLRestServer.StaticDataCreate method to
    // update the file name of an already instancied static table
    property FileName: TFileName read fFileName write fFileName;
    /// read only access to a boolean value set to true if table data was modified
    property Modified: boolean read fModified write fModified;
    /// read only access to the class defining the record type stored in this
    // REST storage
    property StoredClass: TSQLRecordClass read fStoredClass;
    /// read only access to the ORM properties of the associated record type
    // - may be nil if this instance is not associated with a TSQLModel
    property StoredClassProps: TSQLModelRecordProperties read fStoredClassProps;
    /// read only access to the RTTI properties of the associated record type
    property StoredClassRecordProps: TSQLRecordProperties read fStoredClassRecordProps;
    /// read only access to the TSQLRestServer using this in-memory database
    property Owner: TSQLRestServer read fOwner;
  end;

  /// event prototype called by FindWhereEqual() method
  TFindWhereEqualEvent = procedure(aDest: pointer; aRec: TSQLRecord; aIndex: integer) of object;

  /// abstract REST server exposing some internal TSQLRecord-based methods
  TSQLRestStorageRecordBased = class(TSQLRestStorage)
  protected
    function EngineAdd(TableModelIndex: integer; const SentData: RawUTF8): integer; override;
    function EngineUpdate(TableModelIndex, ID: integer; const SentData: RawUTF8): boolean; override;
  public
    /// manual Add of a TSQLRecord
    // - returns the ID created on success
    // - returns -1 on failure (not UNIQUE field value e.g.)
    // - on success, the Rec instance is added to the Values[] list: caller
    // doesn't need to Free it
    function AddOne(Rec: TSQLRecord; ForceID: boolean; const SentData: RawUTF8): integer; virtual; abstract;
    /// manual Retrieval of a TSQLRecord field values
    // - an instance of the associated static class is created
    // - and all its properties are filled from the Items[] values
    // - caller can modify these properties, then use UpdateOne() if the changes
    // have to be stored inside the Items[] list
    // - calller must always free the returned instance
    // - returns NIL if any error occured, e.g. if the supplied aID was incorrect
    // - method available since a TSQLRestStorage instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function GetOne(aID: integer): TSQLRecord; virtual; abstract;
    /// manual Update of a TSQLRecord field values
    // - Rec.ID specifies which record is to be updated
    // - will update all properties, including BLOB fields and such
    // - returns TRUE on success, FALSE on any error (e.g. invalid Rec.ID)
    // - method available since a TSQLRestStorage instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function UpdateOne(Rec: TSQLRecord; const SentData: RawUTF8): boolean; overload; virtual; abstract;
    /// manual Update of a TSQLRecord field values from an array of TSQLVar
    // - will update all properties, including BLOB fields and such
    // - returns TRUE on success, FALSE on any error (e.g. invalid Rec.ID)
    // - method available since a TSQLRestStorage instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    // - this default implementation will create a temporary TSQLRecord instance
    // with the supplied Values[], and will call overloaded UpdateOne() method
    function UpdateOne(ID: integer; const Values: TSQLVarDynArray): boolean; overload; virtual;
  end;

  /// class able to handle a O(1) hashed-based search of a property in a TList
  // - used e.g. to hash TSQLRestStorageInMemory field values
  TListFieldHash = class(TObjectHash)
  protected
    fValues: TList;
    fField: integer;
    fProp: TSQLPropInfo;
    fCaseInsensitive: boolean;
    /// overridden method to hash an item
    function Hash(Item: TObject): cardinal; override;
    /// overridden method to compare two items
    function Compare(Item1,Item2: TObject): boolean; override;
    /// overridden method to get an item
    // - shall return nil if Index is out of range (e.g. >= Count)
    // - will be called e.g. by Find() with Compare() to avoid collision
    function Get(Index: integer): TObject; override;
    /// overridden method to retrieve the number of items
    function Count: integer; override;
  public
    /// initialize a hash for a record array field
    // - aFieldIndex/aField parameters correspond to the indexed field (e.g.
    // "stored AS_UNIQUE" published property)
    // - if CaseInsensitive is TRUE, will apply NormToUpper[] 8 bits uppercase,
    // handling RawUTF8 properties just like the SYSTEMNOCASE collation
    constructor Create(aValues: TList; aFieldIndex: integer;
      aField: TSQLPropInfo; aCaseInsensitive: boolean);
    /// the corresponding field index in the TSQLRecord
    property FieldIndex: integer read fField;
    /// the corresponding field RTTI
    property Field: TSQLPropInfo read fProp;
    /// if the string comparison shall be case-insensitive
    property CaseInsensitive: boolean read fCaseInsensitive;
  end;

  /// REST server with direct access to a memory-stored database
  // - store the associated TSQLRecord values in memory
  // - handle only one TSQLRecord by server (it's NOT a true Rest Server)
  // - must be registered individualy in a TSQLRestServer to access data from a
  // common client, by using the TSQLRestServer.StaticDataCreate method:
  // it allows an unique access for both SQLite3 and Static databases
  // - handle basic REST commands, no SQL interpreter is implemented: only
  // valid SQL command is "SELECT Field1,Field2 FROM Table WHERE ID=120;", i.e
  // a one Table SELECT with one optional "WHERE fieldname = value" statement;
  // if used within a TSQLVirtualTableJSON, you'll be able to handle any kind of
  // SQL statement (even joined SELECT or such) with this memory-stored database
  // - our TSQLRestStorage database engine is very optimized and is a lot
  // faster than SQLite3 for such queries - but its values remain in RAM,
  // therefore it is not meant to deal with more than 100,000 rows
  // - data can be stored and retrieved from a file (JSON format is used by
  // default, if BinaryFile parameter is left to false; a proprietary compressed
  // binary format can be used instead) if a file name is supplied at creating
  // the TSQLRestStorageInMemory instance
  TSQLRestStorageInMemory = class(TSQLRestStorageRecordBased)
  protected
    fValue: TObjectList;
    /// true if IDs are sorted (which is the default behavior of this class),
    // for fastest ID2Index() by using a binary search algorithm
    fIDSorted: boolean;
    fCommitShouldNotUpdateFile: boolean;
    fBinaryFile: boolean;
    fExpandedJSON: boolean;
    fSearchRec: TSQLRecord;
    fBasicUpperSQLSelect: array[boolean] of RawUTF8;
    fUniqueFields: TObjectList;
    function UniqueFieldsUpdateOK(aRec: TSQLRecord; aUpdateIndex: integer): boolean;
    function UniqueFieldHash(aFieldIndex: integer): TListFieldHash;
    function GetCount: integer;
    function GetItem(Index: integer): TSQLRecord;
      {$ifdef HASINLINE}inline;{$endif}
    function GetID(Index: integer): integer;
    // optimized search of WhereValue in WhereField (0=RowID,1..=RTTI)
    function FindWhereEqual(WhereField: integer; const WhereValue: RawUTF8; 
      OnFind: TFindWhereEqualEvent; Dest: pointer; FoundLimit,FoundOffset: integer): PtrInt;
    procedure GetJSONValuesEvent(aDest: pointer; aRec: TSQLRecord; aIndex: integer);
    procedure AddIntegerDynArrayEvent(aDest: pointer; aRec: TSQLRecord; aIndex: integer);
    procedure DoNothingEvent(aDest: pointer; aRec: TSQLRecord; aIndex: integer);
    /// used to create the JSON content from a SELECT parsed command
    // - WhereField index follows FindWhereEqual / TSynTableStatement.WhereField
    // - returns the number of data row added (excluding field names)
    // - this method is very fast and optimized (for search and JSON serializing)
    function GetJSONValues(Stream: TStream; Expand: boolean;
      Stmt: TSynTableStatement): PtrInt;
    /// TSQLRestServer.URI use it for Static.EngineList to by-pass virtual table
    // - overridden method to handle basic queries as handled by EngineList()
    function AdaptSQLForEngineList(var SQL: RawUTF8): boolean; override;
    /// overridden methods for direct in-memory database engine thread-safe process
    function EngineRetrieve(TableModelIndex, ID: integer): RawUTF8; override;
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8; override;
    function EngineUpdate(TableModelIndex, ID: integer; const SentData: RawUTF8): boolean; override;
    function EngineRetrieveBlob(TableModelIndex, aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateBlob(TableModelIndex, aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; override;
    function EngineDeleteWhere(TableModelIndex: integer; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; override;
  public
    /// initialize the server data, reading it from a file if necessary
    // - data encoding on file is UTF-8 JSON format by default, or
    // should be some binary format if aBinaryFile is set to true
    constructor Create(aClass: TSQLRecordClass; aServer: TSQLRestServer;
      const aFileName: TFileName = ''; aBinaryFile: boolean=false); override;
    /// free used memory
    // - especially release all fValue[] instances
    destructor Destroy; override;

    /// load the values from JSON data
    procedure LoadFromJSON(const aJSON: RawUTF8); overload;
    /// load the values from JSON data
    procedure LoadFromJSON(JSONBuffer: PUTF8Char; JSONBufferLen: integer); overload;
    /// save the values into JSON data
    function SaveToJSON(Expand: Boolean): RawUTF8; overload;
    /// save the values into JSON data
    procedure SaveToJSON(Stream: TStream; Expand: Boolean); overload;
    /// load the values from binary data
    // - the binary format is a custom compressed format (using our SynLZ fast
    // compression algorithm), with variable-length record storage
    // - the binary content is first checked for consistency, before loading
    // - warning: the field layout should be the same at SaveToBinary call;
    // for instance, it won't be able to read a file content with a renamed
    // or modified field type 
    // - will return false if the binary content is invalid
    function LoadFromBinary(Stream: TStream): boolean;
    /// save the values into binary data
    // - the binary format is a custom compressed format (using our SynLZ fast
    // compression algorithm), with variable-length record storage: e.g. a 27 KB
    // Dali1.json content is stored into a 6 KB Dali2.data file
    // (this data has a text redundant field content in its FirstName field);
    // 502 KB People.json content is stored into a 92 KB People.data file
    // - returns the number of bytes written into Stream
    function SaveToBinary(Stream: TStream): integer;
    /// if file was modified, the file is updated on disk
    // - this method is called automaticaly when the TSQLRestStorage
    // instance is destroyed: should should want to call in in some cases,
    // in order to force the data to be saved regularly
    // - do nothing if the table content was not modified
    // - will write JSON content by default, or binary content if BinaryFile
    // property was set to true
    procedure UpdateFile;
    /// retrieve the index in Items[] of a particular ID
    // - return -1 if this ID was not found
    // - use fast binary search algorithm (since Items[].ID should be increasing)
    function IDToIndex(ID: integer): integer;
    /// manual Add of a TSQLRecord
    // - returns the ID created on success
    // - returns -1 on failure (not UNIQUE field value e.g.)
    // - on success, the Rec instance is added to the Values[] list: caller
    // doesn't need to Free it
    function AddOne(Rec: TSQLRecord; ForceID: boolean; const SentData: RawUTF8): integer; override;
    /// manual Retrieval of a TSQLRecord field values
    // - an instance of the associated static class is created
    // - and all its properties are filled from the Items[] values
    // - caller can modify these properties, then use UpdateOne() if the changes
    // have to be stored inside the Items[] list
    // - calller must always free the returned instance
    // - returns NIL if any error occured, e.g. if the supplied aID was incorrect
    // - method available since a TSQLRestStorage instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function GetOne(aID: integer): TSQLRecord; override;
    /// manual Update of a TSQLRecord field values
    // - Rec.ID specifies which record is to be updated
    // - will update all properties, including BLOB fields and such
    // - returns TRUE on success, FALSE on any error (e.g. invalid Rec.ID)
    // - method available since a TSQLRestStorage instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function UpdateOne(Rec: TSQLRecord; const SentData: RawUTF8): boolean; override;
    /// manual Update of a TSQLRecord field values from a TSQLVar array
    // - will update all properties, including BLOB fields and such
    // - returns TRUE on success, FALSE on any error (e.g. invalid Rec.ID)
    // - method available since a TSQLRestStorage instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function UpdateOne(ID: integer; const Values: TSQLVarDynArray): boolean; override;
    /// overridden method for direct in-memory database engine call
    // - made public since a TSQLRestStorage instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function EngineDelete(TableModelIndex, ID: integer): boolean; override;
    /// overridden method for direct in-memory database engine call
    // - made public since a TSQLRestStorage instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function EngineUpdateField(TableModelIndex: integer;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
    /// overridden method for direct in-memory database engine call
    function UpdateBlobFields(Value: TSQLRecord): boolean; override;
    /// overridden method for direct in-memory database engine call
    function RetrieveBlobFields(Value: TSQLRecord): boolean; override;
    /// overridden method for direct in-memory database engine call
    function TableRowCount(Table: TSQLRecordClass): integer; override;
    /// overridden method for direct in-memory database engine call
    function TableHasRows(Table: TSQLRecordClass): boolean; override;
    /// search for a field value, according to its SQL content representation
    // - return true on success (i.e. if some values have been added to ResultID)
    // - store the results into the ResultID dynamic array
    // - faster than OneFieldValues method, which creates a temporary JSON content
    function SearchField(const FieldName, FieldValue: RawUTF8;
      var ResultID: TIntegerDynArray): boolean; override;
    /// read-only access to the number of TSQLRecord values
    property Count: integer read GetCount;
    /// read-only access to the TSQLRecord values, storing the data
    // - this returns directly the item class instance stored in memory: if you
    // change the content, it will affect the internal data - so for instance
    // DO NOT change the ID values, unless you may have unexpected behavior
    property Items[Index: integer]: TSQLRecord read GetItem; default;
    /// read-only access to the ID of a TSQLRecord values
    property ID[Index: integer]: integer read GetID;
    /// if set to true, file content on disk will expect binary format
    // - default format on disk is JSON but can be overridden at constructor call
    // - binary format should be more efficient in term of speed and disk usage,
    // but can be proprietary
    property BinaryFile: boolean read fBinaryFile write fBinaryFile;
    // JSON writing, can set if the format should be expanded or not
    // - by default, the JSON will be in the custom non-expanded format,
    // to save disk space and time
    // - you can force the JSON to be emitted as an array of objects,
    // e.g. for better human friendliness (reading and modification)
    property ExpandedJSON: boolean read fExpandedJSON write fExpandedJSON;
    /// set this property to TRUE if you want the COMMIT statement not to
    // update the associated TSQLVirtualTableJSON
    property CommitShouldNotUpdateFile: boolean read fCommitShouldNotUpdateFile
      write fCommitShouldNotUpdateFile;
  end;

  /// REST server with direct access to a memory database, to be used as
  // an external SQLite3 Virtual table
  // - this is the kind of in-memory table expected by TSQLVirtualTableJSON,
  // in order to be consistent with the internal DB cache
  TSQLRestStorageInMemoryExternal = class(TSQLRestStorageInMemory)
  public
    /// this overridden method will notify the Owner when the internal DB content
    // is known to be invalid
    // - by default, all REST/CRUD requests and direct SQL statements are
    // scanned and identified as potentially able to change the internal SQL/JSON
    // cache used at SQLite3 database level; but TSQLVirtualTableJSON virtual
    // tables could flush the database content without proper notification
    // - this overridden implementation will call Owner.FlushInternalDBCache
    procedure StorageLock(WillModifyContent: boolean); override;
  end;

  /// a dynamic array of TSQLRestStorageInMemory instances
  TSQLRestStorageInMemoryDynArray = array of TSQLRestStorageInMemory;

  /// a REST server using only in-memory tables
  // - this server will use TSQLRestStorageInMemory instances to handle
  // the data in memory, and optionally persist the data on disk as JSON or
  // binary files
  // - so it will not handle all SQL requests, just basic CRUD commands on
  // separated tables
  // - at least, it will compile as a TSQLRestServer without complaining for
  // pure abstract methods; it can be used to host some services if database
  // and ORM needs are basic (e.g. if only authentication and CRUD are needed),
  // without the need to link the SQLite3 engine
  TSQLRestServerFullMemory = class(TSQLRestServer)
  protected
    fFileName: TFileName;
    fBinaryFile: Boolean;
    fStaticDataCount: cardinal;
    fStorage: TSQLRestStorageInMemoryDynArray;
    function GetStorage(aTable: TSQLRecordClass): TSQLRestStorageInMemory;
    /// overridden methods which will return error (no main DB here)
    function MainEngineAdd(TableModelIndex: integer; const SentData: RawUTF8): integer; override;
    function MainEngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8; override;
    function MainEngineList(const SQL: RawUTF8; ForceAJAX: Boolean; ReturnedRowCount: PPtrInt): RawUTF8; override;
    function MainEngineUpdate(TableModelIndex, ID: integer; const SentData: RawUTF8): boolean; override;
    function MainEngineDelete(TableModelIndex, ID: integer): boolean; override;
    function MainEngineDeleteWhere(TableModelIndex: integer; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; override;
    function MainEngineRetrieveBlob(TableModelIndex, aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; override;
    function MainEngineUpdateBlob(TableModelIndex, aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; override;
    function MainEngineUpdateField(TableModelIndex: integer;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
  public
    /// initialize a REST server with a database file
    // - all classes of the model will be created as TSQLRestStorageInMemory
    // - then data persistence will be initialized using aFileName, but no
    // file will be written to disk, unless you call explicitly UpdateToFile 
    // - if aFileName is left void (''), data will not be persistent
    constructor Create(aModel: TSQLModel; const aFileName: TFileName='';
      aBinaryFile: boolean=false; aHandleUserAuthentication: boolean=false); reintroduce; virtual;
    /// finalize the REST server
    // - this overridden destructor will write any modification on file (if
    // needed), and release all used memory
    destructor Destroy; override;
    /// Missing tables are created if they don't exist yet for every TSQLRecord
    // class of the Database Model
    // - you must call explicitely this before having called StaticDataCreate()
    // - all table description (even Unique feature) is retrieved from the Model
    // - this method also create additional fields, if the TSQLRecord definition
    // has been modified; only field adding is available, field renaming or
    // field deleting are not allowed in the FrameWork (in such cases, you must
    // create a new TSQLRecord type)
    procedure CreateMissingTables(user_version: cardinal=0); override;
    /// load the content from the specified file name
    // - do nothing if file name was not assigned
    procedure LoadFromFile; virtual;
    /// write any modification into file
    // - do nothing if file name was not assigned
    procedure UpdateToFile; virtual;
    /// clear all internal TObjectList content
    procedure DropDatabase; virtual;
    /// overridden method for direct in-memory database engine call
    // - not implemented: always return false
    function EngineExecuteAll(const aSQL: RawUTF8): boolean; override;
    /// the file name used for data persistence
    property FileName: TFileName read fFileName write fFileName;
    /// direct access to the storage TObjectList storage instances
    // - you can then access to Storage[Table].Count and Storage[Table].Items[]
    property Storage[aTable: TSQLRecordClass]: TSQLRestStorageInMemory read GetStorage;
    /// direct access to the storage TObjectList storage instances
    // - you can then access via Storage[TableIndex].Count and Items[]
    property Storages: TSQLRestStorageInMemoryDynArray read fStorage;
    /// set if the file content is to be compressed binary, or standard JSON
    // - it will use TSQLRestStorageInMemory LoadFromJSON/LoadFromBinary
    // SaveToJSON/SaveToBinary methods for optimized storage
    property BinaryFile: Boolean read fBinaryFile write fBinaryFile;
  published
    /// this method-base service will be accessible from ModelRoot/Flush URI,
    // and will write any modification into file
    // - method parameters signature matches TSQLRestServerCallBack type
    // - do nothing if file name was not assigned
    // - can be used from a remote client to ensure that any Add/Update/Delete
    // will be stored to disk, via
    // ! aClient.CallBackPut('Flush','',dummy)
    procedure Flush(Ctxt: TSQLRestServerURIContext);
  end;

  /// a REST server using a TSQLRestClient for all its ORM process
  // - this server will use an internal TSQLRestClient instance to handle
  // all ORM operations (i.e. access to objects)
  // - it can be used e.g. to host some services on a stand-alone server, with
  // all ORM and data access retrieved from another server: it will allow to
  // easily implement a proxy architecture (for instance, as a DMZ for
  // publishing services, but letting ORM process stay out of scope)
  TSQLRestServerRemoteDB = class(TSQLRestServer)
  protected
    fClient: TSQLRestClient;
    function EngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8; override;
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8; override;
    function EngineAdd(TableModelIndex: integer; const SentData: RawUTF8): integer; override;
    function EngineUpdate(TableModelIndex, ID: integer; const SentData: RawUTF8): boolean; override;
    function EngineDelete(TableModelIndex, ID: integer): boolean; override;
    function EngineDeleteWhere(TableModelIndex: integer; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; override;
    function EngineRetrieveBlob(TableModelIndex, aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateBlob(TableModelIndex, aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateField(TableModelIndex: integer;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
  public
    /// initialize a REST server associated to a given TSQLRestClient instance
    // - the specified TSQLRestClient will be used for all ORM and data process
    // - the supplied TSQLRestClient.Model will be used for TSQLRestServerRemoteDB
    // - note that the TSQLRestClient instance won't be freed - caller shall
    // manage its life time
    constructor Create(aRemoteClient: TSQLRestClient;
      aHandleUserAuthentication: boolean=false); reintroduce; virtual;
    /// implement Server-Side TSQLRest deletion
    /// overridden method for remote database engine call
    // - will return false - i.e. not implemented - since it is a server side
    // operation
    function EngineExecuteAll(const aSQL: RawUTF8): boolean; override;
    /// Execute directly a SQL statement, expecting a list of results
    // - return a result table on success, nil on failure
    // - will call EngineList() abstract method to retrieve its JSON content
    function ExecuteList(const Tables: array of TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON; override;
    /// this method is called internally after any successfull deletion to
    // ensure relational database coherency
    // - this overridden method will just return TRUE: in this remote access,
    // true coherency will be performed on the ORM server side
    function AfterDeleteForceCoherency(Table: TSQLRecordClass; aID: integer): boolean; override;
    /// the remote ORM client used for data persistence
    property Client: TSQLRestClient read fClient;
  end;


  /// possible call parameters for TOnTableUpdate Event
  TOnTableUpdateState = (tusPrepare, tusChanged, tusNoChange);

  /// used by TSQLRestClientURI.UpdateFromServer() to let the client
  // perform the rows update (for Marked[] e.g.)
  TOnTableUpdate = procedure(aTable: TSQLTableJSON; State: TOnTableUpdateState) of object;

  /// used by TSQLRestClientURI.Update() to let the client
  // perform the record update (refresh associated report e.g.)
  TOnRecordUpdate = procedure(Value: TSQLRecord) of object;

  /// a generic REpresentational State Transfer (REST) client
  // - is RESTful (i.e. URI) remotely implemented (TSQLRestClientURI e.g.)
  // - is implemented for direct access to a database (TSQLRestClientDB e.g.)
  TSQLRestClient = class(TSQLRest)
  protected
    fForceBlobTransfert: array of boolean;
    fOnTableUpdate: TOnTableUpdate;
    fOnRecordUpdate: TOnRecordUpdate;
    function GetForceBlobTransfert: Boolean;
    procedure SetForceBlobTransfert(Value: boolean);
    function GetForceBlobTransfertTable(aTable: TSQLRecordClass): Boolean;
    procedure SetForceBlobTransfertTable(aTable: TSQLRecordClass; aValue: Boolean);
    /// get a member from its ID 
    // - implements REST GET collection
    // - returns the data of this object as JSON
    // - override this method for proper data retrieval from the database engine
    // - this method must be implemented in a thread-safe manner
    function ClientRetrieve(TableModelIndex: integer; ID: integer;
      ForUpdate: boolean; var InternalState: cardinal; var Resp: RawUTF8): boolean; virtual; abstract;
    /// this method is called before updating any record
    // - should return FALSE to force no update
    // - can be use to update some field values just before saving to the database
    // (e.g. for digital signing purpose)
    // - this default method just return TRUE (i.e. OK to update)
    function BeforeUpdateEvent(Value: TSQLRecord): Boolean; virtual;
    /// overridden method which will call ClientRetrieve()
    function EngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8; override;
  public
    /// create a new member
    // - implements REST POST collection
    // - URI is 'ModelRoot/TableName' with POST method
    // - if SendData is true, content of Value is sent to the server as JSON
    // - if ForceID is true, client sends the Value.ID field to use this ID
    // - server must return Status 201/HTML_CREATED on success
    // - server must send on success an header entry with
    // $ Location: ModelRoot/TableName/TableID
    // - on success, returns the new ROWID value; on error, returns 0
    // - on success, Value.ID is updated with the new ROWID
    // - if aValue is TSQLRecordFTS3, Value.ID is stored to the virtual table
    // - this overridden method will send BLOB fields, if ForceBlobTransfert is set
    function Add(Value: TSQLRecord; SendData: boolean; ForceID: boolean=false): integer; override;
    /// update a member
    // - implements REST PUT collection
    // - URI is 'ModelRoot/TableName/TableID' with PUT method
    // - server must return Status 200/HTML_SUCCESS OK on success
    // - this overridden method will call BeforeUpdateEvent and also update BLOB
    // fields, if any ForceBlobTransfert is set and CustomFields=[]
    function Update(Value: TSQLRecord; const CustomFields: TSQLFieldBits=[]): boolean; override;
    /// get a member from its ID
    // - implements REST GET collection
    // - URI is 'ModelRoot/TableName/TableID' with GET method
    // - server must return Status 200/HTML_SUCCESS OK on success
    // - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
    // the corresponding record, then retrieve its content; caller has to call
    // UnLock() method after Value usage, to release the record
    function Retrieve(aID: integer; Value: TSQLRecord; ForUpdate: boolean=false): boolean; override;
    /// get a member from its ID
    // - implements REST GET collection
    // - URI is 'ModelRoot/TableName/TableID' with GET method
    // - returns true on server returned 200/HTML_SUCCESS OK success, false on error
    // - set Refreshed to true if the content changed
    function Refresh(aID: integer; Value: TSQLRecord; var Refreshed: boolean): boolean;

    /// retrieve a list of members as a TSQLTable
    // - implements REST GET collection
    // - default SQL statement is 'SELECT ID FROM TableName;' (i.e. retrieve
    // the list of all ID of this collection members)
    // - optional SQLSelect parameter to change the returned fields
    // as in 'SELECT SQLSelect FROM TableName;'
    // - optional SQLWhere parameter to change the search range or ORDER
    // as in 'SELECT SQLSelect FROM TableName WHERE SQLWhere;'
    // - using inlined parameters via :(...): in SQLWhere is always a good idea
    // - for one TClass, you should better use TSQLRest.MultiFieldValues()
    function List(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8 = 'RowID';
      const SQLWhere: RawUTF8 = ''): TSQLTableJSON; virtual; abstract;
    /// retrieve a list of members as a TSQLTable
    // - implements REST GET collection
    // - in this version, the WHERE clause can be created with the same format
    // as FormatUTF8() function, replacing all '%' chars with Args[] values
    // - using inlined parameters via :(...): in SQLWhereFormat is always a good idea
    // - for one TClass, you should better use TSQLRest.MultiFieldValues()
    // - will call the List virtual method internaly
    function ListFmt(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8;
      SQLWhereFormat: PUTF8Char; const Args: array of const): TSQLTableJSON; overload;
    /// retrieve a list of members as a TSQLTable
    // - implements REST GET collection
    // - in this version, the WHERE clause can be created with the same format
    // as FormatUTF8() function, replacing all '%' chars with Args[], and all '?'
    // chars with Bounds[] (inlining them with :(...): and auto-quoting strings)
    // - example of use:
    // ! Table := ListFmt([TSQLRecord],'Name','ID=?',[],[aID]);
    // - for one TClass, you should better use TSQLRest.MultiFieldValues()
    // - will call the List virtual method internaly
    function ListFmt(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8;
      SQLWhereFormat: PUTF8Char; const Args, Bounds: array of const): TSQLTableJSON; overload;
    /// Execute directly a SQL statement
    // - return true on success
    function EngineExecute(const SQL: RawUTF8): boolean; overload; virtual; abstract;
    /// Execute directly a SQL statement with supplied parameters
    // - expect the same format as FormatUTF8() function, replacing all '%' chars
    // with Args[] values
    // - return true on success
    function EngineExecuteFmt(SQLFormat: PUTF8Char; const Args: array of const): boolean; overload;
    /// Execute directly a SQL statement with supplied parameters
    // - expect the same format as FormatUTF8() function, replacing all '%' chars
    // with Args[] values, and all '?' chars with Bounds[] (inlining them
    // with :(...): and auto-quoting strings)
    // - return true on success
    function EngineExecuteFmt(SQLFormat: PUTF8Char; const Args, Bounds: array of const): boolean; overload;
    /// dedicated method used to retrieve matching IDs using a fast R-Tree index
    // - a TSQLRecordRTree is associated to a TSQLRecord with a specified BLOB
    // field, and will call TSQLRecordRTree BlobToCoord and ContainedIn virtual
    // class methods to execute an optimized SQL query
    // - will return all matching DataTable IDs in DataID[]
    // - will generate e.g. the following statement
    // $ SELECT MapData.ID From MapData, MapBox WHERE MapData.ID=MapBox.ID
    // $  AND minX>=:(-81.0): AND maxX<=:(-79.6): AND minY>=:(35.0): AND :(maxY<=36.2):
    // $  AND MapBox_in(MapData.BlobField,:('\uFFF0base64encoded-81,-79.6,35,36.2'):);
    // when the following Delphi code is executed:
    // ! aClient.RTreeMatch(TSQLRecordMapData,'BlobField',TSQLRecordMapBox,
    // !   aMapData.BlobField,ResultID);
    function RTreeMatch(DataTable: TSQLRecordClass;
      const DataTableBlobFieldName: RawUTF8; RTreeTable: TSQLRecordRTreeClass;
      const DataTableBlobField: RawByteString; var DataID: TIntegerDynArray): boolean;
    /// begin a transaction (calls REST BEGIN Member)
    // - by default, Client transaction will use here a pseudo session
    // - in aClient-Server environment with multiple Clients connected at the
    // same time, you should better use BATCH process, specifying a positive
    // AutomaticTransactionPerRow parameter to BatchStart() 
    function TransactionBegin(aTable: TSQLRecordClass; 
	  SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED): boolean; override; 
    /// end a transaction (calls REST END Member)
    // - by default, Client transaction will use here a pseudo session
    procedure Commit(SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED); override;
    /// abort a transaction (calls REST ABORT Member)
    // - by default, Client transaction will use here a pseudo session
    procedure RollBack(SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED); override;

    /// if set to TRUE, all BLOB fields of all tables will be transferred
    // between the Client and the remote Server
    // - i.e. Add() Update() will use Blob-related RESTful PUT/POST request
    // - i.e. Retrieve() will use Blob-related RESTful GET request
    // - note that the Refresh method won't handle BLOB fields, even if this
    // property setting is set to TRUE
    // - by default, this property is set to FALSE, which setting will spare
    // bandwidth and CPU
    // - this property is global to all tables of the model - you can also use
    // ForceBlobTransfertTable[] to force it for a particular table
    property ForceBlobTransfert: boolean read GetForceBlobTransfert write SetForceBlobTransfert;
    /// if set to TRUE for a specified table of the model, all BLOB fields of
    // this tables will be transferred between the Client and the remote Server
    // - i.e. Add() Update() will use BLOB-related RESTful PUT/POST request for
    // this table
    // - i.e. Retrieve() will use BLOB-related RESTful GET request for
    // this table
    // - note that the Refresh method won't handle BLOB fields, even if this
    // property setting is set to TRUE
    // - by default, all items of this property are set to FALSE, which
    // setting will spare bandwidth and CPU
    // - this property is particular to a given tables of the model - you can
    // also use ForceBlobTransfert to force it for a all tables of this model
    property ForceBlobTransfertTable[aTable: TSQLRecordClass]: Boolean
      read GetForceBlobTransfertTable write SetForceBlobTransfertTable;
    /// this Event is called by UpdateFromServer() to let the Client adapt to
    // some rows update (for Marked[] e.g.)
    property OnTableUpdate: TOnTableUpdate read fOnTableUpdate write fOnTableUpdate;
    /// this Event is called by Update() to let the client
    // perform the record update (refresh associated report e.g.)
    property OnRecordUpdate: TOnRecordUpdate read fOnRecordUpdate write fOnRecordUpdate;
  end;

  /// used by TSQLRestClientURI.URI() to let the client ask for an User name
  // and password, in order to retry authentication to the server
  // - should return TRUE if aUserName and aPassword both contain some entered
  // values to be sent for remote secure authentication
  // - should return FALSE if the user pressed cancel or the number of Retry
  // reached a defined limit
  TOnAuthentificationFailed = function(Retry: integer;
    var aUserName, aPassword: string): boolean of object;

  /// a generic REpresentational State Transfer (REST) client with URI
  // - URI are standard Collection/Member implemented as ModelRoot/TableName/TableID
  // - handle RESTful commands GET POST PUT DELETE LOCK UNLOCK
  TSQLRestClientURI = class(TSQLRestClient)
  protected
    fOnAuthentificationFailed: TOnAuthentificationFailed;
    fOnSetUser: TNotifyEvent;
    fMaximumAuthentificationRetry: Integer;
    fRetryOnceOnTimeout: boolean;
    fLastErrorCode: integer;
    fLastErrorMessage: RawUTF8;
    fLastErrorException: ExceptClass;
    /// private values created by sucessfull SetUser() method
    fSessionUser: TSQLAuthUser;
    fSessionID: cardinal;
    fSessionIDHexa8: RawUTF8;
    fSessionPrivateKey: cardinal;
    fSessionLastTick64: Int64;
    fSessionAuthentication: TSQLRestServerAuthenticationClass;
    /// used to make the internal client-side process reintrant
    fMutex: TRTLCriticalSection;
{$ifndef LVCL} // SyncObjs.TEvent not available in LVCL yet
    fBackgroundThread: TSynBackgroundThreadEvent;
    fOnIdle: TOnIdleSynBackgroundThread;
    procedure OnBackgroundProcess(Sender: TSynBackgroundThreadEvent;
      ProcessOpaqueParam: pointer);
    function GetOnIdleBackgroundThreadActive: boolean;
{$endif}
    procedure SetLastException(E: Exception=nil; ErrorCode: integer=HTML_BADREQUEST);
    /// clear session and call the /auth service on the server to notify shutdown
    procedure SessionClose;
    // register the user session to the TSQLRestClientURI instance
    function SessionCreate(aAuth: TSQLRestServerAuthenticationClass;
      var aUser: TSQLAuthUser; const aSessionKey: RawUTF8): boolean;
    /// abstract method to be implemented with a local, piped or HTTP/1.1 provider
    // - you can specify some POST/PUT data in Call.OutBody (leave '' otherwise)
    // - return the execution result in Call.OutStatus
    // - for clients, RestAccessRights is never used
    procedure InternalURI(var Call: TSQLRestURIParams); virtual; abstract;
    /// overridden protected method shall check if not connected to reopen it
    // - shall return TRUE on success, FALSE on any connection error
    function InternalCheckOpen: boolean; virtual; abstract;
    /// overridden protected method shall force the connection to be closed,
    // - a next call to InternalCheckOpen method shall re-open the connection
    procedure InternalClose; virtual; abstract;
    /// calls 'ModelRoot/TableName/TableID' with appropriate REST method
    // - uses GET method if ForUpdate is false
    // - uses LOCK method if ForUpdate is true
    function URIGet(Table: TSQLRecordClass; ID: integer; var Resp: RawUTF8;
      ForUpdate: boolean=false): Int64Rec;
    // overridden methods
    function ClientRetrieve(TableModelIndex, ID: integer; ForUpdate: boolean;
      var InternalState: cardinal; var Resp: RawUTF8): boolean; override;
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8; override;
    function EngineAdd(TableModelIndex: integer; const SentData: RawUTF8): integer; override;
    function EngineUpdate(TableModelIndex, ID: integer; const SentData: RawUTF8): boolean; override;
    function EngineDelete(TableModelIndex, ID: integer): boolean; override;
    function EngineDeleteWhere(TableModelIndex: integer; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; override;
    function EngineRetrieveBlob(TableModelIndex, aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateBlob(TableModelIndex, aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateField(TableModelIndex: integer;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
    function EngineBatchSend(Table: TSQLRecordClass; const Data: RawUTF8;
       var Results: TIntegerDynArray): integer; override;
  public
    /// initialize REST client instance
    constructor Create(aModel: TSQLModel); override;
    /// release memory and close client connection
    // - also unlock all still locked records by this client
    destructor Destroy; override;
    /// authenticate an User to the current connected Server
    // - will call the ModelRoot/Auth service, i.e. call TSQLRestServer.Auth()
    // published method to create a session for this user, with our secure
    // TSQLRestServerAuthenticationDefault authentication scheme
    // - returns true on success
    // - calling this method is optional, depending on your user right policy:
    // your Server need to handle authentication
    // - on success, the SessionUser property map the logged user session on the
    // server side
    // - if aHashedPassword is TRUE, the aPassword parameter is expected to
    // contain the already-hashed value, just as stored in PasswordHashHexa
    // (i.e. SHA256('salt'+Value) as in TSQLAuthUser.SetPasswordPlain method)
    // - if SSPIAUTH conditional is defined, and aUserName='', a Windows
    // authentication will be performed via TSQLRestServerAuthenticationSSPI -
    // in this case, aPassword will contain the SPN domain for Kerberos
    // (otherwise NTLM will be used), and table TSQLAuthUser shall contain
    // an entry for the logged Windows user, with the LoginName in form
    // 'DomainName\UserName'
    // - you can directly create the class method ClientSetUser() of a given
    // TSQLRestServerAuthentication inherited class, if neither
    // TSQLRestServerAuthenticationDefault nor TSQLRestServerAuthenticationSSPI
    // match your need
    function SetUser(const aUserName, aPassword: RawUTF8;
      aHashedPassword: Boolean=false): boolean;
    /// method calling the remote Server via a RESTful command
    // - calls the InternalURI abstract method, which should be overridden with a
    // local, piped or HTTP/1.1 provider
    // - this method will add sign the url with the appropriate digital signature
    // according to the current SessionUser property
    // - this method will retry the connection in case of authentication failure
    // (i.e. if the session was closed by the remote server, for any reason -
    // mostly a time out) if the OnAuthentificationFailed event handler is set
    function URI(const url, method: RawUTF8; Resp: PRawUTF8=nil;
      Head: PRawUTF8=nil; SendData: PRawUTF8=nil): Int64Rec; 
    /// retrieve a list of members as a TSQLTable
    // - implements REST GET collection
    // - URI is 'ModelRoot/TableName' with GET method
    // - SQLSelect and SQLWhere are encoded as 'select=' and 'where=' URL parameters
    // (using inlined parameters via :(...): in SQLWhere is always a good idea)
    // - server must return Status 200/HTML_SUCCESS OK on success
    function List(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8 = 'RowID';
      const SQLWhere: RawUTF8 = ''): TSQLTableJSON; override;
    /// unlock the corresponding record
    // - URI is 'ModelRoot/TableName/TableID' with UNLOCK method
    // - returns true on success
    function UnLock(Table: TSQLRecordClass; aID: integer): boolean; override;
    /// Execute directly a SQL statement
    // - URI is 'ModelRoot' with POST method, and SQL statement sent as UTF-8
    // - server must return Status 200/HTML_SUCCESS OK on success
    function EngineExecute(const SQL: RawUTF8): boolean; override;
    /// Execute directly a SQL statement, expecting a list of resutls
    // - URI is 'ModelRoot' with GET method, and SQL statement sent as UTF-8
    // - return a result table on success, nil on failure
    function ExecuteList(const Tables: array of TSQLRecordClass;
      const SQL: RawUTF8): TSQLTableJSON; override;
    /// ask the server for its current internal state revision counter
    // - this counter is incremented every time the database is modified
    // - the returned value is 0 if the database doesn't support this feature
    // - TSQLTable does compare this value with its internal one to check if
    // its content must be updated
    function ServerInternalState: cardinal;
    /// check if the data may have changed of the server for this objects, and
    // update it if possible
    // - only working types are TSQLTableJSON and TSQLRecord descendants
    // - make use of the InternalState function to check the data content revision
    // - return true if Data is updated successfully, or false on any error
    // during data retrieval from server (e.g. if the TSQLRecord has been deleted)
    // - if Data contains only one TSQLTableJSON, PCurrentRow can point to the
    // current selected row of this table, in order to refresh its value
    // - use this method to refresh the client UI, e.g. via a timer
    function UpdateFromServer(const Data: array of TObject; out Refreshed: boolean;
      PCurrentRow: PInteger = nil): boolean;
    /// send a flush command to the remote Server cache
    // - this method will remotely call the Cache.Flush() methods of the server
    // instance, to force cohesion of the data
    // - ServerCacheFlush() with no parameter will flush all stored JSON content
    // - ServerCacheFlush(aTable) will flush the cache for a given table
    // - ServerCacheFlush(aTable,aID) will flush the cache for a given record
    function ServerCacheFlush(aTable: TSQLRecordClass=nil; aID: integer=0): boolean;
    /// you can call this method to call the remote URI root/TimeStamp
    // - this can be an handy way of testing the connection, since this method
    // is always available, even without authentication
    // - returns TRUE if the client time correction has been retrieved
    // - returns FALSE on any connection error - check LastErrorMessage and
    // LastErrorException to find out the exact connection error
    function ServerTimeStampSynchronize: boolean;

    {/ begin a transaction
     - implements REST BEGIN collection
     - in aClient-Server environment with multiple Clients connected at the
      same time, you should better use BATCH process, specifying a positive
      AutomaticTransactionPerRow parameter to BatchStart()
     - may be used to speed up some SQL statements as Add/Update/Delete methods 
     - must be ended with Commit on success
     - in the current implementation, the aTable parameter is not used yet
     - must be aborted with Rollback if any SQL statement failed
     - return true if no transaction is active, false otherwise
      !if Client.TransactionBegin(TSQLRecordPeopleObject) then
      !try
      !  //.... modify the database content, raise exceptions on error
      !  Client.Commit;
      !except
      !  Client.RollBack; // in case of error
      !end;
     - you may use the dedicated TransactionBeginRetry() method in case of
       potiental Client concurent access }
    function TransactionBegin(aTable: TSQLRecordClass; SessionID: cardinal=1): boolean; override;
    {/ begin a transaction
     - implements REST BEGIN collection
     - in aClient-Server environment with multiple Clients connected at the
      same time, you should better use BATCH process, specifying a positive
      AutomaticTransactionPerRow parameter to BatchStart()
     - this version retries a TranslationBegin() to be successfull within
      a supplied number of times
     - will retry every 100 ms for "Retries" times (excluding the connection
      time in this 100 ms time period
     - default is to retry 10 times, i.e. within 2 second timeout
     - in the current implementation, the aTable parameter is not used yet
     - typical usage should be for instance:
      !if Client.TransactionBeginRetry(TSQLRecordPeopleObject,20) then
      !try
      !  //.... modify the database content, raise exceptions on error
      !  Client.Commit;
      !except
      !  Client.RollBack; // in case of error
      !end; }
    function TransactionBeginRetry(aTable: TSQLRecordClass; Retries: integer=10): boolean;
    {/ end a transaction
    - implements REST END collection
     - write all pending SQL statements to the disk }
    procedure Commit(SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED); override;
    {/ abort a transaction
     - implements REST ABORT collection
     - restore the previous state of the database, before the call to TransactionBegin }
    procedure RollBack(SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED); override;
    /// update a member in current BATCH sequence
    // - this overridden method will call BeforeUpdateEvent() method
    function BatchUpdate(Value: TSQLRecord; const CustomFields: TSQLFieldBits=[]): integer; override;

    {/ wrapper to the protected URI method to call a method on the server, using
      a ModelRoot/[TableName/[ID/]]MethodName RESTful GET request
      - returns the HTTP error code (e.g. 200/HTML_SUCCESS on success)
      - this version will use a GET with supplied parameters (which will be encoded
        with the URL) }
    function CallBackGet(const aMethodName: RawUTF8;
      const aNameValueParameters: array of const;
      out aResponse: RawUTF8; aTable: TSQLRecordClass=nil; aID: integer=0;
      aResponseHead: PRawUTF8=nil): integer;
    {/ wrapper to the protected URI method to call a method on the server, using
      a ModelRoot/[TableName/[ID/]]MethodName RESTful GET request
      - returns the UTF-8 decoded JSON result (server must reply with one
        "result":"value" JSON object)
      - this version will use a GET with supplied parameters (which will be encoded
        with the URL) }
    function CallBackGetResult(const aMethodName: RawUTF8;
      const aNameValueParameters: array of const;
      aTable: TSQLRecordClass=nil; aID: integer=0): RawUTF8;
    {/ wrapper to the protected URI method to call a method on the server, using
      a ModelRoot/[TableName/[ID/]]MethodName RESTful PUT request
      - returns the HTTP error code (e.g. 200/HTML_SUCCESS on success)
      - this version will use a PUT with the supplied raw UTF-8 data }
    function CallBackPut(const aMethodName, aSentData: RawUTF8;
      out aResponse: RawUTF8; aTable: TSQLRecordClass=nil; aID: integer=0;
      aResponseHead: PRawUTF8=nil): integer;
    /// register one or several Services on the client side via their interfaces
    // - this methods expects a list of interfaces to be registered to the client
    // (e.g. [TypeInfo(IMyInterface)])
    // - instance implementation pattern will be set by the appropriate parameter
    // - will return true on success, false if registration failed (e.g. if any of
    // the supplied interfaces is not correct or is not available on the server)
    // - that is, server side will be called to check for the availability of
    // each interface
    // - you can specify an optional custom contract for the first interface
    function ServiceRegister(const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation=sicSingle;
      const aContractExpected: RawUTF8=''): boolean; overload; virtual;
    /// register a Service on the client side via its interface
    // - this methods expects one interface to be registered to the client, as
    // ! Client.ServiceRegister(TypeInfo(IMyInterface),sicShared);
    // - instance implementation pattern will be set by the appropriate parameter
    // - will return the corresponding fake class factory on success, nil if
    // registration failed (e.g. if any of supplied interfaces is not correct or
    // is not available on the server)
    // - that is, server side will be called to check for the availability of
    // each interface
    // - you can specify an optional custom contract for the first interface
    function ServiceRegister(aInterface: PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation=sicSingle;
      const aContractExpected: RawUTF8=''): TServiceFactory; overload;
    /// register and retrieve the sicClientDriven Service instance
    // - will return TRUE on success, filling Obj output variable with the
    // corresponding interface instance
    // - will return FALSE on error
    function ServiceRegisterClientDriven(aInterface: PTypeInfo; out Obj;
      const aContractExpected: RawUTF8=''): boolean; 

    /// low-level error code, as returned by server
    // - check this value about HTML_* constants
    // - HTML_SUCCESS or HTML_CREATED mean no error
    // - otherwise, check LastErrorMessage property for additional information
    // - this property value will record status codes returned by URI() method
    property LastErrorCode: integer read fLastErrorCode;
    /// low-level error message, as returned by server
    // - this property value will record content returned by URI() method in
    // case of an error, or '' if LastErrorCode is HTML_SUCCESS or HTML_CREATED
    property LastErrorMessage: RawUTF8 read fLastErrorMessage;
    /// low-level exception class, if any
    // - will record any Exception class raised within URI() method
    // - contains nil if URI() execution did not raise any exception (which
    // is the most expected behavior, since server-side errors are trapped
    // into LastErrorCode/LastErrorMessage properties 
    property LastErrorException: ExceptClass read fLastErrorException;

    /// this Event is called in case of remote authentication failure
    // - client software can ask the user to enter a password and user name
    // - if no event is specified, the URI() method will return directly
    // an HTML_FORBIDDEN "403 Forbidden" error code
    property OnAuthentificationFailed: TOnAuthentificationFailed
      read fOnAuthentificationFailed write fOnAuthentificationFailed;
    /// this Event is called when a user is authenticated
    // - is called always, on each TSQLRestClientURI.SetUser call
    // - you can check the SessionUser property to retrieve the current
    // authenticated user, or nil if authentication failed
    // - could be used to refresh the User Interface layout according to
    // current authenticated user rights 
    property OnSetUser: TNotifyEvent read fOnSetUser write fOnSetUser;
    /// maximum additional retry occurence
    // - defaut is 0, i.e. will retry once
    // - set OnAuthentificationFailed to nil in order to avoid any retry 
    property MaximumAuthentificationRetry: Integer
      read fMaximumAuthentificationRetry write fMaximumAuthentificationRetry;
    /// if the client shall retry once in case of "408 REQUEST TIMEOUT" error
    property RetryOnceOnTimeout: Boolean
      read fRetryOnceOnTimeout write fRetryOnceOnTimeout;
{$ifndef LVCL}
    /// set a callback event to be executed in loop during remote blocking
    // process, e.g. to refresh the UI during a somewhat long request
    // - if not set, the request will be executed in the current thread,
    // so may block the User Interface
    // - you can assign a callback to this property, calling for instance
    // Application.ProcessMessages, to execute the remote request in a
    // background thread, but let the UI still be reactive: the
    // TLoginForm.OnIdleProcess and OnIdleProcessForm methods of
    // mORMotUILogin.pas will match this property expectations    
    property OnIdle: TOnIdleSynBackgroundThread read fOnIdle write fOnIdle;
    /// TRUE if the background thread is active, and OnIdle event is called
    // during process
    // - to be used e.g. to ensure no re-entrance from User Interface messages
    property OnIdleBackgroundThreadActive: Boolean read GetOnIdleBackgroundThreadActive;
{$endif}
    /// the current user as set by SetUser() method
    // - returns nil if no User is currently authenticated
    // - only available fields by default are LogonName and PasswordHashHexa:
    // you can run code similar to the following to fill all needed properties:
    // !  if fClient.SessionUser<>nil then
    // !  begin
    // !    fClient.Retrieve('LogonName=?',[],[fClient.SessionUser.LogonName],
    // !      fClient.SessionUser); // fill ID, DisplayName, GroupRights
    // !    fClient.RetrieveBlobFields(fClient.SessionUser); // optional Data
    // !  end;
    property SessionUser: TSQLAuthUser read fSessionUser;
    /// the current session ID as set after a successfull SetUser() method call
    // - equals 0 (CONST_AUTHENTICATION_SESSION_NOT_STARTED) if the session
    // is not started yet - i.e. if SetUser() call failed
    // - equals 1 (CONST_AUTHENTICATION_NOT_USED) if authentication mode
    // is not enabled - i.e. after a fresh Create() without SetUser() call
    property SessionID: cardinal read fSessionID;
  end;

{$ifdef MSWINDOWS}
  /// Rest client with remote access to a server through a dll
  // - use only one TURIMapRequest function for the whole communication
  // - the data is stored in Global system memory, and freed by GlobalFree()
  TSQLRestClientURIDll = class(TSQLRestClientURI)
  private
    /// used by Create(from dll) constructor
    fLibraryHandle: cardinal;
  protected
    Func: TURIMapRequest;
    /// method calling the RESTful server through a DLL or executable, using
    // direct memory
    procedure InternalURI(var Call: TSQLRestURIParams); override;
    /// overridden protected method do nothing (direct DLL access has no connection)
    function InternalCheckOpen: boolean; override;
    /// overridden protected method do nothing (direct DLL access has no connection)
    procedure InternalClose; override;
  public
    /// connect to a server from a remote function
    constructor Create(aModel: TSQLModel; aRequest: TURIMapRequest); reintroduce; overload;
    /// connect to a server contained in a shared library
    // - this dll must contain at least a URIRequest entry
    // - raise an exception if the shared library is not found or invalid
    constructor Create(aModel: TSQLModel; const DllName: TFileName); reintroduce; overload;
    /// release memory and handles
    destructor Destroy; override;
  end;

  /// Rest client with remote access to a server through Windows messages
  // - use only one TURIMapRequest function for the whole communication
  // - the data is sent and received by using the standard and fast WM_COPYDATA message
  // - named pipes seems to be somewhat better for bigger messages under XP
  // - this class is thread-safe, since its URI() method is protected by a lock
  TSQLRestClientURIMessage = class(TSQLRestClientURI)
  protected
    /// the HWND of the server process, retrieved by InternalCheckOpen() method
    fServerWindow: HWND;
    /// the Window name used of the server process
    fServerWindowName: string;
    /// the HWND of the client process, as set by Create() method
    fClientWindow: HWND;
    /// the Window name used, if created internaly
    fClientWindowName: string;
    /// the time out to be used, in mili seconds
    fTimeOutMS: cardinal;
    /// if InternalURI will process the Windows Messages loop
    fDoNotProcessMessages: boolean;
    /// the expected current response
    // - this value is set from the incoming WM_COPYDATA
    // - this value is set to #0 (i.e. string of one #0 char) while waiting
    // for a WM_COPYDATA message in URI() method
    fCurrentResponse: RawUTF8;
    /// method calling the RESTful server by using Windows WM_COPYDATA messages
    procedure InternalURI(var Call: TSQLRestURIParams); override;
    /// overridden protected method to handle Windows Message loop connection
    function InternalCheckOpen: boolean; override;
    /// overridden protected method to close Windows Message
    procedure InternalClose; override;
  public
    /// connect to a server from its window name
    // - ServerWindowName is of UnicodeString type since Delphi 2009
    // (direct use of FindWindow()=FindWindowW() Win32 API)
    // - this version must supply a Client Window handle
    constructor Create(aModel: TSQLModel; const ServerWindowName: string;
      ClientWindow: HWND; TimeOutMS: cardinal); reintroduce; overload;
    /// connect to a server from its window name
    // - ServerWindowName is of UnicodeString type since Delphi 2009
    // (direct use of FindWindow()=FindWindowW() Win32 API)
    // - this version will instanciante and create a Client Window from
    // a Window Name, by using low level Win32 API: therefore, the Forms unit
    // is not needed with this constructor (save some KB)
    constructor Create(aModel: TSQLModel; const ServerWindowName,
      ClientWindowName: string; TimeOutMS: cardinal); reintroduce; overload;
    /// release the internal Window class created, if any
    destructor Destroy; override;
    /// event to be triggered when a WM_COPYDATA message is received from the server
    // - to be called by the corresponding message WM_COPYDATA; method in the
    // client window
    procedure WMCopyData(var Msg : TWMCopyData); message WM_COPYDATA;
    /// define if the client will process the Windows Messages loop
    // - set to TRUE if the client is used outside the main GUI application thread
    property DoNotProcessMessages: boolean read fDoNotProcessMessages write fDoNotProcessMessages;
  end;

  /// Rest client with remote access to a server through a Named Pipe
  // - named pipe is fast and optimized under Windows
  // - can be accessed localy or remotely
  // - this class is thread-safe, since its URI() method is protected by a lock
  TSQLRestClientURINamedPipe = class(TSQLRestClientURI)
  private
    /// handle for '\\.\pipe\mORMot_TEST' e.g.
    fServerPipe: THandle;
    /// the pipe name
    fPipeName: TFileName;
{$ifndef ANONYMOUSNAMEDPIPE}
  {$ifndef NOSECURITYFORNAMEDPIPECLIENTS}
    fPipeSecurityAttributes: TSecurityAttributes;
    fPipeSecurityDescriptor: array[0..SECURITY_DESCRIPTOR_MIN_LENGTH] of byte;
  {$endif}
{$endif}
  protected
    /// method calling the RESTful server through a DLL or executable, by using
    // a named pipe (faster than TCP/IP or HTTP connection)
    // - return status code in result.Lo
    // - return database internal state in result.Hi
    // - status code 501 HTML_NOTIMPLEMENTED if no server is available
    procedure InternalURI(var Call: TSQLRestURIParams); override;
    /// overridden protected method to handle named-pipe connection
    function InternalCheckOpen: boolean; override;
    /// overridden protected method to close named-pipe connection
    procedure InternalClose; override;
  public
    /// connect to a server contained in a running application
    // - the server must have been declared by a previous
    // TSQLRestServer.ExportServer(ApplicationName) call
    // with ApplicationName as user-defined server identifier ('DBSERVER' e.g.)
    // - ApplicationName is of UnicodeString type since Delphi 2009
    // (direct use of Wide Win32 API version)
    // - this server identifier is appended to '\\.\pipe\mORMot_' to obtain
    // the full pipe name to connect to ('\\.\pipe\mORMot__DBSERVER' e.g.)
    // - this server identifier may also contain a remote computer name, and
    // must be fully qualified ('\\ServerName\pipe\ApplicationName' e.g.)
    // - raise an exception if the server is not running or invalid
    constructor Create(aModel: TSQLModel; const ApplicationName: TFileName); reintroduce;
  end;
{$endif Win32}

  /// will define a validation to be applied to a TSQLRecord field, using
  // if necessary an associated TSQLRest instance and a TSQLRecord class
  // - a typical usage is to validate a value to be unique in the table
  // (implemented in the TSynValidateUniqueField class)
  // - the optional associated parameters are to be supplied JSON-encoded
  // - ProcessRest and ProcessRec properties will be filled before Process
  // method call by TSQLRecord.Validate()
  TSynValidateRest = class(TSynValidate)
  protected
    fProcessRest: TSQLRest;
    fProcessRec: TSQLRecord;
  public
    /// the associated TSQLRest instance
    // - this value is updated by TSQLRecord.Validate with the current
    // TSQLRest used for the validation
    // - it can be used in the overridden Process method
    property ProcessRest: TSQLRest read fProcessRest;
    /// the associated TSQLRecord instance
    // - this value is updated by TSQLRecord.Validate with the current
    // TSQLRecord instance to be validated
    // - it can be used in the overridden Process method
    property ProcessRec: TSQLRecord read fProcessRec;
  end;

  /// will define a validation for a TSQLRecord Unique field
  // - it will check that the field value is not void
  // - it will check that the field value is not a duplicate
  TSynValidateUniqueField = class(TSynValidateRest)
  public
    /// perform the unique field validation action to the specified value
    // - duplication value check will use ProcessRest and ProcessRec properties,
    // as set by TSQLRecord.Validate
    function Process(aFieldIndex: integer; const Value: RawUTF8; var ErrorMsg: string): boolean; override;
  end;


  /// a WHERE constraint as set by the TSQLVirtualTable.Prepare() method
  TSQLVirtualTablePreparedConstraint = record
    /// Column on left-hand side of constraint
    // - The first column of the virtual table is column 0
    // - The ROWID of the virtual table is column -1
    // - Hidden columns are counted when determining the column index
    // - if this field contains VIRTUAL_TABLE_IGNORE_COLUMN (-2), TSQLVirtualTable.
    // Prepare() should ignore this entry
    Column: integer;
    /// Constraint operator
    // - MATCH keyword is parsed into soBeginWith, and should be handled as
    // soBeginWith, soContains or soSoundsLike* according to the effective
    // expression text value ('text*', '%text'...)
    Operation: TCompareOperator;
    /// If true, the constraint is assumed to be fully handled
    // by the virtual table and is not checked again by SQLite
    // - By default (OmitCheck=false), the SQLite core double checks all
    // constraints on each row of the virtual table that it receives
    // - TSQLVirtualTable.Prepare() can set this property to true
    OmitCheck: boolean;
    /// The associated expression
    // - TSQLVirtualTable.Prepare() must set Value.VType to not svtUnknown
    // (e.g. to svtNull), if an expression is expected at vt_BestIndex() call
    // - TSQLVirtualTableCursor.Search() will receive an expression value,
    // to be retrieved e.g. via sqlite3_value_*() functions
    Value: TSQLVar;
  end;

  /// an ORDER BY clause as set by the TSQLVirtualTable.Prepare() method
  TSQLVirtualTablePreparedOrderBy = record
    /// Column number
    // - The first column of the virtual table is column 0
    // - The ROWID of the virtual table is column -1
    // - Hidden columns are counted when determining the column index.
    Column: Integer;
    /// True for DESCending order, false for ASCending order.
    Desc: boolean;
  end;


  /// the WHERE and ORDER BY statements as set by TSQLVirtualTable.Prepare 
  // - Where[] and OrderBy[] are fixed sized arrays, for fast and easy code
  TSQLVirtualTablePrepared = {$ifndef ISDELPHI2010}object{$else}record{$endif}
  public
    /// number of WHERE statement parameters in Where[] array
    WhereCount: integer;
    /// numver of ORDER BY statement parameters in OrderBy[]
    OrderByCount: integer;
    /// if true, the ORDER BY statement is assumed to be fully handled
    // by the virtual table and is not checked again by SQLite
    // - By default (OmitOrderBy=false), the SQLite core sort all rows of the
    // virtual table that it receives according in order
    OmitOrderBy: boolean;
    ///  Estimated cost of using this prepared index
    // - SQLite uses this value to make a choice between several calls to
    // the TSQLVirtualTable.Prepare() method with several expressions
    EstimatedCost: Double;
    /// WHERE statement parameters, in TSQLVirtualTableCursor.Search() order
    Where: array[0..MAX_SQLFIELDS-1] of TSQLVirtualTablePreparedConstraint;
    /// ORDER BY statement parameters
    OrderBy: array[0..MAX_SQLFIELDS-1] of TSQLVirtualTablePreparedOrderBy;
    /// returns TRUE if there is only one ID=? statement in this search
    function IsWhereIDEquals(CalledFromPrepare: Boolean): boolean;
       {$ifdef HASINLINE}inline;{$endif}
    /// returns TRUE if there is only one FieldName=? statement in this search
    function IsWhereOneFieldEquals: boolean;
       {$ifdef HASINLINE}inline;{$endif}
  end;

  PSQLVirtualTablePrepared = ^TSQLVirtualTablePrepared;

  TSQLVirtualTableCursor = class;
  TSQLVirtualTableCursorClass = class of TSQLVirtualTableCursor;

  /// the possible features of a Virtual Table
  // - vtWrite is to be set if the table is not Read/Only
  // - vtTransaction if handles vttBegin, vttSync, vttCommit, vttRollBack
  // - vtSavePoint if handles vttSavePoint, vttRelease, vttRollBackTo
  // - vtWhereIDPrepared if the ID=? WHERE statement will be handled in
  // TSQLVirtualTableCursor.Search()
  TSQLVirtualTableFeature = (vtWrite, vtTransaction, vtSavePoint,
    vtWhereIDPrepared);

  /// a set of features of a Virtual Table
  TSQLVirtualTableFeatures = set of TSQLVirtualTableFeature;

  /// used to store and handle the main specifications of a TSQLVirtualTableModule
  TVirtualTableModuleProperties = record
    /// a set of features of a Virtual Table
    Features: TSQLVirtualTableFeatures;
    /// the associated cursor class
    CursorClass: TSQLVirtualTableCursorClass;
    /// the associated TSQLRecord class
    // - used to retrieve the field structure with all collations
    RecordClass: TSQLRecordClass;
    /// the associated TSQLRestStorage class used for storage
    // - is e.g. TSQLRestStorageInMemory for TSQLVirtualTableJSON,
    // TSQLRestStorageExternal for TSQLVirtualTableExternal, or nil for
    // TSQLVirtualTableLog
    StaticClass: TSQLRestStorageClass;
    /// can be used to customize the extension of the filename
    // - the '.' is not to be included
    FileExtension: TFileName;
  end;

  {/ parent class able to define a Virtual Table module
   - in order to implement a new Virtual Table type, you'll have to define a so
     called "Module" to handle the fields and data access and an associated
     TSQLVirtualTableCursorClass for handling the SELECT statements
   - for our framework, the SQLite3 unit will inherit from this class to define
     a TSQLVirtualTableModuleSQLite3 class, which will register the associated
     virtual table definition into a SQLite3 connection, on the server side
   - children should override abstract methods in order to implement the
     association with the database engine itself }
  TSQLVirtualTableModule = class
  protected
    fModuleName: RawUTF8;
    fTableClass: TSQLVirtualTableClass;
    fServer: TSQLRestServer;
    fFeatures: TVirtualTableModuleProperties;
    fFilePath: TFileName;
  public
    /// create the Virtual Table instance according to the supplied class
    // - inherited constructors may register the Virtual Table to the specified
    // database connection
    constructor Create(aTableClass: TSQLVirtualTableClass;
      aServer: TSQLRestServer); virtual;
    /// retrieve the file name to be used for a specific Virtual Table
    // - returns by default a file located in the executable folder, with the
    // table name as file name, and module name as extension
    function FileName(const aTableName: RawUTF8): TFileName; virtual;
    /// the Virtual Table module features
    property Features: TSQLVirtualTableFeatures read fFeatures.Features;
    /// the associated virtual table class
    property TableClass: TSQLVirtualTableClass read fTableClass;
    /// the associated virtual table cursor class
    property CursorClass: TSQLVirtualTableCursorClass read fFeatures.CursorClass;
    /// the associated TSQLRestStorage class used for storage
    // - e.g. returns TSQLRestStorageInMemory for TSQLVirtualTableJSON,
    // or TSQLRestStorageExternal for TSQLVirtualTableExternal, or
    // either nil for TSQLVirtualTableLog
    property StaticClass: TSQLRestStorageClass read fFeatures.StaticClass;
    /// the associated TSQLRecord class
    // - is mostly nil, e.g. for TSQLVirtualTableJSON
    // - used to retrieve the field structure for TSQLVirtualTableLog e.g.
    property RecordClass: TSQLRecordClass read fFeatures.RecordClass;
    /// the extension of the filename (without any left '.')
    property FileExtension: TFileName read fFeatures.FileExtension;
    /// the full path to be used for the filename
    // - is '' by default, i.e. will use the executable path
    // - you can specify here a custom path, which will be used by the FileName
    // method to retrieve the .json/.data full file 
    property FilePath: TFileName read fFilePath write fFilePath;
    /// the associated Server instance
    // - may be nil, in case of direct access to the virtual table
    property Server: TSQLRestServer read fServer;
    /// the corresponding module name
    property ModuleName: RawUTF8 read fModuleName;
  end;

  /// the available transaction levels
  TSQLVirtualTableTransaction = (
    vttBegin, vttSync, vttCommit, vttRollBack,
    vttSavePoint, vttRelease, vttRollBackTo);

  {/ abstract class able to access a Virtual Table content
   - override the Prepare/Structure abstract virtual methods for reading
     access to the virtual table content
   - you can optionaly override Drop/Delete/Insert/Update/Rename/Transaction
     virtual methods to allow content writing to the virtual table
   - the same virtual table mechanism can be used with several database module,
     with diverse database engines }
  TSQLVirtualTable = class
  protected
    fModule: TSQLVirtualTableModule;
    fTableName: RawUTF8;
    fStatic: TSQLRest;
    fStaticStorage: TSQLRestStorage;
    fStaticTable: TSQLRecordClass;
    fStaticTableIndex: integer;
  public
    /// create the virtual table access instance
    // - the created instance will be released when the virtual table will be
    // disconnected from the DB connection (e.g. xDisconnect method for SQLite3)
    // - shall raise an exception in case of invalid parameters (e.g. if the
    // supplied module is not associated to a TSQLRestServer instance)
    // - aTableName will be checked against the current aModule.Server.Model
    // to retrieve the corresponding TSQLRecordVirtualTableAutoID class and
    // create any associated Static: TSQLRestStorage instance
    constructor Create(aModule: TSQLVirtualTableModule; const aTableName: RawUTF8;
      FieldCount: integer; Fields: PPUTF8CharArray); virtual;
    /// release the associated memory, especially the Static instance
    destructor Destroy; override;
    /// retrieve the corresponding module name
    // - will use the class name, triming any T/TSQL/TSQLVirtual/TSQLVirtualTable* 
    // - when the class is instanciated, it will be faster to retrieve the same
    // value via Module.ModuleName
    class function ModuleName: RawUTF8;
    /// a generic method to get a 'CREATE TABLE' structure from a supplied
    // TSQLRecord class
    // - is called e.g. by the Structure method
    class function StructureFromClass(aClass: TSQLRecordClass;
      const aTableName: RawUTF8): RawUTF8;
    /// the associated Virtual Table module
    property Module: TSQLVirtualTableModule read fModule;
    /// the name of the Virtual Table, as specified following the TABLE keyword
    // in the CREATE VIRTUAL TABLE statement
    property TableName: RawUTF8 read fTableName;
  public { virtual methods to be overridden }
    /// should return the main specifications of the associated TSQLVirtualTableModule
    class procedure GetTableModuleProperties(
      var aProperties: TVirtualTableModuleProperties); virtual; abstract;
    /// called to determine the best way to access the virtual table
    // - will prepare the request for TSQLVirtualTableCursor.Search()
    // - in Where[], Expr must be set to not 0 if needed for Search method,
    // and OmitCheck to true if double check is not necessary
    // - OmitOrderBy must be set to true if double sort is not necessary
    // - EstimatedCost should receive the estimated cost
    // - default implementation will let the DB engine perform the search,
    // and prepare for ID=? statement if vtWhereIDPrepared was set
    function Prepare(var Prepared: TSQLVirtualTablePrepared): boolean; virtual;
    /// should retrieve the format (the names and datatypes of the columns) of
    // the virtual table, as expected by sqlite3_declare_vtab()
    // - default implementation is to retrieve the structure for the associated
    // Module.RecordClass property (as set by GetTableModuleProperties) or
    // the Static.StoredClass: in both cases, column numbering will follow
    // the TSQLRecord published field order (TSQLRecord.RecordProps.Fields[])
    function Structure: RawUTF8; virtual;
    /// called when a DROP TABLE statement is executed against the virtual table
    // - should return true on success, false otherwise
    // - does nothing by default, and returns false, i.e. always fails
    function Drop: boolean; virtual;
    /// called to delete a virtual table row
    // - should return true on success, false otherwise
    // - does nothing by default, and returns false, i.e. always fails
    function Delete(aRowID: Int64): boolean; virtual;
    /// called to insert a virtual table row content from an array of TSQLVar
    // - should return true on success, false otherwise
    // - should return the just created row ID in insertedRowID on success
    // - does nothing by default, and returns false, i.e. always fails
    function Insert(aRowID: Int64; var Values: TSQLVarDynArray;
      out insertedRowID: Int64): boolean; virtual;
    /// called to update a virtual table row content from an array of TSQLVar
    // - should return true on success, false otherwise
    // - does nothing by default, and returns false, i.e. always fails
    function Update(oldRowID, newRowID: Int64; var Values: TSQLVarDynArray): boolean; virtual;
    /// called to begin a transaction to the virtual table row
    // - do nothing by default, and returns false in case of RollBack/RollBackto
    // - aSavePoint is used for vttSavePoint, vttRelease and vttRollBackTo only
    // - note that if you don't nest your writing within a transaction, SQLite
    // will call vttCommit for each INSERT/UPDATE/DELETE, just like a regular
    // SQLite database - it could make bad written code slow even with Virtual
    // Tables
    function Transaction(aState: TSQLVirtualTableTransaction; aSavePoint: integer): boolean; virtual;
    /// called to rename the virtual table
    // - by default, returns false, i.e. always fails
    function Rename(const NewName: RawUTF8): boolean; virtual;
    /// the associated virtual table storage instance
    // - can be e.g. a TSQLRestStorageInMemory for TSQLVirtualTableJSON,
    // or a TSQLRestStorageExternal for TSQLVirtualTableExternal, or nil
    // for TSQLVirtualTableLog
    property Static: TSQLRest read fStatic;
    /// the associated virtual table storage instance, if is a TSQLRestStorage
    property StaticStorage: TSQLRestStorage read fStaticStorage;
    /// the associated virtual table storage table 
    property StaticTable: TSQLRecordClass read fStaticTable;
    /// the associated virtual table storage index in its Model.Tables[] array
    property StaticTableIndex: integer read fStaticTableIndex;
  end;

  {/ abstract class able to define a Virtual Table cursor
    - override the Search/HasData/Column/Next abstract virtual methods to
    implement the search process }
  TSQLVirtualTableCursor = class
  protected
    fTable: TSQLVirtualTable;
    /// used internaly between two Column() method calls for GetFieldSQLVar()
    fColumnTemp: RawByteString;
    /// easy set a TSQLVar content for the Column() method
    procedure SetColumn(var aResult: TSQLVar; aValue: Int64); overload;
      {$ifdef HASINLINE}inline;{$endif}
    procedure SetColumn(var aResult: TSQLVar; const aValue: double); overload;
      {$ifdef HASINLINE}inline;{$endif}
    procedure SetColumn(var aResult: TSQLVar; const aValue: RawUTF8); overload;
      {$ifdef HASINLINE}inline;{$endif}
    procedure SetColumn(var aResult: TSQLVar; aValue: PUTF8Char; aValueLength: integer); overload;
      {$ifdef HASINLINE}inline;{$endif}
    procedure SetColumnBlob(var aResult: TSQLVar; aValue: pointer; aValueLength: integer);
      {$ifdef HASINLINE}inline;{$endif}
  public
    /// create the cursor instance
    // - it will be destroyed when by the DB engine (e.g. via xClose in SQLite3)
    constructor Create(aTable: TSQLVirtualTable); virtual;
    /// the associated Virtual Table class instance
    property Table: TSQLVirtualTable read fTable;
  public { abstract methods to be overridden }
    /// called to begin a search in the virtual table
    // - the TSQLVirtualTablePrepared parameters were set by
    // TSQLVirtualTable.Prepare and will contain both WHERE and ORDER BY statements
    // (retrieved e.g. by x_BestIndex() from a TSQLite3IndexInfo structure)
    // - Prepared will contain all prepared constraints and the corresponding
    // expressions in the Where[].Value field
    // - should move cursor to first row of matching data
    // - should return false on low-level database error (but true in case of a
    // valid call, even if HasData will return false, i.e. no data match)
    function Search(const Prepared: TSQLVirtualTablePrepared): boolean; virtual; abstract;
    /// called after Search() to check if there is data to be retrieved
    // - should return false if reached the end of matching data
    function HasData: boolean; virtual; abstract;
    /// called to retrieve a column value of the current data row into a TSQLVar
    // - if aColumn=-1, should return the row ID as varInt64 into aResult
    // - should return false in case of an error, true on success
    function Column(aColumn: integer; var aResult: TSQLVar): boolean; virtual; abstract;
    /// called to go to the next row of matching data
    // - should return false on low-level database error (but true in case of a
    // valid call, even if HasData will return false, i.e. no data match)
    function Next: boolean; virtual; abstract;
  end;

  {/ A generic Virtual Table cursor associated to Current/Max index properties }
  TSQLVirtualTableCursorIndex = class(TSQLVirtualTableCursor)
  protected
    fCurrent: integer;
    fMax: integer;
  public
    /// called after Search() to check if there is data to be retrieved
    // - will return false if reached the end of matching data, according to
    // the fCurrent/fMax protected properties values
    function HasData: boolean; override;
    /// called to go to the next row of matching data
    // - will return false on low-level database error (but true in case of a
    // valid call, even if HasData will return false, i.e. no data match)
    // - will check the fCurrent/fMax protected properties values
    function Next: boolean; override;
    /// called to begin a search in the virtual table
    // - this no-op version will mark EOF, i.e. fCurrent=0 and fMax=-1
    function Search(const Prepared: TSQLVirtualTablePrepared): boolean; override;
  end;
  
  {/ A Virtual Table cursor for reading a TSQLRestStorageInMemory content
    - this is the cursor class associated to TSQLVirtualTableJSON }
  TSQLVirtualTableCursorJSON = class(TSQLVirtualTableCursorIndex)
  public
    /// called to begin a search in the virtual table
    // - the TSQLVirtualTablePrepared parameters were set by
    // TSQLVirtualTable.Prepare and will contain both WHERE and ORDER BY statements
    // (retrieved by x_BestIndex from a TSQLite3IndexInfo structure)
    // - Prepared will contain all prepared constraints and the corresponding
    // expressions in the Where[].Value field
    // - will move cursor to first row of matching data
    // - will return false on low-level database error (but true in case of a
    // valid call, even if HasData will return false, i.e. no data match)
    // - only handled WHERE clause is for "ID = value" - other request will
    // return all records in ID order, and let the database engine handle it
    function Search(const Prepared: TSQLVirtualTablePrepared): boolean; override;
    /// called to retrieve a column value of the current data row into a TSQLVar
    // - if aColumn=-1, will return the row ID as varInt64 into aResult
    // - will return false in case of an error, true on success
    function Column(aColumn: integer; var aResult: TSQLVar): boolean; override;
  end;

  {/ A TSQLRestStorageInMemory-based virtual table using JSON storage
   - for ORM access, you should use TSQLModel.VirtualTableRegister method to
     associated this virtual table module to a TSQLRecordVirtualTableAutoID class
   - transactions are not handled by this module
   - by default, no data is written on disk: you will need to call explicitly
     aServer.StaticVirtualTable[aClass].UpdateToFile for file creation or refresh
   - file extension is set to '.json' }
  TSQLVirtualTableJSON = class(TSQLVirtualTable)
  protected
    fStaticInMemory: TSQLRestStorageInMemory;
  public { overridden methods }
    /// create the virtual table access instance
    // - the created instance will be released when the virtual table will be
    // disconnected from the DB connection (e.g. xDisconnect method for SQLite3)
    // - shall raise an exception in case of invalid parameters (e.g. if the
    // supplied module is not associated to a TSQLRestServer instance)
    // - aTableName will be checked against the current aModule.Server.Model
    // to retrieve the corresponding TSQLRecordVirtualTableAutoID class and
    // create any associated Static: TSQLRestStorage instance
    constructor Create(aModule: TSQLVirtualTableModule; const aTableName: RawUTF8;
      FieldCount: integer; Fields: PPUTF8CharArray); override;
    /// returns the main specifications of the associated TSQLVirtualTableModule
    // - this is a read/write table, without transaction, associated to the
    // TSQLVirtualTableCursorJSON cursor type, with 'JSON' as module name
    // - no particular class is supplied here, since it will depend on the
    // associated Static instance 
    class procedure GetTableModuleProperties(
      var aProperties: TVirtualTableModuleProperties); override;
    /// called to determine the best way to access the virtual table
    // - will prepare the request for TSQLVirtualTableCursor.Search()
    // - only prepared WHERE statement is for "ID = value"
    // - only prepared ORDER BY statement is for ascending IDs
    function Prepare(var Prepared: TSQLVirtualTablePrepared): boolean; override;
    /// called when a DROP TABLE statement is executed against the virtual table
    // - returns true on success, false otherwise
    function Drop: boolean; override;
    /// called to delete a virtual table row
    // - returns true on success, false otherwise
    function Delete(aRowID: Int64): boolean; override;
    /// called to insert a virtual table row content from a TSQLVar array
    // - column order follows the Structure method, i.e.
    // StoredClassRecordProps.Fields[] order
    // - returns true on success, false otherwise
    // - returns the just created row ID in insertedRowID on success
    // - does nothing by default, and returns false, i.e. always fails
    function Insert(aRowID: Int64; var Values: TSQLVarDynArray;
      out insertedRowID: Int64): boolean; override;
    /// called to update a virtual table row content from a TSQLVar array
    // - column order follows the Structure method, i.e.
    // StoredClassRecordProps.Fields[] order
    // - returns true on success, false otherwise
    // - does nothing by default, and returns false, i.e. always fails
    function Update(oldRowID, newRowID: Int64; var Values: TSQLVarDynArray): boolean; override;
  end;

  {/ A TSQLRestStorageInMemory-based virtual table using Binary storage
   - for ORM access, you should use TSQLModel.VirtualTableRegister method to
     associated this virtual table module to a TSQLRecordVirtualTableAutoID class
   - transactions are not handled by this module
   - by default, no data is written on disk: you will need to call explicitly
     aServer.StaticVirtualTable[aClass].UpdateToFile for file creation or refresh
   - binary format is more efficient in term of speed and disk usage than
     the JSON format implemented by TSQLVirtualTableJSON
   - binary format will be set by TSQLVirtualTableJSON.CreateTableInstance
   - file extension is set to '.data' }
  TSQLVirtualTableBinary = class(TSQLVirtualTableJSON);

  {/ Implements a read/only virtual table able to access a .log file, as created
     by TSynLog
   - to be used e.g. by a TSQLRecordLog_Log ('Log_' will identify this 'Log' module)
    - the .log file name will be specified by the Table Name, to which a '.log'
      file extension will be appended before loading it from the current
      directory }
  TSQLVirtualTableLog = class(TSQLVirtualTable)
  protected
    fLogFile: TSynLogFile;
  public
    /// returns the main specifications of the associated TSQLVirtualTableModule
    // - this is a read only table, with transaction, associated to the
    // TSQLVirtualTableCursorLog cursor type, with 'Log' as module name,
    // and associated to TSQLRecordLog_Log table field layout
    class procedure GetTableModuleProperties(
      var aProperties: TVirtualTableModuleProperties); override;
    /// creates the TSQLVirtualTable according to the supplied parameters
    // - aTableName will be checked against the current aModule.Server.Model
    // to retrieve the corresponding TSQLRecordVirtualTableAutoID class
    constructor Create(aModule: TSQLVirtualTableModule; const aTableName: RawUTF8;
      FieldCount: integer; Fields: PPUTF8CharArray); override;
    /// release the associated .log file mapping and all internal structures
    destructor Destroy; override;
  end;

  {/ A Virtual Table cursor for reading a TSynLogFile content
    - this is the cursor class associated to TSQLVirtualTableLog }
  TSQLVirtualTableCursorLog = class(TSQLVirtualTableCursorIndex)
  public
    /// called to begin a search in the virtual table
    function Search(const Prepared: TSQLVirtualTablePrepared): boolean; override;
    /// called to retrieve a column value of the current data row as TSQLVar
    function Column(aColumn: integer; var aResult: TSQLVar): boolean; override;
  end;

  {/ Record associated to a Virtual Table implemented in Delphi, with ID
    forced at INSERT
  - will use TSQLVirtualTableModule / TSQLVirtualTable / TSQLVirtualTableCursor
    classes for a generic Virtual table mechanism on the Server side
  - call Model.VirtualTableRegister() before TSQLRestServer.Create on the
    Server side (not needed for Client) to associate such a record with a
    particular Virtual Table module, otherwise an exception will be raised:
    ! Model.VirtualTableRegister(TSQLRecordDali1,TSQLVirtualTableJSON); }
  TSQLRecordVirtualTableForcedID = class(TSQLRecordVirtual);

  {/ Record associated to Virtual Table implemented in Delphi, with ID
    generated automatically at INSERT
  - will use TSQLVirtualTableModule / TSQLVirtualTable / TSQLVirtualTableCursor
    classes for a generic Virtual table mechanism
  - call Model.VirtualTableRegister() before TSQLRestServer.Create on the
    Server side (not needed for Client) to associate such a record with a
    particular Virtual Table module, otherwise an exception will be raised:
    ! Model.VirtualTableRegister(TSQLRecordDali1,TSQLVirtualTableJSON); }
  TSQLRecordVirtualTableAutoID = class(TSQLRecordVirtual);

/// special comparaison function for sorting ftRecord (TRecordReference/RecordRef)
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareRecord(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftBoolean
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareBoolean(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftEnumerate, sftSet or sftID
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareUInt32(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftInteger or
// sftTimeLog / sftModTime / sftCreateTime UTF-8 encoded values in the SQLite3
// database or JSON content
function UTF8CompareInt64(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftCurrency
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareCurr64(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftFloat
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareDouble(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftDateTime
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareISO8601(P1,P2: PUTF8Char): PtrInt;

const
  /// if a TSQLVirtualTablePreparedConstraint.Column is to be ignored
  VIRTUAL_TABLE_IGNORE_COLUMN = -2;
  /// if a TSQLVirtualTablePreparedConstraint.Column points to the RowID
  VIRTUAL_TABLE_ROWID_COLUMN = -1;

  /// if the TSQLRecordVirtual table kind is a FTS3/FTS4 virtual table
  IS_FTS = [rFTS3, rFTS4];

  /// if the TSQLRecordVirtual table kind is not an embedded type
  // - can be set for a TSQLRecord after a VirtualTableExternalRegister call
  IS_CUSTOM_VIRTUAL = [rCustomForcedID, rCustomAutoID];

  /// if the TSQLRecordVirtual table kind expects the ID to be set on INSERT
  INSERT_WITH_ID = [rFTS3, rFTS4, rRTree, rCustomForcedID];

  /// Supervisor Table access right, i.e. alllmighty over all fields
  ALL_ACCESS_RIGHTS = [0..MAX_SQLTABLES-1];

  /// Supervisor Database access right, i.e. allmighty over all Tables
  SUPERVISOR_ACCESS_RIGHTS: TSQLAccessRights =
    (AllowRemoteExecute: [reService,reUrlEncodedSQL,reUrlEncodedDelete];
     GET: ALL_ACCESS_RIGHTS; POST: ALL_ACCESS_RIGHTS;
     PUT: ALL_ACCESS_RIGHTS; DELETE: ALL_ACCESS_RIGHTS);

  /// Supervisor Database access right, i.e. allmighty over all Tables
  // - this constant will set AllowRemoteExecute field to true
  // - is used by default only TSQLRestClientDB.URI() method, for direct
  // local access right
  FULL_ACCESS_RIGHTS: TSQLAccessRights =
    (AllowRemoteExecute: [reSQL,reService,reUrlEncodedSQL,reUrlEncodedDelete];
     GET: ALL_ACCESS_RIGHTS; POST: ALL_ACCESS_RIGHTS;
     PUT: ALL_ACCESS_RIGHTS; DELETE: ALL_ACCESS_RIGHTS);

  /// special TSQLFieldBits value containing all field bits set to 1
  ALL_FIELDS: TSQLFieldBits = [0..MAX_SQLFIELDS-1];

  /// timer identifier which indicates we must refresh the current Page
  // - used for User Interface generation
  // - is associated with the TSQLRibbonTabParameters.AutoRefresh property,
  // and is handled in TSQLRibbon.RefreshClickHandled
  WM_TIMER_REFRESH_SCREEN = 1;
  /// timer identifier which indicates we must refresh the Report content
  // - used for User Interface generation
  // - is handled in TSQLRibbon.RefreshClickHandled
  WM_TIMER_REFRESH_REPORT = 2;

  /// the default URI parameters for query paging
  // - those values are the one expected by YUI components 
  PAGINGPARAMETERS_YAHOO: TSQLRestServerURIPagingParameters = (
    Sort: 'SORT=';
    Dir: 'DIR=';
    StartIndex: 'STARTINDEX=';
    Results: 'RESULTS=';
    Select: 'SELECT=';
    Where: 'WHERE=';
    SendTotalRowsCountFmt: nil);


/// create a TRecordReference with the corresponding parameters
function RecordReference(Model: TSQLModel; aTable: TSQLRecordClass; aID: integer): TRecordReference;

/// convert a dynamic array of TRecordReference into its corresponding IDs
procedure RecordRefToID(var aArray: TPtrUIntDynArray);

/// get the order table name from a SQL statement
// - return the word following any 'ORDER BY' statement
// - return 'RowID' if none found
function SQLGetOrder(const SQL: RawUTF8): RawUTF8;

{$ifdef PUREPASCAL}{$ifdef HASINLINE}
/// this function is published only for class function TSQLRecord.RecordProps()
// internal call after inlining
function PropsCreate(aTable: TSQLRecordClass): TSQLRecordProperties;
{$endif}{$endif}

/// low-level function to retrieve the class instance implementing a given
// interface
// - this will work with interfaces stubs generated by the compiler, but also
// with TInterfaceFactory.CreateFakeInstance kind of classes
function ObjectFromInterface(const aValue: IInterface): TObject;

/// assign a Weak interface reference, to be used for circular references
// - by default setting aInterface.Field := aValue will increment the internal
// reference count of the implementation object: when underlying objects reference
// each other via interfaces (e.g. as parent and children), what causes the
// reference count to never reach zero, therefore resulting in memory links
// - to avoid this issue, use this procedure instead
procedure SetWeak(aInterfaceField: PIInterface; const aValue: IInterface);
 // {$ifdef HASINLINE}inline;{$endif} raise compilation Internal Error C2170

/// assign a Weak interface reference, which will be ZEROed (set to nil) when
// the corresponding object will be released
// - this function is bit slower than SetWeak, but will avoid any GPF, by
// maintaining a list of per-instance weak interface field reference, and
// hook the FreeInstance virtual method in order to reset any reference to nil:
// FreeInstance will be overridden for this given class VMT only (to avoid
// unnecessary slowdown of other classes), calling the previous method afterward
// (so will work even with custom FreeInstance implementations)
// - for faster possible retrieval, it will assign the unused vmtAutoTable VMT
// entry trick (just like TSQLRecord.RecordProps) - note that it will be
// compatible also with interfaces implemented via TSQLRecord children
// - thread-safe implementation, using a per-class fast lock
procedure SetWeakZero(aObject: TObject; aObjectInterfaceField: PIInterface;
  const aValue: IInterface);

{$ifdef ISDELPHIXE} // class helper requires Delphi 2006 or newer but are buggy before XE :(
type
  /// TWeakZeroInterfaceHelper is a class helper that allows you to use
  // SetWeakZero() in any class without specifying the Self parameter
  TWeakZeroInterfaceHelper = class helper for TObject
  protected
    /// Use SetWeak0 to assign an interface to a weak interface field
    // - this is just a wrapper around the global SetWeakZero() function
    procedure SetWeak0(aObjectInterfaceField: PIInterface; const aValue: IInterface);
  end;
{$endif}

{$ifdef MSWINDOWS}
var
  /// if this variable is TRUE, the URIRequest() function won't use
  // Win32 API GlobalAlloc() function, but fastest native Getmem()
  // - can be also useful for debugg
  USEFASTMM4ALLOC: boolean = false;

/// this function can be exported from a DLL to remotely access to a TSQLRestServer
// - use TSQLRestServer.ExportServer to assign a server to this function
// - return 501 HTML_NOTIMPLEMENTED if no TSQLRestServer.ExportServer has been assigned
// - memory for Resp and Head are allocated with GlobalAlloc(): client must release
// this pointers with GlobalFree() after having retrieved their content
// - simply use TSQLRestClientURIDll to access to an exported URIRequest() function
function URIRequest(url, method, SendData: PUTF8Char; Resp, Head: PPUTF8Char): Int64Rec; cdecl;
{$endif}


type
  PServiceRunningContext = ^TServiceRunningContext;
  
  /// will identify the currently running service on the server side
  // - is the type of the global ServiceContext threadvar
  TServiceRunningContext = record
    /// the currently running service factory
    // - it can be used within server-side implementation to retrieve the
    // associated TSQLRestServer instance
    Factory: TServiceFactoryServer;
    /// the currently runnning context which launched the method
    // - make available e.g. current session or authentication parameters
    // (including e.g. user details via Factory.RestServer.SessionGetUser)
    // - low-level RESTful context is also available in its Call member 
    Request: TSQLRestServerURIContext;
    /// the thread which launched the request
    // - is set by TSQLRestServer.BeginCurrentThread from multi-thread server
    // handlers - e.g. TSQLite3HttpServer or TSQLRestServerNamedPipeResponse
    RunningThread: TThread;
  end;

threadvar
  /// this thread-specific variable will be set with the currently running
  // service context (on the server side)
  // - is set by TServiceFactoryServer.ExecuteMethod() just before calling the
  // implementation method of a service, allowing to retrieve the current
  // execution context
  // - its content is reset to zero out of the scope of a method execution
  // - when used, a local copy or a PServiceRunningContext pointer should better
  // be created, since accessing a threadvar has a non negligible performance
  // cost - for instance, if you want to use a "with" statement:
  // ! with PServiceRunningContext(@ServiceContext)^ do
  // !   ... access TServiceRunningContext members
  // - when accessed from a package, use function CurrentServiceContext()
  // instead, to circumvent a Delphi RTL/compiler restriction (bug?)
  ServiceContext: TServiceRunningContext;

/// wrapper function to retrieve the global ServiceContext threadvar value
// - to be used when accessing the value from a package, to circumvent a
// Delphi RTL/compiler restriction (bug?) 
function CurrentServiceContext: TServiceRunningContext;


{ ************ Logging classes and functions }

type
  /// logging class with enhanced RTTI
  // - will write TObject/TSQLRecord, enumerations and sets content as JSON
  // - is the default logging family used by the mORMot framework
  // - mORMotDB.pas unit will set SynDBLog := TSQLLog
  // - moRMotSQLite3.pas unit will set SynSQLite3Log := TSQLLog
  TSQLLog = class(TSynLog)
  protected
    procedure CreateLogWriter; override;
  end;

{$ifdef WITHLOG}
var
  /// TSQLLog class is used for logging for all our ORM related functions
  // - this global variable can be used to customize it
  SQLite3Log: TSynLogClass = TSQLLog;
{$endif}


implementation

uses
  SynCrypto; // for TSQLRecordSigned


// ************ some RTTI and SQL mapping routines

{$ifdef FPC}
function aligntoptr(p : pointer) : pointer; inline;
begin
{$ifdef FPC_REQUIRES_PROPER_ALIGNMENT}
  result := align(p,sizeof(p));
{$else FPC_REQUIRES_PROPER_ALIGNMENT}
  result := p;
{$endif FPC_REQUIRES_PROPER_ALIGNMENT}
end;
{$endif}

type
  /// used to map a TPropInfo.GetProc/SetProc and retrieve its kind
  PropWrap = packed record
    FillBytes: array [0..SizeOf(Pointer)-2] of byte;
    /// = $ff for a field address, or =$fe for a virtual method
    Kind: byte;
  end;

const
  NO_INDEX = Integer($80000000);


function GetOrdProp(Instance: TObject; PropInfo: PPropInfo): PtrInt;
{$ifdef USETYPEINFO}
type // function(Instance: TObject) trick does not work with CPU64 :(
  TGetProc = function: PtrInt of object;
  TIndexedGetProc = function(Index: Integer): PtrInt of object;
var value: PtrInt;
    Call: TMethod;
    P: pointer;
begin
  if PropInfo^.GetProc=0 then  // no read attribute -> use write offset
    if PropWrap(PropInfo^.SetProc).Kind<>$FF then begin
      result := 0;
      exit;
    end else // we only allow setting if we know the field address
      P := Pointer(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF) else
    if PropWrap(PropInfo^.GetProc).Kind=$FF then
      P := Pointer(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF) else begin
      if PropWrap(PropInfo^.GetProc).Kind=$FE then
        Call.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^ else
        Call.Code := Pointer(PropInfo^.GetProc);
      Call.Data := Instance;
      if PropInfo^.Index=NO_INDEX then
        value := TGetProc(Call) else
        value := TIndexedGetProc(Call)(PropInfo^.Index);
      P := @value;
    end;
  with PropInfo^.PropType^^ do
  if Kind=tkClass then
    Result := PPtrInt(P)^ else
    case OrdType of
    otSByte: result := PShortInt(P)^;
    otSWord: result := PSmallInt(P)^;
    otSLong: result := PInteger(P)^;
    otUByte: result := PByte(P)^;
    otUWord: result := PWord(P)^;
    otULong: result := PCardinal(P)^;
    else result := 0; // should not happen
    end;
end;
{$else}
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        { <-    EAX Longint result              }
        PUSH    EBX
        PUSH    EDI
        MOV     EDI,[EDX].TPropInfo.PropType
        MOV     EDI,[EDI]
        MOV     BL,otSLong
        CMP     [EDI].TTypeInfo.Kind,tkClass
        JE      @@isClass
        MOVZX   ECX,[EDI].TTypeInfo.Name.Byte[0]
        MOV     BL,byte ptr [EDI].TTypeInfo.Name[ECX+1] // get the ord type
@@isClass:
        MOV     ECX,[EDX].TPropInfo.GetProc
        CMP     [EDX].TPropInfo.GetProc.Byte[3],$FE
        MOV     EDX,[EDX].TPropInfo.Index
        JB      @@isStaticMethod
        JA      @@isField
        {       the GetProc is a virtual method }
        MOVSX   ECX,CX                  { sign extend slot offs }
        ADD     ECX,[EAX]               { vmt   + slotoffs      }
        CALL    dword ptr [ECX]         { call vmt[slot]        }
        JMP     @@final
@@isStaticMethod:
        CALL    ECX
        JMP     @@final
@@isField:
        AND     ECX,$00FFFFFF
        ADD     ECX,EAX
        MOV     AL,[ECX]
        CMP     BL,otSWord
        JB      @@final
        MOV     AX,[ECX]
        CMP     BL,otSLong
        JB      @@final
        MOV     EAX,[ECX]
@@final:CMP     BL,otSLong
        JAE     @@exit
        CMP     BL,otSWord
        JAE     @@word
        CMP     BL,otSByte
        MOVSX   EAX,AL
        JE      @@exit
        AND     EAX,$FF
        JMP     @@exit
@@word: MOVSX   EAX,AX
        JE      @@exit
        AND     EAX,$FFFF
@@exit: POP     EDI
        POP     EBX
end;
{$endif}

procedure SetOrdProp(Instance: TObject; PropInfo: PPropInfo; Value: PtrInt);
// AB: use the getter field address if no setter (no write attribute) exists
{$ifdef USETYPEINFO}
type // procedure(Instance: TObject) trick does not work with CPU64 :(
  TSetProp = procedure(Value: PtrInt) of object;
  TIndexedProp = procedure(Index: integer; Value: PtrInt) of object;
var P: pointer;
    Call: TMethod;
begin
  if PropInfo^.SetProc=0 then  // no write attribute -> use read offset
    if PropWrap(PropInfo^.GetProc).Kind<>$FF then
      exit else // we only allow setting if we know the field address
      P := Pointer(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF) else
    if PropWrap(PropInfo^.SetProc).Kind=$FF then
      P := Pointer(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF) else begin
      if PropWrap(PropInfo^.SetProc).Kind=$FE then
        Call.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.SetProc))^ else
        Call.Code := Pointer(PropInfo^.SetProc);
      Call.Data := Instance;
      if PropInfo^.Index=NO_INDEX then
        TSetProp(Call)(Value) else
        TIndexedProp(Call)(PropInfo^.Index,Value);
      exit;
    end;
  with PropInfo^.PropType^^ do
  if Kind=tkClass then
    PPtrInt(P)^ := Value else
    case OrdType of
    otSByte,otUByte: PByte(P)^ := Value;
    otSWord,otUWord: PWord(P)^ := Value;
    otSLong,otULong: PInteger(P)^ := Value;
    end;
end;
{$else}
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       ECX Value                       }
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        MOV     EDI,EDX
        MOV     ESI,[EDI].TPropInfo.PropType
        MOV     ESI,[ESI]
        MOV     BL,otSLong
        CMP     [ESI].TTypeInfo.Kind,tkClass
        JE      @@isClass
        XOR     EBX,EBX
        MOV     BL,[ESI].TTypeInfo.Name.Byte[0]
        MOV     BL,byte ptr [ESI].TTypeInfo.Name[EBX+1] // get field size
@@isClass:
        MOV     EDX,[EDI].TPropInfo.Index       { pass Index in DX      }
        CMP     EDX,$80000000
        JNE     @@hasIndex
        MOV     EDX,ECX                         { pass value in EDX     }
@@hasIndex:
        MOV     ESI,[EDI].TPropInfo.SetProc
        OR      ESI,ESI // no setter ? -> use the field address
        JZ      @NOSET
        CMP     [EDI].TPropInfo.SetProc.Byte[3],$FE
@set:   JA      @@isField
        JB      @@isStaticMethod
        {       SetProc turned out to be a virtual method. call it      }
        MOVSX   ESI,SI                          { sign extend slot offset }
        ADD     ESI,[EAX]                       { vmt   + slot offset   }
        CALL    dword ptr [ESI]
        JMP     @@exit
@@isStaticMethod:
        CALL    ESI
        JMP     @@exit
@NoSet: MOV     ESI,[EDI].TPropInfo.GetProc // use the field address
        CMP     [EDI].TPropInfo.GetProc.Byte[3],$FF
        JNE     @@exit // we only allow setting if we know the field address
@@isField:
        AND     ESI,$00FFFFFF
        ADD     EAX,ESI
        MOV     [EAX],CL
        CMP     BL,otSWord
        JB      @@exit
        MOV     [EAX],CX
        CMP     BL,otSLong
        JB      @@exit
        MOV     [EAX],ECX
@@exit: POP     EDI
        POP     ESI
        POP     EBX
end;
{$endif}

function GetInt64Prop(Instance: TObject; PropInfo: PPropInfo): Int64;
{$ifdef USETYPEINFO}
type // function(Instance: TObject) trick does not work with CPU64 :(
  TGetProc = function: Int64 of object;
  TIndexedGetProc = function(Index: Integer): Int64 of object;
var Call: TMethod;
begin 
  if PropWrap(PropInfo^.GetProc).Kind=$FF then
    // field - Getter is the field offset in the instance data
    result := PInt64(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^
  else begin
    if PropWrap(PropInfo^.GetProc).Kind=$FE then
      Call.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^ else
      Call.Code := Pointer(PropInfo^.GetProc);
    Call.Data := Instance;
    if PropInfo^.Index=NO_INDEX then
      result := TGetProc(Call) else
      result := TIndexedGetProc(Call)(PropInfo^.Index);
  end;
end;
{$else}
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        { <-    EDX:EAX result                  }
        CMP     [EDX].TPropInfo.GetProc.Byte[3],$FE
        MOV     ECX,[EDX].TPropInfo.GetProc
        MOV     EDX,[EDX].TPropInfo.Index       { pass Index in EDX     }
        JA      @@isField
        JB      @@isStaticMethod
        {       GetProc is a virtual method     }
        MOVSX   ECX,CX                          { sign extend slot number }
        ADD     ECX,[EAX]
        CALL    dword ptr [ECX]
        JMP     @@exit
@@isStaticMethod:
        CALL    ECX
        JMP     @@exit
@@isField:
        AND     ECX,$00FFFFFF
        ADD     EAX,ECX
        MOV     EDX,[EAX].Integer[4]
        MOV     EAX,[EAX].Integer[0]
@@exit:
end;
{$endif}

{$ifndef NOVARIANTS}

procedure GetVariantProp(Instance: TObject; PropInfo: PPropInfo; var result: Variant);
procedure ByMethod; // sub proc for faster execution of simple types
type // function(Instance: TObject) trick does not work with CPU64 :(
  TGetProc = function: Variant of object;
  TIndexedGetProc = function(Index: Integer): Variant of object;
var Call: TMethod;
begin
  if PropWrap(PropInfo^.GetProc).Kind=$FE then
    Call.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^ else
    Call.Code := Pointer(PropInfo^.GetProc);
  Call.Data := Instance;
  if PropInfo^.Index=NO_INDEX then
    result := TGetProc(Call) else
    result := TIndexedGetProc(Call)(PropInfo^.Index);
end;
begin
  if PropWrap(PropInfo^.GetProc).Kind=$FF then
    // field - Getter is the field offset in the instance data
    result := PVariant(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^
  else
    ByMethod;
end;

procedure SetVariantProp(Instance: TObject; PropInfo: PPropInfo; const Value: variant);
procedure ByMethod; // sub proc for faster execution of simple types
type // procedure(Instance: TObject) trick does not work with CPU64 :(
  TSetProp = procedure(const Value: Variant) of object;
  TIndexedProp = procedure(Index: integer; const Value: Variant) of object;
var Call: TMethod;
begin
  if PropWrap(PropInfo^.SetProc).Kind=$FE then
    Call.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.SetProc))^ else
    Call.Code := Pointer(PropInfo^.SetProc);
  Call.Data := Instance;
  if PropInfo^.Index=NO_INDEX then
    TSetProp(Call)(Value) else
    TIndexedProp(Call)(PropInfo^.Index,Value);
end;
begin
  if PropInfo^.SetProc=0 then  // no write attribute -> use read offset
    if PropWrap(PropInfo^.GetProc).Kind<>$FF then
      exit else // we only allow setting if we know the field address
      PVariant(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^ := Value else
    if PropWrap(PropInfo^.SetProc).Kind=$FF then
      PVariant(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF)^ := Value else
      ByMethod;
end;

{$endif NOVARIANTS}

procedure SetInt64Prop(Instance: TObject; PropInfo: PPropInfo; const Value: Int64);
// AB: use the getter field address if no setter (no write attribute) exists
{$ifdef USETYPEINFO}
type // procedure(Instance: TObject) trick does not work with CPU64 :(
  TSetProp = procedure(const Value: Int64) of object;
  TIndexedProp = procedure(Index: integer; const Value: Int64) of object;
var Call: TMethod;
begin
  if PropInfo^.SetProc=0 then  // no write attribute -> use read offset
    if PropWrap(PropInfo^.GetProc).Kind<>$FF then
      exit else // we only allow setting if we know the field address
      PInt64(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^ := Value else
    if PropWrap(PropInfo^.SetProc).Kind=$FF then
      PInt64(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF)^ := Value else begin
      if PropWrap(PropInfo^.SetProc).Kind=$FE then
        Call.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.SetProc))^ else
        Call.Code := Pointer(PropInfo^.SetProc);
      Call.Data := Instance;
      if PropInfo^.Index=NO_INDEX then
        TSetProp(Call)(Value) else
        TIndexedProp(Call)(PropInfo^.Index,Value);
  end;
end;
{$else}
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       [ESP+4] Value                   }
        MOV     ECX,[EDX].TPropInfo.SetProc
        OR      ECX,ECX
        JZ      @NoSet
        CMP     [EDX].TPropInfo.SetProc.Byte[3],$FE
        JA      @@isField
        MOV     EDX,[EDX].TPropInfo.Index
        PUSH    Value.Integer[4]
        PUSH    Value.Integer[0]
        JB      @@isStaticMethod
        {       SetProc is a virtual method     }
        MOVSX   ECX,CX
        ADD     ECX,[EAX]
        CALL    DWORD PTR [ECX]
        JMP     @@exit
@@isStaticMethod:
        CALL    ECX
        JMP     @@exit
@NoSet: MOV     ECX,[EDX].TPropInfo.GetProc // use the field address
        CMP     [EDX].TPropInfo.GetProc.Byte[3],$FF
        JNE     @@exit // we only allow setting if we know the field address
@@isField:
        AND     ECX,$00FFFFFF
        ADD     EAX,ECX
        MOV     EDX,Value.Integer[0]
        MOV     ECX,Value.Integer[4]
        MOV     [EAX].Integer[0],EDX
        MOV     [EAX].Integer[4],ECX
@@exit:
end;
{$endif}

procedure GetLongStrProp(Instance: TObject; PropInfo: PPropInfo; var Value: RawByteString);
{$ifdef USETYPEINFO}
procedure CallMethod(Instance: TObject; PropInfo: PPropInfo; var Value: RawByteString);
type // function(Instance: TObject) trick does not work with CPU64 :(
  TAStringGetProc = function: RawByteString of object;
  TAStringIndexedGetProc = function(Index: Integer): RawByteString of object;
var Call: TMethod;
begin
  if PropWrap(PropInfo^.GetProc).Kind=$FE then
    // virtual method  - Getter is a signed 2 byte integer VMT offset
    Call.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^ else
    // static method - Getter is the actual address
    Call.Code := Pointer(PropInfo^.GetProc);
  Call.Data := Instance;
  if PropInfo^.Index=NO_INDEX then  // no index
    Value := TAStringGetProc(Call) else
    Value := TAStringIndexedGetProc(Call)(PropInfo^.Index);
end;
begin // caller must check that PropInfo^.PropType^.Kind = tkWString
  if PropWrap(PropInfo^.GetProc).Kind=$FF then
    // field - Getter is the field offset in the instance data
    Value := PRawByteString(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^ else
    CallMethod(Instance,PropInfo,Value);
end;
{$else}
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       ECX Pointer to result string    }
        PUSH    ESI
        PUSH    EDI
        MOV     EDI,EDX
        MOV     EDX,[EDI].TPropInfo.Index       { pass index in EDX }
        CMP     EDX,$80000000
        JNE     @@hasIndex
        MOV     EDX,ECX                         { pass value in EDX }
@@hasIndex:
        MOV     ESI,[EDI].TPropInfo.GetProc
        CMP     [EDI].TPropInfo.GetProc.Byte[3],$FE
        JA      @@isField
        JB      @@isStaticMethod
@@isVirtualMethod:
        MOVSX   ESI,SI                          { sign extend slot offset }
        ADD     ESI,[EAX]                       { vmt + slot offset }
        CALL    DWORD PTR [ESI]
        JMP     @@exit
@@isStaticMethod:
        CALL    ESI
        JMP     @@exit
@@isField:
        AND     ESI,$00FFFFFF
        MOV     EDX,[EAX+ESI]
        MOV     EAX,ECX
        CALL    System.@LStrLAsg // copy local string(EDX) into string(EAX)
@@exit: POP     EDI
        POP     ESI
end;
{$endif}

procedure SetLongStrProp(Instance: TObject; PropInfo: PPropInfo; const Value: RawByteString);
// AB: use the getter field address if no setter (no write attribute) exists
{$ifdef USETYPEINFO}
type // procedure(Instance: TObject) trick does not work with CPU64 :(
  TSetProp = procedure(const Value: RawByteString) of object;
  TIndexedProp = procedure(Index: integer; const Value: RawByteString) of object;
var Call: TMethod;
begin // caller must check that PropInfo^.PropType^.Kind = tkLString
  if PropInfo^.SetProc=0 then  // no setter ?
    if PropWrap(PropInfo^.GetProc).Kind<>$FF then
      exit else  // we only allow setting if we know the field address
      PRawByteString(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^ := Value else
  if PropWrap(PropInfo^.SetProc).Kind=$FF then
    // field - Setter is the field offset in the instance data
    PRawByteString(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF)^ := Value else begin
      if PropWrap(PropInfo^.SetProc).Kind=$FE then
        Call.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.SetProc))^ else
        Call.Code := Pointer(PropInfo^.SetProc);
      Call.Data := Instance;
      if PropInfo^.Index=NO_INDEX then
        TSetProp(Call)(Value) else
        TIndexedProp(Call)(PropInfo^.Index,Value);
  end;
end;
{$else}
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       ECX Pointer to string value     }
        PUSH    ESI
        PUSH    EDI
        MOV     ESI,EDX
        MOV     EDX,[ESI].TPropInfo.Index       { pass index in EDX }
        CMP     EDX,$80000000
        JNE     @@hasIndex
        MOV     EDX,ECX                         { pass value in EDX }
@@hasIndex:
        MOV     EDI,[ESI].TPropInfo.SetProc
        or edi,edi // no setter ?
        jz @NoSet
        CMP     [ESI].TPropInfo.SetProc.Byte[3],$FE
        JA      @@isField
        JB      @@isStaticMethod
@@isVirtualMethod:
        MOVSX   EDI,DI
        ADD     EDI,[EAX]
        CALL    DWORD PTR [EDI]
        JMP     @@exit
@@isStaticMethod:
        CALL    EDI
        JMP     @@exit
@NoSet: MOV     EDI,[ESI].TPropInfo.GetProc // use the field address
        CMP     [ESI].TPropInfo.GetProc.Byte[3],$FF
        JNE     @@exit // we only allow setting if we know the field address
@@isField:
        AND     EDI,$00FFFFFF
        ADD     EAX,EDI
        MOV     EDX,ECX
        CALL    System.@LStrLAsg // copy local string(EDX) into string(EAX)
@@exit: POP     EDI
        POP     ESI
end;
{$endif}

{$ifdef USETYPEINFO}
// this pure pascal version must handle the 64-bits ordinal values and
// the special layout of the underlying compiler (mostly FPC)
// -> use the typinfo unit
procedure GetWideStrProp(Instance: TObject; PropInfo: PPropInfo; var Value: WideString); overload;
{$ifdef HASINLINE}inline;{$endif}
begin
  Value := GetWideStrProp(Instance,pointer(PropInfo));
end;
{$else}

procedure GetWideStrProp(Instance: TObject; PropInfo: PPropInfo; var Value: WideString);
type
  TUStringGetProc = function: WideString of object;
  TUStringIndexedGetProc = function(Index: Integer): WideString of object;
var M: TMethod;
begin // caller must check that PropInfo^.PropType^.Kind = tkWString
  if PropWrap(PropInfo^.GetProc).Kind=$FF then 
    // field - Getter is the field offset in the instance data
    Value := PWideString(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^
  else begin
    if PropWrap(PropInfo^.GetProc).Kind=$FE then
      // virtual method  - Getter is a signed 2 byte integer VMT offset
      M.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^ else
      // static method - Getter is the actual address
      M.Code := Pointer(PropInfo^.GetProc);
    M.Data := Instance;
    if PropInfo^.Index=NO_INDEX then  // no index
      Value := TUStringGetProc(M)() else
      Value := TUStringIndexedGetProc(M)(PropInfo^.Index);
  end;
end;

procedure SetWideStrProp(Instance: TObject; PropInfo: PPropInfo; const Value: WideString);
type
  TUStringSetProc = procedure(const Value: WideString) of object;
  TUStringIndexedSetProc = procedure(Index: Integer; const Value: WideString) of object;
var M: TMethod;
begin // caller must check that PropInfo^.PropType^.Kind = tkWString
  if PropInfo^.SetProc=0 then  // no setter ?
    if PropWrap(PropInfo^.GetProc).Kind<>$FF then
      exit else begin  // we only allow setting if we know the field address
      PWideString(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^ := Value;
      exit;
    end;
  if PropWrap(PropInfo^.SetProc).Kind=$FF then
    // field - Setter is the field offset in the instance data
    PWideString(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF)^ := Value else begin
    if PropWrap(PropInfo^.SetProc).Kind=$FE then
      // virtual method  - Setter is a signed 2 byte integer VMT offset
      M.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.SetProc))^ else
      // static method - Setter is the actual address
      M.Code := Pointer(PropInfo^.SetProc);
    M.Data := Instance;
    if PropInfo^.Index=NO_INDEX then  // no index
      TUStringSetProc(M)(Value) else
      TUStringIndexedSetProc(M)(PropInfo^.Index, Value);
  end;
end;

{$ifdef UNICODE}
function GetUnicodeStrProp(Instance: TObject; PropInfo: PPropInfo): UnicodeString;
type
  TUStringGetProc = function: UnicodeString of object;
  TUStringIndexedGetProc = function(Index: Integer): UnicodeString of object;
var M: TMethod;
begin // caller must check that PropInfo^.PropType^.Kind = tkUString
  if PropWrap(PropInfo^.GetProc).Kind=$FF then
    // field - Getter is the field offset in the instance data
    result := PUnicodeString(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^
  else begin
    if PropWrap(PropInfo^.GetProc).Kind=$FE then
      // virtual method  - Getter is a signed 2 byte integer VMT offset
      M.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^ else
      // static method - Getter is the actual address
      M.Code := Pointer(PropInfo^.GetProc);
    M.Data := Instance;
    if PropInfo^.Index=NO_INDEX then  // no index
      result := TUStringGetProc(M)() else
      result := TUStringIndexedGetProc(M)(PropInfo^.Index);
  end;
end;

procedure SetUnicodeStrProp(Instance: TObject; PropInfo: PPropInfo; const Value: UnicodeString);
type
  TUStringSetProc = procedure (const Value: UnicodeString) of object;
  TUStringIndexedSetProc = procedure (Index: Integer; const Value: UnicodeString) of object;
var M: TMethod;
begin // caller must check that PropInfo^.PropType^.Kind = tkUString
  if PropInfo^.SetProc=0 then  // no setter ?
    if PropWrap(PropInfo^.GetProc).Kind<>$FF then
      exit else begin  // we only allow setting if we know the field address
      PUnicodeString(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF)^ := Value;
      exit;
    end;
  if PropWrap(PropInfo^.SetProc).Kind=$FF then
    // field - Setter is the field offset in the instance data
    PUnicodeString(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF)^ := Value else begin
    if PropWrap(PropInfo^.SetProc).Kind=$FE then
      // virtual method  - Setter is a signed 2 byte integer VMT offset
      M.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.SetProc))^ else
      // static method - Setter is the actual address
      M.Code := Pointer(PropInfo^.SetProc);
    M.Data := Instance;
    if PropInfo^.Index=NO_INDEX then // no index
      TUStringSetProc(M)(Value) else
      TUStringIndexedSetProc(M)(PropInfo^.Index, Value);
  end;
end;
{$endif UNICODE}

procedure SetFloatProp(Instance: TObject; PropInfo: PPropInfo; Value: Extended);
// AB: use the getter field address if no setter (no write attribute) exists
type // procedure(Instance: TObject) trick does not work with CPU64 :(
  TSingleSetProc = procedure(const Value: Single) of object;
  TDoubleSetProc = procedure(const Value: Double) of object;
  TExtendedSetProc = procedure(const Value: Extended) of object;
  TCompSetProc = procedure(const Value: Comp) of object;
  TCurrencySetProc = procedure(const Value: Currency) of object;
var P: Pointer;
    Call: TMethod;
label St;
begin
  if PropInfo^.SetProc=0 then  // no setter ?
    if PropWrap(PropInfo^.GetProc).Kind<>$FF then
      exit else begin  // we only allow setting if we know the field address
      P := Pointer(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF);
      goto St;  // use the field address to set its value
    end;
  if PropWrap(PropInfo^.SetProc).Kind=$FF then begin
    // field - SetProc is the field offset in the instance data
    P := Pointer(PtrInt(Instance)+PropInfo^.SetProc and $00FFFFFF);
St: case PropInfo^.PropType^^.FloatType of
      ftSingle:    PSingle(P)^ := Value;
      ftDoub:      PDouble(P)^ := Value;
      ftExtended:  PExtended(P)^ := Value;
      ftComp:      PComp(P)^ := Value;
      ftCurr:      PCurrency(P)^ := Value;
    end;
  end
  else begin
    if PropWrap(PropInfo^.SetProc).Kind=$FE then
      Call.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.SetProc))^ else
      Call.Code := Pointer(PropInfo^.SetProc);
    Call.Data := Instance;
    if PropInfo^.Index=NO_INDEX then begin // no index
      case PropInfo^.PropType^^.FloatType of
        ftSingle  :  TSingleSetProc(Call)(Value);
        ftDoub :     TDoubleSetProc(Call)(Value);
        ftExtended:  TExtendedSetProc(Call)(Value);
        ftComp    :  TCompSetProc(Call)(Value);
        ftCurr    :  TCurrencySetProc(Call)(Value);
      end;
    end;  // indexed methods not handled here, since not used in TSQLRecord
  end;
end;
{$endif}

{$ifdef USETYPEINFO}
// this pure pascal version must handle the 64-bits ordinal values and
// the special layout of the underlying compiler (mostly FPC)
// -> use the typinfo unit

// a dedicated function to avoid conversion for currency values
function GetCurrencyProp(Instance: TObject; PropInfo: PPropInfo): currency;
  {$ifdef HASINLINE}inline;{$endif}
begin
  result := GetFloatProp(Instance,pointer(PropInfo));
end;

function GetDoubleProp(Instance: TObject; PropInfo: PPropInfo): double;
  {$ifdef HASINLINE}inline;{$endif}
begin
  result := GetFloatProp(Instance,pointer(PropInfo));
end;

{$else}
function GetFloatProp(Instance: TObject; PropInfo: PPropInfo): Extended;
type // function(Instance: TObject) trick does not work with CPU64 :(
  TGetProc = function: extended of object;
  TIndexedGetProc = function(Index: Integer): extended of object;
var P: Pointer;
    Call: TMethod;
begin // faster code by AB
  if PropWrap(PropInfo^.GetProc).Kind=$FF then begin
    // field - GetProc is the field offset in the instance data
    P := Pointer(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF);
    case PropInfo^.PropType^.FloatType of
      ftSingle:    Result := PSingle(P)^;
      ftDoub:      Result := PDouble(P)^;
      ftExtended:  Result := PExtended(P)^;
      ftComp:      Result := PComp(P)^;
      ftCurr:      Result := PCurrency(P)^; // use GetInt64Prop() to avoid rounding
    else Result := 0;
    end;
  end
  else begin
    if PropWrap(PropInfo^.GetProc).Kind=$FE then
      Call.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^ else
      Call.Code := Pointer(PropInfo^.GetProc);
    Call.Data := Instance;
    if PropInfo^.Index=NO_INDEX then
      result := TGetProc(Call) else
      result := TIndexedGetProc(Call)(PropInfo^.Index);
    if PropInfo^.PropType^.FloatType = ftCurr then
      Result := Result / 10000;
  end;
end;

// a dedicated function to avoid conversion for currency values
// - here PropInfo^.PropType^.FloatType should be ftCurr
function GetCurrencyProp(Instance: TObject; PropInfo: PPropInfo): currency;
type // function(Instance: TObject) trick does not work with CPU64 :(
  TGetProc = function: currency of object;
  TIndexedGetProc = function(Index: Integer): currency of object;
var P: Pointer;
    Call: TMethod;
begin // faster code by AB
  if PropWrap(PropInfo^.GetProc).Kind=$FF then begin
    // field - GetProc is the field offset in the instance data
    P := Pointer(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF);
    Result := PCurrency(P)^;
  end
  else begin
    if PropWrap(PropInfo^.GetProc).Kind=$FE then
      Call.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^ else
      Call.Code := Pointer(PropInfo^.GetProc);
    Call.Data := Instance;
    if PropInfo^.Index=NO_INDEX then
      result := TGetProc(Call) else
      result := TIndexedGetProc(Call)(PropInfo^.Index);
  end;
end;

// a dedicated function to avoid conversion for double values to extended
// - here PropInfo^.PropType^.FloatType should be ftDouble
function GetDoubleProp(Instance: TObject; PropInfo: PPropInfo): double;
type // function(Instance: TObject) trick does not work with CPU64 :(
  TGetProc = function: double of object;
  TIndexedGetProc = function(Index: Integer): double of object;
var P: Pointer;
    Call: TMethod;
begin // faster code by AB
  if PropWrap(PropInfo^.GetProc).Kind=$FF then begin
    // field - GetProc is the field offset in the instance data
    P := Pointer(PtrInt(Instance)+PropInfo^.GetProc and $00FFFFFF);
    Result := PDouble(P)^;
  end
  else begin
    if PropWrap(PropInfo^.GetProc).Kind=$FE then
      Call.Code := PPointer(PPtrInt(Instance)^+SmallInt(PropInfo^.GetProc))^ else
      Call.Code := Pointer(PropInfo^.GetProc);
    Call.Data := Instance;
    if PropInfo^.Index=NO_INDEX then
      result := TGetProc(Call) else
      result := TIndexedGetProc(Call)(PropInfo^.Index);
  end;
end;
{$endif}

procedure UseImplGetter(Instance: TObject; ImplGetter: PtrInt; var result: IInterface);
type // function(Instance: TObject) trick does not work with CPU64 :(
  TGetProc = function: IInterface of object;
var Call: TMethod;
begin // sub-procedure to avoid try..finally for TGetProc(): Interface result 
  if PropWrap(ImplGetter).Kind=$FE then
    Call.Code := PPointer(PPtrInt(Instance)^+SmallInt(ImplGetter))^ else
    Call.Code := Pointer(ImplGetter);
  Call.Data := Instance;
  result := TGetProc(Call);
end;

function GetInterfaceFromEntry(Instance: TObject; Entry: PInterfaceEntry; out Obj): boolean;
begin
  Pointer(Obj) := nil;
  if Entry<>nil then
    if Entry^.IOffset <> 0 then begin
      Pointer(Obj) := Pointer(PtrInt(Instance)+Entry^.IOffset);
      if Pointer(Obj)<>nil then
        IInterface(Obj)._AddRef;
    end else
    if PropWrap(Entry^.ImplGetter).Kind=$FF then
      IInterface(Obj) := IInterface(PPointer(PtrUInt(Instance)+PtrUInt(Entry^.ImplGetter and $00FFFFFF))^) else
      UseImplGetter(Instance,Entry^.ImplGetter,IInterface(Obj));
  Result := Pointer(Obj)<>nil;
end;

{$ifdef USETYPEINFO}
// this pure pascal version must handle the 64-bits ordinal values and
// the special layout of the underlying compiler (mostly FPC)
// -> use the typinfo unit
{$else}
function GetMethodProp(Instance: TObject; PropInfo: PPropInfo): TMethod;
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       ECX Pointer to result           }
        PUSH    EBX
        PUSH    EDI
        MOV     EDI,EDX
        MOV     EDX,[EDI].TPropInfo.Index       { pass Index in DX      }
        CMP     EDX,$80000000
        JNE     @@hasIndex
        MOV     EDX,ECX                         { pass value in EDX     }
@@hasIndex:
        MOV     EBX,[EDI].TPropInfo.GetProc
        CMP     [EDI].TPropInfo.GetProc.Byte[3],$FE
        JA      @@isField
        JB      @@isStaticMethod
        {       GetProc is a virtual method     }
        MOVSX   EBX,BX                          { sign extend slot number }
        ADD     EBX,[EAX]
        CALL    dword ptr [EBX]
        JMP     @@exit
@@isStaticMethod:
        CALL    EBX
        JMP     @@exit
@@isField:
        AND     EBX,$00FFFFFF
        ADD     EAX,EBX
        MOV     EDX,[EAX]
        MOV     EBX,[EAX+4]
        MOV     [ECX],EDX
        MOV     [ECX+4],EBX
@@exit: POP     EDI
        POP     EBX
end;
{$endif}

function InternalMethodInfo(aClassType: TClass; const aMethodName: ShortString): PMethodInfo;
var Count, i: integer;
begin
  while aClassType<>nil do begin
    result := PPointer(PtrInt(aClassType)+vmtMethodTable)^;
    if result<>nil then begin
      {$ifdef FPC}
      Count := PCardinal(result)^;
      inc(PCardinal(result));
      {$else}
      Count := PWord(result)^;
      inc(PWord(result));
      {$endif}
      for i := 0 to Count-1 do
      if IdemPropName(result^.Name{$ifdef FPC}^{$endif},aMethodName) then
        Exit else
        {$ifdef FPC}
        inc(result);
        {$else}
        inc(PtrUInt(result),result^.Len);
        {$endif}
    end;
    if PPointer(PtrInt(aClassType)+vmtParent)^<>nil then
      aClassType := PPointer(PPointer(PtrInt(aClassType)+vmtParent)^)^ else
      break;
  end;
  result := nil;
end;

function TMethodInfo.MethodAddr: Pointer;
begin
  if @self<>nil then
    result := Addr else
    result := @self;
end;

function TMethodInfo.ReturnInfo: PReturnInfo;
begin
  if @self<>nil then begin
    result := {$ifdef FPC}aligntoptr{$endif}(@Name[ord(Name[0])+1]);
    if PtrUInt(result)-PtrUInt(@self)=Len then
      result := nil;
  end else
      result := @self;
end;

(*
function TMethodInfo.RetrieveValidTSQLRestServerCallBack: pointer;
{$ifndef DELPHI6OROLDER}
var RI: PReturnInfo;
{$endif}
begin
  {$ifdef DELPHI6OROLDER} // not enough RTTI (e.g. Delphi 6) -> assume OK :(
  if @Self<>nil then
    result := Addr else
  {$else}
  RI := ReturnInfo;
   if (RI=nil) and (@Self<>nil) then begin
    result := Addr; // returns method address (OK) if not enough RTTI
    exit;
  end;
  if (RI^.ParamCount=6) and (RI^.CallingConvention=ccRegister) and
     (RI^.ReturnType<>nil) and (RI^.ReturnType^.Kind=tkInteger) then
  with RI^.Param^ do // expects "aSession: cardinal"
    if ParamType^.Kind=tkInteger then
    with Next^ do
    if (ParamType^.Kind=tkClass) and ParamType^.InheritsFrom(TSQLRecord) then
      with Next^ {ignore PUTF8Char} .Next^ do // expects "const aSentData: RawUTF8"
      if (ParamType^.Kind=tkLString) and (pfConst in Flags) then
        with Next^ do // expects "out aResp: RawUTF8"
        if (ParamType^.Kind=tkLString) and (pfOut in Flags) then
          with Next^ do // expects "out aHead: RawUTF8"
          if (ParamType^.Kind=tkLString) and (pfOut in Flags) then begin
            result := Addr; // returns method address on matching signature
            exit;
          end;
  {$endif}
  result := nil; // method unknown or with wrong signature
end;
*)

function TReturnInfo.Param: PParamInfo;
begin
  result := Pointer(PtrUInt(@self)+sizeof(TReturnInfo));
end;

function TParamInfo.Next: PParamInfo;
begin
  result := {$ifdef FPC}aligntoptr{$endif}(@Name[ord(Name[0])+1]);
end;

{$ifdef FPC}
function InternalClassProp(ClassType: TClass): PClassProp;
begin // FPC use memory alignment + vmtTypeInfo =-60 -> use PtrInt
  result := PTypeInfo(PPointer(PtrInt(ClassType)+vmtTypeInfo)^)^.ClassType^.ClassProp;
end;
{$else}
{$ifdef PUREPASCAL}
function InternalClassProp(ClassType: TClass): PClassProp;
var PTI: PTypeInfo;
begin // code is a bit abstract, but compiles very well
  PTI := PPointer(PtrInt(ClassType)+vmtTypeInfo)^;
  if PTI<>nil then // avoid GPF if no RTTI available for this class
    with PTI^, PClassType(@Name[ord(Name[0])+1])^ do
      result := PClassProp(@UnitName[ord(UnitName[0])+1]) else
    result := nil;
end;
{$else}
function InternalClassProp(ClassType: TClass): PClassProp;
asm // this code is the fastest possible
  mov eax,[eax+vmtTypeInfo]
  or eax,eax; jz @z // avoid GPF if no RTTI available for this class
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
  movzx edx,byte ptr [eax].TClassType.UnitName
  lea eax,[eax+edx].TClassType.UnitName[1].TClassProp
@z:
end;
{$endif}
{$endif}

function ClassFieldIndex(ClassType: TClass; const PropName: shortstring): integer;
var P: PPropInfo;
    CP: PClassProp;
begin
  if ClassType<>nil then begin
    CP := InternalClassProp(ClassType);
    if CP<>nil then begin
      P := @CP^.PropList;
      for result := 0 to CP^.PropCount-1 do
        if IdemPropName(P^.Name,PropName) then
          exit else
          P := P^.Next;
    end;
  end;
  result := -1;
end;

function ClassFieldProp(ClassType: TClass; const PropName: shortstring): PPropInfo;
begin
  if ClassType<>nil then
    result := InternalClassProp(ClassType)^.FieldProp(PropName) else
    result := nil;
end;

function ClassFieldPropWithParents(aClassType: TClass; const PropName: shortstring): PPropInfo;
var i: integer;
    CP: PClassProp;
begin
  while aClassType<>nil do begin
    CP := InternalClassProp(aClassType);
    if CP=nil then
      break; // no RTTI information (e.g. reached TObject level)
    result := @CP^.PropList;
    for i := 1 to CP^.PropCount do
      if IdemPropName(result^.Name,PropName) then
        exit else
        result := result^.Next;
    aClassType := aClassType.ClassParent;
  end;
  result := nil;
end;

function ClassFieldPropWithParentsFromUTF8(aClassType: TClass; PropName: PUTF8Char): PPropInfo;
var i, L: integer;
    CP: PClassProp;
begin
  L := StrLen(PropName);
  while (L<>0) and (aClassType<>nil) do begin
    CP := InternalClassProp(aClassType);
    if CP=nil then
      break; // no RTTI information (e.g. reached TObject level)
    result := @CP^.PropList;
    for i := 1 to CP^.PropCount do
      if IdemPropName(result^.Name,PropName,L) then
        exit else
        {$ifdef FPC}
        result := result^.Next;
        {$else}
        result := @result^.Name[ord(result^.Name[0])+1]; // inlined result^.Next
        {$endif}
    aClassType := aClassType.ClassParent;
  end;
  result := nil;
end;

function GetObjectComponent(Obj: TPersistent; const ComponentName: shortstring;
  ComponentClass: TClass): pointer;
var P: PPropInfo;
begin
  result := nil;
  if Obj=nil then
    exit;
  P := ClassFieldPropWithParents(PPointer(Obj)^,ComponentName);
  if (P<>nil) and (P^.PropType^^.Kind=tkClass) then
    if P^.PropType^^.ClassType^.ClassType.InheritsFrom(ComponentClass) then
{$ifdef CPU64} // pointer(P) to call typinfo
      result := pointer(GetOrdProp(Obj, pointer(P))); {$else}
      result := pointer(P^.GetOrdValue(Obj));
{$endif}
end;
  
function ClassFieldPropFromIndex(ClassType: TClass; PropIndex: integer): PPropInfo;
var i: integer;
begin
  result := nil;
  if ClassType<>nil then
  with InternalClassProp(ClassType)^ do
  if PropIndex<PropCount then begin
    result := @PropList;
    for i := 1 to PropIndex do
      result := result^.Next;
  end;
end;

function GetEnumCaption(aTypeInfo: PTypeInfo; const aIndex): string;
begin
  if (aTypeInfo=nil) or (aTypeInfo^.Kind<>tkEnumeration) then
    result := '' else
    result := aTypeInfo^.EnumBaseType^.GetCaption(PByte(@aIndex)^);
end;

function GetEnumNameTrimed(aTypeInfo: PTypeInfo; const aIndex): RawUTF8;
begin
  if (aTypeInfo=nil) or (aTypeInfo^.Kind<>tkEnumeration) then
    result := '' else
    result := aTypeInfo^.EnumBaseType^.GetEnumNameTrimed(aIndex);
end;


{ TSQLPropInfo }

const
  NULL_SHORTSTRING: string[0] = '';

function TSQLPropInfo.GetSQLFieldTypeName: PShortString;
begin
  if self=nil then
    result := @NULL_SHORTSTRING else
    result := PTypeInfo(TypeInfo(TSQLFieldType))^.EnumBaseType^.GetEnumNameOrd(ord(SQLFieldType));
end;

procedure TSQLPropInfo.TextToBinary(Value: PUTF8Char; var result: RawByteString);
begin
  result := BlobToTSQLRawBlob(Value);
end;

procedure TSQLPropInfo.BinaryToText(var Value: RawUTF8; ToSQL: boolean;
  wasSQLString: PBoolean);
begin
  if Value='' then begin
    if wasSQLString<>nil then
      wasSQLString^ := false;
    Value := 'null';
  end else begin
    if wasSQLString<>nil then
      wasSQLString^ := true;
    if ToSQL then
      // encode as BLOB literals (e.g. "X'53514C697465'")
      Value := TSQLRawBlobToBlob(TSQLRawBlob(Value)) else
      // JSON content is e.g. '\uFFF0base64encodedbinary'
      Value := BinToBase64WithMagic(Value);
  end;
end;

constructor TSQLPropInfo.Create(const aName: RawUTF8; aSQLFieldType: TSQLFieldType;
  aAttributes: TSQLPropInfoAttributes; aFieldWidth, aPropertyIndex: integer);
begin
  if aName='' then
    EORMException.CreateFmt('Void name for %s.Create',[ClassName]);
  fName := aName;
  fSQLFieldType := aSQLFieldType;
  fAttributes := aAttributes;
  fFieldWidth := aFieldWidth;
  fPropertyIndex := aPropertyIndex;
end;

function TSQLPropInfo.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var tmp: RawUTF8;
begin
  GetValueVar(Instance,false,tmp,nil);
  result := crc32c(0,pointer(tmp),length(tmp));
end;

procedure TSQLPropInfo.GetJSONValues(Instance: TObject; W: TJSONSerializer);
var wasString: boolean;
    tmp: RawUTF8;
begin
  GetValueVar(Instance,false,tmp,@wasString);
  if wasString then begin
    W.Add('"');
    if PtrUInt(tmp)<>0 then
      W.AddJSONEscape(pointer(tmp),PInteger(PtrUInt(tmp)-4)^);
    W.Add('"');
  end else
    if PtrUInt(tmp)<>0 then
      W.AddNoJSONEscape(pointer(tmp),PInteger(PtrUInt(tmp)-4)^);
end;

function TSQLPropInfo.GetValue(Instance: TObject; ToSQL: boolean;
  wasSQLString: PBoolean): RawUTF8;
begin
  GetValueVar(Instance,ToSQL,Result,wasSQLString);
end;

const
  SQLFieldTypeToDB: array[TSQLFieldType] of TSQLDBFieldType =
    (ftUnknown,   // sftUnknown
     ftUTF8,      // sftAnsiText
     ftUTF8,      // sftUTF8Text
     ftInt64,     // sftEnumerate
     ftInt64,     // sftSet
     ftInt64,     // sftInteger
     ftInt64,     // sftID
     ftInt64,     // sftRecord
     ftInt64,     // sftBoolean
     ftDouble,    // sftFloat
     ftDate,      // sftDateTime
     ftInt64,     // sftTimeLog
     ftCurrency,  // sftCurrency
     ftUTF8,      // sftObject
{$ifndef NOVARIANTS}
     ftUTF8,      // sftVariant
{$endif}
     ftBlob,      // sftBlob
     ftBlob,      // sftBlobDynArray
     ftBlob,      // sftBlobCustom
     ftUTF8,      // sftUTF8Custom
     ftUnknown,   // sftMany
     ftInt64,     // sftModTime
     ftInt64);    // sftCreateTime

procedure TSQLPropInfo.GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
  var temp: RawByteString);
begin
  GetValueVar(Instance,true,RawUTF8(temp),nil);
  aValue.VType := SQLFieldTypeToDB[fSQLFieldType];
  case aValue.VType of
    ftInt64:
      aValue.VInt64 := GetInt64(pointer(temp));
    ftDouble:
      aValue.VDouble := GetExtended(pointer(temp));
    ftDate:
      aValue.VDateTime := Iso8601ToDateTime(temp);
    ftCurrency:
      aValue.VInt64 := StrToCurr64(pointer(temp));
    ftBlob: begin
      temp := BlobToTSQLRawBlob(temp);
      aValue.VBlob := pointer(temp);
      aValue.VBlobLen := length(temp);
    end;
    ftUTF8:
      aValue.VText := pointer(temp);
    else
      aValue.VInt64 := 0;
  end;
end;

function TSQLPropInfo.SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean;
begin
  case aValue.VType of
    ftInt64:
      SetValue(Instance,pointer(Int64ToUtf8(aValue.VInt64)),false);
    ftDouble:
      SetValue(Instance,pointer(DoubleToStr(aValue.VDouble)),false);
    ftCurrency:
      SetValue(Instance,pointer(Curr64ToStr(aValue.VInt64)),false);
    ftDate:
      SetValue(Instance,pointer(DateTimeToIso8601Text(aValue.VDateTime)),true);
    ftBlob:
      SetValue(Instance,pointer(TSQLRawBlobToBlob(aValue.VBlob,aValue.VBlobLen)),true);
    ftUTF8:
      SetValue(Instance,aValue.VText,true);
    else
      SetValue(Instance,nil,false);
  end;
  result := true;
end;

const
  NULL_LOW = ord('n')+ord('u')shl 8+ord('l')shl 16+ord('l')shl 24;
  FALSE_LOW = ord('f')+ord('a')shl 8+ord('l')shl 16+ord('s')shl 24;
  TRUE_LOW  = ord('t')+ord('r')shl 8+ord('u')shl 16+ord('e')shl 24;

{$ifndef NOVARIANTS}
procedure ValueVarToVariant(Value: PUTF8Char; FT: TSQLFieldType;
  var result: TVarData; createValueTempCopy: boolean);
const
  /// map our available types for any SQL field property into variant values
  // - varNull will be used to store a true variant instance from JSON
  SQL_ELEMENTTYPES: array[TSQLFieldType] of word = (
 // sftUnknown, sftAnsiText, sftUTF8Text, sftEnumerate, sftSet, sftInteger,
    varEmpty,    varString,  varString,   varInteger,   varInt64, varInteger,
 // sftID, sftRecord, sftBoolean, sftFloat, sftDateTime, sftTimeLog, sftCurrency,
    varInteger,varInteger,varBoolean,varDouble,varDate,  varInt64, varCurrency,
 // sftObject, {$ifndef NOVARIANTS} sftVariant, {$endif} sftBlob, sftBlobDynArray,
    varNull,{$ifndef NOVARIANTS} varNull, {$endif} varString, varNull,
 // sftBlobCustom, sftUTF8Custom, sftMany, sftModTime, sftCreateTime
    varString,      varString,    varEmpty, varInt64, varInt64);
var tempCopy: RawUTF8;
    err: integer;
begin
  if not (result.VType in VTYPE_STATIC) then
    VarClear(variant(result));
  result.VType := SQL_ELEMENTTYPES[FT];
  case FT of
  sftCurrency:
    result.VInt64 := StrToCurr64(Value);
  sftFloat: begin
    result.VDouble := GetExtended(Value,err);
    if err<>0 then begin
      result.VType := varString;
      result.VAny := nil; // avoid GPF
      RawUTF8(result.VAny) := Value;
    end;
  end;
  sftDateTime:
    result.VDate := Iso8601ToDateTimePUTF8Char(Value,0);
  sftBoolean:
    result.VBoolean := (Value=nil) or (PWord(Value)^=ord('0')) or
      (PInteger(Value)^=FALSE_LOW);
  sftEnumerate, sftID, sftRecord, sftInteger:
    result.VInteger := GetInteger(Value);
  sftSet, sftTimeLog, sftModTime, sftCreateTime:
    result.VInt64 := GetInt64(Value);
  sftMany:
    exit;
  sftAnsiText, sftUTF8Text: begin
    pointer(result.VAny) := nil;
    RawUTF8(result.VAny) := Value;
  end;
  sftBlobCustom, sftBlob: begin
    pointer(result.VAny) := nil;
    RawByteString(result.VAny) := BlobToTSQLRawBlob(Value);
  end;
  sftObject, sftVariant, sftBlobDynArray, sftUTF8Custom: begin
    if createValueTempCopy then begin
      tempCopy := Value;
      Value := pointer(tempCopy);
    end;
    GetVariantFromJSON(Value,false,variant(result),@JSON_OPTIONS[true]);
  end;
  else raise ESQLTableException.CreateFmt('Unexpected type %d',[ord(FT)]);
  end;
end;

procedure TSQLPropInfo.GetVariant(Instance: TObject; var Dest: Variant);
var temp: RawUTF8;
begin
  GetValueVar(Instance,true,temp,nil);
  ValueVarToVariant(pointer(temp),fSQLFieldType,TVarData(Dest),false);
end;

procedure TSQLPropInfo.SetVariant(Instance: TObject; const Source: Variant);
begin
  SetValue(Instance,pointer(VariantToUTF8(Source)),
    not (TVarData(Source).VType in VTYPE_STATIC));
end;
{$endif NOVARIANTS}

function TSQLPropInfo.CompareValue(Item1, Item2: TObject; CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: RawUTF8;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetValueVar(Item1,false,tmp1,nil);
    GetValueVar(Item2,false,tmp2,nil);
    if CaseInsensitive then // slow, always working implementation
      result := StrIComp(pointer(tmp1),pointer(tmp2)) else
      result := StrComp(pointer(tmp1),pointer(tmp2));
  end;
end;


{ TSQLPropInfoRTTI }

class function TSQLPropInfoRTTI.CreateFrom(aPropInfo: PPropInfo; aPropIndex: integer): TSQLPropInfo;
var aSQLFieldType: TSQLFieldType;
    aType: PTypeInfo;
    C: TSQLPropInfoRTTIClass;
begin
  if aPropInfo=nil then
    raise EORMException.Create('Invalid CreateFrom() call');
  aType := aPropInfo^.PropType^;
  aSQLFieldType := aType^.SQLFieldType;
  C := nil;
  case aSQLFieldType of
    sftUnknown, sftBlobCustom:
      ; // will raise an EORMException
    sftBoolean, sftEnumerate:
      C := TSQLPropInfoRTTIEnum;
    sftTimeLog, sftModTime, sftCreateTime: // specific class for further use
      C := TSQLPropInfoRTTITimeLog;
    sftCurrency:
      C := TSQLPropInfoRTTICurrency;
    sftDateTime:
      C := TSQLPropInfoRTTIDateTime;
    sftID:
      C := TSQLPropInfoRTTIID;
    sftRecord:
      C := TSQLPropInfoRTTIInstance;
    sftMany:
      C := TSQLPropInfoRTTIMany;
    sftObject:
      C := TSQLPropInfoRTTIObject;
    {$ifndef NOVARIANTS}
    sftVariant:
      C := TSQLPropInfoRTTIVariant;
    {$endif}
    sftBlob:
      C := TSQLPropInfoRTTIRawBlob;
    sftBlobDynArray:
      C := TSQLPropInfoRTTIDynArray;
    sftUTF8Custom: begin // will happen only for DELPHI XE6 and up
      result := TSQLPropInfoCustomJSON.Create(aPropInfo,aPropIndex);
      exit;
    end;
    else
    case aType^.Kind of // retrieve exact type at binary level
      tkInteger:
        C := TSQLPropInfoRTTIInt32;
      tkSet:
        C := TSQLPropInfoRTTISet;
      tkChar, tkWChar:
        C := TSQLPropInfoRTTIChar;
      tkInt64{$ifdef FPC}, tkQWord{$endif}:
        C := TSQLPropInfoRTTIInt64;
      tkFloat:
        if aType^.FloatType=ftDoub then
          C := TSQLPropInfoRTTIDouble;
      {$ifdef FPC}tkAString,{$endif}
      tkLString:
        if aType=TypeInfo(RawUTF8) then
          C := TSQLPropInfoRTTIRawUTF8 else
        if aType=TypeInfo(RawUnicode) then
          C := TSQLPropInfoRTTIRawUnicode else
        if aType=TypeInfo(WinAnsiString) then
          C := TSQLPropInfoRTTIWinAnsi else
        if aType=TypeInfo(AnsiString) then
          C := TSQLPropInfoRTTIAnsi;
      {$ifdef UNICODE}
      tkUString:
        C := TSQLPropInfoRTTIUnicode;
      {$endif}
      tkWString:
        C := TSQLPropInfoRTTIWide;
    end;
  end;
  if C=nil then
    raise EORMException.CreateFmt('Unhandled %s/%s type for property %s',
      [GetEnumName(TypeInfo(TSQLFieldType),ord(aSQLFieldType))^,
       GetEnumName(TypeInfo(TTypeKind),ord(aType^.Kind))^,aPropInfo^.Name]);
  result := C.Create(aPropInfo,aPropIndex,aSQLFieldType);
end;

function TSQLPropInfoRTTI.GetFieldAddr(Instance: TObject): pointer;
begin
  if Instance=nil then
    result := nil else
    result := fPropInfo^.GetFieldAddr(Instance);
end;

constructor TSQLPropInfoRTTI.Create(aPropInfo: PPropInfo; aPropIndex: integer; aSQLFieldType: TSQLFieldType);
var attrib: TSQLPropInfoAttributes;
begin
  byte(attrib) := 0;
  if aPropInfo^.IsStored(nil)=AS_UNIQUE then
    Include(attrib,aIsUnique); // property MyProperty: RawUTF8 stored AS_UNIQUE;
  inherited Create(ShortStringToAnsi7String(aPropInfo^.Name),aSQLFieldType,attrib,
    aPropInfo^.Index,aPropIndex); // property MyProperty: RawUTF8 index 10; -> FieldWidth=10
  fPropInfo := aPropInfo;
end;


{ TSQLPropInfoRTTIInt32 }

procedure TSQLPropInfoRTTIInt32.CopyValue(Source, Dest: TObject);
begin
  SetOrdProp(Dest,pointer(fPropInfo),GetOrdProp(Source,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIInt32.GetBinary(Instance: TObject; W: TFileBufferWriter);
begin
   W.WriteVarUInt32(cardinal(GetOrdProp(Instance,pointer(fPropInfo))));
end;

function TSQLPropInfoRTTIInt32.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
begin
  result := GetOrdProp(Instance,pointer(fPropInfo));
end;

procedure TSQLPropInfoRTTIInt32.GetJSONValues(Instance: TObject; W: TJSONSerializer);
begin
  W.Add(GetOrdProp(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIInt32.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  if wasSQLString<>nil then
    wasSQLString^ := false;
  Int32ToUtf8(GetOrdProp(Instance,pointer(fPropInfo)),result);
end;

procedure TSQLPropInfoRTTIInt32.NormalizeValue(var Value: RawUTF8);
var err, VInt: integer;
begin
  VInt := GetInteger(pointer(Value),err);
  if err<>0 then
    Value := '' else
    Int32ToUtf8(VInt,Value);
end;

function TSQLPropInfoRTTIInt32.CompareValue(Item1, Item2: TObject; CaseInsensitive: boolean): PtrInt;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else 
    result := GetOrdProp(Item1,pointer(fPropInfo))-GetOrdProp(Item2,pointer(fPropInfo));
end;

function TSQLPropInfoRTTIInt32.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  if P<>nil then
    SetOrdProp(Instance,pointer(fPropInfo),integer(FromVarUInt32(PByte(P))));
  result := P;
end;

procedure TSQLPropInfoRTTIInt32.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  SetOrdProp(Instance,pointer(fPropInfo),GetInteger(Value));
end;

function TSQLPropInfoRTTIInt32.SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean;
begin
  if aValue.VType=ftInt64 then begin
    SetOrdProp(Instance,pointer(fPropInfo),aValue.VInt64);
    result := true;
  end else
    result := inherited SetFieldSQLVar(Instance,aValue);
end;

procedure TSQLPropInfoRTTIInt32.GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
  var temp: RawByteString);
begin
  aValue.VType := ftInt64;
  aValue.VInt64 := GetOrdProp(Instance,pointer(fPropInfo));
end;


{ TSQLPropInfoRTTISet }

constructor TSQLPropInfoRTTISet.Create(aPropInfo: PPropInfo; aPropIndex: integer;
  aSQLFieldType: TSQLFieldType);
begin
  inherited;
  fSetEnumType := fPropInfo^.PropType^^.SetEnumType;
end;


{ TSQLPropInfoRTTIEnum }

constructor TSQLPropInfoRTTIEnum.Create(aPropInfo: PPropInfo; aPropIndex: integer;
  aSQLFieldType: TSQLFieldType);
begin
  inherited;
  fEnumType := fPropInfo^.PropType^^.EnumBaseType;
end;

procedure TSQLPropInfoRTTIEnum.GetJSONValues(Instance: TObject; W: TJSONSerializer);
var i: integer;
begin
  i := GetOrdProp(Instance,pointer(fPropInfo));
  if fSQLFieldType=sftBoolean then
    W.AddString(JSON_BOOLEAN[boolean(i)]) else
    W.Add(i);
end;

procedure TSQLPropInfoRTTIEnum.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var i: integer;
begin
  if wasSQLString<>nil then
    wasSQLString^ := false;
  i := GetOrdProp(Instance,pointer(fPropInfo));
  if (fSQLFieldType=sftBoolean) and not ToSQL then
    result := JSON_BOOLEAN[boolean(i)] else
    Int32ToUtf8(i,result);
end;

procedure TSQLPropInfoRTTIEnum.NormalizeValue(var Value: RawUTF8);
var i,err: integer;
begin
  i := GetInteger(pointer(Value),err);
  if err<>0 then  // we allow a value stated as text
    if fSQLFieldType=sftBoolean then
      i := Ord(IdemPropNameU(Value,'TRUE') or IdemPropNameU(Value,'YES')) else
      i := fEnumType^.GetEnumNameValue(pointer(Value),length(Value)) else
    if fSQLFieldType=sftBoolean then // normalize boolean values range to 0,1
      if Boolean(i) then
        i := 1 else
        i := 0;
  if cardinal(i)>cardinal(fEnumType^.MaxValue) then
    Value := '' else // only set a valid value
    Int32ToUtf8(i,Value);
end;

procedure TSQLPropInfoRTTIEnum.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var i,err: integer;
begin
  if Value=nil then
    i := 0 else begin
    i := GetInteger(Value,err);
    if err<>0 then begin // we allow a value stated as text
      if fSQLFieldType=sftBoolean then
        i := Ord(IdemPropNameU(Value,'TRUE') or IdemPropNameU(Value,'YES')) else
        i := fEnumType^.GetEnumNameValue(Value); // -> convert into integer
      if cardinal(i)>cardinal(fEnumType^.MaxValue) then
        i := 0;  // only set a valid text value
    end else
    if fSQLFieldType=sftBoolean then // normalize boolean values range to 0,1
      if Boolean(i) then
        i := 1 else
        i := 0;
  end;
  SetOrdProp(Instance,pointer(fPropInfo),i);
end;


{ TSQLPropInfoRTTIChar }

procedure TSQLPropInfoRTTIChar.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var w: WideChar;
begin
  w := WideChar(GetOrdProp(Instance,pointer(fPropInfo)));
  if ToSQL and (w=#0) then begin
    // 'null' and not #0 to avoid end of SQL text - JSON will escape #0
    result := 'null';
    if wasSQLString<>nil then
      wasSQLString^ := false;
   end else begin
    RawUnicodeToUtf8(@w,1,result);
    if wasSQLString<>nil then
      wasSQLString^ := true;
  end;
end;

procedure TSQLPropInfoRTTIChar.NormalizeValue(var Value: RawUTF8);
begin // do nothing: should already be UTF-8 encoded
end;

procedure TSQLPropInfoRTTIChar.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var i: integer;
begin
  if (Value=nil) or (PInteger(Value)^=NULL_LOW) then
    i := 0 else
    i := GetUTF8Char(Value);
  SetOrdProp(Instance,pointer(fPropInfo),I);
end;


{ TSQLPropInfoRTTIInt64 }

procedure TSQLPropInfoRTTIInt64.CopyValue(Source, Dest: TObject);
begin
  SetInt64Prop(Dest,pointer(fPropInfo),GetInt64Prop(Source,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIInt64.GetBinary(Instance: TObject;
  W: TFileBufferWriter);
var V64: Int64;
begin
  V64 := GetInt64Prop(Instance,pointer(fPropInfo));
  W.Write(@V64,SizeOf(Int64));
end;

function TSQLPropInfoRTTIInt64.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var I64: Int64;
begin
  I64 := GetInt64Prop(Instance,pointer(fPropInfo));
  result := Int64Rec(I64).Lo xor Int64Rec(I64).Hi;
end;

procedure TSQLPropInfoRTTIInt64.GetJSONValues(Instance: TObject; W: TJSONSerializer);
begin
  W.Add(GetInt64Prop(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIInt64.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  if wasSQLString<>nil then
    wasSQLString^ := false;
  Int64ToUtf8(GetInt64Prop(Instance,pointer(fPropInfo)),result);
end;

procedure TSQLPropInfoRTTIInt64.NormalizeValue(var Value: RawUTF8);
var err: integer;
    VInt64: Int64;
begin
  VInt64 := GetInt64(pointer(Value),err);
  if err<>0 then
    Value := '' else
    Int64ToUtf8(VInt64,Value);
end;

function TSQLPropInfoRTTIInt64.CompareValue(Item1, Item2: TObject; CaseInsensitive: boolean): PtrInt;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else 
    result := GetInt64Prop(Item1,pointer(fPropInfo))-GetInt64Prop(Item2,pointer(fPropInfo));
end;

function TSQLPropInfoRTTIInt64.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  if P=nil then
    result := nil else begin
    SetInt64Prop(Instance,pointer(fPropInfo),PInt64(P)^);
    result := P+sizeof(Int64);
  end;
end;

procedure TSQLPropInfoRTTIInt64.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  SetInt64Prop(Instance,pointer(fPropInfo),GetInt64(Value));
end;

function TSQLPropInfoRTTIInt64.SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean;
begin
  if aValue.VType=ftInt64 then begin
    SetInt64Prop(Instance,pointer(fPropInfo),aValue.VInt64);
    result := true;
  end else
    result := inherited SetFieldSQLVar(Instance,aValue);
end;

procedure TSQLPropInfoRTTIInt64.GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
  var temp: RawByteString);
begin
  aValue.VType := ftInt64;
  aValue.VInt64 := GetInt64Prop(Instance,pointer(fPropInfo));
end;


{ TSQLPropInfoRTTIDouble }

procedure TSQLPropInfoRTTIDouble.GetJSONValues(Instance: TObject; W: TJSONSerializer);
begin
  W.Add(GetDoubleProp(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIDouble.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  if wasSQLString<>nil then
    wasSQLString^ := false;
  ExtendedToStr(GetDoubleProp(Instance,pointer(fPropInfo)),DOUBLE_PRECISION,result);
end;

procedure TSQLPropInfoRTTIDouble.NormalizeValue(var Value: RawUTF8);
var VFloat: Extended;
    err: integer;
begin
  VFloat := GetExtended(pointer(Value),err);
  if err<>0 then
    Value := '' else
    ExtendedToStr(VFloat,DOUBLE_PRECISION,Value);
end;

procedure TSQLPropInfoRTTIDouble.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var V: extended;
    err: integer;
begin
  if Value=nil then begin
    V := 0;
    err := 1;
  end else
    V := GetExtended(pointer(Value),err);
  if err<>0 then
    SetInt64Prop(Instance,pointer(fPropInfo),0) else
    SetFloatProp(Instance,pointer(fPropInfo),V);
end;

function TSQLPropInfoRTTIDouble.CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt;
var V1, V2: double;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    V1 := GetFloatProp(Item1,pointer(fPropInfo));
    V2 := GetFloatProp(Item2,pointer(fPropInfo));
    if SynCommons.SameValue(V1,V2) then
      result := 0 else
    if V1>V2 then
      result := 1 else
      result := -1;
  end;
end;

function TSQLPropInfoRTTIDouble.SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean;
var V: Extended;
begin
  case aValue.VType of
  ftDouble, ftDate:
    V := aValue.VDouble;
  ftInt64:
    V := aValue.VInt64;
  ftCurrency:
    V := aValue.VCurrency;
  else begin
    result := inherited SetFieldSQLVar(Instance,aValue);
    exit;
  end;
  end;
  SetFloatProp(Instance,pointer(fPropInfo),V);
  result := true;
end;

procedure TSQLPropInfoRTTIDouble.GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
  var temp: RawByteString);
begin
  aValue.VType := ftDouble;
  aValue.VDouble := GetFloatProp(Instance,pointer(fPropInfo));
end;


{ TSQLPropInfoRTTICurrency }

procedure TSQLPropInfoRTTICurrency.GetJSONValues(Instance: TObject; W: TJSONSerializer);
begin
  W.AddCurr64(GetCurrencyProp(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTICurrency.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  if wasSQLString<>nil then
    wasSQLString^ := false;
  result := CurrencyToStr(GetCurrencyProp(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTICurrency.NormalizeValue(var Value: RawUTF8);
begin
  Value := Curr64ToStr(StrToCurr64(pointer(Value)));
end;

procedure TSQLPropInfoRTTICurrency.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  if PropWrap(fPropInfo^.SetProc).Kind=$ff then
    SetInt64Prop(Instance,pointer(fPropInfo),StrToCurr64(Value)) else
    inherited SetValue(Instance,Value,wasString);
end;

function TSQLPropInfoRTTICurrency.CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt;
var V1, V2: currency;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    V1 := GetCurrencyProp(Item1,pointer(fPropInfo));
    V2 := GetCurrencyProp(Item2,pointer(fPropInfo));
    Result := PInt64(@V1)^-PInt64(@V2)^;
  end;
end;

procedure TSQLPropInfoRTTICurrency.GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
  var temp: RawByteString);
begin
  aValue.VType := ftCurrency;
  aValue.VCurrency := GetCurrencyProp(Instance,pointer(fPropInfo));
end;


{ TSQLPropInfoRTTIDateTime }

procedure TSQLPropInfoRTTIDateTime.GetJSONValues(Instance: TObject; W: TJSONSerializer);
begin
  W.Add('"');
  W.AddDateTime(GetDoubleProp(Instance,pointer(fPropInfo)));
  W.Add('"');
end;

function TSQLPropInfoRTTIDateTime.CompareValue(Item1,Item2: TObject; CaseInsensitive: boolean): PtrInt;
var Date1,Date2: TTimeLogBits;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    Date1.From(GetDoubleProp(Item1,pointer(fPropInfo)));
    Date2.From(GetDoubleProp(Item2,pointer(fPropInfo)));
    result := Date1.Value-Date2.Value;
  end;
end;

procedure TSQLPropInfoRTTIDateTime.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  if wasSQLString<>nil then
    wasSQLString^ := true;
  DateTimeToIso8601TextVar(GetDoubleProp(Instance,pointer(fPropInfo)),'T',result);
end;

procedure TSQLPropInfoRTTIDateTime.NormalizeValue(var Value: RawUTF8);
begin
  DateTimeToIso8601TextVar(Iso8601ToDateTime(Value),'T',Value);
end;

procedure TSQLPropInfoRTTIDateTime.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var V: TDateTime;
begin
  Iso8601ToDateTimePUTF8CharVar(Value,0,V);
  SetFloatProp(Instance,pointer(fPropInfo),V);
end;

procedure TSQLPropInfoRTTIDateTime.GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
  var temp: RawByteString);
begin
  aValue.VType := ftDate;
  aValue.VCurrency := GetDoubleProp(Instance,pointer(fPropInfo));
end;


{ TSQLPropInfoRTTIMany }

// TSQLRecordMany stores nothing within the table

procedure TSQLPropInfoRTTIMany.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  result := '';
end;

procedure TSQLPropInfoRTTIMany.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
end;

procedure TSQLPropInfoRTTIMany.GetBinary(Instance: TObject; W: TFileBufferWriter);
begin
end;

function TSQLPropInfoRTTIMany.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  result := P;
end;


{ TSQLPropInfoRTTIInstance }

constructor TSQLPropInfoRTTIInstance.Create(aPropInfo: PPropInfo; aPropIndex: integer;
  aSQLFieldType: TSQLFieldType);
begin
  inherited Create(aPropInfo,aPropIndex,aSQLFieldType);
  fObjectClass := aPropInfo^.PropType^^.ClassType^.ClassType;
end;

function TSQLPropInfoRTTIInstance.GetInstance(Instance: TObject): TObject;
begin
  result := pointer(GetOrdProp(Instance,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIInstance.SetInstance(Instance, Value: TObject);
begin
  SetOrdProp(Instance,pointer(fPropInfo),PtrInt(Value));
end;

{ TSQLPropInfoRTTIID }

procedure TSQLPropInfoRTTIID.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  if TSQLRecord(Instance).fFill.JoinedFields then
    raise EORMException.CreateFmt(
      'TSQLPropInfoRTTIID(%s).SetValue after Create*Joined',[Name]);
  inherited SetValue(Instance,Value,wasString);
end;

procedure TSQLPropInfoRTTIID.GetJSONValues(Instance: TObject; W: TJSONSerializer);
var ID: PtrUInt;
begin
  ID := GetOrdProp(Instance,pointer(fPropInfo));
  if TSQLRecord(Instance).fFill.JoinedFields then
    ID := TSQLRecord(ID).fID;
  W.Add(ID);
end;


{ TSQLPropInfoRTTIIObject }

procedure TSQLPropInfoRTTIObject.CopyValue(Source, Dest: TObject);
var S,D: TObject;
begin
  // generic case: copy also class content (create instances)
  S := GetInstance(Source);
  D := GetInstance(Dest);
  // note: Get/SetOrdProp() works also for CPU64 (returns an PtrInt)
{$ifndef LVCL}
  if S.InheritsFrom(TCollection) then
    CopyCollection(TCollection(S),TCollection(D)) else
{$endif} begin
    D.Free; // release previous child
    if S=nil then
      D := nil else begin
      D := ClassInstanceCreate(S.ClassType); // create new child instance
      CopyObject(S,D); // copy child content
    end;
    SetInstance(Dest,D);
  end;
end;                 

procedure TSQLPropInfoRTTIObject.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var valid: boolean;
    ValueLocalCopy: RawUTF8;
begin
  ValueLocalCopy := Value; // private copy since the buffer will be modified
  PropInfo^.ClassFromJSON(Instance,pointer(ValueLocalCopy),valid);
end;

procedure TSQLPropInfoRTTIObject.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  if wasSQLString<>nil then
    wasSQLString^ := true;
  result := ObjectToJSON(GetInstance(Instance));
end;                                         

procedure TSQLPropInfoRTTIObject.GetBinary(Instance: TObject; W: TFileBufferWriter);
begin
  // serialize object as JSON UTF-8 TEXT - not fast, but works
  W.Write(ObjectToJSON(GetInstance(Instance)));
end;

function TSQLPropInfoRTTIObject.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
var valid: boolean;
begin
  // unserialize object from JSON UTF-8 TEXT - not fast, but works
  PropInfo^.ClassFromJSON(Instance,pointer(FromVarString(PByte(P))),valid);
  if valid then
    result := P else
    result := nil;
end;

function TSQLPropInfoRTTIObject.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var tmp: RawUTF8;
begin
  tmp := ObjectToJSON(GetInstance(Instance));
  result := crc32c(0,pointer(tmp),length(tmp));
end;

procedure TSQLPropInfoRTTIObject.NormalizeValue(var Value: RawUTF8);
begin // do nothing: should already be normalized
end;

procedure TSQLPropInfoRTTIObject.GetJSONValues(Instance: TObject; W: TJSONSerializer);
begin
  W.WriteObjectAsString(GetInstance(Instance));
end;


{ TSQLPropInfoRTTIAnsi }

procedure TSQLPropInfoRTTIAnsi.CopyValue(Source, Dest: TObject);
var Value: RawByteString;
begin
  GetLongStrProp(Source,fPropInfo,Value);
  SetLongStrProp(Dest,fPropInfo,Value);
end;

procedure TSQLPropInfoRTTIAnsi.GetBinary(Instance: TObject; W: TFileBufferWriter);
var Value: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,Value);
  W.Write(Value);
end;

function TSQLPropInfoRTTIAnsi.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var Up: array[byte] of AnsiChar; // avoid slow heap allocation
    Value: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,Value);
  if CaseInsensitive then
    result := crc32c(0,Up,UpperCopy255(Up,Value)-Up) else
    result := crc32c(0,pointer(Value),length(Value));
end;

procedure TSQLPropInfoRTTIAnsi.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var tmp: RawByteString;
begin
  if wasSQLString<>nil then
    wasSQLString^ := true;
  GetLongStrProp(Instance,fPropInfo,tmp);
  result := CurrentAnsiConvert.AnsiToUTF8(tmp);
end;

procedure TSQLPropInfoRTTIAnsi.NormalizeValue(var Value: RawUTF8);
begin // do nothing: should already be UTF-8 encoded
end;

function TSQLPropInfoRTTIAnsi.CompareValue(Item1, Item2: TObject; CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: RawByteString;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetLongStrProp(Item1,fPropInfo,tmp1);
    GetLongStrProp(Item2,fPropInfo,tmp2);
    if CaseInsensitive then
      result := StrIComp(pointer(tmp1),pointer(tmp2)) else
      result := StrComp(pointer(tmp1),pointer(tmp2));
  end;
end;

function TSQLPropInfoRTTIAnsi.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  SetLongStrProp(Instance,fPropInfo,FromVarString(PByte(P)));
  result := P;
end;

procedure TSQLPropInfoRTTIAnsi.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  if Value=nil then
    SetLongStrProp(Instance,fPropInfo,'') else
    SetLongStrProp(Instance,fPropInfo,
      CurrentAnsiConvert.UTF8BufferToAnsi(Value,StrLen(Value)));
end;

function TSQLPropInfoRTTIAnsi.SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean;
var tmp: RawByteString;
begin
  case aValue.VType of
  ftNull: ; // leave tmp=''
  ftUTF8: CurrentAnsiConvert.UTF8BufferToAnsi(aValue.VText,StrLen(aValue.VText),tmp);
  else begin
    result := inherited SetFieldSQLVar(Instance,aValue);
    exit;
  end;
  end;
  SetLongStrProp(Instance,fPropInfo,tmp);
  result := True;
end;

procedure TSQLPropInfoRTTIAnsi.GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
  var temp: RawByteString);
begin
  GetLongStrProp(Instance,fPropInfo,temp);
  temp := CurrentAnsiConvert.AnsiToUTF8(temp);
  aValue.VType := ftUTF8;
  aValue.VText := Pointer(temp);
end;


{ TSQLPropInfoRTTIRawUTF8 }

function TSQLPropInfoRTTIRawUTF8.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var Up: array[byte] of AnsiChar; // avoid slow heap allocation
    Value: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,Value);
  if CaseInsensitive then
    result := crc32c(0,Up,UTF8UpperCopy255(Up,Value)-Up) else
    result := crc32c(0,pointer(Value),length(Value));
end;

procedure TSQLPropInfoRTTIRawUTF8.GetJSONValues(Instance: TObject; W: TJSONSerializer);
var tmp: RawByteString;
begin
  W.Add('"');
  GetLongStrProp(Instance,fPropInfo,tmp);
  if PtrUInt(tmp)<>0 then
    W.AddJSONEscape(pointer(tmp),PInteger(PtrUInt(tmp)-4)^);
  W.Add('"');
end;

procedure TSQLPropInfoRTTIRawUTF8.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  if wasSQLString<>nil then
    wasSQLString^ := true;
  GetLongStrProp(Instance,fPropInfo,RawByteString(result));
end;

function TSQLPropInfoRTTIRawUTF8.SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean;
var tmp: RawByteString;
begin
  case aValue.VType of
  ftNull: ; // leave tmp=''
  ftUTF8: SetString(tmp,PAnsiChar(aValue.VText),StrLen(aValue.VText));
  else begin
    result := inherited SetFieldSQLVar(Instance,aValue);
    exit;
  end;
  end;
  SetLongStrProp(Instance,fPropInfo,tmp);
  result := True;
end;

procedure TSQLPropInfoRTTIRawUTF8.GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
  var temp: RawByteString);
begin
  GetLongStrProp(Instance,fPropInfo,temp);
  aValue.VType := ftUTF8;
  aValue.VText := Pointer(temp);
end;

function TSQLPropInfoRTTIRawUTF8.CompareValue(Item1, Item2: TObject; CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: RawByteString;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetLongStrProp(Item1,fPropInfo,tmp1);
    GetLongStrProp(Item2,fPropInfo,tmp2);
    if CaseInsensitive then
      result := UTF8IComp(pointer(tmp1),pointer(tmp2)) else
      result := StrComp(pointer(tmp1),pointer(tmp2));
  end;
end;

procedure TSQLPropInfoRTTIRawUTF8.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  SetLongStrProp(Instance,fPropInfo,RawUTF8(Value));
end;


{ TSQLPropInfoRTTIWinAnsi }

function TSQLPropInfoRTTIWinAnsi.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var Up: array[byte] of AnsiChar; // avoid slow heap allocation
    Value: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,Value);
  if CaseInsensitive then
    result := crc32c(0,Up,UpperCopyWin255(Up,Value)-Up) else
    result := crc32c(0,pointer(Value),length(Value));
end;

procedure TSQLPropInfoRTTIWinAnsi.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var tmp: RawByteString;
begin
  if wasSQLString<>nil then
    wasSQLString^ := true;
  GetLongStrProp(Instance,fPropInfo,tmp);
  result := WinAnsiConvert.AnsiBufferToRawUTF8(pointer(tmp),length(tmp));
end;

function TSQLPropInfoRTTIWinAnsi.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: RawByteString;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetLongStrProp(Item1,fPropInfo,tmp1);
    GetLongStrProp(Item2,fPropInfo,tmp2);
    if CaseInsensitive then
      result := AnsiIComp(pointer(tmp1),pointer(tmp2)) else
      result := StrComp(pointer(tmp1),pointer(tmp2));
  end;
end;

procedure TSQLPropInfoRTTIWinAnsi.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  if Value=nil then
    SetLongStrProp(Instance,fPropInfo,'') else
    SetLongStrProp(Instance,fPropInfo,
      WinAnsiConvert.UTF8BufferToAnsi(Value,StrLen(Value)));
end;


{ TSQLPropInfoRTTIRawUnicode }

function TSQLPropInfoRTTIRawUnicode.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var Up: array[byte] of AnsiChar; // avoid slow heap allocation
    Value: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,Value);
  if CaseInsensitive then
    result := crc32c(0,Up,UpperCopy255W(Up,pointer(Value),length(Value)shr 1)-Up) else
    result := crc32c(0,pointer(Value),length(Value));
end;

procedure TSQLPropInfoRTTIRawUnicode.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var tmp: RawByteString;
begin
  if wasSQLString<>nil then
    wasSQLString^ := true;
  GetLongStrProp(Instance,fPropInfo,tmp);
  RawUnicodeToUTF8(pointer(tmp),length(tmp)shr 1,result);
end;

function TSQLPropInfoRTTIRawUnicode.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: RawByteString;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetLongStrProp(Item1,fPropInfo,tmp1);
    GetLongStrProp(Item2,fPropInfo,tmp2);
    if CaseInsensitive then
      result := AnsiICompW(pointer(tmp1),pointer(tmp2)) else
      result := StrCompW(pointer(tmp1),pointer(tmp2));
  end;
end;

procedure TSQLPropInfoRTTIRawUnicode.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  if Value=nil then
    SetLongStrProp(Instance,fPropInfo,'') else
    SetLongStrProp(Instance,fPropInfo,Utf8DecodeToRawUnicode(Value,StrLen(Value)));
end;


{ TSQLPropInfoRTTIRawBlob }

function TSQLPropInfoRTTIRawBlob.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var Value: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,Value);
  result := crc32c(0,pointer(Value),length(Value)); // binary -> case sensitive
end;

procedure TSQLPropInfoRTTIRawBlob.GetJSONValues(Instance: TObject; W: TJSONSerializer);
var tmp: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,tmp);
  W.WrBase64(pointer(tmp),length(tmp),true);
end;

procedure TSQLPropInfoRTTIRawBlob.GetBlob(Instance: TObject;
  var Blob: RawByteString);
begin
  GetLongStrProp(Instance,fPropInfo,Blob);
end;

procedure TSQLPropInfoRTTIRawBlob.SetBlob(Instance: TObject;
  const Blob: RawByteString);
begin
  SetLongStrProp(Instance,fPropInfo,Blob);
end;

function TSQLPropInfoRTTIRawBlob.IsNull(Instance: TObject): Boolean;
var Blob: RawByteString;
begin
  GetLongStrProp(Instance,fPropInfo,Blob);
  result := (Blob='');
end;

procedure TSQLPropInfoRTTIRawBlob.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  GetLongStrProp(Instance,fPropInfo,RawByteString(result));
  BinaryToText(result,ToSQL,wasSQLString);
end;

function TSQLPropInfoRTTIRawBlob.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: RawByteString;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetLongStrProp(Item1,fPropInfo,tmp1);
    GetLongStrProp(Item2,fPropInfo,tmp2);
    // BLOB is binary so always case sensitive
    result := StrComp(pointer(tmp1),pointer(tmp2));
  end;
end;

procedure TSQLPropInfoRTTIRawBlob.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  SetLongStrProp(Instance,fPropInfo,BlobToTSQLRawBlob(Value));
end;

function TSQLPropInfoRTTIRawBlob.SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean;
var tmp: RawByteString;
begin
  case aValue.VType of
  ftBlob: begin
    SetString(tmp,PAnsiChar(aValue.VBlob),aValue.VBlobLen);
    SetLongStrProp(Instance,fPropInfo,tmp);
    result := true;
  end;
  ftNull: begin
    SetLongStrProp(Instance,fPropInfo,'');
    result := True;
  end;
  else
    result := inherited SetFieldSQLVar(Instance,aValue);
  end;
end;

procedure TSQLPropInfoRTTIRawBlob.GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
  var temp: RawByteString);
begin
  GetLongStrProp(Instance,fPropInfo,temp);
  if temp='' then
    aValue.VType := ftNull else begin
    aValue.VType := ftBlob;
    aValue.VBlob := pointer(temp);
    aValue.VBlobLen := length(temp);
  end;
end;


{ TSQLPropInfoRTTIWide }

procedure TSQLPropInfoRTTIWide.CopyValue(Source, Dest: TObject);
var Value: WideString;
begin
  GetWideStrProp(Source,fPropInfo,Value);
  SetWideStrProp(Dest,pointer(fPropInfo),Value);
end;

procedure TSQLPropInfoRTTIWide.GetBinary(Instance: TObject; W: TFileBufferWriter);
var Value: WideString;
begin
  GetWideStrProp(Instance,fPropInfo,Value);
  W.Write(WideStringToUTF8(Value));
end;

function TSQLPropInfoRTTIWide.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var Up: array[byte] of AnsiChar; // avoid slow heap allocation
    Value: WideString;
begin
  GetWideStrProp(Instance,fPropInfo,Value);
  if CaseInsensitive then
    result := crc32c(0,Up,UpperCopy255W(Up,pointer(Value),length(Value))-Up) else
    result := crc32c(0,pointer(Value),length(Value)*2);
end;

procedure TSQLPropInfoRTTIWide.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var Value: WideString;
begin
  GetWideStrProp(Instance,fPropInfo,Value);
  result := WideStringToUTF8(Value);
  if wasSQLString<>nil then
    wasSQLString^ := true;
end;

function TSQLPropInfoRTTIWide.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: WideString;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetWideStrProp(Item1,fPropInfo,tmp1);
    GetWideStrProp(Item2,fPropInfo,tmp2);
    if CaseInsensitive then
      result := AnsiICompW(pointer(tmp1),pointer(tmp2)) else
      result := StrCompW(pointer(tmp1),pointer(tmp2));
  end;
end;

function TSQLPropInfoRTTIWide.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  SetWideStrProp(Instance,pointer(fPropInfo),
    UTF8ToWideString(FromVarString(PByte(P))));
  result := P;
end;

procedure TSQLPropInfoRTTIWide.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var Wide: WideString;
begin
  UTF8ToWideString(Value,StrLen(Value),Wide);
  SetWideStrProp(Instance,pointer(fPropInfo),Wide);
end;


{$ifdef UNICODE}

{ TSQLPropInfoRTTIUnicode }

procedure TSQLPropInfoRTTIUnicode.CopyValue(Source, Dest: TObject);
begin
  SetUnicodeStrProp(Dest,pointer(fPropInfo),
    GetUnicodeStrProp(Source,pointer(fPropInfo)));
end;

procedure TSQLPropInfoRTTIUnicode.GetBinary(Instance: TObject; W: TFileBufferWriter);
begin
  W.Write(UnicodeStringToUtf8(GetUnicodeStrProp(Instance,pointer(fPropInfo))));
end;

function TSQLPropInfoRTTIUnicode.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var Up: array[byte] of AnsiChar; // avoid slow heap allocation
    Value: UnicodeString;
begin
  Value := GetUnicodeStrProp(Instance,pointer(fPropInfo));
  if CaseInsensitive then
    result := crc32c(0,Up,UpperCopy255W(Up,pointer(Value),length(Value))-Up) else
    result := crc32c(0,pointer(Value),length(Value)*2);
end;

procedure TSQLPropInfoRTTIUnicode.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  result := UnicodeStringToUtf8(GetUnicodeStrProp(Instance,pointer(fPropInfo)));
  if wasSQLString<>nil then
    wasSQLString^ := true;
end;

function TSQLPropInfoRTTIUnicode.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
var tmp1,tmp2: UnicodeString;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    tmp1 := GetUnicodeStrProp(Item1,pointer(fPropInfo));
    tmp2 := GetUnicodeStrProp(Item2,pointer(fPropInfo));
    if CaseInsensitive then
      result := AnsiICompW(pointer(tmp1),pointer(tmp2)) else
      result := StrCompW(pointer(tmp1),pointer(tmp2));
  end;
end;

function TSQLPropInfoRTTIUnicode.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  SetUnicodeStrProp(Instance,pointer(fPropInfo),
    UTF8DecodeToUnicodeString(FromVarString(PByte(P))));
  result := P;
end;

procedure TSQLPropInfoRTTIUnicode.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
begin
  SetUnicodeStrProp(Instance,pointer(fPropInfo),UTF8DecodeToUnicodeString(Value,StrLen(Value)));
end;

function TSQLPropInfoRTTIUnicode.SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean;
var tmp: UnicodeString;
begin
  case aValue.VType of
  ftNull: ; // leave tmp=''
  ftUTF8: UTF8DecodeToUnicodeString(aValue.VText,StrLen(aValue.VText),tmp);
  else begin
    result := inherited SetFieldSQLVar(Instance,aValue);
    exit;
  end;
  end;
  SetUnicodeStrProp(Instance,pointer(fPropInfo),tmp);
  result := True;
end;

procedure TSQLPropInfoRTTIUnicode.GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
  var temp: RawByteString);
begin
  temp := UnicodeStringToUtf8(GetUnicodeStrProp(Instance,pointer(fPropInfo)));
  aValue.VType := ftUTF8;
  aValue.VText := Pointer(temp);
end;

{$endif UNICODE}


{ TSQLPropInfoRTTIDynArray }

procedure TSQLPropInfoRTTIDynArray.CopyValue(Source, Dest: TObject);
begin
  GetDynArray(Dest).Copy(GetDynArray(Source));
end;

procedure TSQLPropInfoRTTIDynArray.GetBinary(Instance: TObject; W: TFileBufferWriter);
var Value: RawByteString;
begin
  Value := GetDynArray(Instance).SaveTo;
  W.Write(pointer(Value),length(Value));
end;

function TSQLPropInfoRTTIDynArray.GetDynArray(Instance: TObject): TDynArray;
begin
  result.Init(fPropInfo^.PropType^,GetFieldAddr(Instance)^);
end;

function TSQLPropInfoRTTIDynArray.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var tmp: RawByteString;
begin
  tmp := GetDynArray(Instance).SaveTo;
  result := crc32c(0,pointer(tmp),length(tmp));
end;

procedure TSQLPropInfoRTTIDynArray.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  result := GetDynArray(Instance).SaveTo;
  BinaryToText(result,ToSQL,wasSQLString);
end;

{$ifndef NOVARIANTS}

procedure TSQLPropInfoRTTIDynArray.GetVariant(Instance: TObject; var Dest: Variant);
begin
  DynArrayToVariant(Dest,GetFieldAddr(Instance),fPropInfo^.PropType^);
end;

procedure TSQLPropInfoRTTIDynArray.SetVariant(Instance: TObject; const Source: Variant);
begin
  DynArrayFromVariant(PPointer(GetFieldAddr(Instance))^,Source,fPropInfo^.PropType^);
end;

{$endif NOVARIANTS}

procedure TSQLPropInfoRTTIDynArray.NormalizeValue(var Value: RawUTF8);
begin // do nothing: should already be normalized
end;

function TSQLPropInfoRTTIDynArray.CompareValue(Item1, Item2: TObject; CaseInsensitive: boolean): PtrInt;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else
  if GetDynArray(Item1).Equals(GetDynArray(Item2)) then
    result := 0 else
    result := PtrInt(Item1)-PtrInt(Item2); // pseudo comparison
end;

function TSQLPropInfoRTTIDynArray.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  result := GetDynArray(Instance).LoadFrom(P);
end;

procedure TSQLPropInfoRTTIDynArray.SetValue(Instance: TObject;
  Value: PUTF8Char; wasString: boolean);
var blob: RawByteString;
begin
  if Value=nil then
    GetDynArray(Instance).Clear else
  if Base64MagicCheckAndDecode(Value,blob) then
    GetDynArray(Instance).LoadFrom(pointer(blob)) else begin
    blob := Value; // private copy since LoadFromJSON() modifies buffer in-place
    GetDynArray(Instance).LoadFromJSON(Pointer(blob));
  end;
end;

function TSQLPropInfoRTTIDynArray.SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean;
begin
  if aValue.VType=ftBlob then
    result := GetDynArray(Instance).LoadFrom(aValue.VBlob)<>nil else
    result := inherited SetFieldSQLVar(Instance,aValue);
end;

procedure TSQLPropInfoRTTIDynArray.GetJSONValues(Instance: TObject; W: TJSONSerializer);
var tmp: RawByteString;
begin
  tmp := GetDynArray(Instance).SaveTo;
  W.WrBase64(pointer(tmp),Length(tmp),true); // withMagic=true -> add ""
end;

procedure TSQLPropInfoRTTIDynArray.GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
  var temp: RawByteString);
begin
  temp := GetDynArray(Instance).SaveTo;
  aValue.VType := ftBlob;
  aValue.VBlob := pointer(temp);
  aValue.VBlobLen := length(temp);
end;


{$ifndef NOVARIANTS}

{ TSQLPropInfoRTTIVariant }

constructor TSQLPropInfoRTTIVariant.Create(aPropInfo: PPropInfo; aPropIndex: integer;
  aSQLFieldType: TSQLFieldType);
begin
  inherited;
  fDocVariantOptions := JSON_OPTIONS[true];
end;

procedure TSQLPropInfoRTTIVariant.CopyValue(Source, Dest: TObject);
var value: Variant;
begin
  GetVariantProp(Source,pointer(fPropInfo),value);
  SetVariantProp(Dest,pointer(fPropInfo),value);
end;

procedure TSQLPropInfoRTTIVariant.GetBinary(Instance: TObject;
  W: TFileBufferWriter);
var value: Variant;
begin
  GetVariantProp(Instance,pointer(fPropInfo),value);
  W.Write(value);
end;

function TSQLPropInfoRTTIVariant.GetHash(Instance: TObject;
  CaseInsensitive: boolean): cardinal;
var Up: array[byte] of AnsiChar; // avoid slow heap allocation
    value: Variant;
procedure ComplexType;
var tmp: RawUTF8;
begin // slow but always working conversion to string
  tmp := VariantSaveJSON(value,twNone);
  if CaseInsensitive then
    result := crc32c(0,Up,UTF8UpperCopy255(Up,tmp)-Up) else
    result := crc32c(0,pointer(tmp),length(tmp));
end;
begin
  GetVariantProp(Instance,pointer(fPropInfo),value);
  with TVarData(value) do
  case VType of
    varNull, varEmpty:
      result := 0;
    varSmallint, varWord, varBoolean:
      result := VWord;
    varShortInt, varByte:
      result := VByte;
    varLongWord, varInteger, varSingle:
      result := varLongWord;
    varInt64, varDouble, varDate, varCurrency:
      result := crc32c(0,@VInt64,sizeof(Int64));
    varString:
      if CaseInsensitive then
        result := crc32c(0,Up,UTF8UpperCopy255(Up,RawUTF8(VString))-Up) else
        result := crc32c(0,VString,length(RawUTF8(VString)));
    varOleStr {$ifdef UNICODE}, varUString{$endif}:
      if CaseInsensitive then
        result := crc32c(0,Up,UpperCopy255W(Up,VOleStr,StrLenW(VOleStr))-Up) else
        result := crc32c(0,VAny,StrLenW(VOleStr)*2);
  else
    ComplexType;
  end;
end;

procedure TSQLPropInfoRTTIVariant.GetJSONValues(Instance: TObject;
  W: TJSONSerializer);
var value: Variant;
begin
  GetVariantProp(Instance,pointer(fPropInfo),value);
  W.AddVariantJSON(value,twJSONEscape);
end;

procedure TSQLPropInfoRTTIVariant.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var wasString: boolean;
    value: Variant;
begin
  GetVariantProp(Instance,pointer(fPropInfo),value);
  VariantToUTF8(value,result,wasString);
  if wasSQLString<>nil then
    // from SQL point of view, variant columns are TEXT or null
    wasSQLString^ := TVarData(value).VType>varNull;
end;

procedure TSQLPropInfoRTTIVariant.GetVariant(Instance: TObject;
  var Dest: Variant);
begin
  GetVariantProp(Instance,pointer(fPropInfo),Dest);
end;

procedure TSQLPropInfoRTTIVariant.NormalizeValue(var Value: RawUTF8);
begin // content should be already normalized
end;

function TSQLPropInfoRTTIVariant.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
var V1,V2: variant;
    u1,u2: RawUTF8;
    wasString: boolean;
begin
  if Item1=Item2 then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    GetVariantProp(Item1,pointer(fPropInfo),V1);
    GetVariantProp(Item2,pointer(fPropInfo),V2);
    if (TVarData(V1).VType=TVarData(V2).VType) and // fast simple type compare
       (TVarData(V1).VType in VTYPE_STATIC) then
      if V1>V2 then 
        result := 1 else
      if V1=V2 then
        result := 0 else
        result := -1 else begin // slow but always working string-based compare
      VariantToUTF8(V1,u1,wasString);
      VariantToUTF8(V2,u2,wasString);
      if CaseInsensitive then
        result := StrIComp(pointer(u1),pointer(u2)) else
        result := StrComp(pointer(u1),pointer(u2));
    end;
  end;
end;

function TSQLPropInfoRTTIVariant.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
var value: Variant;
begin
  FromVarVariant(PByte(P),value,DocVariantOptions);
  SetVariantProp(Instance,pointer(fPropInfo),value);
  result := P;
end;

procedure TSQLPropInfoRTTIVariant.SetValue(Instance: TObject; Value: PUTF8Char;
  wasString: boolean);
var V: Variant;
    ValueLocalCopy: RawUTF8;
begin
  ValueLocalCopy := Value; // private copy since the buffer will be modified
  GetVariantFromJSON(pointer(ValueLocalCopy),wasString,V,@DocVariantOptions);
  SetVariantProp(Instance,pointer(fPropInfo),V);
end;

procedure TSQLPropInfoRTTIVariant.SetVariant(Instance: TObject;
  const Source: Variant);
begin
  SetVariantProp(Instance,pointer(fPropInfo),Source);
end;

{$endif NOVARIANTS}


{ TSQLPropInfoCustom }

function TSQLPropInfoCustom.GetFieldAddr(Instance: TObject): pointer;
begin
  if Instance=nil then
    result := nil else
    result := PAnsiChar(Instance)+fOffset;
end;

constructor TSQLPropInfoCustom.Create(const aName: RawUTF8;
  aSQLFieldType: TSQLFieldType; aAttributes: TSQLPropInfoAttributes;
  aFieldWidth, aPropIndex: integer; aProperty: pointer;
  aData2Text: TOnSQLPropInfoRecord2Text; aText2Data: TOnSQLPropInfoRecord2Data);
begin
  inherited Create(aNAme,aSQLFieldType,aAttributes,aFieldWidth,aPropIndex);
  fOffset := PtrUInt(aProperty);
  if (Assigned(aData2Text) and not Assigned(aText2Data)) or
     (Assigned(aText2Data) and not Assigned(aData2Text)) then
    raise EORMException.CreateFmt(
      'Invalid %s.Create: expecting both Data2Text/Text2Data',[ClassName]);
  fData2Text := aData2Text;
  fText2Data := aText2Data;
end;

procedure TSQLPropInfoCustom.TextToBinary(Value: PUTF8Char; var result: RawByteString);
begin
  if Assigned(fText2Data) then
    fText2Data(Value,result) else
    result := BlobToTSQLRawBlob(Value);
end;

procedure TSQLPropInfoCustom.BinaryToText(var Value: RawUTF8; ToSQL: boolean;
  wasSQLString: PBoolean);
begin
  if Assigned(fData2Text) then 
    fData2Text(@Value[1],length(Value),Value) else
    inherited BinaryToText(Value,ToSQL,wasSQLString);
end;


{ TSQLPropInfoRecordRTTI }

procedure TSQLPropInfoRecordRTTI.CopyValue(Source, Dest: TObject);
begin
  RecordCopy(GetFieldAddr(Dest)^,GetFieldAddr(Source)^,fTypeInfo);
end;

constructor TSQLPropInfoRecordRTTI.Create(aRecordInfo: PTypeInfo;
  const aName: RawUTF8; aPropertyIndex: integer; aPropertyPointer: pointer;
  aAttributes: TSQLPropInfoAttributes; aFieldWidth: integer;
  aData2Text: TOnSQLPropInfoRecord2Text; aText2Data: TOnSQLPropInfoRecord2Data);
begin
  if (aRecordInfo=nil) or (aRecordInfo^.Kind<>tkRecord) then
    raise EORMException.CreateFmt(
      'TSQLPropInfoRecordRTTI: Invalid type information for %s',[aName]);
  inherited Create(aName,sftBlobCustom,aAttributes,aFieldWidth,aPropertyIndex,
    aPropertyPointer,aData2Text,aText2Data);
  fTypeInfo := aRecordInfo;
end;

procedure TSQLPropInfoRecordRTTI.GetBinary(Instance: TObject; W: TFileBufferWriter);
var Value: RawByteString;
begin
  Value := RecordSave(GetFieldAddr(Instance)^,fTypeInfo);
  W.Write(pointer(Value),length(Value));
end;

function TSQLPropInfoRecordRTTI.GetHash(Instance: TObject;
  CaseInsensitive: boolean): cardinal;
var Value: RawByteString;
begin
  Value := RecordSave(GetFieldAddr(Instance)^,fTypeInfo);
  result := crc32c(0,pointer(Value),length(Value));
end;

{$ifndef NOVARIANTS}
procedure TSQLPropInfoRecordRTTI.GetVariant(Instance: TObject; var Dest: Variant);
begin
  Dest := RecordSave(GetFieldAddr(Instance)^,fTypeInfo);
end;

procedure TSQLPropInfoRecordRTTI.SetVariant(Instance: TObject; const Source: Variant);
begin
  if TVarData(Source).VType=varString then
    RecordLoad(GetFieldAddr(Instance)^,TVarData(Source).VAny,fTypeInfo) else
    RecordClear(GetFieldAddr(Instance)^,fTypeInfo);
end;
{$endif NOVARIANTS}

procedure TSQLPropInfoRecordRTTI.NormalizeValue(var Value: RawUTF8);
begin // a BLOB should already be normalized
end;

function TSQLPropInfoRecordRTTI.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
begin
  if RecordEquals(GetFieldAddr(Item1)^,GetFieldAddr(Item2)^,fTypeInfo) then
    result := 0 else
    result := PtrInt(Item1)-PtrInt(Item2); // pseudo comparison
end;

function TSQLPropInfoRecordRTTI.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  result := RecordLoad(GetFieldAddr(Instance)^,P,fTypeInfo);
end;

procedure TSQLPropInfoRecordRTTI.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var data: RawByteString;
begin
  TextToBinary(Value,data);
  RecordLoad(GetFieldAddr(Instance)^,pointer(data),fTypeInfo);
end;

procedure TSQLPropInfoRecordRTTI.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  result := RecordSave(GetFieldAddr(Instance)^,fTypeInfo);
  BinaryToText(result,ToSQL,wasSQLString);
end;

function TSQLPropInfoRecordRTTI.SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean;
begin
  if aValue.VType=ftBlob then
    result := RecordLoad(GetFieldAddr(Instance)^,aValue.VBlob,fTypeInfo)<>nil else
    result := inherited SetFieldSQLVar(Instance,aValue);
end;

procedure TSQLPropInfoRecordRTTI.GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
  var temp: RawByteString);
begin
  temp := RecordSave(GetFieldAddr(Instance)^,fTypeInfo);
  aValue.VType := ftBlob;
  aValue.VBlob := pointer(temp);
  aValue.VBlobLen := length(temp);
end;


{ TSQLPropInfoRecordFixedSize }

procedure TSQLPropInfoRecordFixedSize.CopyValue(Source, Dest: TObject);
begin
  move(GetFieldAddr(Source)^,GetFieldAddr(Dest)^,fRecordSize);
end;

constructor TSQLPropInfoRecordFixedSize.Create(aRecordSize: cardinal;
  const aName: RawUTF8; aPropertyIndex: integer;
  aPropertyPointer: pointer; aAttributes: TSQLPropInfoAttributes;
  aFieldWidth: integer; aData2Text: TOnSQLPropInfoRecord2Text;
  aText2Data: TOnSQLPropInfoRecord2Data);
begin
  if integer(aRecordSize)<=0 then
    raise EORMException.CreateFmt(
      'TSQLPropInfoRecordFixedSize: invalid %d record size',[aRecordSize]);
  fRecordSize := aRecordSize;
  inherited Create(aName,sftBlobCustom,aAttributes,aFieldWidth,aPropertyIndex,
    aPropertyPointer,aData2Text,aText2Data);
end;

procedure TSQLPropInfoRecordFixedSize.GetBinary(Instance: TObject; W: TFileBufferWriter);
begin
  W.Write(GetFieldAddr(Instance),fRecordSize);
end;

function TSQLPropInfoRecordFixedSize.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
begin
  result := crc32c(0,GetFieldAddr(Instance),fRecordSize);
end;

procedure TSQLPropInfoRecordFixedSize.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
begin
  SetRawUTF8(result,GetFieldAddr(Instance),fRecordSize);
  BinaryToText(result,ToSQL,wasSQLString);
end;

{$ifndef NOVARIANTS}
procedure TSQLPropInfoRecordFixedSize.GetVariant(Instance: TObject;
  var Dest: Variant);
var tmp: RawByteString;
begin
  SetString(tmp,PAnsiChar(GetFieldAddr(Instance)),fRecordSize);
  Dest := tmp;
end;

procedure TSQLPropInfoRecordFixedSize.SetVariant(Instance: TObject;
  const Source: Variant);
begin
  if TVarData(Source).VType=varString then
    move(TVarData(Source).VAny^,GetFieldAddr(Instance)^,fRecordSize) else
    fillchar(GetFieldAddr(Instance)^,fRecordSize,0);
end;
{$endif NOVARIANTS}

procedure TSQLPropInfoRecordFixedSize.NormalizeValue(var Value: RawUTF8);
begin // a BLOB should already be normalized
end;

function TSQLPropInfoRecordFixedSize.CompareValue(Item1, Item2: TObject;
  CaseInsensitive: boolean): PtrInt;
var i: Integer;
    P1,P2: PByteArray;
begin
  if (Item1=Item2) or (fRecordSize=0) then
    result := 0 else
  if Item1=nil then
    result := -1 else
  if Item2=nil then
    result := 1 else begin
    result := 0;
    P1 := GetFieldAddr(Item1);
    P2 := GetFieldAddr(Item2);
    for i := 0 to fRecordSize-1 do begin
      result := P1^[i]-P2^[i];
      if result<>0 then
        exit;
    end;
  end;
end;

function TSQLPropInfoRecordFixedSize.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
begin
  if P=nil then
    fillchar(GetFieldAddr(Instance)^,fRecordSize,0) else
    move(P^,GetFieldAddr(Instance)^,fRecordSize);
  result := P+fRecordSize;
end;

procedure TSQLPropInfoRecordFixedSize.SetValue(Instance: TObject; Value: PUTF8Char; wasString: boolean);
var data: RawByteString;
begin
  TextToBinary(Value,data);
  Value := pointer(data);
  if Value=nil then
    fillchar(GetFieldAddr(Instance)^,fRecordSize,0) else
    move(Value^,GetFieldAddr(Instance)^,fRecordSize);
end;

function TSQLPropInfoRecordFixedSize.SetFieldSQLVar(Instance: TObject; const aValue: TSQLVar): boolean;
begin
  if aValue.VType=ftBlob then begin
    result := aValue.VBlobLen=fRecordSize;
    if result then
      move(aValue.VBlob^,GetFieldAddr(Instance)^,fRecordSize)
  end else
    result := inherited SetFieldSQLVar(Instance,aValue);
end;

procedure TSQLPropInfoRecordFixedSize.GetFieldSQLVar(Instance: TObject; var aValue: TSQLVar;
  var temp: RawByteString);
begin
  SetString(temp,PAnsiChar(GetFieldAddr(Instance)),fRecordSize);
  aValue.VType := ftBlob;
  aValue.VBlob := pointer(temp);
  aValue.VBlobLen := length(temp);
end;


{ TSQLPropInfoCustomJSON }

constructor TSQLPropInfoCustomJSON.Create(aPropInfo: PPropInfo; aPropIndex: integer);
var attrib: TSQLPropInfoAttributes;
begin
  byte(attrib) := 0;
  if aPropInfo^.IsStored(nil)=AS_UNIQUE then
    Include(attrib,aIsUnique); // property MyProperty: RawUTF8 stored AS_UNIQUE;ieldWidth=10
  Create(aPropInfo^.PropType^,ShortStringToAnsi7String(aPropInfo^.Name),
    aPropIndex,aPropInfo^.GetFieldAddr(nil),attrib,aPropInfo^.Index);
end;

constructor TSQLPropInfoCustomJSON.Create(aTypeInfo: PTypeInfo;
  const aName: RawUTF8; aPropertyIndex: integer; aPropertyPointer: pointer;
  aAttributes: TSQLPropInfoAttributes; aFieldWidth: integer);
begin
  inherited Create(aName,sftUTF8Custom,aAttributes,aFieldWidth,aPropertyIndex,
    aPropertyPointer,nil,nil);
  SetCustomParser(TJSONCustomParserRTTI.CreateFromRTTI(aName,aTypeInfo,0));
end;

constructor TSQLPropInfoCustomJSON.Create(const aTypeName, aName: RawUTF8;
  aPropertyIndex: integer; aPropertyPointer: pointer;
  aAttributes: TSQLPropInfoAttributes; aFieldWidth: integer);
begin
  inherited Create(aName,sftUTF8Custom,aAttributes,aFieldWidth,aPropertyIndex,
    aPropertyPointer,nil,nil);
  SetCustomParser(TJSONCustomParserRTTI.CreateFromTypeName(aName,aTypeName));
end;

procedure TSQLPropInfoCustomJSON.SetCustomParser(
  aCustomParser: TJSONCustomParserRTTI);
begin
  if aCustomParser=nil then
    raise EORMException.CreateFmt(
      '%s: Invalid type information for %s',[ClassName,Name]);
  fCustomParser := aCustomParser;
end;

destructor TSQLPropInfoCustomJSON.Destroy;
begin
  inherited;
  fCustomParser.Free;
end;

procedure TSQLPropInfoCustomJSON.CopyValue(Source, Dest: TObject);
var JSON: RawUTF8;
begin
  GetValueVar(Source,false,JSON,nil);
  SetValue(Dest,pointer(JSON),false);
end;

procedure TSQLPropInfoCustomJSON.GetBinary(Instance: TObject;
  W: TFileBufferWriter);
var JSON: RawUTF8;
begin
  GetValueVar(Instance,false,JSON,nil);
  W.Write(JSON);
end;

function TSQLPropInfoCustomJSON.SetBinary(Instance: TObject;
  P: PAnsiChar): PAnsiChar;
begin
  SetValue(Instance,pointer(FromVarString(PByte(P))),false);
  result := P;
end;

procedure TSQLPropInfoCustomJSON.NormalizeValue(var Value: RawUTF8);
begin // do nothing: should already be normalized
end;

procedure TSQLPropInfoCustomJSON.GetJSONValues(Instance: TObject;
  W: TJSONSerializer);
var Data: PByte;
begin
  Data := GetFieldAddr(Instance);
  fCustomParser.WriteOneLevel(W,Data,
    [soReadIgnoreUnknownFields,soCustomVariantCopiedByReference]);
  W.CancelLastComma;
end;

procedure TSQLPropInfoCustomJSON.GetValueVar(Instance: TObject;
  ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var W: TJSONSerializer;
begin
  W := TJSONSerializer.CreateOwnedStream;
  with W do
  try
    GetJSONValues(Instance,W);
    W.SetText(result);
    if wasSQLString<>nil then
      wasSQLString^ := (result<>'') and (result[1]='"');
  finally
    W.Free;
  end;
end;

procedure TSQLPropInfoCustomJSON.SetValue(Instance: TObject;
  Value: PUTF8Char; wasString: boolean);
var Data: PByte;
    tmp: RawUTF8;
begin
  Data := GetFieldAddr(Instance);
  if Value<>nil then
  if ((Value[0]<>'{')or(Value[StrLen(Value)-1]<>'}')) and
     ((Value[0]<>'[')or(Value[StrLen(Value)-1]<>']')) then begin
    QuotedStr(Value,'"',tmp);
    Value := pointer(tmp);
  end;
  fCustomParser.ReadOneLevel(Value,Data,
    [soReadIgnoreUnknownFields,soCustomVariantCopiedByReference]);
end;


{ TSQLPropInfoList }

destructor TSQLPropInfoList.Destroy;
var i: integer;
begin
  for i := 0 to fCount-1 do
    fList[i].Free;
  inherited;
end;

function TSQLPropInfoList.Add(aTable: TClass; aItem: TSQLPropInfo): integer;
var f: integer;
begin
  // check that this property is not an ID/RowID (handled separately)
  if IsRowID(pointer(aItem.Name)) then
    raise EModelException.CreateFmt('%s should not include a %s published property',
      [aTable.ClassName,aItem.Name]);
  // check that this property name is not already defined
  for f := 0 to fCount-1 do
    if IdemPropNameU(fList[f].Name,aItem.Name) then
      raise EModelException.CreateFmt('dup property name %s',[aItem.Name]);
  // add to the internal list
  result := fCount;
  if result>=length(fList) then
    SetLength(fList,result+result shr 3+32);
  inc(fCount);
  fList[result] := aItem;
  if fOrderedByName<>nil then
    SetLength(fOrderedByName,0);
end;

function TSQLPropInfoList.GetItem(aIndex: integer): TSQLPropInfo;
begin
  if cardinal(aIndex)>=Cardinal(fCount) then
    EORMException.Create('Invalid TSQLPropInfoList index');
  result := fList[aIndex];
end;

procedure TSQLPropInfoList.QuickSortByName(L,R: PtrInt);
var I,J,P,Tmp: PtrInt;
    pivot: PUTF8Char;
begin
  if L<R then
  repeat
    I := L; J := R;
    P := (L+R) shr 1;
    repeat
      pivot := pointer(fList[fOrderedByName[P]].fName);
      while StrIComp(pointer(fList[fOrderedByName[I]].fName),pivot)<0 do inc(I);
      while StrIComp(pointer(fList[fOrderedByName[J]].fName),pivot)>0 do dec(J);
      if I <= J then begin
        Tmp := fOrderedByName[J];
        fOrderedByName[J] := fOrderedByName[I];
        fOrderedByName[I] := Tmp;
        if P=I then P := J else if P=J then P := I;
        inc(I); dec(J);
      end;
    until I>J;
    if L<J then
      QuickSortByName(L,J);
    L := I;
  until I >= R;
end;

function TSQLPropInfoList.ByRawUTF8Name(const aName: RawUTF8): TSQLPropInfo;
var i: integer;
begin
  i := IndexByName(pointer(aName));
  if i<0 then
    result := nil else
    result := fList[i];
end;

function TSQLPropInfoList.ByName(aName: PUTF8Char): TSQLPropInfo;
var i: integer;
begin
  i := IndexByName(aName);
  if i<0 then
    result := nil else
    result := fList[i];
end;

function TSQLPropInfoList.IndexByName(aName: PUTF8Char): integer;
var i,cmp,L,R: integer;
begin
  if (self<>nil) and (aName<>nil) and (fCount>0) then
  if fCount<5 then begin
    for result := 0 to fCount-1 do
      if StrIComp(pointer(fList[result].fName),aName)=0 then
        exit;
  end else begin
    if fOrderedByName=nil then begin
      SetLength(fOrderedByName,fCount);
      for i := 0 to fCount-1 do
        fOrderedByName[i] := i;
      QuickSortByName(0,fCount-1);
    end;
    L := 0;
    R := fCount-1;
    repeat
      result := (L+R)shr 1;
      cmp := StrIComp(pointer(fList[fOrderedByName[result]].fName),aName);
      if cmp=0 then begin
        result := fOrderedByName[result];
        exit;
      end;
      if cmp<0 then
        L := result+1 else
        R := result-1;
    until L>R;
  end;
  result := -1;
end;

function TSQLPropInfoList.IndexByName(const aName: RawUTF8): integer;
begin
  result := IndexByName(pointer(aName));
end;

function TSQLPropInfoList.IndexByNameOrExcept(const aName: RawUTF8): integer;
begin
  if IsRowID(pointer(aName)) then
    result := -1 else begin
    result := IndexByName(pointer(aName));
    if result<0 then
      raise EORMException.CreateFmt('Unkwnown field name "%s"',[aName]);
  end;
end;

procedure TSQLPropInfoList.NamesToRawUTF8DynArray(var Names: TRawUTF8DynArray);
var i: integer;
begin
  SetLength(Names,Count);
  for i := 0 to Count-1 do
    Names[i] := fList[i].Name;
end;


{ TSQLTable }

function TSQLTable.FieldIndex(FieldName: PUTF8Char): integer;
begin
  if (self<>nil) and (fResults<>nil) and (FieldName<>nil) and (FieldCount>0) then
    if IsRowID(FieldName) then begin // will work for both 'ID' or 'RowID'
      result := fFieldIndexID;
      exit;
    end else
    if FieldCount<4 then begin
      for result := 0 to FieldCount-1 do
        if StrIComp(fResults[result],FieldName)=0 then
          exit;
    end else begin
      if fFieldNameOrder=nil then
        QuickSortIndexedPUTF8Char(fResults,FieldCount,fFieldNameOrder);
      result := FastFindIndexedPUTF8Char(fResults,FieldCount-1,fFieldNameOrder,
        FieldName,@StrIComp);
      exit;
    end;
  result := -1;
end;

function TSQLTable.FieldIndex(const FieldName: RawUTF8): integer;
begin
  result := FieldIndex(Pointer(FieldName));
end;

function TSQLTable.FieldValue(const FieldName: RawUTF8; Row: integer): PUTF8Char;
var Index: integer;
begin
  Index := FieldIndex(pointer(FieldName));
  if (Index<0) or (cardinal(Row-1)>=cardinal(RowCount)) then
    result := nil else                     
    result := fResults[Index+Row*FieldCount];
end;

procedure TSQLTable.SortBitsFirst(var Bits);
var oldIDColumn, oldResults: array of PUTF8Char;
    i, j, nSet, n: integer;
    R: PPUTF8Char;
begin
  if fIDColumn<>nil then begin
    n := length(fIDColumn);
    SetLength(oldIDColumn,n);
    move(fIDColumn[0],oldIDColumn[0],n*4);
  end;
  i := (RowCount+1)*FieldCount;
  SetLength(oldResults,i);
  move(fResults[0],oldResults[0],i*4);
  // put marked IDs first
  n := 1; // copy row data (first row=0 i.e. idents is left as it is)
  R := @fResults[FieldCount];
  j := FieldCount;
  for i := 1 to RowCount do begin
    if GetBit(Bits,i-1) then begin
      if fIDColumn<>nil then
        fIDColumn[n] := oldIDColumn[i];
      move(oldResults[j],R^,FieldCount*4);
      inc(n);
      inc(R,FieldCount);
    end;
    inc(j,FieldCount);
  end;
  nSet := n-1;
  // put unmarked IDs
  j := FieldCount;
  for i := 1 to RowCount do begin
    if not GetBit(Bits,i-1) then begin
      if fIDColumn<>nil then
        fIDColumn[n] := oldIDColumn[i];
      move(oldResults[j],R^,FieldCount*4);
      inc(n);
      inc(R,FieldCount);
    end;
    inc(j,FieldCount);
  end;
  assert(n-1=RowCount);
  // recalcultate Bits[]
  fillchar(Bits,(RowCount shr 3)+1,0);
  for i := 0 to nSet-1 do
    SetBit(Bits,i); // slow but accurate
end;

function TSQLTable.IDColumnHide: boolean;
var FID,R,F: integer;
    S,D1,D2: PPUTF8Char;
begin
  // 1. check if possible
  result := false;
  if (self=nil) or Assigned(fIDColumn) or (FieldCount<=1) then
    exit; // already hidden or not possible
  FID := fFieldIndexID;
  if FID<0 then
    exit; // no 'ID' field
  // 2. alloc new arrays of PUTF8Char
  dec(fFieldCount);
  R := RowCount+1;
  SetLength(fIDColumn,R);               // will contain the ID column data
  SetLength(fNotIDColumn,R*FieldCount); // will be the new fResults[]
  // 3. copy fResults[] into new arrays
  S := @fResults[0];
  D1 := @fNotIDColumn[0];
  D2 := @fIDColumn[0];
  for R := 0 to RowCount do
    for F := 0 to FieldCount do begin // we have FieldCount := FieldCount-1
      if F<>FID then begin
        D1^ := S^; // copy not ID column into fNotIDColumn[]
        inc(D1);
      end else begin
        D2^ := S^; // copy ID column into fIDColumn[]
        inc(D2);
      end;
      inc(S);
    end;
  // 4. TSQLTable data now points to new values without ID field
  result := true;
  fResults := @fNotIDColumn[0];
end;

function TSQLTable.IDColumnHiddenValue(Row: integer): integer;
begin
  if (self=nil) or (fResults=nil) or (Row<=0) or (Row>RowCount) then
    result := 0 else
    if Assigned(fIDColumn) then // get hidden ID column UTF-8 content
      result := GetInteger(fIDColumn[Row]) else begin
      result := fFieldIndexID;  // get ID column field index
      if result>=0 then
        result := GetInteger(fResults[Row*FieldCount+result]) else
        result := 0;
    end;
end;

procedure TSQLTable.IDArrayFromBits(const Bits; var IDs: TIntegerDynArray);
var n, i, FID: integer;
begin
  if not Assigned(fIDColumn) then begin
    FID := fFieldIndexID; // get ID column field index
    if FID<0 then
      exit;
  end else
    FID := 0; // make compiler happy
  n := GetBitsCount(Bits,RowCount);
  if n=RowCount then begin
    IDColumnHiddenValues(IDs); // all selected -> direct get all IDs
    exit;
  end;
  SetLength(IDs,n);
  if n=0 then
    exit;
  n := 0;
  if Assigned(fIDColumn) then begin
    for i := 1 to RowCount do
    if GetBit(Bits,i-1) then begin
      IDs[n] := GetInteger(fIDColumn[i]); // get hidden ID column UTF-8 content
      inc(n);
    end;
  end else begin
    inc(FID,FieldCount); // [i*FieldCount+FID] = [(i+1)*FieldCount+FID] below
    for i := 0 to RowCount-1 do
    if GetBit(Bits,i) then begin
      IDs[n] := GetInteger(fResults[i*FieldCount+FID]); // get ID column UTF-8 content
      inc(n);
    end;
  end;
end;

procedure TSQLTable.IDColumnHiddenValues(var IDs: TIntegerDynArray);
var n, i, FID: integer;
    U: PPUTF8Char;
begin
  n := RowCount;
  if not Assigned(fIDColumn) then begin
    FID := fFieldIndexID; // get ID column field index
    if FID<0 then
      n := 0;
  end else
    FID := 0;
  SetLength(IDs,n);
  if n=0 then
    exit;
  if Assigned(fIDColumn) then begin
    for i := 1 to RowCount do
      IDs[i-1] := GetInteger(fIDColumn[i]); // get hidden ID column UTF-8 content
  end else begin
    U := @fResults[FID+FieldCount];  // U^ = ID column UTF-8 content
    for i := 0 to RowCount-1 do begin
      IDs[i] := GetInteger(U^);
      inc(U,FieldCount);
    end;
  end;
end;

procedure TSQLTable.IDArrayToBits(var Bits; var IDs: TIntegerDynArray);
var i,FID: integer;
    U: PPUTF8Char;
    ID: Pointer;
    IDn: integer;
//    AllID: TIntegerDynArray;
begin
  if length(IDs)=RowCount then begin
    fillchar(Bits,(RowCount shr 3)+1,255); // all selected -> all bits set to 1
    exit;
  end;
  fillchar(Bits,(RowCount shr 3)+1,0);
  if IDs=nil then
    exit; // no selected -> all bits left to 0
  // we sort IDs to use FastFindIntegerSorted() and its fast binary search
  ID := @IDs[0];
  IDn := high(IDs);
  QuickSortInteger(ID,0,IDn);
  if not Assigned(fIDColumn) then begin
    FID := fFieldIndexID; // get ID column field index
    if FID<0 then
      exit; // no ID column -> unable to get bit index
  end else
    FID := 0; // make compiler happy
  if Assigned(fIDColumn) then begin
    for i := 1 to RowCount do
      if FastFindIntegerSorted(ID,IDn,GetInteger(fIDColumn[i]))>=0 then
        SetBit(Bits,i-1);
  end else begin
    U := @fResults[FID+FieldCount];  // U^ = ID column UTF-8 content
    for i := 0 to RowCount-1 do begin
      if FastFindIntegerSorted(ID,IDn,GetInteger(U^))>=0 then
        SetBit(Bits,i);
      inc(U,FieldCount);
    end;
  end;
{  // debugg:
  IDArrayFromBits(Bits,AllID);
  assert(length(AllID)=length(IDs));
  QuickSortInteger(@AllID[0],0,high(AllID));
  QuickSortInteger(@IDs[0],0,high(IDs));
  assert(comparemem(@AllID[0],@IDs[0],length(AllID)*4)); }
end;

function TSQLTable.RowFromID(aID: integer): integer;
var ID: RawUTF8;
    FID: integer;
    U: PPUTF8Char;
begin
  if self=nil then begin
    result := -1;
    exit;
  end;
  if (fResults<>nil) and (aID>0) then begin
    // search aID as UTF-8 in fIDColumn[] or fResults[]
    UInt32ToUtf8(aID,ID);
    if Assigned(fIDColumn) then begin // get hidden ID column UTF-8 content
      for result := 1 to RowCount do
        if StrComp(fIDColumn[result],pointer(ID))=0 then
          exit;
    end else begin
      FID := fFieldIndexID;  // get ID column field index
      if FID>=0 then begin
        U := @fResults[FID+FieldCount];  // U^ = ID column UTF-8 content
        for result := 1 to RowCount do
          if StrComp(U^,pointer(ID))=0 then
            exit else
            inc(U,FieldCount);
      end;
    end;
  end;
  result := RowCount; // not found -> return last row index
end;

procedure TSQLTable.DeleteRow(Row: integer);
begin
  if (Row<1) or (Row>RowCount) then
    exit; // out of range
  if Assigned(fIDColumn) then
    if Row<RowCount then
      move(fIDColumn[Row+1],fIDColumn[Row],(RowCount-Row)*4);
  if Row<RowCount then begin
    Row := Row*FieldCount; // convert row index into position in fResults[]
    move(fResults[Row+FieldCount],fResults[Row],(RowCount*FieldCount-Row)*sizeof(pointer));
  end;
  dec(fRowCount);
end;

procedure TSQLTable.InitFieldNames;
var f: integer;
    P: PUTF8Char;
begin
  SetLength(fFieldNames,fFieldCount); // share one TRawUTF8DynArray
  for f := 0 to fFieldCount-1 do begin
    P := Get(0,f);
    if IsRowID(P) then // normalize RowID field name to ID
      fFieldNames[f] := 'ID' else
      fFieldNames[f] := P;
  end;
end;

{$ifndef NOVARIANTS}

var
  SQLTableRowVariantType: TCustomVariantType = nil;

procedure TSQLTable.ToDocVariant(Row: integer; out doc: variant);
var Values: TVariantDynArray;
    V: PPUtf8CharArray;
    f: integer;
begin
  if (self=nil) or (Row<1) or (Row>RowCount) then
    exit; // out of range
  if length(fFieldNames)<>fFieldCount then
    InitFieldNames;
  if not Assigned(fFieldType) then
    InitFieldTypes;
  SetLength(Values,fFieldCount);
  V := @fResults[Row*FieldCount];
  for f := 0 to fFieldCount-1 do
    ValueVarToVariant(V[f],fFieldType[f].ContentType,TVarData(Values[f]),true);
  TDocVariantData(doc).InitObjectFromVariants(fFieldNames,Values,JSON_OPTIONS[true]);
end;

procedure TSQLTable.ToDocVariant(out docs: TVariantDynArray; readonly: boolean);
var r: integer;
begin
  if (self=nil) or (RowCount=0) then
    exit;
  SetLength(docs,RowCount);
  if readonly then begin
    if SQLTableRowVariantType=nil then
      SQLTableRowVariantType := SynRegisterCustomVariantType(TSQLTableRowVariant);
    for r := 0 to RowCount-1 do
    with TSQLTableRowVariantData(docs[r]) do begin
      VType := SQLTableRowVariantType.VarType;
      VTable := self;
      VRow := r+1;
    end;
  end else
    for r := 0 to RowCount-1 do
      ToDocVariant(r+1,docs[r]);
end;

procedure TSQLTable.ToDocVariant(out docarray: variant; readonly: boolean);
var Values: TVariantDynArray;
begin
  ToDocVariant(Values,readonly);
  TDocVariantData(docarray).InitArrayFromVariants(Values,JSON_OPTIONS[true]);
end;

{$endif NOVARIANTS}

procedure TSQLTable.DeleteColumnValues(Field: integer);
var i: integer;
    U: PPUTF8Char;
begin
  if cardinal(Field)>=cardinal(FieldCount) then
    exit; // out of range
  U := @fResults[Field+FieldCount];  // U^ = column UTF-8 content for this field
  for i := 1 to RowCount do begin
    U^[0] := #0; // just void UTF-8 content text
    inc(U,FieldCount);
  end;
end;

function FieldPropFromTable(const aTable: TSQLRecordClass; const PropName: RawUTF8;
  EnumTypeInfo: PPointer): TSQLFieldType;
var f: TSQLPropInfo;
begin
  if IsRowID(pointer(PropName)) then
    result := sftInteger else
    with aTable.RecordProps do begin
      f := Fields.ByRawUTF8Name(PropName);
      if f=nil then
        result := sftUnknown else begin
        result := f.SQLFieldType;
        if EnumTypeInfo<>nil then begin
          EnumTypeInfo^ := nil;
          if f.InheritsFrom(TSQLPropInfoRTTI) then
          with TSQLPropInfoRTTI(f).PropInfo^.PropType^^ do
          case result of
            sftEnumerate:
              EnumTypeInfo^ := EnumBaseType;
            sftSet:
              EnumTypeInfo^ := SetEnumType;
          end;
        end;
      end;
    end;
end;

function FieldPropFromTables(const Tables: TSQLRecordClassDynArray;
  const PropName: RawUTF8; EnumTypeInfo: PPointer; out TableIndex: integer): TSQLFieldType;
var SubProp: RawUTF8;
    i,t: integer;
begin
  TableIndex := -1;
  if length(Tables)=1 then begin
    result := FieldPropFromTable(Tables[0],PropName,EnumTypeInfo);
    if result<>sftUnknown then
      TableIndex := 0;
  end else begin
    i := PosEx('.',PropName); 
    if i=0 then begin
      // no 'ClassName.PropertyName' format: find first exact property name
      for t := 0 to high(Tables) do begin
        result := FieldPropFromTable(Tables[t],PropName,EnumTypeInfo);
        if result<>sftUnknown then begin
          TableIndex := t;
          exit;
        end;
      end;
    end else begin
      // we expect property names as 'ClassName.PropertyName'
      dec(i);
      SubProp := copy(PropName,i+2,255); 
      for t := 0 to high(Tables) do
        if Tables[t]<>nil then // avoid GPF
        if IdemPropName( // found class?
          // new TObject.ClassName is UnicodeString (Delphi 20009) -> inline code with
          // vmtClassName = UTF-8 encoded text stored in a shortstring = -44
          PShortString(PPointer(PtrInt(Tables[t])+vmtClassName)^)^,
          pointer(PropName),i) then begin
        //if Tables[t].ClassNameIs(SubClass) then begin // not Delphi 2009 OK
          TableIndex := t;
          result := FieldPropFromTable(Tables[t],SubProp,EnumTypeInfo); // get property type
          exit;
        end;
    end;
    result := sftUnknown;
  end;
end;

procedure TSQLTable.SetFieldType(Field: integer; FieldType: TSQLFieldType;
   aEnumTypeinfo: pointer=nil; FieldSize: integer=-1);
begin
  if (self=nil) or (cardinal(Field)>=cardinal(FieldCount)) then
    exit;
  if fFieldType=nil then
    InitFieldTypes;
  with fFieldType[Field] do begin
    TableIndex := -1;
    ContentType := FieldType;
    ContentSize := FieldSize;
    EnumTypeInfo := aEnumTypeInfo;
  end;
end;

procedure TSQLTable.SetFieldType(const FieldName: RawUTF8; FieldType: TSQLFieldType;
   aEnumTypeinfo: pointer=nil; FieldSize: integer=-1);
begin
  SetFieldType(FieldIndex(FieldName),FieldType,aEnumTypeinfo,FieldSize);
end;

procedure TSQLTable.InitFieldTypes;
var f,i: integer;
    T: TSQLFieldType;
    P: pointer;
    TableInd: integer;
begin
  if Assigned(fQueryColumnTypes) and (FieldCount<>length(fQueryColumnTypes)) then
    raise ESQLTableException.CreateFmt('%s.CreateWithColumnTypes() called with %d '+
      'column types, whereas the result has %d columns',[ClassName,length(fQueryColumnTypes),FieldCount]);
  SetLength(fFieldType,FieldCount);
  for f := 0 to FieldCount-1 do begin
    P := nil;
    TableInd := -1;
    // init fFieldType[] from fQueryTables/fQueryColumnTypes[]
    if Assigned(fQueryColumnTypes) then
      T := fQueryColumnTypes[f] else
    if Assigned(QueryTables) then // retrieve column info from field name
      T := FieldPropFromTables(QueryTables,fResults[f],@P,TableInd) else
      T := sftUnknown;
    if T=sftUnknown then
      // not found from fQueryTables/fQueryColumnTypes[]: get from content
      if IsRowID(fResults[f]) then
        T := sftInteger else
      for i := 1 to RowCount do begin
        T := UTF8ContentType(fResults[i*FieldCount+f]);
        if T<>sftUnknown then begin
          if (T in [sftInteger,sftFloat]) and (f in fFieldParsedAsString) then
            T := sftUTF8Text else // force string value not to be a number
          if T=sftInteger then
            T := sftCurrency; // we only checked the first field... best guess...
          break; // get first non null field content
        end;
      end;
    with fFieldType[f] do begin
      TableIndex := TableInd;
      ContentType := T;
      ContentSize := -1;
      EnumTypeInfo := P;
    end;
  end;
end;

function TSQLTable.FieldType(Field: integer): TSQLFieldType;
begin
  if (self<>nil) and (cardinal(Field)<cardinal(FieldCount)) then begin
    if not Assigned(fFieldType) then
      InitFieldTypes;
    result := fFieldType[Field].ContentType;
  end else
    result := sftUnknown;
end;

function TSQLTable.FieldType(Field: integer; EnumTypeInfo: PPointer): TSQLFieldType;
begin
  if (self<>nil) and (cardinal(Field)<cardinal(FieldCount)) then begin
    if not Assigned(fFieldType) then
      InitFieldTypes;
    result := fFieldType[Field].ContentType;
    if EnumTypeInfo<>nil then
      EnumTypeInfo^ := fFieldType[Field].EnumTypeInfo;
  end else
    result := sftUnknown;
end;

function TSQLTable.Get(Row, Field: integer): PUTF8Char;
const PCharNil: integer = 0;
begin
  if (self=nil) or (fResults=nil) or (cardinal(Row)>cardinal(RowCount)) or
     (cardinal(Field)>=cardinal(FieldCount)) then // cardinal() -> test <0
    result := @PCharNil else
    result := fResults[Row*FieldCount+Field];
end;

function TSQLTable.GetU(Row,Field: integer): RawUTF8;
var P: PUTF8Char;
begin
  if (self=nil) or (fResults=nil) or (cardinal(Row)>cardinal(RowCount)) or
     (cardinal(Field)>=cardinal(FieldCount)) then // cardinal() -> test <0
    result := '' else begin
    P := fResults[Row*FieldCount+Field];
    SetRawUTF8(Result,P,StrLen(P));
  end;
end;

function TSQLTable.GetA(Row, Field: integer): WinAnsiString;
begin
  result := Utf8ToWinAnsi(Get(Row,Field));
end;

function TSQLTable.GetAsInteger(Row, Field: integer): integer;
begin
  result := GetInteger(Get(Row,Field));
end;

function TSQLTable.GetAsInt64(Row, Field: integer): Int64;
begin
  SetInt64(Get(Row,Field),result);
end;

function TSQLTable.GetAsFloat(Row,Field: integer): extended;
begin
  result := GetExtended(Get(Row,Field));
end;

function TSQLTable.GetAsCurrency(Row,Field: integer): currency;
begin
  result := StrToCurrency(Get(Row,Field));
end;

function TSQLTable.GetAsDateTime(Row,Field: integer): TDateTime;
var P: PUTF8Char;
begin
  result := 0;
  if Row=0 then
    exit; // header
  P := Get(Row,Field);
  if P=nil then
    exit;
  case FieldType(Field) of
  sftCurrency,sftFloat:
    result := GetExtended(P);
  sftInteger, // TSQLTable.InitFieldTypes may have recognized a sftInteger 
  sftTimeLog, sftModTime, sftCreateTime:
    result := TimeLogToDateTime(GetInt64(P));
  else // sftDateTime and any other kind will try from ISO-8601 text
    result := Iso8601ToDateTimePUTF8Char(P);  
  end;
end;

function TSQLTable.GetS(Row, Field: integer): shortstring;
begin
  UTF8ToShortString(result,Get(Row,Field));
end;

function TSQLTable.GetString(Row, Field: integer): string;
var U: PUTF8Char;
begin
  U := Get(Row,Field);
  if U=nil then
    result := '' else
    {$ifdef UNICODE}
    UTF8DecodeToUnicodeString(U,StrLen(U),result);
    {$else}
    CurrentAnsiConvert.UTF8BufferToAnsi(U,StrLen(U),result);
    {$endif}
end;

function TSQLTable.GetSynUnicode(Row,Field: integer): SynUnicode;
var U: PUTF8Char;
begin
  result := '';
  U := Get(Row,Field);
  if U<>nil then
    UTF8ToSynUnicode(U,StrLen(U),result);
end;

function TSQLTable.GetCaption(Row, Field: integer): string;
begin
  GetCaptionFromPCharLen(Get(Row,Field),result);
end;

function BlobToTSQLRawBlob(P: PUTF8Char): TSQLRawBlob;
var Len, LenHex: integer;
begin
  result := '';
  if P=nil then
    exit;
  Len := StrLen(P);
  if Len=0 then
    exit;
  if (P[0] in ['x','X']) and (P[1]='''') and (P[Len-1]='''') then begin
    // BLOB literals are string literals containing hexadecimal data and
    // preceded by a single "x" or "X" character. For example: X'53514C697465'
    LenHex := (Len-3) shr 1;
    SetLength(result,LenHex);
    if HexToBin(@P[2],pointer(result),LenHex) then
      exit; // valid hexa data
  end else
  if (PInteger(P)^ and $00ffffff=JSON_BASE64_MAGIC) and IsBase64(@P[3],Len-3) then begin
    // Base-64 encoded content ('\uFFF0base64encodedbinary')
    result := Base64ToBin(@P[3],Len-3);
    exit;
  end;
  // TEXT format
  SetString(result,PAnsiChar(P),Len);
end;

function BlobToTSQLRawBlob(const Blob: RawByteString): TSQLRawBlob;
var Len, LenHex: integer;
    P: PUTF8Char; 
begin
  result := '';
  if Blob='' then
    exit;
  Len := length(Blob);
  P := pointer(Blob);
  if (P[0] in ['x','X']) and (P[1]='''') and (P[Len-1]='''') then begin
    // BLOB literals are string literals containing hexadecimal data and
    // preceded by a single "x" or "X" character. For example: X'53514C697465'
    LenHex := (Len-3) shr 1;
    SetLength(result,LenHex);
    if HexToBin(@P[2],pointer(result),LenHex) then
      exit; // valid hexa data
  end else
  if (PInteger(P)^ and $00ffffff=JSON_BASE64_MAGIC) and IsBase64(@P[3],Len-3) then begin
    // Base-64 encoded content ('\uFFF0base64encodedbinary')
    result := Base64ToBin(@P[3],Len-3);
    exit;
  end;
  // TEXT format
  result := Blob;
end;

function BlobToStream(P: PUTF8Char): TStream;
begin
  Result := TRawByteStringStream.Create(BlobToTSQLRawBlob(P));
end;

function BlobToBytes(P: PUTF8Char): TBytes;
var Len, LenResult: integer;
begin
  result := nil;
  Len := StrLen(P);
  if Len=0 then
    exit;
  if (P[0] in ['x','X']) and (P[1]='''') and (P[Len-1]='''') then begin
    // BLOB literals format
    LenResult := (Len-3)shr 1;
    SetLength(Result,LenResult);
    if HexToBin(@P[2],pointer(Result),LenResult) then
      exit; // valid hexa data
  end else
  if (PInteger(P)^ and $00ffffff=JSON_BASE64_MAGIC) and IsBase64(@P[3],Len-3) then begin
    // Base-64 encoded content ('\uFFF0base64encodedbinary')
    inc(P,3);
    dec(Len,3);
    LenResult := Base64ToBinLength(pointer(P),len);
    SetLength(Result,LenResult);
    if LenResult>0 then
      Base64Decode(pointer(P),pointer(Result),Len shr 2);
    exit;
  end;
  // TEXT format
  SetLength(Result,Len);
  Move(P^,pointer(Result)^,Len);
end;

function TSQLRawBlobToBlob(const RawBlob: TSQLRawBlob): RawUTF8;
// BLOB literals are string literals containing hexadecimal data and
//  preceded by a single "x" or "X" character. For example: X'53514C697465'
begin
  result := TSQLRawBlobToBlob(pointer(RawBlob),length(RawBlob));
end;

function TSQLRawBlobToBlob(RawBlob: pointer; RawBlobLength: integer): RawUTF8; overload;
// BLOB literals are string literals containing hexadecimal data and
//  preceded by a single "x" or "X" character. For example: X'53514C697465'
var P: PAnsiChar;
begin
  result := '';
  if RawBlobLength<>0 then begin
    SetLength(result,RawBlobLength*2+3);
{$ifdef UNICODE2} // not needed: SetLength() did already set the codepage
    PWord(PtrUInt(result)-12)^ := CP_UTF8; // use only SetLength() -> force set code page
{$endif}
    P := pointer(result);
    P[0] := 'X';
    P[1] := '''';
    BinToHex(RawBlob,P+2,RawBlobLength);
    P[RawBlobLength*2+2] := '''';
  end;
end;

function isBlobHex(P: PUTF8Char): boolean;
// BLOB literals are string literals containing hexadecimal data and
// preceded by a single "x" or "X" character. For example: X'53514C697465'
var Len: integer;
begin
  if P=nil then begin
    result := false;
    exit;
  end;
  while P^ in [#1..' '] do inc(P);
  if (P[0] in ['x','X']) and (P[1]='''') then begin
    Len := (StrLen(P)-3) shr 1;
    result := (P[Len-1]='''') and HexToBin(@P[2],nil,Len);
    exit;
  end else begin
    result := false;
    exit;
  end;
end;

function TSQLTable.GetBlob(Row, Field: integer): TSQLRawBlob;
begin
  result := BlobToTSQLRawBlob(Get(Row,Field));
end;

function TSQLTable.GetBytes(Row,Field: integer): TBytes;
begin
  result := BlobToBytes(Get(Row,Field));
end;

function TSQLTable.GetStream(Row,Field: integer): TStream;
begin
  result := BlobToStream(Get(Row,Field));
end;

{$ifdef PUREPASCAL} 
function TSQLTable.GetDateTime(Row, Field: integer): TDateTime;
begin
  result := Iso8601ToDateTimePUTF8Char(Get(Row,Field),0)
end;
{$else}
function TSQLTable.GetDateTime(Row, Field: integer): TDateTime;
asm
  call TSQLTable.Get
  xor edx,edx // L=0 -> will call strlen()
  jmp Iso8601ToDateTimePUTF8Char
end;
{$endif}

procedure TSQLTable.GetRowValues(Field: integer; out Values: TRawUTF8DynArray);
var i: integer;
    U: PPUTF8Char;
begin
  Finalize(Values);
  if (self=nil) or (cardinal(Field)>cardinal(FieldCount)) then
    exit;
  SetLength(Values,RowCount);
  U := @fResults[FieldCount+Field]; // start reading after first Row (= Field Names)
  for i := 0 to RowCount-1 do begin
    SetString(Values[i],PAnsiChar(U^),StrLen(U^));
    inc(U,FieldCount); // go to next row
  end;
end;

procedure TSQLTable.GetRowValues(Field: integer; out Values: TIntegerDynArray);
var i: integer;
    U: PPUTF8Char;
begin
  Finalize(Values);
  if (self=nil) or (cardinal(Field)>cardinal(FieldCount)) then
    exit;
  SetLength(Values,RowCount);
  U := @fResults[FieldCount+Field]; // start reading after first Row (= Field Names)
  for i := 0 to RowCount-1 do begin
    Values[i] := GetInteger(U^);
    inc(U,FieldCount); // go to next row
  end;
end;

function TSQLTable.GetRowValues(Field: integer; Sep: AnsiChar): RawUTF8;
var i, L: integer;
    U: PPUTF8Char;
    P: PUTF8Char;
begin
  result := '';
  if (self=nil) or (cardinal(Field)>cardinal(FieldCount)) or (RowCount=0) then
    exit;
  L := 0;
  U := @fResults[FieldCount+Field]; // start reading after first Row (= Field Names)
  for i := 1 to RowCount do begin
    inc(L,StrLen(U^)+1);
    inc(U,FieldCount); // go to next row
  end;
  if L=0 then
    exit;
  SetLength(result,L-1); // L-1 = don't add a last ','
  P := pointer(result);
  U := @fResults[FieldCount+Field]; // start reading after first Row (= Field Names)
  for i := 1 to RowCount do begin
    L := StrLen(U^);
    move(U^^,P^,L);
    if i=RowCount then // don't add a last ','
      break;
    P[L] := Sep;
    inc(P,L+1);
    inc(U,FieldCount); // go to next row
  end;
end;

procedure TSQLTable.GetJSONValues(JSON: TStream; Expand: boolean;
  RowFirst: integer=0; RowLast: integer=0);
var W: TJSONWriter;
    F,R: integer;
    U: PPUTF8Char;
begin
  W := TJSONWriter.Create(JSON,Expand,false);
  try
    if (self=nil) or (FieldCount<=0) or (RowCount<=0) then begin
      W.CancelAllVoid;
      exit;
    end;
    // check range
    if RowLast=0 then
      RowLast := RowCount else
    if RowLast>RowCount then
      RowLast := RowCount;
    if RowFirst<=0 then 
      RowFirst := 1; // start reading after first Row (Row 0 = Field Names)
    // get col names and types
    SetLength(W.ColNames,FieldCount);
    for F := 0 to FieldCount-1 do
      W.ColNames[F] := fResults[F]; // first Row is field Names
    W.AddColumns(RowLast-RowFirst+1); // write or init field names (see JSON Expand)
    if Expand then
      W.Add('[');
    // write rows data
    U := @fResults[FieldCount*RowFirst];
    for R := RowFirst to RowLast do begin
      if Expand then
        W.Add('{');
      for F := 0 to FieldCount-1 do begin
        if Expand then
          W.AddString(W.ColNames[F]); // '"'+ColNames[]+'":'
        if U^=nil then
          W.AddShort('null') else
        if IsStringJSON(U^) then begin
          // IsStringJSON() is fast and safe: no need to guess exact value type
          W.Add('"');
          W.AddJSONEscape(U^,0);
          W.Add('"');
        end else
          W.AddNoJSONEscape(U^,0);
        W.Add(',');
        inc(U); // points to next value
      end;
      W.CancelLastComma; // cancel last ','
      if Expand then begin
        W.Add('}',',');
        if R<>RowLast then
          W.AddCR; // make expanded json more human readable
      end else
        W.Add(',');
    end;
    W.EndJSONObject(1,0); // "RowCount": set by W.AddColumns(RowLast-RowFirst+1)
  finally
    W.Free;
  end;
end;

procedure TSQLTable.GetCSVValues(Dest: TStream; Tab: boolean; CommaSep: AnsiChar=',';
  AddBOM: boolean=false);
var U: PPUTF8Char;
    F,R,FMax: integer;
    W: TTextWriter;
begin
  if (self=nil) or (FieldCount<=0) or (RowCount<=0) then
    exit;
  W := TTextWriter.Create(Dest,8196);
  try
    if AddBOM then
      W.AddShort(#$ef#$bb#$bf); // add UTF-8 Byte Order Mark
    if Tab then
      CommaSep := #9;
    FMax := FieldCount-1;
    U := pointer(fResults);
    for R := 0 to RowCount do
      for F := 0 to FMax do begin
        if Tab or (not IsStringJSON(U^)) then
          W.AddNoJSONEscape(U^) else begin
          W.Add('"');
          W.AddNoJSONEscape(U^);
          W.Add('"');
        end;
        if F=FMax then
          W.AddCR else
          W.Add(CommaSep);
        inc(U); // points to next value
      end;
    W.Flush;
  finally
    W.Free;
  end;
end;

function TSQLTable.GetJSONValues(Expand: boolean): RawUTF8;
var MS: TRawByteStringStream;
begin
  MS := TRawByteStringStream.Create;
  try
    GetJSONValues(MS,Expand); // create JSON data in MS
    result := MS.DataString;
  finally
    MS.Free;
  end;
end;

function TSQLTable.GetW(Row, Field: integer): RawUnicode;
begin
  result := UTF8DecodeToRawUnicode(Get(Row,Field),0);
end;

function TSQLTable.GetWP(Row, Field: integer; Dest: PWideChar; MaxDestChars: cardinal): integer;
var P: PUTF8Char;
begin
  P := Get(Row,Field);
  result := UTF8ToWideChar(Dest,P,MaxDestChars,0) shr 1; // bytes div 2
end;

function TSQLTable.LengthW(Row, Field: integer): integer;
begin // nil -> fast calculate unicode length, without any memory allocation
  result := Utf8ToUnicodeLength(Get(Row,Field));
end;

function UTF8CompareCurr64(P1,P2: PUTF8Char): PtrInt;
var V1,V2: Int64;
begin // faster than UTF8CompareDouble() for pure decimal (no exponent) values
  V1 := StrToCurr64(P1);
  V2 := StrToCurr64(P2);
  if V1<V2 then
    result := -1 else
    if V1=V2 then
      result := 0 else
      result := +1;
end;

function UTF8CompareBoolean(P1,P2: PUTF8Char): PtrInt;
label Z,P,N;
begin // assume 0 is FALSE, anything else is true
  if P1=P2  then goto Z else
  if P1=nil then goto P else
  if P2=nil then goto N else
  if (P1^=#0) or (PWord(P1)^=ord('0')) then
    if (P2^=#0) or (PWord(P2)^=ord('0')) then begin
Z:    result := 0;  // P1=false P2=false
      exit;
    end else begin
N:    result := -1; // P1=false P2=true
      exit;
    end else
    if (P2^<>#0) and (PWord(P2)^<>ord('0')) then
      goto Z        // P1=true P2=true
    else begin
P:    result := 1;  // P1=true P2=false
      exit;
    end;
end;

function UTF8CompareInt32(P1,P2: PUTF8Char): PtrInt;
var V1,V2: PtrInt;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  V1 := GetInteger(P1);
  V2 := GetInteger(P2);
  if V1<V2 then
    result := -1 else
    if V1=V2 then
      result := 0 else
      result := +1;
end;

function UTF8CompareUInt32(P1,P2: PUTF8Char): PtrInt;
var V1,V2: PtrUInt;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  V1 := GetCardinal(P1);
  V2 := GetCardinal(P2);
  if V1<V2 then
    result := -1 else
    if V1=V2 then
      result := 0 else
      result := +1;
end;

function UTF8CompareRecord(P1,P2: PUTF8Char): PtrInt;
var V1,V2,T1,T2: PtrUInt;
label er;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  V1 := GetCardinal(P1);
  V2 := GetCardinal(P2);
  if V1=V2 then
    result := 0 else begin
    // special RecordRef / TRecordReference INTEGER sort
    T1 := V1 and 63;  // first sort by Table order
    T2 := V2 and 63;
    if T1<T2 then
      result := -1 else
      if T1>T2 then
        result := +1 else
        // we have T1=T2 -> same Table -> sort by ID
        if V1<V2 then
          result := -1 else
          if V1=V2 then
            result := 0 else
            result := +1;
  end;
end;

function UTF8CompareInt64(P1,P2: PUTF8Char): PtrInt;
var V1,V2: Int64;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  SetInt64(P1,V1);
  SetInt64(P2,V2);
  if V1<V2 then
    result := -1 else
    if V1=V2 then
      result := 0 else
      result := +1;
end;

function UTF8CompareDouble(P1,P2: PUTF8Char): PtrInt;
var V1,V2: extended;
    Err: integer;
label er;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  v1 := GetExtended(P1,Err);
  if Err<>0 then begin
er: result := UTF8IComp(P1,P2);
    exit;
  end;
  V2 := GetExtended(P2,Err);
  if Err<>0 then goto er;
  if V1<V2 then // we don't care about exact = for a sort: Epsilon check is slow
    result := -1 else
    result := +1;
end;

function UTF8CompareISO8601(P1,P2: PUTF8Char): PtrInt;
var V1,V2: Int64; // faster than Iso8601ToDateTimePUTF8Char: uses integer math
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  V1 := Iso8601ToTimeLogPUTF8Char(P1,0);
  V2 := Iso8601ToTimeLogPUTF8Char(P2,0);
  if (V1=0) or (V2=0) then // any invalid date -> compare as strings
    result := UTF8IComp(P1,P2) else
    if V1<V2 then
      result := -1 else
      if V1=V2 then
        result := 0 else
        result := +1;
end;

var
  /// simple wrapper to UTF-8 compare function for the SQLite3 field datatypes
  // - used internaly for field sorting (see TSQLTable.SortFields() method)
  // and for default User Interface Query (see TSQLRest.QueryIsTrue() method)
  SQLFieldTypeComp: array[TSQLFieldType] of TUTF8Compare  =
   (nil,                  // unknown
    nil,    // AnsiText will be set to AnsiIComp in initialization block below
{$ifdef USENORMTOUPPER}
    UTF8IComp,           // UTF8Text, 8 bits case insensitive compared
{$else}
    nil,    // UTF8Text will be set to AnsiIComp in initialization block below
{$endif}
    UTF8CompareUInt32,   // Enumerate
    UTF8CompareUInt32,   // Set
    UTF8CompareInt64,    // Integer
    UTF8CompareUInt32,   // ID
    UTF8CompareRecord,   // Record
    UTF8CompareBoolean,  // Boolean
    UTF8CompareDouble,   // Float
    UTF8CompareISO8601,  // DateTime
    UTF8CompareInt64,    // TimeLog
    UTF8CompareCurr64,   // Currency
    nil,                 // Object (TEXT serialization)
{$ifndef NOVARIANTS}
    nil,                 // Variant (TEXT serialization)
{$endif}
    nil,                 // Blob
    nil,                 // BlobDynArray
    nil,                 // BlobCustom
    nil,                 // UTF8Custom
    nil,
    UTF8CompareInt64,    // ModTime
    UTF8CompareInt64);   // CreateTime

type
  /// a static object is used for smaller recursive stack size and faster code
  // - these special sort implementation do the comparaison first by the
  // designed field, and, if the field value is identical, the ID value is
  // used (it will therefore sort by time all identical values)
  // - code generated is very optimized: stack and memory usage, CPU registers
  // prefered, multiplication avoided to calculate memory position from index,
  // hand tuned assembler...
  TUTF8QuickSort = {$ifndef UNICODE}object{$else}record{$endif}
  public
    // sort parameters
    fComp: TUTF8Compare;
    Results: PPUtf8CharArray;
    IDColumn: PPUtf8CharArray;
    Params: TSQLTableSortParams;
    CurrentRow: integer;
    // used to avoid multiplications to calculate data memory position from index
    // - CPU64 ready
    FieldCountNextPtr, FieldIndexNextPtr: PtrInt;
    // temp vars (avoid stack usage):
    PID: Integer;
    PP, CI, CJ: PPUTF8Char;
    I, J: PtrInt;
{$ifdef PUREPASCAL}
    Tmp: PUTF8Char;
{$endif}
    /// recursively perform the sort
    procedure QuickSort(L, R: Integer);
    /// compare value at index I with pivot value
    // - sort by ID if values are identical
    function CompI: integer;
    /// compare value at index J with pivot value
    // - sort by ID if values are identical
    function CompJ: integer;
    /// set the pivot value
    procedure SetPP(aPP: PPUTF8Char; aP: PtrInt);
  end;

procedure TUTF8QuickSort.SetPP(aPP: PPUTF8Char; aP: PtrInt);
begin
  PP := aPP;
  // PID must be updated every time PP is modified
  if Assigned(IDColumn) then
    PID := GetInteger(IDColumn[aP]) else
    PID := GetInteger(PPUTF8Char(PtrInt(aPP)-FieldIndexNextPtr)^);
end;

function TUTF8QuickSort.CompI: integer;
begin
  result := fComp(CI^,PP^);
  if result=0 then
    // same value -> sort by ID
    if Assigned(IDColumn) then
      result := GetInteger(IDColumn[I])-PID else
      result := GetInteger(PPUTF8Char(PtrInt(CI)-FieldIndexNextPtr)^)-PID;
end;

function TUTF8QuickSort.CompJ: integer;
begin
  result := fComp(CJ^,PP^);
  if result=0 then
    // same value -> sort by ID
    if Assigned(IDColumn) then
      result := GetInteger(IDColumn[J])-PID else
      result := GetInteger(PPUTF8Char(PtrInt(CJ)-FieldIndexNextPtr)^)-PID;
end;

procedure ExchgPtrUInt(P1,P2: PtrUInt; FieldCount: integer); 
{$ifdef PUREPASCAL}  // CPU64 will call this version e.g.
var B: PtrUInt;
    i: PtrUInt;
begin
  for i := 1 to FieldCount do begin
    B := PPtrUInt(P1)^;
    PPtrUInt(P1)^ := PPtrUInt(P2)^;
    PPtrUInt(P2)^ := B;
    inc(PPtrUInt(P1));
    inc(PPtrUInt(P2));
  end;
end;
{$else}
asm // eax=P1 edx=P2 ecx=FieldCount
    push esi
    push edi
@1: dec ecx
    mov esi,[eax]
    mov edi,[edx]
    mov [edx],esi
    mov [eax],edi
    lea eax,[eax+4]
    lea edx,[edx+4]
    jnz @1
    pop edi
    pop esi
end;
{$endif}

procedure TUTF8QuickSort.QuickSort(L, R: Integer);
  {$ifndef PUREPASCAL}
  procedure Exchg32(P: pointer; I,J: integer);
  asm // eax=P edx=I ecx=J
    push ebx
    lea edx,[eax+edx*4]
    lea ecx,[eax+ecx*4]
    mov eax,[edx]
    mov ebx,[ecx]
    mov [ecx],eax
    mov [edx],ebx
    pop ebx
  end;
  {$endif}
// code below is very fast and optimized
var P: PtrInt;
begin
  if @fComp<>nil then
  repeat
    I := L;
    CI := @Results[I*Params.FieldCount+Params.FieldIndex];
    J := R;
    CJ := @Results[J*Params.FieldCount+Params.FieldIndex];
    P := ((I+J) shr 1);
    SetPP(@Results[P*Params.FieldCount+Params.FieldIndex],P);
    repeat
      // this loop has no multiplication -> most of the time is spent in comp()
      if Params.Asc then begin // ascending order comparaison
        while compI<0 do begin
          inc(I);
          inc(PtrInt(CI),FieldCountNextPtr); // next row
        end;
        while compJ>0 do begin
          dec(J);
          dec(PtrInt(CJ),FieldCountNextPtr); // previous row
        end;
      end else begin // descending order comparaison
        while compI>0 do begin
          inc(I);
          inc(PtrInt(CI),FieldCountNextPtr); // next row
        end;
        while compJ<0 do begin
          dec(J);
          dec(PtrInt(CJ),FieldCountNextPtr); // previous row
        end;
      end;
      if I<=J then begin
        if I<>J then begin // swap elements
          if CurrentRow=J then // update current row number
            CurrentRow := I else
          if CurrentRow=I then
            CurrentRow := J;
          // full row exchange
          ExchgPtrUInt(PtrInt(CI)-FieldIndexNextPtr,PtrInt(CJ)-FieldIndexNextPtr,
            Params.FieldCount); // exchange PUTF8Char for whole I,J rows
          if Assigned(IDColumn) then begin // update hidden ID column also
          {$ifdef PUREPASCAL}
            Tmp := IDColumn[I];
            IDColumn[I] := IDColumn[J];
            IDColumn[J] := Tmp;
          {$else}
            Exchg32(IDColumn,I,J);
          {$endif}
          end;
        end;
        if PP=CI then
          SetPP(CJ,J) else
        if PP=CJ then
          SetPP(CI,I);
        inc(I);
        dec(J);
        inc(PtrInt(CI),FieldCountNextPtr);
        dec(PtrInt(CJ),FieldCountNextPtr);
      end else
        break;
    until I>J;
    P := I; // save I which will be overwritten by QuickSort() below
    if L<J then
      QuickSort(L, J);
    I := P;
    L := P;
  until I>=R;
end;

procedure TSQLTable.SortFields(Field: integer; Asc: boolean=true;
  PCurrentRow: PInteger=nil; FieldType: TSQLFieldType=sftUnknown;
  CustomCompare: TUTF8Compare=nil);
var Sort: TUTF8QuickSort; // fast static object for sorting
begin
  if FieldCount=0 then
    exit;
  if FieldType=sftUnknown then // guess the field type from first row
    FieldType := self.FieldType(Field,nil);
  if Assigned(CustomCompare) then
    Sort.fComp := CustomCompare else begin
    Sort.fComp := SQLFieldTypeComp[FieldType];
    if @Sort.fComp=nil then
      exit;
  end;
  // store sorting parameters for resort in TSQLTableJSON.FillFrom()
  fSortParams.FieldType := FieldType;
  fSortParams.FieldCount := FieldCount;
  fSortParams.FieldIndex := Field;
  fSortParams.Asc := Asc;
  // this sort routine is very fast, thanks to the dedicated static object
  Sort.Params := fSortParams;
  Sort.Results := fResults;
  Sort.IDColumn := @fIDColumn[0];
  Sort.FieldCountNextPtr := FieldCount*sizeof(PtrInt);
  Sort.FieldIndexNextPtr := Field*sizeof(PtrInt);
  if PCurrentRow=nil then
    Sort.CurrentRow := -1 else
    Sort.CurrentRow := PCurrentRow^;
  if RowCount>1 then
    Sort.QuickSort(1,RowCount); // ignore first row = field names -> (1,RowCount)
  if PCurrentRow<>nil then
    PCurrentRow^ := Sort.CurrentRow;
end;

type
  TUTF8QuickSortMulti = {$ifndef UNICODE}object{$else}record{$endif}
  public
    Results: PPUtf8CharArray;
    IDColumn: PPUtf8CharArray;
    FieldCount: integer;
    IndexMax: integer;
    Index: array of record
      ndx: integer;
      Comp: TUTF8Compare;
      Desc: boolean;
    end;
    // used for row content comparison
    function Compare(A,B: integer): integer;
    /// recursively perform the sort
    procedure QuickSort(L, R: Integer);
  end;

function TUTF8QuickSortMulti.Compare(A,B: integer): integer;
var i: integer;
begin
  result := 0;
  for i := 0 to IndexMax do
   with Index[i] do begin
     if ndx>=0 then
       result := Comp(Results[A*FieldCount+ndx],Results[B*FieldCount+ndx]) else
       // Fields[].ndx=-1 for hidden ID column
       result := GetInteger(IDColumn[A])-GetInteger(IDColumn[B]);
     if result<>0 then begin
       if Desc then
         result := -result; // descending order -> inverse comparison 
       exit;
     end;
   end;
end;

procedure TUTF8QuickSortMulti.QuickSort(L, R: Integer);
var I,J,P: integer;
    Tmp: PUTF8Char;
begin
  if L<R then
  repeat
    I := L;
    J := R;
    P := (L+R) shr 1;
    repeat
      while Compare(I,P)<0 do inc(I);
      while Compare(J,P)>0 do dec(J);
      if I<=J then begin
        if I<>J then begin // swap elements
          ExchgPtrUInt(PtrUInt(@Results[I*FieldCount]),
            PtrUInt(@Results[J*FieldCount]),FieldCount);
          if Assigned(IDColumn) then begin // update hidden ID column also
            Tmp := IDColumn[I];
            IDColumn[I] := IDColumn[J];
            IDColumn[J] := Tmp;
          end;
        end;
        if P=I then
          P := J else
        if P=J then
          P := I;
        inc(I);
        dec(J);
      end;
    until I>J;
    if L<J then
      QuickSort(L,J);
    L := I;
  until I >= R;
end;

procedure TSQLTable.SortFields(const Fields: array of integer;
  const Asc: array of boolean);
var Sort: TUTF8QuickSortMulti;
    i: integer;
begin
  if (self=nil) or (RowCount<=1) or (FieldCount<=0) or (length(Fields)=0) then
    exit;
  Sort.FieldCount := FieldCount;
  Sort.IndexMax := high(Fields);
  SetLength(Sort.Index,Sort.IndexMax+1);
  for i := 0 to Sort.IndexMax do
  with Sort.Index[i] do begin
    ndx := Fields[i];
    if ndx<0 then begin // Fields[]=-1 for ID column
      if not Assigned(fIDColumn) then begin // leave ndx<0 for hidden ID
        ndx := fFieldIndexID;  // use the ID column
        if ndx<0 then
          exit; // no ID column available
        Comp := @UTF8CompareUInt32;
      end;
      continue;
    end;
    Comp := SortCompare(ndx);
    if @Comp=nil then
      exit; // impossible to sort this kind of field (or invalid field index)
  end;
  for i := 0 to high(Asc) do
    if (i<=Sort.IndexMax) and not Asc[i] then
      Sort.Index[i].Desc := true;
  Sort.Results := fResults;
  Sort.IDColumn := @fIDColumn[0];
  Sort.QuickSort(1,RowCount); // ignore first row = field names -> (1,RowCount)
end;

function TSQLTable.SortCompare(Field: integer): TUTF8Compare;
begin
  result := SQLFieldTypeComp[FieldType(Field,nil)];
end;

procedure TSQLTable.Assign(source: TSQLTable);
begin
  fResults := source.fResults;
  fRowCount := source.fRowCount;
  fFieldCount := source.fFieldCount;
end;

constructor TSQLTable.Create(const aSQL: RawUTF8);
begin
  fQuerySQL := aSQL;
  fFieldIndexID := -1;
end;

constructor TSQLTable.CreateFromTables(const Tables: array of TSQLRecordClass;
  const aSQL: RawUTF8);
var n: integer;
begin
  Create(aSQL);
  n := length(Tables);
  if n>0 then begin
    SetLength(fQueryTables,n);
    move(Tables[0],fQueryTables[0],n*sizeof(TClass));
  end;
end;

constructor TSQLTable.CreateWithColumnTypes(const ColumnTypes: array of TSQLFieldType;
  const aSQL: RawUTF8);
begin
  Create(aSQL);
  SetLength(fQueryColumnTypes,length(ColumnTypes));
  Move(ColumnTypes[0],fQueryColumnTypes[0],length(ColumnTypes)*sizeof(TSQLFieldType));
end;

destructor TSQLTable.Destroy;
begin
  fOwnedRecords.Free;
  inherited;
end;

function TSQLTable.QueryRecordType: TSQLRecordClass;
begin
  if (self<>nil) and (pointer(fQueryTables)<>nil) then
      result := fQueryTables[0] else
      result := nil;
end;

function TSQLTable.NewRecord(RecordType: TSQLRecordClass=nil): TSQLRecord;
begin
  result := nil;
  if self=nil then
    exit;
  if RecordType=nil then begin
    RecordType := QueryRecordType;
    if RecordType=nil then
      exit;
  end;
  result := RecordType.Create;
  if fOwnedRecords=nil then
    fOwnedRecords := TObjectList.Create;
  fOwnedRecords.Add(result);
end;

{$ifdef ISDELPHI2010} // Delphi 2009 generics are buggy
function TSQLTable.ToObjectList<T>: TObjectList<T>;
var R,Item: TSQLRecord;
    Row: PPUtf8Char;
    i: integer;
begin
  result := TObjectList<T>.Create; // TObjectList<T> will free each T instance
  if (self=nil) or (RowCount=0) then
    exit;
  R := TSQLRecordClass(T).Create;
  try
    R.FillPrepare(self);
    Row := @fResults[FieldCount];     // Row^ points to first row of data
    {$ifdef ISDELPHIXE3}
    result.Count := RowCount;         // faster than manual Add()
    for i := 0 to RowCount-1 do begin
      Item := TSQLRecordClass(T).Create;
      PPointerArray(result.List)[i] := Item;
    {$else}
    for i := 0 to RowCount-1 do begin
      Item := TSQLRecordClass(T).Create;
      Result.Add(Item);
    {$endif}
      R.fFill.Fill(pointer(Row),Item);
      Inc(Row,FieldCount); // next data row
    end;
  finally
    R.Free;
  end;
end;
{$endif}

procedure TSQLTable.ToObjectList(DestList: TObjectList; RecordType: TSQLRecordClass=nil);
var R: TSQLRecord;
    Row: PPUtf8Char;
    i: integer;
begin
  if DestList=nil then
    exit;
  DestList.Clear;
  if (self=nil) or (RowCount=0) then
    exit;
  if RecordType=nil then begin
    RecordType := QueryRecordType;
    if RecordType=nil then
      exit;
  end;
  R := RecordType.Create;
  try
    R.FillPrepare(self);
    DestList.Count := RowCount;       // faster than manual Add()
    Row := @fResults[FieldCount];     // Row^ points to first row of data
    for i := 0 to RowCount-1 do begin // TObjectList will free each instance
      DestList.List[i] := RecordType.Create;
      R.fFill.Fill(pointer(Row),TSQLRecord(DestList.List[i]));
      Inc(Row,FieldCount); // next data row
    end;
  finally
    R.Free;
  end;
end;

function TSQLTable.ToObjectList(RecordType: TSQLRecordClass=nil): TObjectList;
begin
  result := TObjectList.Create;
  ToObjectList(result,RecordType);
end;

function TSQLTable.Step(SeekFirst: boolean=false; RowVariant: PVariant=nil): boolean;
begin
  result := false;
  if (self=nil) or (fRowCount<=0) then
    exit; // nothing to iterate over
  if SeekFirst then
    fStepRow := 1 else
    if fStepRow>=fRowCount then
      exit else
      inc(fStepRow);
  result := true;
{$ifndef NOVARIANTS}
  if RowVariant=nil then
    exit;
  if SQLTableRowVariantType=nil then
    SQLTableRowVariantType := SynRegisterCustomVariantType(TSQLTableRowVariant);
  if (PVarData(RowVariant)^.VType=SQLTableRowVariantType.VarType) and
     (PSQLTableRowVariantData(RowVariant)^.VTable=self) and
     (PSQLTableRowVariantData(RowVariant)^.VRow<0) then
    exit; // already initialized -> quick exit
  VarClear(RowVariant^);
  PSQLTableRowVariantData(RowVariant)^.VType := SQLTableRowVariantType.VarType;
  PSQLTableRowVariantData(RowVariant)^.VTable := self;
  PSQLTableRowVariantData(RowVariant)^.VRow := -1; // follow fStepRow
{$endif NOVARIANTS}
end;

function TSQLTable.FieldBuffer(FieldIndex: Integer): PUTF8Char;
begin
  if (self=nil) or (cardinal(FieldIndex)>=cardinal(fFieldCount)) then
    raise ESQLTableException.CreateFmt('FieldBuffer(%d): invalid index',[FieldIndex]);
  if (fStepRow=0) or (fStepRow>fRowCount) then
    raise ESQLTableException.Create('FieldBuffer(): no prior valid Step');
  result := fResults[fStepRow*FieldCount+FieldIndex];
end;

function TSQLTable.FieldBuffer(const FieldName: RawUTF8): PUTF8Char;
var i: integer;
begin
  i := FieldIndex(FieldName);
  if i<0 then
    raise ESQLTableException.CreateFmt('FieldBuffer(%s): unknown field',[FieldName]);
  if (fStepRow=0) or (fStepRow>fRowCount) then
    raise ESQLTableException.CreateFmt('FieldBuffer(%s): no prior valid Step',[FieldName]);
  result := fResults[fStepRow*FieldCount+i];
end;

{$ifndef NOVARIANTS}
function TSQLTable.Field(FieldIndex: integer): variant;
begin
  if (self=nil) or (cardinal(FieldIndex)>=cardinal(fFieldCount)) then
    raise ESQLTableException.CreateFmt('FieldBuffer(%d): invalid index',[FieldIndex]);
  if (fStepRow=0) or (fStepRow>fRowCount) then
    raise ESQLTableException.Create('FieldBuffer(): no prior valid Step');
  GetVariant(fStepRow,FieldIndex,nil,result);
end;

function TSQLTable.Field(const FieldName: RawUTF8): variant;
var i: integer;
begin
  i := FieldIndex(FieldName);
  if i<0 then
    raise ESQLTableException.CreateFmt('Field(%s): unknown field',[FieldName]);
  result := Field(i);
end;
{$endif}

function TSQLTable.CalculateFieldLengthMean(var aResult: TIntegerDynArray;
  FromDisplay: boolean=false): integer;
procedure CalculateEnumerates(F: integer; P: PEnumType);
var R, i, n: integer;
    EnumCounts: array of integer; // slow GetCaption() will be called once
    U: PPUTF8Char;
begin
  if P=nil then
    exit; // no a true enumerate field
  // 1. count of every possible enumerated value into EnumCounts[]
  SetLength(EnumCounts,P^.MaxValue+1); // EnumCounts[] := 0
  U := @fResults[FieldCount+F]; // start reading after first Row (= Field Names)
  for R := 1 to RowCount do begin
    n := GetInteger(U^);
    if n<=P^.MaxValue then // update count of every enumerated value
      inc(EnumCounts[n]) else
      inc(EnumCounts[0]); // GetCaption(invalid index) displays first one
    inc(U,FieldCount); // points to next row
  end;
  // 2. update aResult[F] with displayed caption text length
  n := 0;
  for i := 0 to P^.MaxValue do
    if EnumCounts[i]<>0 then
      inc(n,length(P^.GetCaption(i))*EnumCounts[i]);
  aResult[F] := n; // store displayed total length
end;
var R,F,n: integer;
    U: PPUTF8Char;
    Tot: cardinal;
begin
  SetLength(aResult,FieldCount);
  if FromDisplay and (length(fFieldLengthMean)=FieldCount) then begin
    move(fFieldLengthMean[0],aResult[0],FieldCount*4);
    result := fFieldLengthMeanSum;
    exit;
  end;
  if RowCount=0 then begin
    // no data: calculate field length from first row (i.e. Field Names)
    U := @fResults[0];
    for F := 0 to FieldCount-1 do begin
      inc(aResult[F],Utf8FirstLineToUnicodeLength(U^));  // count
      inc(U); // points to next value
    end;
    Tot := 1;
  end else begin
    if not Assigned(fFieldType) then
      InitFieldTypes;
    U := @fResults[FieldCount]; // start reading after first Row
    for R := 1 to RowCount do // sum all lengths by field
      for F := 0 to FieldCount-1 do begin
        case fFieldType[F].ContentType of
        sftInteger, sftBlob, sftBlobCustom, sftUTF8Custom, sftRecord,
        sftID, sftSet, sftCurrency:
          inc(aResult[F],8);
        else inc(aResult[F],Utf8FirstLineToUnicodeLength(U^));
        end;
        inc(U); // points to next value
      end;
    if Assigned(fQueryTables) then begin
      // aResult[] must be recalculated from captions, if exists
      for F := 0 to FieldCount-1 do
      with fFieldType[F] do
        case ContentType of
        sftEnumerate:
          CalculateEnumerates(F,EnumTypeInfo);
        end;
    end;
    Tot := RowCount;
  end;
  result := 0;
  for F := 0 to FieldCount-1 do begin
    n := cardinal(aResult[F]) div Tot; // Mean = total/count
    if n=0 then n := 1;  // none should be 0
    aResult[F] := n;
    inc(result,n); // fast calculate mean sum
  end;
end;

function TSQLTable.FieldLengthMean(Field: integer): cardinal;
begin
  if (self=nil) or (cardinal(Field)>=cardinal(FieldCount)) or (fResults=nil) then
    result := 0 else begin
    if fFieldLengthMean=nil then
      // if not already calculated, do it now
      fFieldLengthMeanSum := CalculateFieldLengthMean(fFieldLengthMean);
    result := fFieldLengthMean[Field];
  end;
end;

function TSQLTable.FieldLengthMeanSum: cardinal;
begin
  if self=nil then
    result := 0 else begin
    if fFieldLengthMean=nil then
      FieldLengthMean(0); // initialize fFieldLengthMean[] and fFieldLengthMeanSum
    result := fFieldLengthMeanSum;
  end;
end;

function TSQLTable.FieldLengthMax(Field: integer; NeverReturnsZero: boolean): cardinal;
var i: integer;
    len: cardinal;
    U: PPUTF8Char;
begin
  result := 0;
  if (self<>nil) and (cardinal(Field)<cardinal(FieldCount)) then begin
    if not Assigned(fFieldType) then
      InitFieldTypes;
    with fFieldType[Field] do 
    if ContentSize>=0 then
      // return already computed value
      result := ContentSize else begin
      if (EnumTypeInfo<>nil) and (ContentType=sftEnumerate) then begin
        // compute maximum size from available captions
        for i := 0 to PEnumType(EnumTypeInfo)^.MaxValue do begin
          len := length(PEnumType(EnumTypeInfo)^.GetCaption(i));
          if len>result then
            result := len;
        end;
      end else begin
        // compute by reading all data rows
        U := @fResults[FieldCount+Field];
        for i := 1 to RowCount do begin
          len := StrLen(U^);
          if len>result then
            result := len;
          inc(U,FieldCount);
        end;
      end;
      ContentSize := result;
    end;
  end;
  if (result=0) and NeverReturnsZero then
    result := 1; // minimal not null length
end;

function TSQLTable.FieldTable(Field: integer): TSQLRecordClass;
begin
  if (self=nil) or (cardinal(Field)>=cardinal(FieldCount)) or (fQueryTables=nil) then
    result := nil else begin
    if not Assigned(fFieldType) then
       InitFieldTypes;
    Field := fFieldType[Field].TableIndex;
    if Field<0 then
      result := nil else
      result := fQueryTables[Field];
  end;
end;

procedure TSQLTable.SetFieldLengthMean(const Lengths: array of cardinal);
var F: integer;
    n: cardinal;
begin
  if (self=nil) or (length(Lengths)<>FieldCount) then
    exit;
  if fFieldLengthMean=nil then // if not already calculated, allocate array
    SetLength(fFieldLengthMean,FieldCount);
  fFieldLengthMeanSum := 0;
  for F := 0 to FieldCount-1 do begin
    n := Lengths[F];
    if n=0 then n := 1;  // none should be 0
    fFieldLengthMean[F] := n;
    inc(fFieldLengthMeanSum,n); // fast calculate mean sum
  end;
end;

procedure TSQLTable.FieldLengthMeanIncrease(aField, aIncrease: integer);
begin
  if (self=nil) or (cardinal(aField)>=cardinal(FieldCount)) then
    exit; // avoid GPF
  if fFieldLengthMean=nil then
    FieldLengthMean(0); // initialize fFieldLengthMean[] and fFieldLengthMeanSum
  inc(fFieldLengthMean[aField],aIncrease);
  inc(fFieldLengthMeanSum,aIncrease);
end;

function TSQLTable.SearchValue(const aUpperValue: RawUTF8;
  StartRow, FieldIndex: integer; Client: TObject; Lang: TSynSoundExPronunciation;
  UnicodeComparison: boolean): integer;
var U: PPUTF8Char;
    Kind: TSQLFieldType;
    Search: PAnsiChar;
    UpperUnicode: RawUnicode;
    UpperUnicodeLen: integer;
    EnumType: PEnumType;
    Value: PtrInt;
    err: integer;
    TimeLog: Int64;
    EnumValue: RawUTF8;
    s: string;
    P: PShortString;
    EnumValues: set of 0..63;
    Soundex: TSynSoundEx;
    CL: TSQLRest absolute Client;
    tmp: array[0..23] of AnsiChar;
begin
  result := 0;
  if (StartRow<=0) or (StartRow>RowCount) or (aUpperValue='') or
     (cardinal(FieldIndex)>=cardinal(FieldCount)) then
    exit;
  Search := pointer(aUpperValue);
  if Search^='%' then begin
    inc(Search);
    if Search^='%' then begin
      inc(Search);
      if Search^='%' then begin
        inc(Search);
        Lang := sndxSpanish;
      end else
        Lang := sndxFrench;
    end else
      Lang := sndxEnglish;
  end;
  if ((Lang<>sndxNone) and not Soundex.Prepare(Search,Lang)) then
    exit;
  result := StartRow;
  Kind := FieldType(FieldIndex,@EnumType);
  U := @fResults[FieldCount*StartRow+FieldIndex];
  // search in one specified field value
  if (Kind=sftEnumerate) and (EnumType<>nil) then begin
    // for enumerates: first search in all available values
    Int64(EnumValues) := 0;
    P := @EnumType^.NameList;
    for Value := 0 to EnumType^.MaxValue do begin
      EnumValue := TrimLeftLowerCaseShort(P);
      GetCaptionFromPCharLen(pointer(EnumValue),s);
      EnumValue := StringToUTF8(s);
      if ((Lang<>sndxNone) and SoundEx.UTF8(pointer(EnumValue))) or
         ((Lang=sndxNone) and FindUTF8(pointer(EnumValue),Search)) then 
        include(EnumValues,Value);
      inc(PtrUInt(P),ord(P^[0])+1);
    end;
    // then search directly from the INTEGER value
    if Int64(EnumValues)<>0 then
    while cardinal(result)<=cardinal(RowCount) do begin
      Value := GetInteger(U^,err);
      if (err=0) and (Value in EnumValues) then
        exit; // we found a matching field
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end;
    result := 0; // not found
    exit;
  end;
  // special cases: conversion from INTEGER to text before search
  if Kind in [sftTimeLog,sftModTime,sftCreateTime] then
    while cardinal(result)<=cardinal(RowCount) do begin
      SetInt64(U^,TimeLog);
      if TimeLog<>0 then begin
        tmp[TTimeLogBits(TimeLog).Text(tmp,true,' ')] := #0;
        if FindAnsi(tmp,Search) then
          exit;
      end;
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end
  else
  if ((Kind in [sftRecord,sftID]) and
     (Client<>nil) and Client.InheritsFrom(TSQLRest) and (CL.Model<>nil)) then
    while cardinal(result)<=cardinal(RowCount) do begin
      Value := GetInteger(U^);
      if Value<>0 then begin
        if Kind=sftRecord then
          EnumValue := RecordRef(Value).Text(CL.Model) else
          EnumValue := U^; // sftID -> display ID number -> no sounded
        if Lang=sndxNone then begin
          if FindUTF8(pointer(EnumValue),Search) then exit;
        end else
          if SoundEx.UTF8(pointer(EnumValue)) then exit;
      end;
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end
  else
  // by default, search as UTF-8 encoded text
  if Lang<>sndxNone then begin
    while cardinal(result)<=cardinal(RowCount) do
    if SoundEx.UTF8(U^) then
      exit else begin
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end;
  end else
  if UnicodeComparison then begin
    // slowest but always accurate Unicode comparison
    UpperUnicode := UTF8DecodeToRawUnicodeUI(RawUTF8(Search),@UpperUnicodeLen);
    while cardinal(result)<=cardinal(RowCount) do
    if FindUnicode(pointer(Utf8DecodeToRawUnicode(U^,0)),
       pointer(UpperUnicode),UpperUnicodeLen) then
      exit else begin
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end
  end else
    // default fast Win1252 search
    while cardinal(result)<=cardinal(RowCount) do
    if FindUTF8(U^,Search) then
      exit else begin
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end;
  result := 0; // not found
end;

function TSQLTable.SearchValue(const aUpperValue: RawUTF8;
  StartRow: integer; FieldIndex: PInteger; Client: TObject; Lang: TSynSoundExPronunciation;
  UnicodeComparison: boolean): integer;
var F, Row: integer;
begin
  result := 0;
  if (self=nil) or (StartRow<=0) or (StartRow>RowCount) or (aUpperValue='') then
    exit;
  // search in all fields values
  for F := 0 to FieldCount-1 do begin
    Row := SearchValue(aUpperValue,StartRow,F,Client,Lang,UnicodeComparison);
    if (Row<>0) and ((result=0) or (Row<result)) then begin
      if FieldIndex<>nil then
        FieldIndex^ := F;
      result := Row;
    end;
  end;
end;

function TSQLTable.SearchFieldEquals(const aValue: RawUTF8; FieldIndex: integer): integer;
begin
  result := 0;
  if (self=nil) or (aValue='') or (cardinal(FieldIndex)>cardinal(fFieldCount)) then
    exit;
  for result := 1 to RowCount do
    if UTF8IComp(Get(result,FieldIndex),pointer(aValue))=0 then
      exit;
  result := 0;
end;

{$ifndef NOVARIANTS}

function TSQLTable.GetVariant(Row, Field: integer; Client: TObject): Variant;
begin
  GetVariant(Row,Field,Client,result);
end;

procedure TSQLTable.GetVariant(Row,Field: integer; Client: TObject; var result: variant);
begin
  if Row=0 then // Field Name
    RawUTF8ToVariant(GetU(0,Field),result) else
    ValueVarToVariant(Get(Row,Field),FieldType(Field),TVarData(result),true);
end;

{$endif NOVARIANTS}

function TSQLTable.ExpandAsString(Row, Field: integer; Client: TObject;
  out Text: string; const CustomFormat: string): TSQLFieldType;
var EnumType: PEnumType;
    err: integer;
    Value: Int64;
    Ref: RecordRef absolute Value;
label IsDateTime;
begin // Text was already forced to '' because was defined as "out" parameter
  if Row=0 then begin // Field Name
    result := sftUnknown;
    Text := GetCaption(0,Field);
    exit;
  end;
  result := FieldType(Field,@EnumType);
  case result of
  sftDateTime: begin
   Value := Iso8601ToTimeLogPUTF8Char(Get(Row,Field),0);
IsDateTime:
    if Value<>0 then begin
      {$ifndef LVCL}
      if CustomFormat<>'' then begin
        Text := FormatDateTime(CustomFormat,TTimeLogBits(Value).ToDateTime);
        if Text<>CustomFormat then
          exit; // valid conversion
      end;
      {$endif LVCL}
      if Assigned(i18nDateText) then
        Text := i18nDateText(Value) else
        Text := {$ifdef UNICODE}Ansi7ToString{$endif}(TTimeLogBits(Value).Text(true,' '));
      exit;
    end;
  end;
  sftBlob:
    Text := '???';
  sftFloat:
    if CustomFormat<>'' then
    try
      if pos('%',CustomFormat)>0 then
        Text := Format(CustomFormat,[GetExtended(Get(Row,Field))])
        {$ifndef LVCL} else
        Text := FormatFloat(CustomFormat,GetExtended(Get(Row,Field)))
        {$endif LVCL};
      exit;
    except
      on {$ifdef LVCL}Exception{$else}EConvertError{$endif} do
        Text := '';
    end;
  sftCurrency:
    if CustomFormat<>'' then
    try
      if pos('%',CustomFormat)>0 then
        Text := Format(CustomFormat,[StrToCurrency(Get(Row,Field))])
        {$ifndef LVCL} else
        Text := FormatCurr(CustomFormat,StrToCurrency(Get(Row,Field)))
        {$endif};
      exit;
    except
      on {$ifdef LVCL}Exception{$else}EConvertError{$endif} do
        Text := '';
    end;
  sftEnumerate, sftSet, sftRecord, sftID, sftTimeLog, sftModTime, sftCreateTime: begin
    Value := GetInt64(Get(Row,Field),err);
    if err<>0 then
      // not an integer -> to be displayed as sftUTF8Text
      result := sftUTF8Text else
    case result of
      sftEnumerate: begin
        Text := EnumType^.GetCaption(Value);
        exit;
      end;
      sftTimeLog, sftModTime, sftCreateTime:
        goto IsDateTime;
{      sftID, sftSet:
        result := sftUTF8Text; // will display INTEGER field as number }
      sftRecord:
        if (Value<>0) and 
           (Client<>nil) and Client.InheritsFrom(TSQLRest) then // 'TableName ID'
          Text := {$ifdef UNICODE}Ansi7ToString{$endif}(Ref.Text(TSQLRest(Client).Model)) else
          result := sftUTF8Text; // display ID number if no table model
    end;
  end;
  end;
  if Text='' then
    // returns the value as text by default
    Text := GetString(Row,Field);
end;

function TSQLTable.ExpandAsSynUnicode(Row,Field: integer; Client: TObject; out Text: SynUnicode): TSQLFieldType;
var s: string;
begin
  result := ExpandAsString(Row,Field,Client,s);
  Text := StringToSynUnicode(s);
end;

function TSQLTable.GetTimeLog(Row, Field: integer; Expanded: boolean;
  FirstTimeChar: AnsiChar): RawUTF8;
var Value: TTimeLogBits;
begin
  SetInt64(Get(Row,Field),Value.Value);
  result := Value.Text(Expanded,FirstTimeChar);
end;


{$ifndef NOVARIANTS}

{ TSQLTableRowVariant }

procedure TSQLTableRowVariant.IntGet(var Dest: TVarData;
  const V: TVarData; Name: PAnsiChar);
var r,f: integer;
begin
  if (TSQLTableRowVariantData(V).VTable=nil) or (Name=nil) then
    ESQLTableException.CreateFmt('Invalid TSQLTableRowVariant.%s call',[Name]);
  r := TSQLTableRowVariantData(V).VRow;
  if r<0 then begin
    r := TSQLTableRowVariantData(V).VTable.fStepRow;
    if (r=0) or (r>TSQLTableRowVariantData(V).VTable.fRowCount) then
      raise ESQLTableException.CreateFmt('TSQLTableRowVariant.%s: no prior valid Step',[Name]);
  end;
  f := TSQLTableRowVariantData(V).VTable.FieldIndex(PUTF8Char(Name));
  if cardinal(f)>=cardinal(TSQLTableRowVariantData(V).VTable.fFieldCount) then
    raise ESQLTableException.CreateFmt('TSQLTableRowVariant.%s: unknown field',[Name]);
  TSQLTableRowVariantData(V).VTable.GetVariant(r,f,nil,Variant(Dest));
end;

procedure TSQLTableRowVariant.IntSet(const V, Value: TVarData; Name: PAnsiChar);
begin
  ESQLTableException.Create('TSQLTableRowVariant is read-only');
end;

procedure TSQLTableRowVariant.Cast(var Dest: TVarData; const Source: TVarData);
begin
  CastTo(Dest,Source,VarType);
end;

procedure TSQLTableRowVariant.CastTo(var Dest: TVarData;
  const Source: TVarData; const AVarType: TVarType);
var r: integer;
    tmp: variant; // use a temporary TDocVariant for the conversion
begin
  if AVarType=VarType then begin
    RaiseCastError;
  end else begin
    if Source.VType<>VarType then
      RaiseCastError;
    r := TSQLTableRowVariantData(Source).VRow;
    if r<0 then
      r := TSQLTableRowVariantData(Source).VTable.fStepRow;
    TSQLTableRowVariantData(Source).VTable.ToDocVariant(r,tmp);
    RawUTF8ToVariant(VariantSaveJSON(tmp),Dest,AVarType);
  end;
end;

procedure TSQLTableRowVariant.ToJSON(W: TTextWriter; const Value: variant;
  Escape: TTextWriterKind);
var r: integer;
    tmp: variant; // write row via a TDocVariant
begin
  r := TSQLTableRowVariantData(Value).VRow;
  if r<0 then
    r := TSQLTableRowVariantData(Value).VTable.fStepRow;
  TSQLTableRowVariantData(Value).VTable.ToDocVariant(r,tmp);
  W.AddVariantJSON(tmp,Escape);
end;

{$endif NOVARIANTS}


procedure Base64MagicToBlob(Base64: PUTF8Char; var result: RawUTF8);
begin
  // do not escape the result: returns e.g. X'53514C697465'
  result := TSQLRawBlobToBlob(Base64ToBin(PAnsiChar(Base64),StrLen(Base64)));
end;


{ TJSONObjectDecoder }

const
  EndOfJSONField = [',',']','}',':'];

function GetJSONArrayOrObjectAsQuotedStr(P: PUTF8Char; out PDest: PUTF8Char;
  EndOfObject: PUTF8Char): RawUTF8;
var Beg: PUTF8Char;
begin
  assert(EndOfObject<>nil);
  result := '';
  PDest := nil;
  Beg := P;
  P := GotoNextJSONObjectOrArray(P); // quick go to end of array of object
  if P=nil then
    exit;
  EndOfObject^ := P^;
  P^ := #0; // so Beg will be a valid ASCIIZ string
  PDest := P+1;
  result := QuotedStr(Beg,'''');
end;

procedure TJSONObjectDecoder.Decode(var P: PUTF8Char; const Fields: TRawUTF8DynArray;
  Params: TJSONObjectDecoderParams; RowID: integer; ReplaceRowIDWithID: boolean);
var EndOfObject: AnsiChar;

  procedure GetSQLValue(ndx: integer);
  var wasString: boolean;
      res: PUTF8Char;
      c: integer;
  begin
    res := P;
    if res=nil then begin
      FieldValues[ndx] := ''; // avoid GPF, but will return invalid SQL
      exit;
    end;
    while res^ in [#1..' '] do inc(res);
    if (PInteger(res)^=NULL_LOW) and
       (res[4] in [#0,#9,#10,#13,' ',',','}',']'])  then begin
      /// GetJSONField('null') returns '' -> check here to make a diff with '""'
      FieldTypeApproximation[ndx] := ftaNull;
      FieldValues[ndx] := 'null';
      inc(res,4);
      while res^ in [#1..' '] do inc(res);
      if res^=#0 then
        P := nil else begin
        EndOfObject := res^;
        res^ := #0;
        P := res+1;
      end;
    end else begin
      // first check if nested object or array
      case res^ of // handle JSON {object} or [array] in P
      '{': begin // will work e.g. for custom variant types
        FieldTypeApproximation[ndx] := ftaObject;
        FieldValues[ndx] := GetJSONArrayOrObjectAsQuotedStr(res,P,@EndOfObject);
      end;
      '[': begin // will work e.g. for custom variant types
        FieldTypeApproximation[ndx] := ftaArray;
        FieldValues[ndx] := GetJSONArrayOrObjectAsQuotedStr(res,P,@EndOfObject);
      end;
      else begin
        // handle JSON string, number or false/true in P
        res := GetJSONField(res,P,@wasString,@EndOfObject);
        if wasString then begin
          c := PInteger(res)^ and $00ffffff;
          if c=JSON_BASE64_MAGIC then begin
            FieldTypeApproximation[ndx] := ftaBlob;
            case Params of
            pInlined: //untouched -> recognized as BLOB in SQLParamContent()
              FieldValues[ndx] := QuotedStr(res,'''');
{            pQuoted: // \uFFF0base64encodedbinary -> 'X''hexaencodedbinary'''
              // if not inlined, it can be used directly in INSERT/UPDATE statements
              Base64MagicToBlob(res+3,FieldValues[ndx]);
            pNonQuoted:}
            else // returned directly as RawByteString
              FieldValues[ndx] := Base64ToBin(res+3);
            end;
          end else begin
            if c=JSON_SQLDATE_MAGIC then begin
              FieldTypeApproximation[ndx] := ftaDate;
              inc(res,3); // ignore \uFFF1 magic marker
            end else
              FieldTypeApproximation[ndx] := ftaString;
            // regular string content
            if Params=pNonQuoted then
              // returned directly as RawUTF8
              FieldValues[ndx] := res else
              { escape SQL strings, cf. the official SQLite3 documentation:
                "A string is formed by enclosing the string in single quotes (').
                 A single quote within the string can be encoded by putting two
                 single quotes in a row - as in Pascal." }
              FieldValues[ndx] := QuotedStr(res,'''');
          end;
        end else
          // non string params (numeric or false/true) are passed untouched
          if PInteger(res)^=FALSE_LOW then begin
            FieldValues[ndx] := '0';
            FieldTypeApproximation[ndx] := ftaBoolean;
          end else
          if PInteger(res)^=TRUE_LOW then begin
            FieldValues[ndx] := '1';
            FieldTypeApproximation[ndx] := ftaBoolean;
          end else begin
            FieldValues[ndx] := res;
            FieldTypeApproximation[ndx] := ftaNumber;
          end;
      end;
      end;
    end;
    Inc(FieldValueLen,length(FieldValues[ndx]));
  end;

var FieldName: RawUTF8;
    F: integer;
    FieldIsRowID: Boolean;
begin
  FieldCount := 0;
  FieldValueLen := 0;
  FieldNameLen := 0;
  DecodedRowID := 0;
  FillChar(FieldTypeApproximation,sizeof(FieldTypeApproximation),0);
  InlinedParams := Params=pInlined;
  if pointer(Fields)=nil then begin
    // get "COL1"="VAL1" pairs, stopping at '}' or ']'
    DecodedFieldNames := @FieldNames;
    if RowID>0 then begin // insert explicit RowID
      if ReplaceRowIDWithID then
        FieldNames[0] := 'ID' else
        FieldNames[0] := 'RowID';
      Int32ToUtf8(RowID,FieldValues[0]);
      FieldCount := 1;
      FieldNameLen := Length(FieldNames[0]);
      FieldValueLen := Length(FieldValues[0]);
      DecodedRowID := RowID;
    end;
    if P<>nil then
    repeat
      FieldName := GetJSONPropName(P);
      if (FieldName='') or (P=nil) then
        break; // invalid JSON field name
      FieldIsRowID := IsRowId(pointer(FieldName));
      if FieldIsRowID then
        if RowID>0 then begin
          GetJSONField(P,P,nil,@EndOfObject); // ignore this if explicit RowID
          if EndOfObject in [#0,'}',']'] then
            break else continue;
        end else
        if ReplaceRowIDWithID then
          FieldName := 'ID';
      inc(FieldNameLen,length(FieldName));
      FieldNames[FieldCount] := FieldName;
      GetSQLValue(FieldCount); // update EndOfObject
      if FieldIsRowID then
        DecodedRowID := GetInteger(pointer(FieldValues[FieldCount]));
      inc(FieldCount);
      if FieldCount=MAX_SQLFIELDS then
        raise EParsingException.Create('Too many inlines in TJSONObjectDecoder');
    until EndOfObject in [#0,'}',']'];
  end else begin
    // get "VAL1","VAL2"...
    if P=nil then
      exit;
    if RowID>0 then
      raise EParsingException.Create('TJSONObjectDecoder(expanded) won''t handle RowID');
    if length(Fields)>MAX_SQLFIELDS then
      raise EParsingException.Create('Too many inlines in TJSONObjectDecoder');
    DecodedFieldNames := pointer(Fields);
    FieldCount := length(Fields);
    for F := 0 to FieldCount-1 do begin
      inc(FieldNameLen,length(Fields[F]));
      GetSQLValue(F); // update EndOfObject
    end;
  end;
end;

procedure TJSONObjectDecoder.Decode(JSON: RawUTF8; const Fields: TRawUTF8DynArray;
  Params: TJSONObjectDecoderParams; RowID: Integer=0; ReplaceRowIDWithID: Boolean=false);
var P: PUTF8Char;
begin
  if JSON='' then
    P := nil else begin
    P := @JSON[1]; // call UniqueString(JSON)
    while P^ in [#1..' ','{','['] do inc(P);
  end;
  Decode(P,Fields,Params,RowID,ReplaceRowIDWithID);
end;

function TJSONObjectDecoder.SameFieldNames(const Fields: TRawUTF8DynArray): boolean;
var i: integer;
begin
  result := false;
  if length(Fields)<>FieldCount then
    exit;
  for i := 0 to FieldCount-1 do
    if not IdemPropNameU(Fields[i],FieldNames[i]) then
      exit;
  result := true;
end;

procedure TJSONObjectDecoder.AssignFieldNamesTo(var Fields: TRawUTF8DynArray);
var i: integer;
begin
  SetLength(Fields,FieldCount);
  for i := 0 to FieldCount-1 do
    Fields[i] := FieldNames[i];
end;

function TJSONObjectDecoder.EncodeAsSQLPrepared(const TableName: RawUTF8;
  Occasion: TSQLOccasion; const UpdateIDFieldName: RawUTF8;
  MultipleInsertCount: integer): RawUTF8;
const SQL: array[boolean] of PUTF8Char = (
   'insert into %%', 'update % set % where %=?');
var F: integer;
    P: PUTF8Char;
    tmp: RawUTF8;
begin
  result := '';
  if FieldCount<>0 then begin
    if (Occasion<>soInsert) or (MultipleInsertCount<=0) then
      MultipleInsertCount := 1;
    SetLength(tmp,FieldNameLen+4*FieldCount*MultipleInsertCount+24); // max length
    P := pointer(tmp);
    case Occasion of
    soUpdate: begin
      // returns 'COL1=?,COL2=?' (UPDATE SET format)
      for F := 0 to FieldCount-1 do begin
        P := AppendRawUTF8ToBuffer(P,DecodedFieldNames[F]);
        PInteger(P)^ := Ord('=')+Ord('?')shl 8+Ord(',')shl 16;
        inc(P,3);
      end;
      dec(P);
    end;
    soInsert: begin
      // returns ' (COL1,COL2) VALUES (?,?)' (INSERT format)
      PWord(P)^ := Ord(' ')+ord('(')shl 8;
      inc(P,2);
      for F := 0 to FieldCount-1 do begin
        P := AppendRawUTF8ToBuffer(P,DecodedFieldNames[F]);
        P^ := ',';
        inc(P);
      end;
      P := AppendRawUTF8ToBuffer(P-1,') VALUES (');
      repeat
        for F := 1 to FieldCount do begin
          PWord(P)^ := Ord('?')+Ord(',')shl 8;
          inc(P,2);
        end;
        P[-1] := ')';
        dec(MultipleInsertCount);
        if MultipleInsertCount=0 then
          break;
        PWord(P)^ := Ord(',')+Ord('(')shl 8;
        inc(P,2);
      until false;
    end;
    else
      raise EORMException.Create('Invalid EncodeAsSQLPrepared() call');
    end;
    assert(P-pointer(tmp)<length(tmp));
    SetLength(tmp,P-pointer(tmp));
  end else
    if Occasion=soUpdate then
      exit else
      tmp := ' default values';
  result := FormatUTF8(SQL[Occasion=soUpdate],[TableName,tmp,UpdateIDFieldName]);
end;

function TJSONObjectDecoder.EncodeAsSQL(Update: boolean): RawUTF8;
var F, Len: integer;
    P: PUTF8Char;
begin
  result := '';
  if FieldCount=0 then
    exit;
  if InlinedParams then
    Len := FieldNameLen+FieldValueLen+6*FieldCount else
    Len := FieldNameLen+FieldValueLen+2*FieldCount;
  if Update then begin
    // returns 'COL1='VAL1',COL2=VAL2' (UPDATE SET format)
    SetLength(result,Len-1); // -1 for last ','
    P := pointer(result);
    for F := 0 to FieldCount-1 do begin
      P := AppendRawUTF8ToBuffer(P,DecodedFieldNames[F]);
      if InlinedParams then begin
        PInteger(P)^ := Ord('=')+Ord(':')shl 8+Ord('(')shl 16;
        inc(P,3);
      end else begin
        P^ := '=';
        inc(P);
      end;
      P := AppendRawUTF8ToBuffer(P,FieldValues[F]);
      if InlinedParams then begin
        PWord(P)^ := Ord(')')+Ord(':')shl 8;
        P[2] := ',';
        // PInteger(P)^ := Ord(')')+Ord(':')shl 8+Ord(',')shl 16; may corrupt mem
        inc(P,3);
      end else begin
        P^ := ',';
        inc(P);
      end;
    end;
    dec(P);
    P^ := #0; // trim last ','
  end else begin
    // returns ' (COL1,COL2) VALUES ('VAL1',VAL2)' (INSERT format)
    SetLength(result,Len+11);
    P := pointer(result);
    PWord(P)^ := Ord(' ')+ord('(')shl 8;
    inc(P,2);
    for F := 0 to FieldCount-1 do begin
      P := AppendRawUTF8ToBuffer(P,DecodedFieldNames[F]);
      P^ := ',';
      inc(P);
    end;
    P := AppendRawUTF8ToBuffer(P-1,') VALUES (');
    for F := 0 to FieldCount-1 do begin
      if InlinedParams then begin
        PWord(P)^ := Ord(':')+Ord('(')shl 8;
        inc(P,2);
      end;
      P := AppendRawUTF8ToBuffer(P,FieldValues[F]);
      if InlinedParams then begin
        PWord(P)^ := Ord(')')+Ord(':')shl 8;
        P[2] := ',';
        inc(P,3);
      end else begin
        P^ := ',';
        inc(P);
      end;
    end;
    P[-1] := ')';
  end;
  Assert(P-pointer(result)=length(result));
end;


const
  FROMINLINED: array[boolean] of TJSONObjectDecoderParams = (
    pQuoted, pInlined);

function GetJSONObjectAsSQL(var P: PUTF8Char; const Fields: TRawUTF8DynArray;
  Update, InlinedParams: boolean; RowID: Integer=0; ReplaceRowIDWithID: Boolean=false): RawUTF8;
var Decoder: TJSONObjectDecoder;
begin
  Decoder.Decode(P,Fields,FROMINLINED[InlinedParams],RowID,ReplaceRowIDWithID);
  result := Decoder.EncodeAsSQL(Update);
end;

function GetJSONObjectAsSQL(JSON: RawUTF8; Update, InlinedParams: boolean;
 RowID: Integer=0; ReplaceRowIDWithID: Boolean=false): RawUTF8; overload;
var Decoder: TJSONObjectDecoder;
begin
  Decoder.Decode(JSON,nil,FROMINLINED[InlinedParams],RowID,ReplaceRowIDWithID);
  result := Decoder.EncodeAsSQL(Update);
end;

function Expect(var P: PUTF8Char; const Value: RawUTF8): boolean;
  {$ifdef HASINLINE}inline;{$endif}
var L: integer;
begin
  if P=nil then
    result := false else begin
    while P^ in [#1..' '] do inc(P);
    if Value='' then
      result := false else begin
      L := length(Value);
      result := CompareMem(P,pointer(Value),L);
      if result then
        inc(P,L);
    end;
  end;
end;

function GetJSONIntegerVar(var P: PUTF8Char): PtrInt;
var c: PtrUInt;
begin
  if P^ in [#1..' '] then repeat inc(P) until not(P^ in [#1..' ']);
  c := byte(P^)-48;
  if c>9 then
    result := 0 else begin
    result := c;
    inc(P);
    repeat
      c := byte(P^)-48;
      if c>9 then
        break;
      result := result*10+PtrInt(c);
      inc(P);
    until false;
  end;
end;

const
  FIELDCOUNT_PATTERN: RawUTF8 = '{"fieldCount":';
  ROWCOUNT_PATTERN: RawUTF8 = ',"rowCount":';
  VALUES_PATTERN: RawUTF8 = ',"values":[';

function UnJSONFirstField(var P: PUTF8Char): RawUTF8;
// expand=true: [ {"col1":val11} ] -> val11
// expand=false: { "fieldCount":1,"values":["col1",val11] } -> vall11
begin
  result := '';
  if P=nil then exit;
  if Expect(P,FIELDCOUNT_PATTERN) then begin
    // not expanded format
    if GetJSONIntegerVar(P)<>1 then
      exit; // wrong field count
    while P^<>'[' do if P^=#0 then exit else inc(P); // go to ["col1"
    inc(P); // go to "col1"
  end else begin
    // expanded format
    while P^<>'[' do if P^=#0 then exit else inc(P); // need an array of objects
    repeat inc(P); if P^=#0 then exit; until P^='{'; // go to object begining
  end;
  GetJSONPropName(P); // ignore field name
  result := GetJSONField(P,P); // get field value
end;

function IsNotAjaxJSON(P: PUTF8Char): Boolean;
begin
  result := Expect(P,FIELDCOUNT_PATTERN);
end;

function NotExpandedBufferRowCountPos(P,PEnd: PUTF8Char): PUTF8Char;
var i: integer;
begin
  result := nil;
  if (PEnd<>nil) and (PEnd-P>24) then
    for i := 1 to 24 do // search for "rowCount": at the end of the JSON buffer
    case PEnd[-i] of
    ']',',':
      exit;
    ':': begin
      if CompareMem(PEnd-i-11,pointer(ROWCOUNT_PATTERN),11) then
        result := PEnd-i+1;
      exit;
    end;
    end;
end;

function IsNotExpandedBuffer(var P: PUTF8Char; PEnd: PUTF8Char;
  var FieldCount,RowCount: integer): boolean;
  procedure GetRowCountNotExpanded(P: PUTF8Char);
  begin
    RowCount := 0;
    repeat
      // get a row
      P := GotoNextJSONItem(P,FieldCount);
      if P=nil then exit; // unexpected end
      inc(RowCount);
    until P[-1]=']'; // end of array
    if P^ in ['}',','] then begin // expected formated JSON stream
      if RowCount>0 then
        dec(RowCount); // first Row = field names -> data in rows 1..RowCount
    end else
      RowCount := -1; // bad format -> no data
  end;
var RowCountPos: PUTF8Char;
begin
  if not Expect(P,FIELDCOUNT_PATTERN) then begin
    result := false;
    exit;
  end;
  FieldCount := GetJSONIntegerVar(P);
  if Expect(P,ROWCOUNT_PATTERN) then
    RowCount := GetJSONIntegerVar(P) else begin
    RowCountPos := NotExpandedBufferRowCountPos(P,PEnd);
    if RowCountPos=nil then
      RowCount := -1 else // mark "rowCount":.. not available
      RowCount := GetCardinal(RowCountPos);
  end;
  result := (FieldCount<>0) and Expect(P,VALUES_PATTERN);
  if result and (RowCount<0) then
    GetRowCountNotExpanded(P); // returns RowCount=-1 if P^ is invalid
end;

function JSONGetObject(var P: PUTF8Char; ExtractID: PInteger;
  var EndOfObject: AnsiChar): RawUTF8;
var Beg, PC: PUTF8Char;
begin
  result := '';
  if P=nil then
    exit;
  while not (P^ in ['{',#0]) do inc(P);
  Beg := P;
  P := GotoNextJSONObjectOrArray(Beg);
  if (P<>nil) and not (P^ in EndOfJSONField) then
    P := nil;
  if P<>nil then begin
    EndOfObject := P^;
    inc(P); // ignore end of object, i.e. ',' or ']'
    if ExtractID<>nil then begin
      PC := Beg;
      while PC^<>'"' do
        if PC^=#0 then exit else inc(PC);
      if IdemPChar(PC,'"ID":') or IdemPChar(PC,'"ROWID":') then begin
        ExtractID^ := GetInteger(PosChar(PC,':')+1);
        PC := PosChar(PC,',');
        PC^ := '{';
        SetString(result,PAnsiChar(PC),P-PC-1); // extract the '"ID":203,' pair
        exit;
      end else
        ExtractID^ := 0;
    end;
    SetString(result,PAnsiChar(Beg),P-Beg-1);
  end;
end;


{ TSQLTableJSON }

function TSQLTableJSON.PrivateCopyChanged(aJSON: PUTF8Char; aLen: integer): boolean;
var Hash: cardinal;
begin
  Hash := crc32c(0,pointer(aJSON),aLen);
  result := (fPrivateCopyHash=0) or (Hash=0) or (Hash<>fPrivateCopyHash);
  if not result then
    exit;
  SetString(fPrivateCopy,PAnsiChar(aJSON),aLen);
  fPrivateCopyHash := Hash;
end;

function TSQLTableJSON.ParseAndConvert(Buffer: PUTF8Char; BufferLen: integer): boolean;
function GetFieldCountExpanded(P: PUTF8Char): integer;
var EndOfObject: AnsiChar;
begin
  result := 0;
  repeat
    P := GotoNextJSONItem(P,2,@EndOfObject); // ignore Name+Value items
    if P=nil then begin // unexpected end
      result := 0;
      exit;
    end;
    inc(result);
    if EndOfObject='}' then break; // end of object
  until false;
end;
var i, max, nfield, nrow, resmax, f: integer;
    EndOfObject: AnsiChar;
    P: PUTF8Char;
    wasString: Boolean;
begin
  result := false; // error on parsing
  fFieldIndexID := -1;
  if (self=nil) or (Buffer=nil) then
    exit;
  // go to start of object
  P := GotoNextNotSpace(Buffer);
  if IsNotExpandedBuffer(P,Buffer+BufferLen,fFieldCount,fRowCount) then begin
    // A. Not Expanded format
(* {"fieldCount":9,"values":["ID","Int","Test","Unicode","Ansi","ValFloat","ValWord",
    "ValDate","Next",0,0,"abcde+ef++","abcde+ef++","abcde+ef++",
    3.14159265300000E+0000,1203,"2009-03-10T21:19:36",0,..],"rowCount":20} *)
    // 1. check RowCount and DataLen
    if fRowCount<0 then begin // IsNotExpanded() notified wrong input
      fRowCount := 0; // may occur if P^ content was invalid
      exit;
    end;
    // 2. initialize and fill fResults[] PPUTF8CharArray memory
    max := (RowCount+1)*FieldCount;
    SetLength(fJSONResults,max);
    fResults := @fJSONResults[0];
    // unescape+zeroify JSONData + fill fResults[] to proper place
    dec(max);
    f := 0;
    for i := 0 to max do begin
      // get a field
      fJSONResults[i] := GetJSONFieldOrObjectOrArray(P,@wasString,nil,true);
      if (P=nil) and (i<>max) then
        exit; // failure (GetRowCountNotExpanded should have detect it)
      if (f>=0) and (i>=FieldCount) then begin
        if wasString then
          Include(fFieldParsedAsString,f); // mark column was "string"
        inc(f);
        if f=FieldCount then
          f := -1; // only check first row (should be consistent)
      end;
    end;
  end else begin
    // B. Expanded format
(* [{"ID":0,"Int":0,"Test":"abcde+ef++","Unicode":"abcde+ef++","Ansi":
    "abcde+ef++","ValFloat": 3.14159265300000E+0000,"ValWord":1203,
    "ValDate":"2009-03-10T21:19:36","Next":0},{..}] *)
    // 1. get fields count from first row
    while P^<>'[' do if P^=#0 then exit else inc(P); // need an array of objects
    repeat inc(P); if P^=#0 then exit; until P^ in ['{',']']; // go to object beginning
    if P^=']' then begin // [] -> void data
      result := true;
      exit;
    end;
    inc(P);
    nfield := GetFieldCountExpanded(P);
    if nField=0 then
      exit; // invalid data for first row
    // 2. get values (assume fields are always the same as in the first object)
    max := nfield; // index to start storing values in fResults[]
    resmax := nfield*2;
    SetLength(fJSONResults,resmax); // space for field names + 1 data row
    nrow := 0;
    repeat // unescape+zeroify JSONData + fill U[] with pointer to values
      for i := 0 to nfield-1 do begin
        if nrow=0 then // get field name from 1st Row
          fJSONResults[i] := GetJSONPropName(P) else
          P := GotoNextJSONItem(P);  // ignore field name for later rows
        if max>=resmax then begin // check space inside loop for GPF security
          inc(resmax,resmax shr 3+nfield shl 8);
          SetLength(fJSONResults,resmax); // enough space for 256 more rows
        end;
        if P=nil then break; // normal end: no more field name
        fJSONResults[max] := GetJSONFieldOrObjectOrArray(P,@wasString,@EndOfObject,true); 
        if P=nil then begin
          nfield := 0;
          break; // unexpected end
        end;
        if (nrow=1) and wasString then // mark column was "string"
          Include(fFieldParsedAsString,max-nfield);
        inc(max);
      end;
      if P=nil then
        break; // unexpected end
      if EndOfObject<>'}' then
        break; // data field layout is not consistent: should never happen
      inc(nrow);
      while (P^<>'{') and (P^<>']') do // go to next object beginning
        if P^=#0 then
          exit else
          inc(P);
      if P^=']' then
        break else
        inc(P); // jmp '{'
    until false;
    if max<>(nrow+1)*nfield then begin // field count must be the same for all objects
      fFieldCount := 0;
      fRowCount := 0;
      exit; // data field layout is not consistent: should never happen
    end;
    // 3. save field pointers to fResults[]
    SetLength(fJSONResults,max); // resize to exact size
    fResults := @fJSONResults[0];
    fFieldCount := nfield;
    fRowCount := nrow;
  end;
  for i := 0 to fFieldCount-1 do
    if IsRowID(fResults[i]) then begin
      fFieldIndexID := i;
      break;
    end;
  result := true; // if we reached here, means successfull conversion from P^
end;

function TSQLTableJSON.UpdateFrom(const aJSON: RawUTF8; var Refreshed: boolean;
  PCurrentRow: PInteger): boolean;
var len: Integer;
begin
  len := length(aJSON);
  if PrivateCopyChanged(pointer(aJSON),len) then
    if ParseAndConvert(pointer(fPrivateCopy),len) then begin
     // parse success from new aJSON data -> need some other update?
     if Assigned(fIDColumn) then begin
       // ID column was hidden -> do it again
       Finalize(fIDColumn);
       IDColumnHide;
     end;
     with fSortParams do
       if FieldCount<>0 then
         // TSQLTable.SortFields() was called -> do it again
         SortFields(FieldIndex,Asc,PCurrentRow,FieldType);
     Refreshed := true;
     result := true;
    end else
      // parse error
      result := false else
    // data didn't change (fPrivateCopyHash checked)
    result := true;
end;

constructor TSQLTableJSON.Create(const aSQL: RawUTF8; JSONBuffer: PUTF8Char; JSONBufferLen: integer);
begin // don't raise exception on error parsing
  inherited Create(aSQL);
  ParseAndConvert(JSONBuffer,JSONBufferLen);
end;

constructor TSQLTableJSON.Create(const aSQL, aJSON: RawUTF8);
var len: integer;
begin
  len := length(aJSON);
  SetString(fPrivateCopy,PAnsiChar(pointer(aJSON)),len);
  Create(aSQL,pointer(fPrivateCopy),len);
end;

constructor TSQLTableJSON.CreateFromTables(const Tables: array of TSQLRecordClass;
  const aSQL: RawUTF8; JSONBuffer: PUTF8Char; JSONBufferLen: integer);
begin // don't raise exception on error parsing
  inherited CreateFromTables(Tables,aSQL);
  ParseAndConvert(JSONBuffer,JSONBufferLen);
end;

constructor TSQLTableJSON.CreateFromTables(const Tables: array of TSQLRecordClass; const aSQL,
  aJSON: RawUTF8);
var len: integer;
begin
  len := length(aJSON);
  SetString(fPrivateCopy,PAnsiChar(pointer(aJSON)),len);
  CreateFromTables(Tables,aSQL,pointer(fPrivateCopy),len);
end;

constructor TSQLTableJSON.CreateWithColumnTypes(const ColumnTypes: array of TSQLFieldType;
  const aSQL: RawUTF8; JSONBuffer: PUTF8Char; JSONBufferLen: integer);
begin // don't raise exception on error parsing
  inherited CreateWithColumnTypes(ColumnTypes,aSQL);
  ParseAndConvert(JSONBuffer,JSONBufferLen);
end;

constructor TSQLTableJSON.CreateWithColumnTypes(const ColumnTypes: array of TSQLFieldType;
  const aSQL, aJSON: RawUTF8);
var len: integer;
begin
  len := length(aJSON);
  SetString(fPrivateCopy,PAnsiChar(pointer(aJSON)),len);
  CreateWithColumnTypes(ColumnTypes,aSQL,pointer(fPrivateCopy),len);
end;


{ TINIWriter }

const
  sWriteObject1: PWinAnsiChar = #13'[%]'#13;
  sWriteObject2: PWinAnsiChar = '%%=%'#13;
  
procedure TINIWriter.WriteObject(Value: TObject; const SubCompName: RawUTF8='';
  WithSection: boolean=true);
var P: PPropInfo;
    i, V: integer;
    VT: shortstring; // for str()
    Obj: TObject;
    CP: PClassProp;
    WS: WideString;
    {$ifndef NOVARIANTS}
    VV: Variant;
    {$endif}
begin
  if Value<>nil then begin
    if WithSection then
      // new TObject.ClassName is UnicodeString (Delphi 20009) -> inline code with
      // vmtClassName = UTF-8 encoded text stored in a shortstring = -44
      Add(sWriteObject1,[PShortString(PPointer(PPtrInt(Value)^+vmtClassName)^)^]);
    CP := InternalClassProp(PPointer(Value)^);
    if CP=nil then
      exit;
    P := @CP^.PropList;
    for i := 1 to CP^.PropCount do begin
      case P^.PropType^^.Kind of
        tkInt64{$ifdef FPC}, tkQWord{$endif}:
          Add(sWriteObject2,[SubCompName,P^.Name,GetInt64Prop(Value,pointer(P))]);
        {$ifdef FPC}tkBool,{$endif}
        tkEnumeration, tkInteger, tkSet: begin
          V := GetOrdProp(Value,pointer(P)); // pointer() to call typinfo
          if V<>P^.Default then
            Add(sWriteObject2,[SubCompName,P^.Name,V]);
        end;
        {$ifdef FPC}tkAString,{$endif} tkLString:
          Add(sWriteObject2,[SubCompName,P^.Name,P^.GetLongStrValue(Value)]);
        tkFloat: begin
          VT[0] := AnsiChar(ExtendedToString(VT,GetFloatProp(Value,pointer(P)),DOUBLE_PRECISION));
          Add(sWriteObject2,[SubCompName,P^.Name,VT]);
        end;
        tkWString: begin
          GetWideStrProp(Value,P,WS);
          Add(sWriteObject2,[SubCompName,P^.Name,WS]);
        end;
        {$ifdef UNICODE}
        tkUString: // write converted to UTF-8
          Add(sWriteObject2,[SubCompName,P^.Name,GetUnicodeStrProp(Value,pointer(P))]);
        {$endif}
        tkDynArray: begin
          Add(sWriteObject2,[SubCompName,P^.Name]);
          AddDynArrayJSON(P^.GetDynArray(Value));
          Add(#13);
        end;
        {$ifdef PUBLISHRECORD}
        tkRecord:
          Add(sWriteObject2,[SubCompName,P^.Name,BinToBase64WithMagic(
            RecordSave(P^.GetFieldAddr(Value)^,P^.PropType^))]);
        {$endif}
        tkClass: begin
          Obj := pointer(GetOrdProp(Value,pointer(P)));  // works also for CPU64
          if (Obj<>nil) and Obj.InheritsFrom(TPersistent) then
             WriteObject(Obj,SubCompName+RawUTF8(P^.Name)+'.',false);
        end;
        {$ifndef NOVARIANTS}
        tkVariant: begin // stored as JSON, e.g. '1.234' or '"text"'
          GetVariantProp(Value,P,VV);
          Add(sWriteObject2,[SubCompName,P^.Name,VariantSaveJSON(VV)]);
        end;
        {$endif}
      end; // tkString (shortstring) is not handled
      P := P^.Next;
    end;
  end;
end;

function UTF8ContentType(P: PUTF8Char): TSQLFieldType;
var V: PUTF8Char;
    c: integer;
begin
  if P=nil then begin
    result := sftUnknown;
    exit;
  end;
  P := GotoNextNotSpace(P);
  V := P;
  if (PInteger(P)^=NULL_LOW) and (P[4]=#0) then
     result := sftUnknown else
  // don't check for 'false' or 'true' here, since their UTF-8 value is '0' or '1'
  if (P[0] in ['1'..'9']) or // is first char numeric?
     ((P[0]='0') and not (P[1] in ['0'..'9'])) or // '012' excluded by JSON
     ((P[0]='-') and (P[1] in ['0'..'9'])) then begin
    // check if P^ is a true numerical value
    result := sftInteger;
    repeat inc(P) until not (P^ in ['0'..'9']); // check digits
    if P^='.' then begin
      inc(P);
      if P^ in ['0'..'9'] then begin
        result := sftFloat;
        repeat inc(P) until not (P^ in ['0'..'9']); // check fractional digits
      end else begin
        result := sftUTF8Text; // invalid '23023.' value
        exit;
      end;
    end else
      if P-V>18 then begin
        Result := sftUTF8Text; // outside Int64 digits range
        exit; // even sftFloat precision won't be able to handle it
      end;
    if byte(P^) and $DF=ord('E') then begin
      result := sftFloat;
      inc(P);
      if P^='+' then inc(P) else
      if P^='-' then inc(P);
      while P^ in ['0'..'9'] do inc(P);
    end;
    P := GotoNextNotSpace(P);
    if P^<>#0 then // invalid numerical value -> test if not TDateTime
      if Iso8601ToTimeLogPUTF8Char(V,0)<>0 then
        result := sftDateTime else
        result := sftUTF8Text;
    exit;
  end else begin
    c := PInteger(V)^ and $00ffffff;
    if (c=JSON_BASE64_MAGIC) or ((V[1]='''') and isBlobHex(V)) then
      result := sftBlob else
    if c=JSON_SQLDATE_MAGIC then
      result := sftDateTime else
      result := sftUTF8Text;
  end;
end;


{ TPropInfo }

function TPropInfo.ClassFromJSON(Instance: TObject; From: PUTF8Char;
  var Valid: boolean; Options: TJSONToObjectOptions): PUTF8Char;
var Field: ^TObject;
    tmp: TObject;
begin
  valid := false;
  result := nil;
  if (@self=nil) or (PropType^^.Kind<>tkClass) or (Instance=nil) then
    exit;
  if PropWrap(SetProc).Kind=$FF then
    // setter to field -> direct in-memory access
    Field := Pointer(PtrInt(Instance)+SetProc and $00FFFFFF) else
  if SetProc<>0  then begin
    // it is a setter method -> create a temporary object
    tmp := PropType^.ClassCreate;
    try
      result := JSONToObject(tmp,From,Valid,nil,Options);
      if not Valid then
        tmp.Free else
        SetOrdProp(Instance,@self,PtrInt(tmp)); // PtrInt(tmp) is OK for CPU64
    except
      on Exception do
        tmp.Free;
    end;
    exit;
  end else
  if PropWrap(GetProc).Kind=$FF then
    // no setter -> use direct in-memory access from getter (if available)
    Field := Pointer(PtrInt(Instance)+GetProc and $00FFFFFF) else
    // no setter, nor direct field offset -> impossible to set the instance
    exit;
  result := JSONToObject(Field^,From,Valid,nil,Options);
end;

function TPropInfo.GetOrdValue(Instance: TObject): Integer;
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind in [
       tkInteger,tkEnumeration,tkSet,{$ifdef FPC}tkBool,{$endif}tkClass]) then
    result := GetOrdProp(Instance,pointer(@self)) else
    result := -1;
end;

function TPropInfo.GetInt64Value(Instance: TObject): Int64;
begin
  if (Instance<>nil) and (@self<>nil) then
  case PropType^^.Kind of
    tkInteger,tkEnumeration,tkSet,{$ifdef FPC}tkBool,{$endif}tkClass:
      result := GetOrdProp(Instance,pointer(@self));
    tkInt64{$ifdef FPC}, tkQWord{$endif}:
      result := GetInt64Prop(Instance,pointer(@self));
    else result := 0;
  end else
    result := 0;
end;

function TPropInfo.GetCurrencyValue(Instance: TObject): Currency;
begin
  if (Instance<>nil) and (@self<>nil) and (PropType^^.Kind=tkFloat) and
     (PropType^.FloatType=ftCurr) then
    result := GetCurrencyProp(Instance,pointer(@self)) else
    result := 0;
end;

function TPropInfo.GetExtendedValue(Instance: TObject): Extended;
begin
  if (Instance<>nil) and (@self<>nil) and (PropType^^.Kind=tkFloat) then
     result := GetFloatProp(Instance,pointer(@self)) else
     result := 0;
end;

procedure TPropInfo.SetExtendedValue(Instance: TObject; const Value: Extended);
begin
  if (Instance<>nil) and (@self<>nil) and (PropType^^.Kind=tkFloat) then
    SetFloatProp(Instance,pointer(@self),Value);
end;

function TPropInfo.GetDynArray(Instance: TObject): TDynArray;
begin
  result.Init(PropType^,GetFieldAddr(Instance)^);
end;

function TPropInfo.GetLongStrValue(Instance: TObject): RawUTF8;
var tmp: RawByteString;
begin
  result := '';
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind in [{$ifdef FPC}tkAString,{$endif}tkLString]) then
    if PropType^=TypeInfo(RawUTF8) then
      GetLongStrProp(Instance,pointer(@self),RawByteString(result)) else begin
      GetLongStrProp(Instance,pointer(@self),tmp);
      if tmp<>'' then
        if PropType^=TypeInfo(WinAnsiString) then
          result := WinAnsiToUTF8(WinAnsiString(tmp)) else
        if PropType^=TypeInfo(RawUnicode) then
          RawUnicodeToUTF8(pointer(tmp),length(tmp)shr 1,result) else
        if PropType^=TypeInfo(TSQLRawBlob) then
          result := TSQLRawBlobToBlob(TSQLRawBlob(tmp)) else
          // not a known LongStr type -> use generic AnsiString
          result := CurrentAnsiConvert.AnsiToUTF8(tmp);
    end;
end;

procedure TPropInfo.GetRawByteStringValue(Instance: TObject; var Value: RawByteString);
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind in [{$ifdef FPC}tkAString,{$endif}tkLString]) then
    GetLongStrProp(Instance,pointer(@self),Value) else
    Value := '';
end;

procedure TPropInfo.SetLongStrValue(Instance: TObject; const Value: RawUTF8);
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind in [{$ifdef FPC}tkAString,{$endif}tkLString]) then
  if (Value='') or (PropType^=TypeInfo(RawUTF8)) then
    SetLongStrProp(Instance,pointer(@self),Value) else 
  if PropType^=TypeInfo(WinAnsiString) then
    SetLongStrProp(Instance,pointer(@self),UTF8ToWinAnsi(Value)) else
  if PropType^=TypeInfo(RawUnicode) then
    SetLongStrProp(Instance,pointer(@self),Utf8DecodeToRawUnicode(Value)) else
  if PropType^=TypeInfo(TSQLRawBlob) then
    SetLongStrProp(Instance,pointer(@self),BlobToTSQLRawBlob(Value)) else
    // not a known LongStr type -> use generic AnsiString
    SetLongStrProp(Instance,pointer(@self),AnsiString(UTF8ToString(Value)));
end;

function TPropInfo.GetGenericStringValue(Instance: TObject): string;
begin
  if (Instance=nil) or (@self=nil) then
    result := '' else
    case PropType^^.Kind of
      {$ifdef FPC}tkAString,{$endif} tkLString:
        result := UTF8ToString(GetLongStrValue(Instance));
{$ifdef UNICODE}
      tkUString:
        result := GetUnicodeStrProp(Instance,pointer(@self));
{$endif}
     else result := '';
     end;
end;

procedure TPropInfo.SetGenericStringValue(Instance: TObject; const Value: string);
begin
  if (Instance<>nil) and (@self<>nil) then
    case PropType^^.Kind of
      {$ifdef FPC}tkAString,{$endif}tkLString:
         SetLongStrValue(Instance,StringToUtf8(Value));
{$ifdef UNICODE}
       tkUString:
         SetUnicodeStrProp(Instance,pointer(@self),Value);
{$endif}
    end;
end;

{$ifdef UNICODE}

function TPropInfo.GetUnicodeStrValue(Instance: TObject): UnicodeString;
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind=tkUString) then
    result := GetUnicodeStrProp(Instance,pointer(@self));
end;

procedure TPropInfo.SetUnicodeStrValue(Instance: TObject; const Value: UnicodeString);
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind=tkUString) then
    SetUnicodeStrProp(Instance,pointer(@self),Value);
end;
{$endif}

procedure TPropInfo.SetOrdValue(Instance: TObject; Value: Integer);
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind in [
       tkInteger,tkEnumeration,tkSet,{$ifdef FPC}tkBool,{$endif}tkClass]) then
    SetOrdProp(Instance,pointer(@self),Value);
end;

procedure TPropInfo.SetInt64Value(Instance: TObject; Value: Int64);
begin
  if (Instance<>nil) and (@self<>nil) then
  case PropType^^.Kind of
    tkInteger,tkEnumeration,tkSet,{$ifdef FPC}tkBool,{$endif}tkClass:
      SetOrdProp(Instance,pointer(@self),Value);
    tkInt64{$ifdef FPC}, tkQWord{$endif}:
      SetInt64Prop(Instance,pointer(@self),Value);
  end;
end;

procedure TPropInfo.CopyValue(Source, Dest: TObject);
var Value: RawByteString;
    WS: WideString;
    {$ifndef NOVARIANTS}
    V: variant;
    {$endif}
    S,D: TObject;
label i64, int, obj;
begin
  if (@self<>nil) and (Source<>nil) and (Dest<>Source) and (Dest<>nil) then
//    (PPointer(Source)^=PPointer(Dest)^) then // allow parent into child e.g.
  case PropType^^.Kind of
    {$ifdef FPC}tkBool,{$endif}
    tkEnumeration, tkInteger, tkSet, tkChar, tkWChar:
int:  SetOrdProp(Dest,pointer(@self),GetOrdProp(Source,pointer(@self)));
    tkClass:
    case PropType^^.ClassSQLFieldType of
      sftID:
        // special case for TSQLRecord published properties (sftID, sftRecord)
        if TSQLRecord(Source).fFill.JoinedFields then
          // -> pre-allocated fields by Create*Joined()
          goto obj else
          // -> these are not class instances, but INTEGER reference to records
          goto int;
      sftObject: begin
        // generic case: copy also class content (create instances)
obj:    S := pointer(GetOrdProp(Source,pointer(@self)));
        D := pointer(GetOrdProp(Dest,pointer(@self)));
        // note: Get/SetOrdProp() works also for CPU64 (returns an PtrInt)
{$ifndef LVCL}
        if S.InheritsFrom(TCollection) then
          CopyCollection(TCollection(S),TCollection(D)) else
{$endif}begin
          D.Free; // release previous child
          if S=nil then
            D := nil else begin
            D := ClassInstanceCreate(S.ClassType); // create new child instance
            CopyObject(S,D); // copy child content
          end;
          SetOrdProp(Dest,pointer(@self),PtrInt(D));
        end;
      end;
    end;
    tkInt64{$ifdef FPC}, tkQWord{$endif}:
      // works also with TTimeLog, Double and Currency
i64:  SetInt64Prop(Dest,pointer(@self),GetInt64Prop(Source,pointer(@self)));
    tkFloat:
    if (PropType^.FloatType in [ftDoub,ftCurr]) and
       (PropWrap(GetProc).Kind=$FF) and (PropWrap(SetProc).Kind=$FF) then
      goto I64 else
      SetFloatProp(Dest,pointer(@self),GetFloatProp(Source,pointer(@self)));
    {$ifdef FPC}tkAString,{$endif}
    tkLString: begin
      GetLongStrProp(Source,pointer(@self),Value);
      SetLongStrProp(Dest,pointer(@self),Value);
    end;
    {$ifdef UNICODE}
    tkUString:
      SetUnicodeStrProp(Dest,pointer(@self),GetUnicodeStrProp(Source,pointer(@self)));
    {$endif}
    tkWString: begin
      GetWideStrProp(Source,pointer(@self),WS);
      SetWideStrProp(Dest,pointer(@self),WS);
    end;
    tkDynArray:
      GetDynArray(Dest).Copy(GetDynArray(Source));
    tkRecord:
      RecordCopy(GetFieldAddr(Dest)^,GetFieldAddr(Source)^,PropType^);
    {$ifndef NOVARIANTS}
    tkVariant: begin // do not handle getter/setter yet
      GetVariantProp(Source,pointer(@self),V);
      SetVariantProp(Dest,pointer(@self),V);
    end;
    {$endif}
  end; // note: tkString (shortstring) not handled
end;

function TPropInfo.GetFieldAddr(Instance: TObject): pointer;
begin
  if PropWrap(GetProc).Kind<>$FF then
    // getter method -> check setter
    if PropWrap(SetProc).Kind<>$FF then
       // both are methods -> returns nil
      result := nil else
      //  field - Setter is the field offset in the instance data
      result := Pointer(PtrInt(Instance)+SetProc and $00FFFFFF) else
    // field - Getter is the field offset in the instance data
    result := Pointer(PtrInt(Instance)+GetProc and $00FFFFFF);
end;

function TPropInfo.IsBlob: boolean;
begin
  if @self=nil then
    result := false else
  with PropType^^ do
    result := (Kind in [{$ifdef FPC}tkAString,{$endif}tkLString]) and
      (PropType^=TypeInfo(TSQLRawBlob));
end;

function TPropInfo.IsStored(Instance: TObject): boolean;
type // function(Instance: TObject) trick does not work with CPU64 :(
  TStoredProc = function: Boolean of object;
var Call: TMethod;
begin
{$ifdef FPC} // extracted from IsStoredProp() function in typinfo.pp
  result := ((PropProcs shr 4) and 3=ptconst) and LongBool(StoredProc);
{$else}      // Delphi version
  if (StoredProc and (not PtrInt($ff)))=0 then
    result := boolean(StoredProc) else
  if Instance=nil then
    // field or method without Instance specified -> assume "stored true"
    result := true else
  if PropWrap(StoredProc).Kind=$ff then
    result := PBoolean(PtrInt(Instance)+StoredProc and $00FFFFFF)^ else begin
    if PropWrap(StoredProc).Kind=$fe then
      Call.Code := pointer((PPtrUInt(PPtrInt(Instance)^+SmallInt(StoredProc))^)) else
      Call.Code := pointer(StoredProc);
    Call.Data := Instance;
    result := TStoredProc(Call);
  end;
{$endif}
end;

{$ifdef FPC}

// extracted from typeinfo.pp
function aligntoptr(p : pointer): pointer; inline;
begin
{$ifdef FPC_REQUIRES_PROPER_ALIGNMENT}
   result := align(p,sizeof(p));
{$else FPC_REQUIRES_PROPER_ALIGNMENT}
   result := p;
{$endif FPC_REQUIRES_PROPER_ALIGNMENT}
end;

function TPropInfo.Next: PPropInfo;
begin
  result := aligntoptr(@Name[ord(Name[0])+1]);
end;
{$else}
{$ifdef HASINLINE}
function TPropInfo.Next: PPropInfo;
begin
  result := @Name[ord(Name[0])+1];
end;
{$else}
{$ifdef PUREPASCAL}
function TPropInfo.Next: PPropInfo;
begin
  result := @Name[ord(Name[0])+1];
end;
{$else}
function TPropInfo.Next: PPropInfo;
asm // very fast code
  movzx edx,byte ptr [eax].TPropInfo.Name
  lea eax,[eax+edx].TPropInfo.Name[1]
end;
{$endif}
{$endif}
{$endif}


{ TTypeInfo }

{$ifdef FPC}
function TTypeInfo.ClassType: PClassType;
begin // FPC can use memory alignment -> use GetTypeData() function
  if pointer(@self)<>nil then
    result := pointer(GetTypeData(pointer(@self))) else // use typinfo.pp function
    result := nil; // avoid GPF
end;
{$else}
{$ifdef PUREPASCAL}
function TTypeInfo.ClassType: PClassType;
begin
  result := @Name[ord(Name[0])+1];
end;
{$else}
function TTypeInfo.ClassType: PClassType;
asm // very fast code
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
end;
{$endif}
{$endif}

function TTypeInfo.ClassCreate: TObject;
begin
  result := ClassInstanceCreate(ClassType^.ClassType);
end;

{$ifdef FPC}
function TTypeInfo.RecordType: PRecordType; 
begin // FPC can use memory alignment -> use GetTypeData() function
  if pointer(@self)<>nil then
    result := pointer(GetTypeData(pointer(@self))) else // use typinfo.pp function
    result := nil; // avoid GPF
end;
{$else}
{$ifdef PUREPASCAL}
function TTypeInfo.RecordType: PRecordType;
begin
  result := @Name[ord(Name[0])+1];
end;
{$else}
function TTypeInfo.RecordType: PRecordType;
asm // very fast code
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
end;
{$endif}
{$endif}

function TTypeInfo.ClassSQLFieldType: TSQLFieldType;
var CT: PClassType;
begin
  {$ifdef FPC}
  CT := pointer(GetTypeData(pointer(@self))); // use typinfo.pp function
  {$else}
  CT := PClassType(@Name[ord(Name[0])+1]);
  {$endif}
  while true do // unrolled three InheritsFrom() calls
    if CT^.ClassType<>TSQLRecordMany then
    if CT^.ClassType<>TSQLRecord then
    if (CT^.ClassType<>TPersistent) and (CT^.ClassType<>TRawUTF8List) then
      if CT^.ParentInfo<>nil then
        {$ifdef FPC}
        CT := CT^.ParentInfo^^.ClassTypes // use typinfo.pp function
        {$else}
        with CT^.ParentInfo^^ do
          CT := @Name[ord(Name[0])+1] // get parent ClassType
        {$endif}
      else break
    else begin
      result := sftObject; // published properties, TStrings TRawUTF8List TCollection
      exit;
    end else begin
      result := sftID; // TSQLRecord field value is pointer(RecordID), not any Instance
      exit;
    end else begin
      result := sftMany; // no data is stored here, but in a pivot table
      exit;
    end;
  result := sftUnknown;
end;

{$ifdef FPC}
function TTypeInfo.EnumBaseType: PEnumType;
begin // FPC can use memory alignment -> use GetTypeData() function
  result := pointer(GetTypeData(PEnumType(GetTypeData(pointer(@self)))^.BaseType^);
end;
{$else}
{$ifdef PUREPASCAL}
function TTypeInfo.EnumBaseType: PEnumType;
begin
  with PEnumType(@Name[ord(Name[0])+1])^.BaseType^^ do
    result := @Name[ord(Name[0])+1];
end;
{$else}
function TTypeInfo.EnumBaseType: PEnumType;
asm // very fast code
  movzx edx,byte ptr [eax].TTypeInfo.Name
  mov eax,[eax+edx].TTypeInfo.Name[1].TEnumType.BaseType
  mov eax,[eax]
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
end;
{$endif}
{$endif}

{$ifdef PUREPASCAL}
function TTypeInfo.InheritsFrom(AClass: TClass): boolean;
var CT: PClassType;
begin
  CT := ClassType;
  while CT<>nil do begin
    if CT^.ClassType=pointer(AClass) then begin
      result := true;
      exit;
    end;
    if CT^.ParentInfo=nil then
      break else
      CT := CT^.ParentInfo^.ClassType;
  end;
  result := false;
end;
{$else}
function TTypeInfo.InheritsFrom(AClass: TClass): boolean;
asm // eax=PClassType edx=AClass
@1:movzx ecx,byte ptr [eax].TTypeInfo.Name
   lea eax,[eax+ecx].TTypeInfo.Name[1]
   cmp edx,[eax].TClassType.ClassType
   jz @2
   mov eax,[eax].TClassType.ParentInfo
   or eax,eax
   jz @3 // no parent
   mov eax,[eax] // get parent type info
   jmp @1
@2:mov al,1
@3:
end;
{$endif}

function TTypeInfo.SQLFieldType: TSQLFieldType;
begin // very fast, thanks to the TypeInfo() compiler-generated function
  case Kind of
    tkInteger:
      if (@self=TypeInfo(TRecordReference)) or
         (@self=TypeInfo(TRecordReferenceToBeDeleted)) then begin
        result := sftRecord;
        exit; // direct exit is faster in generated asm code (Delphi 7 at least)
      end else begin
        result := sftInteger;
        exit;
      end;
    tkInt64:
      if @self=TypeInfo(TCreateTime) then begin
        result := sftCreateTime;
        exit;
      end else
      if @self=TypeInfo(TModTime) then begin
        result := sftModTime;
        exit;
      end else
      if @self=TypeInfo(TTimeLog) then begin
        result := sftTimeLog;
        exit;
      end else begin
        result := sftInteger;
        exit;
      end;
    {$ifdef FPC}
    tkBool: begin
      result := sftBoolean;
      exit;
    end;
    {$endif}
    tkSet: begin
      result := sftSet;
      exit;
    end;
    tkEnumeration:
      {$ifndef FPC}
      if @self=TypeInfo(Boolean) then begin
        result := sftBoolean;
        exit;
      end else
      {$endif}
      begin
        result := sftEnumerate;
        exit;
      end;
    tkFloat:
      if @self=TypeInfo(Currency) then begin
        result := sftCurrency;
        exit;
      end else
      if @self=TypeInfo(TDateTime) then begin
        result := sftDateTime;
        exit;
      end else begin
        result := sftFloat;
        exit;
      end;
      {$ifdef FPC}tkAString,{$endif} tkLString:
      if (@self=TypeInfo(RawUTF8)) or (@self=TypeInfo(RawUnicode)) then begin
        result := sftUTF8Text;
        exit;
      end else
      if @self=TypeInfo(TSQLRawBlob) then begin
        result := sftBlob;
        exit;
      end else begin
        result := sftAnsiText;
        exit;
      end;
    {$ifdef UNICODE}tkUString,{$endif} tkChar, tkWChar, tkWString: begin
      result := sftUTF8Text;
      exit;
    end;
    tkDynArray: begin
      result := sftBlobDynArray;
      exit;
    end;
    {$ifdef PUBLISHRECORD}
    tkRecord: begin
      result := sftUTF8Custom;
      exit;
    end;
    {$endif}
    {$ifndef NOVARIANTS}
    tkVariant: begin
      result := sftVariant;
      exit;
    end;
    {$endif}
    tkClass: begin
      result := ClassSQLFieldType;
      exit;
    end;
    // note: tkString (shortstring) not handled
    else begin
      result := sftUnknown;
      exit;
    end;
  end;
end;

{$ifdef FPC}
function TTypeInfo.FloatType: TFloatType;
type PFloatType = ^TFloatType;
begin // FPC can use memory alignment -> use GetTypeData() function
  result := PFloatType(GetTypeData(pointer(@self)))^; // use typinfo.pp function
end;
{$else}
function TTypeInfo.FloatType: TFloatType;
begin
  result := TFloatType(Name[ord(Name[0])+1]);
end;
{$endif}

{$ifdef FPC}
function TTypeInfo.OrdType: TOrdType;
type POrdType = ^TOrdType;
begin // FPC can use memory alignment -> use GetTypeData() function
  result := POrdType(GetTypeData(pointer(@self)))^; // use typinfo.pp function
end;
{$else}
function TTypeInfo.OrdType: TOrdType;
begin
  result := TOrdType(Name[ord(Name[0])+1]);
end;
{$endif}

{$ifdef FPC}
function TTypeInfo.SetEnumType: PEnumType;
begin // FPC can use memory alignment -> use GetTypeData() function
  result := PTypeInfo(GetTypeData(pointer(@self))^.CompType^).EnumBaseType;
end;
{$else}
function TTypeInfo.SetEnumType: PEnumType;
begin
  result := PPTypeInfo(PPointer(@Name[ord(Name[0])+(1+sizeof(TOrdType))])^)^.EnumBaseType;
end;
{$endif}


{ TClassProp }

function TClassProp.FieldCountWithParents: integer;
var aClassType: TClass;
    CP: PClassProp;
begin
  result := 0;
  if @self=nil then
    exit;
  aClassType := TClass(@self);
  repeat
    CP := InternalClassProp(aClassType);
    if CP=nil then
      break; // no RTTI information (e.g. reached TObject level)
    inc(result,CP^.PropCount);
    aClassType := aClassType.ClassParent;
  until aClassType=nil;
end;

function TClassProp.FieldProp(const PropName: shortstring): PPropInfo;
var i: integer;
begin
  if @self<>nil then begin
    result := @PropList;
    for i := 1 to PropCount do
      if IdemPropName(result^.Name,PropName) then
        exit else
        result := result^.Next;
  end;
  result := nil;
end;

{ TClassType }

{$ifdef FPC}
function TClassType.ClassProp: PClassProp;
begin
  if pointer(@self)<>nil then
    result := aligntoptr(@UnitName[ord(UnitName[0])+1]) else
    result := nil; // avoid GPF
end;
{$else}
function TClassType.ClassProp: PClassProp;
begin
  if pointer(@self)<>nil then
    result := pointer(@UnitName[ord(UnitName[0])+1]) else
    result := nil; // avoid GPF
end;
{$endif}

function TClassType.RTTISize: integer;
var C: PClassProp;
    P: PPropInfo;
    i: Integer;
begin
  result := 0;
  C := ClassProp;
  if C=nil then
    exit;
  P := @C^.PropList;
  for i := 1 to C^.PropCount do
    P := P^.Next;
  result := PtrUInt(P)-PtrUInt(@self);
end;

{$ifdef PUREPASCAL}
function TClassType.InheritsFrom(AClass: TClass): boolean;
var P: PPTypeInfo;
begin
  result := true;
  if ClassType=AClass then
    exit;
  P := ParentInfo;
  while P<>nil do
    with P^.ClassType^ do
    if ClassType=AClass then
      exit else
      P := ParentInfo;
  result := false;
end;
{$else}
function TClassType.InheritsFrom(AClass: TClass): boolean;
asm // eax=PClassType edx=AClass
    cmp [eax].TClassType.ClassType,edx
    jz @3
@2: mov eax,[eax].TClassType.ParentInfo
    or eax,eax
    jz @0
@1: mov eax,[eax]
    movzx ecx,byte ptr [eax].TTypeInfo.Name
    lea eax,[eax+ecx].TTypeInfo.Name[1]
    cmp edx,[eax].TClassType.ClassType
    jnz @2
@3: mov al,1
@0:
end;
{$endif}


{ TEnumType }

function TEnumType.GetEnumName(const Value): PShortString;
var Ordinal: integer;
begin
  if MaxValue<=255 then
    Ordinal := byte(Value) else
    Ordinal := word(Value);
  result := GetEnumNameOrd(Ordinal);
end;

function TEnumType.GetEnumNameOrd(Value: Integer): PShortString;
// note: FPC doesn't align NameList (cf. GetEnumName() function in typinfo.pp)
{$ifdef PUREPASCAL}
begin
  result := @NameList;
  if cardinal(Value)<=cardinal(MaxValue) then
    while Value>0 do begin
      dec(Value);
      inc(PtrUInt(result),ord(result^[0])+1);
    end else
    result := @NULL_SHORTSTRING;
end;
{$else}
asm // eax=PEnumType edx=Value
    cmp edx,[eax].TEnumType.MaxValue
    lea eax,[eax].TEnumType.NameList
    ja @z
    or edx,edx
    jz @2
    xor ecx,ecx
@1: mov cl,[eax]
    dec edx
    lea eax,[eax+ecx+1]
    jnz @1
@2: ret
@z: lea eax,NULL_SHORTSTRING
end;
{$endif}

function TEnumType.GetEnumNameValue(Value: PUTF8Char; ValueLen: integer): Integer;
var PS: PShortString;
    P: PUTF8Char;
    PLen: integer;
begin
  PS := @NameList;
  if (Value<>nil) and (ValueLen>0) then begin
    if Value^ in ['a'..'z'] then
      // e.g. 'sllWarning'
      for result := 0 to MaxValue do
        if IdemPropName(PS^,Value,ValueLen) then
          exit else
          inc(PtrUInt(PS),ord(PS^[0])+1) else begin
      // e.g. 'Warning'
      for result := 0 to MaxValue do begin
        PLen := Length(PS^);
        P := @PS^[1];
        while (PLen>0) and (P^ in ['a'..'z']) do begin
          inc(P);
          dec(PLen);
        end;
        if (PLen>0) and IdemPropName(Value,P,ValueLen,PLen) then
          exit else
          inc(PtrUInt(PS),ord(PS^[0])+1);
      end;
    end;
  end;
  result := -1;
end;

function TEnumType.GetEnumNameValue(const EnumName: ShortString): Integer;
begin
  result := GetEnumNameValue(@EnumName[1],ord(EnumName[0]));
end;

function TEnumType.GetEnumNameValue(Value: PUTF8Char): Integer;
begin
  result := GetEnumNameValue(Value,StrLen(Value));
end;

{$ifdef HASINLINE}
function TEnumType.GetEnumNameTrimed(const Value): RawUTF8;
begin
  result := TrimLeftLowerCaseShort(GetEnumName(Value));
end;
{$else}
{$ifdef PUREPASCAL}
function TEnumType.GetEnumNameTrimed(const Value): RawUTF8;
begin
  result := TrimLeftLowerCaseShort(GetEnumName(Value));
end;
{$else}
function TEnumType.GetEnumNameTrimed(const Value): RawUTF8;
asm
  push ecx
  call TEnumType.GetEnumName
  pop edx
  jmp TrimLeftLowerCaseShort
end;
{$endif}
{$endif}

function TEnumType.GetCaption(const Value): string;
// GetCaptionFromPCharLen() expect ASCIIz -> use temp RawUTF8
begin
  GetCaptionFromPCharLen(pointer(GetEnumNameTrimed(Value)),result);
end;

procedure TEnumType.GetEnumNameTrimedAll(var result: RawUTF8);
var i: integer;
    V: PShortString;
begin
  with TTextWriter.CreateOwnedStream(1024) do
  try
    V := @NameList;
    for i := MinValue to MaxValue do begin
      AddTrimLeftLowerCase(V);
      Add(',');
      inc(PtrUInt(V),length(V^)+1);
    end;
    CancelLastComma;
    SetText(result);
  finally
    Free;
  end;
end;

procedure TEnumType.AddCaptionStrings(Strings: TStrings; UsedValuesBits: Pointer=nil);
var i, L: integer;
    Line: array[byte] of AnsiChar;
    P: PAnsiChar;
    V: PShortString;
    s: string;
begin
  if @self=nil then
    exit;
  {$ifndef LVCL}
  Strings.BeginUpdate;
  try
  {$endif}
    V := @NameList;
    for i := MinValue to MaxValue do begin
      if (UsedValuesBits=nil) or
         GetBit(UsedValuesBits^,i) then begin
        L := ord(V^[0]);
        P := @V^[1];
        while (L>0) and (P^ in ['a'..'z']) do begin // ignore left lowercase chars
          inc(P);
          dec(L);
        end;
        if L=0 then begin
          L := ord(V^[0]);
          P := @V^[1];
        end;
        Line[L] := #0; // GetCaptionFromPCharLen() expect it as ASCIIZ
        move(P^,Line,L);
        GetCaptionFromPCharLen(Line,s);
        Strings.AddObject(s,pointer(i));
      end;
      inc(PtrUInt(V),length(V^)+1);
    end;
  {$ifndef LVCL}
  finally
    Strings.EndUpdate;
  end;
  {$endif}
end;

function TEnumType.GetCaptionStrings(UsedValuesBits: Pointer=nil): string;
var List: TStringList;
begin
  List := TStringList.Create;
  try
    AddCaptionStrings(List,UsedValuesBits);
    result := List.Text;
  finally
    List.Free;
  end;
end;

function TEnumType.GetEnumNameTrimedValue(const EnumName: ShortString): Integer;
var P: PUTF8Char;
    L: integer;
    V: PShortString;
begin
  V := @NameList;
  for result := 0 to MaxValue do begin
    L := ord(V^[0]);
    P := @V^[1];
    while (L>0) and (P^ in ['a'..'z']) do begin  // ignore left lowercase chars
      inc(P);
      dec(L);
    end;
    if L=0 then begin // no uppercase in this enum value caption -> try whole
      if IdemPropName(EnumName,V^) then
        exit;
    end else // P^ points to the first uppercase char in this enum value caption
      if IdemPropName(EnumName,P,L) then
        exit;
    inc(PtrUInt(V),length(V^)+1);
  end;
  result := -1;
end;

function TEnumType.GetEnumNameTrimedValue(Value: PUTF8Char): Integer;
var EnumName: shortstring; // temporary string
begin
  if Value=nil then
    result := -1 else begin
    EnumName := Value;
    result := GetEnumNameTrimedValue(EnumName);
  end;
end;


function SQLFromWhere(const Where: RawUTF8): RawUTF8;
begin
  if Where='' then
    result := '' else
  if IdemPChar(pointer(Where),'ORDER BY ') or
     IdemPChar(pointer(Where),'GROUP BY ') or
     IdemPChar(pointer(Where),'LIMIT ') then
    result := ' '+Where else
    result := ' WHERE '+Where;
end;

function SQLFromSelect(const TableName, Select, Where, SimpleFields: RawUTF8): RawUTF8;
begin
  if Select='*' then
     // don't send BLOB values to query: retrieve all other fields
    result := 'SELECT '+SimpleFields  else
    result := 'SELECT '+Select;
  result := result+' FROM '+TableName+SQLFromWhere(Where)+';';
end;


{ TSQLRecordFill }

function TSQLRecordFill.GetJoinedFields: boolean;
begin
  if self=nil then
    result := false else
    result := fJoinedFields;
end;

procedure TSQLRecordFill.AddMap(aRecord: TSQLRecord; aField: TSQLPropInfo;
  aIndex: integer);
begin
  if (self=nil) or (aRecord=nil) then
    exit;
  if fTableMapCount>=length(fTableMap) then
    SetLength(fTableMap,fTableMapCount+fTableMapCount shr 1+16);
  with fTableMap[fTableMapCount] do begin
    Dest := aRecord;
    DestField := aField;
    TableIndex := aIndex;
    inc(fTableMapCount);
  end;
end;

procedure TSQLRecordFill.AddMap(aRecord: TSQLRecord; const aFieldName: RawUTF8;
  aIndex: integer);
var aFieldIndex: integer;
begin
  if (self<>nil) and (aRecord<>nil) then
    if IsRowID(pointer(aFieldName)) then
      AddMap(aRecord,nil,aIndex) else
      with aRecord.RecordProps do begin
        aFieldIndex := Fields.IndexByName(aFieldName);
        if aFieldIndex>=0 then begin // only map if column name is a valid field
          include(fTableMapFields,aFieldIndex);
          AddMap(aRecord,Fields.List[aFieldIndex],aIndex);
        end;
      end;
end;

procedure TSQLRecordFill.AddMapSimpleFields(aRecord: TSQLRecord;
  const aProps: array of TSQLPropInfo; var aIndex: integer);
var i: integer;
begin
  AddMap(aRecord,nil,aIndex);
  inc(aIndex);
  for i := 0 to high(aProps) do
  if aProps[i].SQLFieldType<>sftID then begin
    AddMap(aRecord,aProps[i],aIndex);
    inc(aIndex);
  end;
end;

destructor TSQLRecordFill.Destroy;
begin
  try
    UnMap; // release fTable instance if necessary
  finally
    inherited;
  end;
end;

function TSQLRecordFill.Fill(aRow: integer): Boolean;
begin
  if (self=nil) or (Table=nil) or (cardinal(aRow)>cardinal(Table.RowCount)) then
    Result := False else begin
    Fill(@Table.fResults[aRow*Table.FieldCount]);
    Result := True;
  end;
end;

function TSQLRecordFill.Fill(aRow: integer; aDest: TSQLRecord): Boolean;
begin
  if (self=nil) or (aDest=nil) or
     (Table=nil) or (cardinal(aRow)>cardinal(Table.RowCount)) then
    Result := False else begin
    Fill(@Table.fResults[aRow*Table.FieldCount],aDest);
    Result := True;
  end;
end;

procedure TSQLRecordFill.Fill(aTableRow: PPUtf8CharArray);
var f: integer;
begin
  if (self<>nil) and (aTableRow<>nil) then
    for f := 0 to fTableMapCount-1 do
      with fTableMap[f] do
        if DestField=nil then
          Dest.ID := GetInteger(aTableRow[TableIndex]) else
          DestField.SetValue(Dest,aTableRow[TableIndex],false);
end;

procedure TSQLRecordFill.Fill(aTableRow: PPUtf8CharArray; aDest: TSQLRecord);
var f: integer;
begin
  if (self<>nil) and (aTableRow<>nil) then
  for f := 0 to fTableMapCount-1 do
    with fTableMap[f] do
      if DestField=nil then
        aDest.ID := GetInteger(aTableRow[TableIndex]) else
        DestField.SetValue(aDest,aTableRow[TableIndex],false);
end;

procedure TSQLRecordFill.Map(aRecord: TSQLRecord; aTable: TSQLTable;
  aCheckTableName: TSQLCheckTableName);
var f: integer;
    ColumnName: PUTF8Char;
    FieldName: shortstring;
    Props: TSQLRecordProperties;
begin
  if (aTable=nil) or (aTable.fResults=nil) then // avoid any GPF
    exit;
  fTable := aTable;
  Props := aRecord.RecordProps;
  for f := 0 to aTable.FieldCount-1 do begin
    ColumnName := aTable.fResults[f];
    if aCheckTableName=ctnNoCheck then
      FieldName := ColumnName else
      if IdemPChar(ColumnName,pointer(Props.SQLTableNameUpperWithDot)) then
        FieldName := ColumnName+length(Props.SQLTableNameUpperWithDot) else
        if aCheckTableName=ctnMustExist then
          continue else
          FieldName := ColumnName;
    AddMap(aRecord,FieldName,f);
  end;
  fFillCurrentRow := 1; // point to first data row (0 is field names)
end;

procedure TSQLRecordFill.UnMap;
var i: integer;
begin
  if self=nil then
    exit;
  fTableMapCount := 0;
  fFillCurrentRow :=  0;
  // release TSQLRecordMany.fDestID^ instances set by TSQLRecord.FillPrepareMany()
  for i := 0 to high(fTableMapRecordManyInstances) do
  with fTableMapRecordManyInstances[i] do begin
    TObject(fDestID^).Free;
    fDestID^ := 0;
    fSourceID^ := 0;
  end;
  SetLength(fTableMapRecordManyInstances,0);
  FillChar(fTableMapFields,sizeof(fTableMapFields),0);
  // free any previous fTable if necessary
  if Table<>nil then
  try
    if Table.OwnerMustFree then
      Table.Free;
  finally
    fTable := nil;
  end;
end;


{ TSQLRecord }

constructor TSQLRecord.Create;
var i: integer;
begin
  // auto-instanciate any TSQLRecordMany instance
  with RecordProps do
    if pointer(ManyFields)<>nil then
    for i := 0 to high(ManyFields) do
      ManyFields[i].SetInstance(self,TSQLRecordClass(ManyFields[i].ObjectClass).Create);
end;

constructor TSQLRecord.Create(const aSimpleFields: array of const; aID: integer);
begin
  Create;
  fID := aID;
  if not SimplePropertiesFill(aSimpleFields) then
    raise EORMException.CreateFmt('Incorrect %s.Create(aSimpleFields) call',[ClassName]);
end;

function TSQLRecord.CreateCopy: TSQLRecord;
var i: integer;
begin
  // create new instance
  if self=nil then begin
    result := nil;
    exit;
  end;
  result := RecordClass.Create;
  // copy properties content
  result.fID := fID;
  with RecordProps do
    for i := 0 to high(CopiableFields) do
      CopiableFields[i].CopyValue(self,Result);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; aID: integer; ForUpdate: boolean=false);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(aID,self,ForUpdate);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; aPublishedRecord: TSQLRecord; ForUpdate: boolean);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(aPublishedRecord.ID,self,ForUpdate);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; const aSQLWhere: RawUTF8);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(aSQLWhere,self);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
  const BoundsSQLWhere: array of const);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere),self);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
  const ParamsSQLWhere, BoundsSQLWhere: array of const);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(FormatUTF8(FormatSQLWhere,ParamsSQLWhere,BoundsSQLWhere),self);
end;

class procedure TSQLRecord.InitializeTable(Server: TSQLRestServer; const FieldName: RawUTF8);
var f: integer;
begin // is not part of TSQLRecordProperties because has been declared as virtual
  if (self<>nil) and (Server<>nil) then begin
    if (FieldName='') or IsRowID(pointer(FieldName)) then
      Server.CreateSQLIndex(self,'ID',true); // for external tables
    with RecordProps do
    for f := 0 to Fields.Count-1 do
      with Fields.List[f] do
      if (SQLFieldType in [sftRecord, sftID]) or
         (aIsUnique in Attributes) then
        if (FieldName='') or IdemPropNameU(FieldName,Name) then
            Server.CreateSQLIndex(self,Name,false);
  end; // failure in Server.CreateSQLIndex() above is ignored (may already exist)
end;

procedure TSQLRecord.FillFrom(aRecord: TSQLRecord);
var i, f: integer;
    S, D: TSQLRecordProperties;
    wasString: boolean;
    tmp: RawUTF8;
begin
  if (self=nil) or (aRecord=nil) or not InheritsFrom(aRecord.ClassType) then
    exit;
  S := aRecord.RecordProps;
  if PSQLRecordClass(aRecord)^=PSQLRecordClass(Self)^ then begin
    fID := aRecord.fID; // same class -> ID values will match
    for f := 0 to high(S.CopiableFields) do
      S.CopiableFields[f].CopyValue(aRecord,self);
    exit;
  end;
  D := RecordProps;
  for i := 0 to high(S.CopiableFields) do begin
    f := D.Fields.IndexByName(S.CopiableFields[i].Name);
    if f>=0 then
      if S.CopiableFields[i].ClassType=D.Fields.List[f].ClassType then
        S.CopiableFields[f].CopyValue(aRecord,self) else begin
        S.CopiableFields[i].GetValueVar(aRecord,False,tmp,@wasString);
        D.Fields.List[f].SetValue(Self,Pointer(tmp),wasString);
      end;
    end;
end;

procedure TSQLRecord.FillFrom(Table: TSQLTable; Row: integer);
begin
  try
    FillPrepare(Table);
    if Table.InternalState<>fInternalState then
      fInternalState := Table.InternalState;
    FillRow(Row);
  finally
    FillClose; // avoid GPF in TSQLRecord.Destroy
  end;
end;

procedure TSQLRecord.FillFrom(const JSONTable: RawUTF8; Row: integer);
var Table: TSQLTableJSON;
    PrivateCopy: RawUTF8;
begin
  PrivateCopy := JSONTable;
  Table := TSQLTableJSON.Create('',@PrivateCopy[1],length(PrivateCopy));
  try
    FillFrom(Table,Row);
  finally
    Table.Free;
  end;
end;

procedure TSQLRecord.FillFrom(const JSONRecord: RawUTF8);
var tmp: pointer; // FillFrom() modifies the buffer memory: work on a copy
    P: PUTF8Char;
    L: integer;
begin
  P := pointer(JSONRecord);
  if P<>nil then begin
    L := PInteger(P-4)^+1; // +1 for last #0
    getmem(tmp,L);
    try
      move(P^,tmp^,L); // make a working copy of the JSON text (including #1)
      FillFrom(tmp); // now we can safely call FillFrom()
    finally
      Freemem(tmp);
    end;
  end;
end;

procedure TSQLRecord.FillFrom(P: PUTF8Char);
(* two possible formats = first not expanded, 2nd is expanded (most useful)
 {"fieldCount":9,"values":["ID","Int","Test","Unicode","Ansi","ValFloat","ValWord",
  "ValDate","Next",0,0,"abcde+ef++","abcde+ef++","abcde+ef++",
  3.14159265300000E+0000,1203,"2009-03-10T21:19:36",0]}
 {"ID":0,"Int":0,"Test":"abcde+ef++","Unicode":"abcde+ef++","Ansi":
 "abcde+ef++","ValFloat": 3.14159265300000E+0000,"ValWord":1203,
 "ValDate":"2009-03-10T21:19:36","Next":0} *)
var F: array[0..MAX_SQLFIELDS-1] of PUTF8Char; // store field/property names
    wasString: boolean;
    i, n: integer;
    Prop, Value: PUTF8Char;
begin
  // go to start of object
  if P=nil then
    exit;
  while P^<>'{' do
    if P^=#0 then exit else inc(P);
  if Expect(P,FIELDCOUNT_PATTERN) then begin
    // not expanded format
    n := GetJSONIntegerVar(P)-1;
    if cardinal(n)>high(F) then
      exit;
    if Expect(P,ROWCOUNT_PATTERN) then
      GetJSONIntegerVar(P); // just ignore "rowCount":.. here
    if not Expect(P,VALUES_PATTERN) then
      exit;
    for i := 0 to n do
      F[i] := GetJSONField(P,P); 
    for i := 0 to n do begin
      Value := GetJSONFieldOrObjectOrArray(P,@wasString,nil,true);
      FillValue(F[i],Value,wasString); // set properties from values
    end;
  end else
  if P^='{' then begin
    // expanded format
    inc(P);
    repeat
      Prop := GetJSONPropName(P);
      if (Prop=nil) or (P=nil) then break;
      Value := GetJSONFieldOrObjectOrArray(P,@wasString,nil,true);
      FillValue(Prop,Value,wasString); // set property from value
    until P=nil;
  end;
end;

procedure TSQLRecord.FillPrepare(Table: TSQLTable; aCheckTableName: TSQLCheckTableName);
begin
  if self=nil then
    exit;
  if fFill=nil then
    fFill := TSQLRecordFill.Create else
    fFill.UnMap;
  fFill.Map(self,Table,aCheckTableName);
end;

function TSQLRecord.FillPrepare(aClient: TSQLRest; const aSQLWhere: RawUTF8;
  const aCustomFieldsCSV: RawUTF8; aCheckTableName: TSQLCheckTableName): boolean;
var T: TSQLTable;
begin
  result := false;
  FillClose; // so that no further FillOne will work
  if (self=nil) or (aClient=nil) then
    exit;
  T := aClient.MultiFieldValues(RecordClass,aCustomFieldsCSV,aSQLWhere);
  if T=nil then
    exit;
  T.OwnerMustFree := true;
  FillPrepare(T,aCheckTableName);
  result := true;
end;

function TSQLRecord.FillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
  const BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8=''): boolean;
begin
  if (FormatSQLWhere=nil) or (high(BoundsSQLWhere)<0) then
    result := false else
    result := FillPrepare(aClient,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere),
      aCustomFieldsCSV);
end;

function TSQLRecord.FillPrepare(aClient: TSQLRest;
  FormatSQLWhere: PUTF8Char; const ParamsSQLWhere, BoundsSQLWhere: array of const;
  const aCustomFieldsCSV: RawUTF8): boolean;
begin
  if (FormatSQLWhere=nil) or ((high(ParamsSQLWhere)<0)and(high(BoundsSQLWhere)<0)) then
    result := false else
    result := FillPrepare(aClient,
      FormatUTF8(FormatSQLWhere,ParamsSQLWhere,BoundsSQLWhere),aCustomFieldsCSV);
end;

function TSQLRecord.FillPrepare(aClient: TSQLRest; const aIDs: array of integer;
  const aCustomFieldsCSV: RawUTF8=''): boolean;
begin
  if high(aIDs)<0 then
    result := false else
    result := FillPrepare(aClient,
      IntegerDynArrayToCSV(aIDs,length(aIDs),'ID in (',')'),aCustomFieldsCSV);
end;

procedure TSQLRecord.FillRow(aRow: integer; aDest: TSQLRecord=nil);
begin
  if self<>nil then
    if aDest=nil then
      fFill.Fill(aRow) else
      if fFill.fTableMapRecordManyInstances=nil then
        fFill.Fill(aRow,aDest) else
        raise EBusinessLayerException.Create('FillRow() forbidden after FillPrepareMany');
end;

function TSQLRecord.FillOne: boolean;
begin
  if (self=nil) or (fFill=nil) or (fFill.Table=nil) or
     (fFill.Table.RowCount=0) or // also check if FillTable is emtpy
     (cardinal(fFill.FillCurrentRow)>cardinal(fFill.Table.RowCount)) then
    result := false else begin
    FillRow(fFill.FillCurrentRow);
    inc(fFill.fFillCurrentRow);
    result := true;
  end;
end;

function TSQLRecord.FillRewind: boolean;
begin
  if (self=nil) or (fFill=nil) or (fFill.Table=nil) or (fFill.Table.RowCount=0) then
    result := false else begin
    fFill.fFillCurrentRow := 1;
    result := true;
  end;
end;

procedure TSQLRecord.FillClose;
begin
  if self<>nil then
    fFill.UnMap;
end;

procedure TSQLRecord.FillValue(PropName: PUTF8Char; Value: PUTF8Char; wasString: boolean);
var field: TSQLPropInfo;
begin
  if self<>nil then
    if IsRowID(pointer(PropName)) then
      fID := GetInteger(Value) else begin
      field := RecordProps.Fields.ByName(PropName);
      if field<>nil then
        field.SetValue(self,Value,wasString);
    end;
end;

function TSQLRecord.SetFieldSQLVars(const Values: TSQLVarDynArray): boolean;
var max, field: integer;
begin
  result := false;
  max := high(Values);
  with RecordProps do begin
    // expect exact Values[] type match with FieldType[]
    if max<>Fields.Count-1 then // must match field count
      exit else
    for field := 0 to max do
      if SQLFieldTypeToDB[Fields.List[field].SQLFieldType]<>Values[field].VType then
        exit;
    // now we can safely update field values
    for field := 0 to max do
      Fields.List[field].SetFieldSQLVar(self,Values[field]);
  end;
  result := true;
end;

procedure TSQLRecord.GetBinaryValues(W: TFileBufferWriter);
var f: integer;
begin
  with RecordProps do
    for f := 0 to Fields.Count-1 do
      Fields.List[f].GetBinary(self,W);
end;

procedure TSQLRecord.GetBinaryValuesSimpleFields(W: TFileBufferWriter);
var f: integer;
begin
  with RecordProps do
    for f := 0 to SimpleFieldCount-1 do
      SimpleFields[f].GetBinary(self,W);
end;

procedure TSQLRecord.GetBinaryValues(W: TFileBufferWriter;
  const aFields: TSQLFieldBits);
var f: integer;
begin
  with RecordProps do
    for f := 0 to Fields.Count-1 do
      if f in aFields then
        Fields.List[f].GetBinary(self,W);
end;

function TSQLRecord.GetBinary: RawByteString;
var W: TFileBufferWriter;
begin
  W := TFileBufferWriter.Create(TRawByteStringStream);
  try
    W.WriteVarUInt32(fID);
    GetBinaryValues(W);
    W.Flush;
    result := (W.Stream as TRawByteStringStream).DataString;
  finally
    W.Free;
  end;
end;

function TSQLRecord.SetBinary(P: PAnsiChar): Boolean;
begin
  fID := FromVarUInt32(PByte(P));
  result := SetBinaryValues(P);
end;

function TSQLRecord.SetBinaryValues(var P: PAnsiChar): boolean;
var f: integer;
begin
  result := false;
  with RecordProps do
    for f := 0 to Fields.Count-1 do begin
      P := Fields.List[f].SetBinary(self,P);
      if P=nil then
        exit; // on error
    end;
  result := true;
end;

function TSQLRecord.SetBinaryValuesSimpleFields(var P: PAnsiChar): Boolean;
var f: integer;
begin
  result := false;
  with RecordProps do
    for f := 0 to SimpleFieldCount-1 do begin
      P := SimpleFields[f].SetBinary(self,P);
      if P=nil then
        exit; // on error
    end;
  result := true;
end;

procedure TSQLRecord.GetJSONValues(W: TJSONSerializer);
var i,n: integer;
label txt,txt1;
begin
  if self=nil then
    exit;
  // write the row data
  if W.Expand then begin
    W.Add('{');
    if W.WithID then
      W.AddString(W.ColNames[0]);
  end;
  if W.WithID then begin
    W.Add(fID);
    W.Add(',');
    n := 1;
  end else
    n := 0;
  with RecordProps do
  for i := 0 to Fields.Count-1 do
    if i in W.Fields then begin
      if W.Expand then begin
        W.AddString(W.ColNames[n]); // '"'+ColNames[]+'":'
        inc(n);
      end;
      Fields.List[i].GetJSONValues(Self,W);
      W.Add(',');
    end;
  W.CancelLastComma; // cancel last ','
  if W.Expand then
    W.Add('}');
end;

procedure TSQLRecord.GetJSONValuesAndFree(JSON : TJSONSerializer);
begin
  if JSON<>nil then
  try
    // write the row data
    GetJSONValues(JSON);
    // end the JSON object
    if not JSON.Expand then
      JSON.AddNoJSONEscape(PAnsiChar(']}'),2);
    JSON.Flush;
  finally
    JSON.Free;
  end;
end;

procedure TSQLRecord.GetJSONValues(JSON: TStream; Expand: boolean; withID: boolean;
  Occasion: TSQLOccasion);
begin
  if self<>nil then
  with RecordProps do
    GetJSONValuesAndFree(CreateJSONWriter(JSON,Expand,withID,SimpleFieldsBits[Occasion],0));
end;

function TSQLRecord.GetJSONValues(Expand: boolean; withID: boolean;
  const Fields: TSQLFieldBits): RawUTF8;
var J: TRawByteStringStream;
begin
  J := TRawByteStringStream.Create;
  try
    GetJSONValuesAndFree(RecordProps.CreateJSONWriter(J,Expand,withID,Fields,0));
    result := J.DataString;
  finally
    J.Free;
  end;
end;

function TSQLRecord.GetJSONValues(Expand: boolean; withID: boolean;
  Occasion: TSQLOccasion; UsingStream: TCustomMemoryStream=nil): RawUTF8;
var J: TRawByteStringStream;
begin
  if (not withID) and IsZero(RecordProps.SimpleFieldsBits[Occasion]) then
    // no simple field to write -> quick return
    result := '' else
  if UsingStream<>nil then begin
    UsingStream.Seek(0,soFromBeginning);
    GetJSONValues(UsingStream,Expand,withID,Occasion);
    SetRawUTF8(result,UsingStream.Memory,UsingStream.Seek(0,soFromCurrent));
  end else begin
    J := TRawByteStringStream.Create;
    try
      GetJSONValues(J,Expand,withID,Occasion);
      result := J.DataString;
    finally
      J.Free;
    end;
  end;
end;

function GetVirtualTableSQLCreate(Props: TSQLRecordProperties): RawUTF8;
var i: integer;
    SQL: RawUTF8;
begin
  result := ''; // RowID is added by sqlite3_declare_vtab() for a Virtual Table 
  for i := 0 to Props.Fields.Count-1 do
  with Props.Fields.List[i] do begin
    SQL := Props.SQLFieldTypeToSQL(i);
    if SQL<>'' then
      result := result+Name+SQL;
  end;
  if result='' then
    result := ');' else
    pWord(@result[length(result)-1])^ := ord(')')+ord(';')shl 8;
end;

class function TSQLRecord.GetSQLCreate(aModel: TSQLModel): RawUTF8;
// not implemented in TSQLRecordProperties since has been made virtual
var i: integer;
    SQL: RawUTF8;
    M: TSQLVirtualTableClass;
    Props: TSQLModelRecordProperties;
begin
  if aModel=nil then
    raise EModelException.Create('Invalid GetSQLCreate call');
  Props := aModel.Props[self];
  with Props.Props do
  if Props.Kind<>rSQLite3 then begin
    // create a FTS3/FTS4/RTREE virtual table
    result := 'CREATE VIRTUAL TABLE '+SQLTableName+' USING ';
    case Props.Kind of
    rFTS3:  result := result+'fts3(';
    rFTS4:  result := result+'fts4(';
    rRTree: result := result+'rtree(RowID,';
    rCustomForcedID, rCustomAutoID: begin
      M := aModel.VirtualTableModule(self);
      if M=nil then
        raise EModelException.CreateFmt('No registered module for %s',[Table.ClassName]);
      if Fields.Count=0 then
        raise EModelException.CreateFmt(
          'Virtual %s class % should have published properties',[M.ModuleName,ClassName]);
      result := result+M.ModuleName+'('+GetVirtualTableSQLCreate(RecordProps);
    end;
    end;
    case Props.Kind of
    rFTS3, rFTS4: begin
      for i := 0 to Fields.Count-1 do
        with Fields.List[i] do
        if SQLFieldType<>sftUTF8Text then
          raise EModelException.CreateFmt('%s.%s: FTS3/FTS4 field must be RawUTF8',
            [SQLTableName,Name]) else
          result := result+Name+',';
      if InheritsFrom(TSQLRecordFTS3Porter) or
         InheritsFrom(TSQLRecordFTS4Porter) then
        result := result+' tokenize=porter)' else
        result := result+' tokenize=simple)';
    end;
    rRTree: begin
      if (Fields.Count<2) or (Fields.Count>RTREE_MAX_DIMENSION*2) or
         (Fields.Count and 2<>0) then
        raise EModelException.CreateFmt('%d: %s RTREE expects 2,4,6..%d field number',
          [Fields.Count,SQLTableName,RTREE_MAX_DIMENSION*2]);
      for i := 0 to Fields.Count-1 do
        with Fields.List[i] do
        if SQLFieldType<>sftFloat then
          raise EModelException.CreateFmt('%s.%s: RTREE field must be double',
            [SQLTableName,Name]) else
          result := result+Name+',';
      result[length(result)] := ')';
    end;
    end;
  end else begin
    // inherits from TSQLRecord: create a "normal" SQLite3 table
    result := 'CREATE TABLE '+SQLTableName+
      '(ID INTEGER PRIMARY KEY AUTOINCREMENT, ';
    // we always add an ID field which is an INTEGER PRIMARY KEY
    // column, as it is always created (as hidden ROWID) by the SQLite3 engine
    for i := 0 to Fields.Count-1 do
    with Fields.List[i] do begin
      SQL := SQLFieldTypeToSQL(i);
      if SQL<>'' then begin
        result := result+Name+SQL;
        if i in IsUniqueFieldsBits then
          insert(' UNIQUE',result,length(result)-1);
      end;
    end;
    pWord(@result[length(result)-1])^ := ord(')')+ord(';')shl 8;
  end;
end;

function TSQLRecord.GetSQLSet: RawUTF8;
var i: integer;
    V: RawUTF8;
    wasString: boolean;
begin
  result := '';
  if self=nil then
    exit;
  with RecordProps do
    for i := 0 to High(SimpleFields) do
    with SimpleFields[i] do begin
      // format is 'COL1='VAL1', COL2='VAL2'' }
      GetValueVar(self,true,V,@wasString);
      if wasString then
        V := QuotedStr(V);
      result := result+Name+'='+V+', ';
    end;
  if result<>'' then
    SetLength(result,length(result)-2);
end;

function TSQLRecord.GetSQLValues: RawUTF8;
var i: integer;
    V: RawUTF8;
    wasString: boolean;
begin
  result := '';
  if self<>nil then
  with RecordProps do
    if SimpleFields=nil then
      exit else begin
    if HasNotSimpleFields then // get 'COL1,COL2': no 'ID,' for INSERT (false below)
      result := SQLTableSimpleFieldsNoRowID; // always <> '*'
    result := result+' VALUES (';
    for i := 0 to high(SimpleFields) do
    with SimpleFields[i] do begin
      GetValueVar(self,true,V,@wasString);
      if wasString then
        V := QuotedStr(V);
      result := result+V+',';
    end;
    result[length(result)] := ')';
  end;
end;

class function TSQLRecord.CaptionName(Action: PRawUTF8=nil; ForHint: boolean=false): string;
begin
  if Action=nil then
    GetCaptionFromPCharLen(pointer(RecordProps.SQLTableName),result) else
    GetCaptionFromPCharLen(TrimLeftLowerCase(Action^),result);
end;

class function TSQLRecord.CaptionNameFromRTTI(Action: PShortString): string;
var tmp: RawUTF8;
begin
  if Action=nil then
    result := CaptionName(nil) else begin
    SetString(tmp,PAnsiChar(@Action^[1]),ord(Action^[0]));
    result := CaptionName(@tmp);
  end;
end;

function TSQLRecord.SameValues(Reference: TSQLRecord): boolean;
var O: TSQLPropInfo;
    i: integer;
    This,Ref: TSQLRecordProperties;
begin
  result := false;
  if (self=nil) or (Reference=nil) or
     (Reference.fID<>fID) then // ID field must be tested by hand
    exit;
  if self<>Reference then
  if (PSQLRecordClass(Reference)^=PSQLRecordClass(self)^) then begin
    // faster comparison on same exact class
    with RecordProps do
    for i := 0 to high(SimpleFields) do
      // compare not TSQLRawBlob/TSQLRecordMany fields
      with SimpleFields[i] do
        if CompareValue(self,Reference,false)<>0 then
          exit; // properties don't have the same value
  end else begin
    // comparaison of all properties of Reference against self
    This := RecordProps;
    Ref := Reference.RecordProps;
    for i := 0 to high(Ref.SimpleFields) do
    with Ref.SimpleFields[i] do begin
      // compare not TSQLRawBlob/TSQLRecordMany fields
      O := This.Fields.ByRawUTF8Name(Name);
      if O=nil then
        exit; // this Reference property doesn't exist in current object
      if GetValue(Reference,false,nil)<>O.GetValue(self,false,nil) then
        exit; // properties don't have the same value
    end;
  end;
  result := true;
end;

function TSQLRecord.SameRecord(Reference: TSQLRecord): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or (Reference=nil) or
     (PSQLRecordClass(Reference)^<>PSQLRecordClass(Self)^) or (Reference.fID<>fID) then
    exit;
  with RecordProps do
    for i := 0 to high(SimpleFields) do
      // compare not TSQLRawBlob/TSQLRecordMany fields
      with SimpleFields[i] do
        if CompareValue(self,Reference,false)<>0 then
          exit; // properties don't have the same value
  result := true;
end;

procedure TSQLRecord.ClearProperties;
var i: integer;
begin
  if self=nil then
    exit;
  fInternalState := 0;
  fID := 0;
  with RecordProps do
    if fFill.JoinedFields then begin
      for i := 0 to high(CopiableFields) do
        if CopiableFields[i].SQLFieldType<>sftID then
          CopiableFields[i].SetValue(self,nil,false) else
          TSQLRecord(TSQLPropInfoRTTIInstance(CopiableFields[i]).GetInstance(Self)).
            ClearProperties; // clear nested allocated TSQLRecord 
    end else
    for i := 0 to high(CopiableFields) do
      CopiableFields[i].SetValue(self,nil,false);
end;

{$IFDEF PUREPASCAL}
function TSQLRecord.RecordClass: TSQLRecordClass; 
begin
  if self=nil then
    Result := nil else
    Result := PSQLRecordClass(Self)^;
end;
{$else}
function TSQLRecord.RecordClass: TSQLRecordClass;
asm
  or eax,eax; jz @z
  mov eax,[eax]
@z:
end;
{$endif}              

{$IFDEF PUREPASCAL}
function TSQLRecord.ClassProp: PClassProp;
begin
  if self<>nil then
    result := InternalClassProp(PPointer(Self)^) else
    result := nil; // avoid GPF
end;
{$else}
function TSQLRecord.ClassProp: PClassProp;
asm
  or eax,eax; jz @z // avoid GPF
  mov eax,[eax] // get ClassType of this TSQLRecord instance
  or eax,eax; jz @z // avoid GPF
  mov eax,[eax+vmtTypeInfo]
  or eax,eax; jz @z // avoid GPF
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
  movzx edx,byte ptr [eax].TClassType.UnitName
  lea eax,[eax+edx].TClassType.UnitName[1].TClassProp
@z:
end;
{$endif}

function TSQLRecord.RecordReference(Model: TSQLModel): TRecordReference;
begin
  if (self=nil) or (fID<=0) then
    result := 0 else begin
    result := Model.GetTableIndexExisting(PSQLRecordClass(Self)^);
    if result>63 then // TRecordReference handle up to 64=1 shl 6 tables
      result := 0 else
      inc(result,fID shl 6);
  end;
end;

destructor TSQLRecord.Destroy;
var i: integer;
    props: TSQLRecordProperties;
begin
  props := RecordProps;
  if fFill<>nil then begin
    if fFill.fJoinedFields then
      // free all TSQLRecord instances created by TSQLRecord.CreateJoined
      for i := 0 to high(props.JoinedFields) do
        props.JoinedFields[i].GetInstance(self).Free;
    fFill.Free; // call UnMap -> release fTable instance if necessary
  end;
  // free all TSQLRecordMany instances created by TSQLRecord.Create
  if pointer(props.ManyFields)<>nil then
    for i := 0 to high(props.ManyFields) do
      props.ManyFields[i].GetInstance(self).Free;
  inherited;
end;

function TSQLRecord.SimplePropertiesFill(const aSimpleFields: array of const): boolean;
var i: integer;
    tmp: RawUTF8;
begin
  if self=nil then
    result := false else // means error
    with RecordProps do
    if length(SimpleFields)<>length(aSimpleFields) then
      result := false else begin
      for i := 0 to high(aSimpleFields) do begin
        VarRecToUTF8(aSimpleFields[i],tmp); // will work for every handled type
        SimpleFields[i].SetValue(self,pointer(tmp),false);
      end;
      result := True;
    end;
end;

constructor TSQLRecord.CreateAndFillPrepare(aClient: TSQLRest;
  const aSQLWhere: RawUTF8; const aCustomFieldsCSV: RawUTF8='');
var aTable: TSQLTable;
begin
  Create;
  aTable := aClient.MultiFieldValues(RecordClass,aCustomFieldsCSV,aSQLWhere);
  if aTable=nil then
    exit;
  aTable.OwnerMustFree := true;
  FillPrepare(aTable);
end;

constructor TSQLRecord.CreateAndFillPrepare(aClient: TSQLRest;
  FormatSQLWhere: PUTF8Char; const BoundsSQLWhere: array of const;
  const aCustomFieldsCSV: RawUTF8='');
begin
  CreateAndFillPrepare(aClient,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere),
    aCustomFieldsCSV);
end;

constructor TSQLRecord.CreateAndFillPrepare(aClient: TSQLRest;
  FormatSQLWhere: PUTF8Char; const ParamsSQLWhere,
  BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8);
begin
  CreateAndFillPrepare(aClient,
    FormatUTF8(FormatSQLWhere,ParamsSQLWhere,BoundsSQLWhere),aCustomFieldsCSV);
end;

constructor TSQLRecord.CreateAndFillPrepare(aClient: TSQLRest;
  const aIDs: array of integer; const aCustomFieldsCSV: RawUTF8='');
begin
  Create;
  FillPrepare(aClient,aIDs,aCustomFieldsCSV);
end;

constructor TSQLRecord.CreateAndFillPrepare(const aJSON: RawUTF8);
var aTable: TSQLTable;
begin
  Create;
  aTable := TSQLTableJSON.CreateFromTables([RecordClass],'',aJSON);
  aTable.OwnerMustFree := true;
  FillPrepare(aTable);
end;

constructor TSQLRecord.CreateAndFillPrepareJoined(aClient: TSQLRest;
  const aFormatSQLJoin: RawUTF8; const aParamsSQLJoin, aBoundsSQLJoin: array of const);
var i,n: integer;
    props: TSQLModelRecordProperties;
    T: TSQLTableJSON;
    instance: TSQLRecord;
    SQL: RawUTF8;
begin
  Create;
  props := aClient.Model.Props[PSQLRecordClass(Self)^];
  if props.props.JoinedFields=nil then
    raise EORMException.CreateFmt('No nested TSQLRecord to JOIN in %s',
      [props.props.SQLTableName]);
  SQL := props.SQL.SelectAllJoined;
  if aFormatSQLJoin<>'' then
    SQL := SQL+FormatUTF8(pointer(SQLFromWhere(aFormatSQLJoin)),
      aParamsSQLJoin,aBoundsSQLJoin);
  T := aClient.ExecuteList(props.props.JoinedFieldsTable,SQL);
  if T=nil then
    exit;
  fFill := TSQLRecordFill.Create;
  fFill.fJoinedFields := True;
  fFill.fTable := T;
  fFill.fTable.OwnerMustFree := true;
  n := 0;
  with props.props do begin // follow SQL.SelectAllJoined columns
    fFill.AddMapSimpleFields(Self,SimpleFields,n);
    for i := 1 to high(JoinedFieldsTable) do begin
      instance := JoinedFieldsTable[i].Create;
      JoinedFields[i-1].SetInstance(self,instance);
      fFill.AddMapSimpleFields(instance,JoinedFieldsTable[i].RecordProps.SimpleFields,n);
    end;
  end;
  fFill.fFillCurrentRow := 1; // point to first data row (0 is field names)
end;

constructor TSQLRecord.CreateJoined(aClient: TSQLRest; aID: integer);
begin
  CreateAndFillPrepareJoined(aClient,'%.RowID=?',[RecordProps.SQLTableName],[aID]);
  FillOne;
end;

constructor TSQLRecord.CreateAndFillPrepareMany(aClient: TSQLRest;
  aFormatSQLJoin: PUTF8Char; const aParamsSQLJoin, aBoundsSQLJoin: array of const);
begin
  Create;
  FillPrepareMany(aClient,aFormatSQLJoin,aParamsSQLJoin,aBoundsSQLJoin);
end;

function TSQLRecord.FillPrepareMany(aClient: TSQLRest;
  aFormatSQLJoin: PUTF8Char; const aParamsSQLJoin, aBoundsSQLJoin: array of const): boolean;
var aSQLFields, aSQLFrom, aSQLWhere, aSQL: RawUTF8;
    aField: string[3];
    aMany: RawUTF8;
    f, n, i, SQLFieldsCount: Integer;
    Props: TSQLRecordProperties;
    T: TSQLTable;
    SQLFields: array of record
      SQL: string[3];
      Prop: TSQLPropInfo;
      Instance: TSQLRecord;
    end;
    M: TSQLRecordMany;
    D: TSQLRecord;
    P: PUTF8Char;
    Objects: array of TSQLRecord;
    ObjectsClass: array of TSQLRecordClass;

  function AddField(aProp: TSQLPropInfo): Boolean;
  begin
    if SQLFieldsCount>=MAX_SQLFIELDS then
      result := false else
      with SQLFields[SQLFieldsCount] do begin
        SQL := aField;
        Prop := aProp;
        Instance := Objects[f];
        inc(SQLFieldsCount);
        result := true;
      end;
  end;
  function ProcessField(var P: PUTF8Char): RawUTF8;
  var B: PUTF8Char;
      field: TSQLPropInfo;
      i: integer;
      M: TSQLRecordMany;
      aManyField: string[63];
    function GetManyField(F: PUTF8Char): boolean;
    var B: PUTF8Char;
    begin
      result := true;
      B := F;
      while ord(F^) in IsIdentifier do inc(F); // go to end of sub-field name
      if B=F then begin
        result := false;
        exit;
      end;
      dec(B,2); // space for 'C.'
      SetString(aManyField,B,F-B);
      aManyField[2] := '.';
      P := F;
    end;
  begin
    B := P;
    while ord(P^) in IsIdentifier do inc(P); // go to end of field name
    SetRawUTF8(result,B,P-B);
    if (result='') or IdemPropNameU(result,'AND') or IdemPropNameU(result,'OR') or
       IdemPropNameU(result,'LIKE') or IdemPropNameU(result,'NOT') or
       IdemPropNameU(result,'NULL') then
      exit;
    if not IsRowID(pointer(result)) then begin
      i := Props.Fields.IndexByName(result);
      if i<0 then
        exit;
      field := Props.Fields.List[i];
      if field.SQLFieldType=sftMany then begin
        M := TSQLPropInfoRTTIInstance(field).GetInstance(self) as TSQLRecordMany;
        assert(M<>nil);
        for i := 0 to n-1 do
        if Objects[i*2+1]=M then begin
          if IdemPChar(P,'.DEST.') then begin // special case of Many.Dest.*
            if GetManyField(P+6) then begin
              aManyField[1] := AnsiChar(i*2+67);
              result := RawUTF8(aManyField);
              exit; // Categories.Dest.Name=? -> C.Name=?
            end;
          end else
          if (P^='.') and GetManyField(P+1) then begin
            aManyField[1] := AnsiChar(i*2+66);
            result := RawUTF8(aManyField);
            exit;  // Categories.Kind=? -> CC.Kind=?
          end;
        end;
        exit;
      end;
    end;
    result := 'A.'+result; // Owner=? -> A.Owner=?
  end;

begin
  result := false;
  FillClose; // so that no further FillOne will work
  if (self=nil) or (aClient=nil) then
    exit;
  // reset TSQLRecordFill object
  if fFill=nil then
    fFill := TSQLRecordFill.Create else
    fFill.UnMap;
  // compute generic joined SQL statement and initialize Objects*[]+SQLFields[]
  SetLength(SQLFields,MAX_SQLFIELDS);
  Props := RecordProps;
  n := Length(Props.ManyFields);
  SetLength(Objects,n*2+1);
  SetLength(ObjectsClass,n*2+1);
  Objects[0] := self;
  ObjectsClass[0] := PSQLRecordClass(self)^;
  SetLength(fFill.fTableMapRecordManyInstances,n);  // fFill.UnMap will release memory
  for f := 0 to n-1 do begin
    M := TSQLRecordMany(Props.ManyFields[f].GetInstance(self));
    assert(M<>nil,'TSQLRecord.Create should have created TSQLRecordMany instances');
    fFill.fTableMapRecordManyInstances[f] := M;
    Objects[f*2+1] := M;
    ObjectsClass[f*2+1] := PSQLRecordClass(M)^;
    with M.RecordProps do begin
      Assert((fRecordManySourceProp.ObjectClass=PClass(self)^)
         and (fRecordManyDestProp.ObjectClass<>nil));
      ObjectsClass[f*2+2] := TSQLRecordClass(fRecordManyDestProp.ObjectClass);
      D := TSQLRecordClass(fRecordManyDestProp.ObjectClass).Create;
      // let TSQLRecordMany.Source and Dest point to real instances
      M.fSourceID^ := PtrInt(self);
      M.fDestID^ := PtrInt(D);
    end;
    Objects[f*2+2] := TSQLRecord(M.fDestID^);
    if Props.fSQLFillPrepareMany='' then begin
      aMany := AnsiChar(f*2+66); // Many=B,D,F...
      if aSQLWhere<>'' then
        aSQLWhere := aSQLWhere+' and ';
      aSQLWhere := FormatUTF8('%%.Source=A.RowID and %.Dest=%.RowID',
        [aSQLWhere,aMany,aMany,AnsiChar(f*2+67){Dest=C,E,G..}]);
    end;
  end;
  SQLFieldsCount := 0;
  aField := 'A00';
  for f := 0 to high(ObjectsClass) do
    with ObjectsClass[f].RecordProps do begin
      PWord(@aField[2])^ := ord('I')+ord('D')shl 8;
      if not AddField(nil) then
        Exit; // try to add the ID field
      if Props.fSQLFillPrepareMany='' then begin
        if aSQLFields<>'' then
          aSQLFields := aSQLFields+',';
          aSQLFields := FormatUTF8('%%.RowID %',[aSQLFields,aField[1],aField]);
      end;
      for i := 0 to high(SimpleFields) do
      with SimpleFields[i] do begin
        if (f and 1=0) {self/dest} or
           not(IdemPropNameU(Name,'SOURCE') or
               IdemPropNameU(Name,'DEST')) {many} then begin
          PWord(@aField[2])^ := TwoDigitLookupW[i];
          if not AddField(SimpleFields[i]) then
            Exit; // try to add this simple field
          if Props.fSQLFillPrepareMany='' then
            aSQLFields := FormatUTF8('%,%.% %',[aSQLFields,aField[1],Name,aField]);
        end;
      end;
      if Props.fSQLFillPrepareMany='' then begin
        if aSQLFrom<>'' then
          aSQLFrom := aSQLFrom+',';
        aSQLFrom := aSQLFrom+SQLTableName+' '+RawUTF8(aField[1]);
      end;
      inc(aField[1]);
    end;
  if Props.fSQLFillPrepareMany<>'' then
    aSQL := Props.fSQLFillPrepareMany else begin
    aSQL := FormatUTF8('select % from % where %',[aSQLFields,aSQLFrom,aSQLWhere]);
    Props.fSQLFillPrepareMany := aSQL;
  end;
  // process aFormatSQLJoin,aParamsSQLJoin and aBoundsSQLJoin parameters
  if aFormatSQLJoin<>nil then begin
    aSQLWhere := '';
    repeat
      P := aFormatSQLJoin;
      while not (ord(P^) in IsIdentifier) do begin
        case P^ of
        '"':  repeat inc(P) until P^ in [#0,'"'];
        '''': repeat inc(P) until P^ in [#0,''''];
        end;
        if P^=#0 then break;
        inc(P);
      end;
      if P<>aFormatSQLJoin then begin // append ' ',')'..
        SetString(aSQLFrom,aFormatSQLJoin,P-aFormatSQLJoin);
        aSQLWhere := aSQLWhere+aSQLFrom;
        aFormatSQLJoin := P;
      end;
      if P^=#0 then break;
      aSQLWhere := aSQLWhere+ProcessField(aFormatSQLJoin);
    until aFormatSQLJoin^=#0;
    aSQL := aSQL+' and ('+FormatUTF8(pointer(aSQLWhere),aParamsSQLJoin,aBoundsSQLJoin)+')';
  end;
  // execute SQL statement and retrieve data
  T := aClient.ExecuteList(ObjectsClass,aSQL);
  if (T=nil) or (T.fResults=nil) then
    exit;
  fFill.fTable := T;
  T.OwnerMustFree := true;
  // map fields
  assert(T.FieldCount=SQLFieldsCount);
  for i := 0 to SQLFieldsCount-1 do
    assert(IdemPropName(SQLFields[i].SQL,T.fResults[i],StrLen(T.fResults[i])));
  for i := 0 to SQLFieldsCount-1 do
    with SQLFields[i] do
      fFill.AddMap(Instance,Prop,i);
  fFill.fFillCurrentRow := 1; // point to first data row (0 is field names)
  result := true;
end;

function TSQLRecord.GetID: integer;
begin
  if PtrUInt(self)<PtrUInt(SystemInfo.lpMinimumApplicationAddress) then
    // was called from a TSQLRecord property (sftID type)
    // (will return 0 if current instance is nil)
    result := PtrUInt(self) else
    // was called from a real TSQLRecord instance
    result := fID;
end;

function TSQLRecord.GetIDAsPointer: pointer;
begin
  if PtrUInt(self)<PtrUInt(SystemInfo.lpMinimumApplicationAddress) then
    // was called from a TSQLRecord property (sftID type)
    // (will return 0 if current instance is nil)
    result := self else
    // was called from a real TSQLRecord instance
    {$ifdef CPU64}
    PtrInt(result) := fId;
    {$else}
    result := pointer(fID);
    {$endif}
end;

class procedure TSQLRecord.InternalRegisterCustomProperties(Props: TSQLRecordProperties);
begin
  // do nothing by default
end;

function TSQLRecord.GetHasBlob: boolean;
begin
  if Self=nil then
    result := false else
    result := RecordProps.BlobFields<>nil;
end;

function TSQLRecord.GetSimpleFieldCount: integer;
begin
  if Self=nil then
    result := 0 else
    result := length(RecordProps.SimpleFields);
end;

function TSQLRecord.GetFillCurrentRow: integer;
begin
  if (self=nil) or (fFill=nil) then
    result := 0 else
    result := fFill.FillCurrentRow;
end;

function TSQLRecord.GetTable: TSQLTable;
begin
  if (self=nil) or (fFill=nil) then
    result := nil else
    result := fFill.Table;
end;

function TSQLRecord.GetFieldValue(const PropName: RawUTF8): RawUTF8;
var P: TSQLPropInfo;
begin
  result := '';
  if self=nil then
    exit;
  P := RecordProps.Fields.ByName(pointer(PropName));
  if P<>nil then
    P.GetValueVar(self,False,result,nil);
end;

procedure TSQLRecord.SetFieldValue(const PropName: RawUTF8; Value: PUTF8Char);
var P: TSQLPropInfo;
begin
  if self=nil then
    exit;
  P := RecordProps.Fields.ByName(pointer(PropName));
  if P<>nil then
    P.SetValue(self,Value,false);
end;

{$ifndef NOVARIANTS}
function TSQLRecord.GetFieldVariant(const PropName: string): Variant;
var P: TSQLPropInfo;
begin
  if self=nil then
    P := nil else
    P := RecordProps.Fields.ByRawUTF8Name({$ifdef UNICODE}StringToUTF8{$endif}(PropName));
  if P=nil then
    VarClear(result) else
    P.GetVariant(self,result);
end;

procedure TSQLRecord.SetFieldVariant(const PropName: string;
  const Source: Variant);
var P: TSQLPropInfo;
begin
  if self=nil then
    P := nil else
    P := RecordProps.Fields.ByRawUTF8Name({$ifdef UNICODE}StringToUTF8{$endif}(PropName));
  if P<>nil then
    P.SetVariant(self,Source);
end;
{$endif}

function PropsCreate(aTable: TSQLRecordClass): TSQLRecordProperties;
var PVMT: pointer;
begin // private sub function makes the code faster in most case
  if not aTable.InheritsFrom(TSQLRecord) then
    // invalid call
    result := nil else begin
    // create the properties information from RTTI
    result := TSQLRecordProperties.Create(aTable);
    // store the TSQLRecordProperties instance into AutoTable unused VMT entry
    PVMT := pointer(PtrInt(aTable)+vmtAutoTable);
    if PPointer(PVMT)^<>nil then
      raise ESynException.CreateFmt('%s.AutoTable VMT entry already set',
        [PShortString(PPointer(PtrInt(aTable)+vmtClassName)^)^]);
    PatchCodePtrUInt(PVMT,PtrUInt(result),true); // LeaveUnprotected=true 
    // register to the internal garbage collection (avoid memory leak)
    GarbageCollectorFreeAndNil(PVMT^,result); // set to nil at finalization
  end;
end;

// since "var class" are not available in Delphi 6-7, and is inherited by
// the children classes under latest Delphi versions (i.e. the "var class" is
// shared by all inherited classes, whereas we want one var per class), we reused
// one of the unused magic VMT slots (i.e. the one for automated methods,
// AutoTable, a relic from Delphi 2 that is generally not used anymore) - see
// http://hallvards.blogspot.com/2007/05/hack17-virtual-class-variables-part-ii.html

{$ifdef PUREPASCAL}
class function TSQLRecord.RecordProps: TSQLRecordProperties;
begin
  if Self<>nil then begin
    result := PPointer(PtrInt(Self)+vmtAutoTable)^;
    if result=nil then
      result := PropsCreate(self);
  end else
    result := nil;
end;
{$else}
class function TSQLRecord.RecordProps: TSQLRecordProperties;
asm
  or eax,eax
  jz @null
  mov edx,[eax+vmtAutoTable]
  or edx,edx
  jz PropsCreate
  mov eax,edx
@null:
end;
{$endif}

function TSQLRecord.Filter(const aFields: TSQLFieldBits): boolean;
var f, i: integer;
    Value, Old: RawUTF8;
begin
  result := IsZero(aFields);
  if (self=nil) or result then
    // avoid GPF and handle case if no field was selected
    exit;
  with RecordProps do
  if Filters=nil then
    // no filter set yet -> process OK
    result := true else begin
    for f := 0 to Fields.Count-1 do
      if (Fields.List[f].SQLFieldType in COPIABLE_FIELDS) and
         (Filters[f]<>nil) then
        with Filters[f] do
        for i := 0 to Count-1 do
        if TSynFilterOrValidate(List[i]).InheritsFrom(TSynFilter) then begin
          Fields.List[f].GetValueVar(self,false,Value,nil);
          Old := Value;
          TSynFilter(List[i]).Process(f,Value);
          if Old<>Value then
            // value was changed -> store modified
            Fields.List[f].SetValue(self,pointer(Value),false);
        end;
  end;
end;

function TSQLRecord.Filter(const aFields: array of RawUTF8): boolean;
var F: TSQLFieldBits;
begin
  if RecordProps.FieldIndexsFromRawUTF8(aFields,F) then
    // must always call the virtual Filter() method
    result := Filter(F) else
    result := false;
end;

class function TSQLRecord.SQLTableName: RawUTF8;
begin
  if self=nil then
    result := '' else
    result := RecordProps.SQLTableName;
end;

class function TSQLRecord.AddFilterOrValidate(const aFieldName: RawUTF8;
  aFilter: TSynFilterOrValidate): TSynFilterOrValidate;
begin
  result := RecordProps.AddFilterOrValidate(aFieldName,aFilter);
end;

function TSQLRecord.Validate(aRest: TSQLRest; const aFields: TSQLFieldBits;
  aInvalidFieldIndex: PInteger): string;
var f, i: integer;
    Value: RawUTF8;
    Validate: TSynValidate;
    ValidateRest: TSynValidateRest absolute Validate;
begin
  result := '';
  if (self=nil) or IsZero(aFields) then
    // avoid GPF and handle case if no field was selected
    exit;
  with RecordProps do
  for f := 0 to Fields.Count-1 do
  if Fields.List[f].SQLFieldType in COPIABLE_FIELDS then begin
    if (Filters<>nil) and (Filters[f]<>nil) then
      for i := 0 to Filters[f].Count-1 do begin
        Validate := TSynValidate(Filters[f].List[i]);
        if Validate.InheritsFrom(TSynValidate) then begin
          if Value='' then
            Fields.List[f].GetValueVar(self,false,Value,nil);
          if Validate.InheritsFrom(TSynValidateRest) then begin
            // set additional parameters
            ValidateRest.fProcessRec := self;
            ValidateRest.fProcessRest := aRest;
          end;
          if not Validate.Process(f,Value,result) then begin
            // TSynValidate process failed -> notify caller
            if aInvalidFieldIndex<>nil then
              aInvalidFieldIndex^ := f;
            if result='' then
              // no custom message -> show a default message
              result := format(sValidationFailed,[
                GetCaptionFromClass(Validate.ClassType)]);
            exit;
          end;
        end;
      end;
    Value := '';
  end;
end;

function TSQLRecord.Validate(aRest: TSQLRest; const aFields: array of RawUTF8;
  aInvalidFieldIndex: PInteger=nil): string;
var F: TSQLFieldBits;
begin
  if RecordProps.FieldIndexsFromRawUTF8(aFields,F) then
    // must always call the virtual Validate() method
    result := Validate(aRest,F,aInvalidFieldIndex) else
    result := '';
end;

function TSQLRecord.DynArray(const DynArrayFieldName: RawUTF8): TDynArray;
var F: integer;
begin
  with RecordProps do
    for F := 0 to high(DynArrayFields) do
      with DynArrayFields[F] do
      if IdemPropNameU(Name,DynArrayFieldName) then begin
        result := GetDynArray(self);
        exit;
      end;
  result.Void;
end;

function TSQLRecord.DynArray(DynArrayFieldIndex: integer): TDynArray;
var F: integer;
begin
  if DynArrayFieldIndex>0 then
    with RecordProps do
      for F := 0 to high(DynArrayFields) do
        with DynArrayFields[F] do
        if DynArrayIndex=DynArrayFieldIndex then begin
          result := GetDynArray(self);
          exit;
        end;
  result.Void;
end;

procedure TSQLRecord.ComputeFieldsBeforeWrite(aRest: TSQLRest; aOccasion: TSQLEvent);
var F: integer;
    types: TSQLFieldTypes;
    TimeStamp: TTimeLog;
begin
  if (self<>nil) and (aRest<>nil) then
    with RecordProps do begin
      integer(types) := 0;
      if sftModTime in HasTypeFields then
        include(types,sftModTime);
      if (sftCreateTime in HasTypeFields) and (aOccasion=seAdd) then
        include(types,sftCreateTime);
      if integer(types)<>0 then begin
        TimeStamp := aRest.ServerTimeStamp;
        for F := 0 to Fields.Count-1 do
        with TSQLPropInfoRTTIInt64(Fields.List[f]) do
        if SQLFieldType in types then
          SetInt64Prop(Self,Pointer(fPropInfo),TimeStamp);
      end;
    end;
end;


{ TSQLModelRecordPropertiesExternal }

procedure TSQLModelRecordPropertiesExternal.Init(Props: TSQLModelRecordProperties;
  const ExternalTableName: RawUTF8; ExternalDataBase: TObject);
begin
  if ExternalTableName='' then
    fTableName := Props.Props.SQLTableName else
    fTableName := ExternalTableName;
  fConnectionProperties := ExternalDataBase;
  fProps := Props;
  fRowIDFieldName := 'ID';
  Props.Props.Fields.NamesToRawUTF8DynArray(fFieldNames);
  FillChar(fFieldNamesMatchInternal,sizeof(fFieldNamesMatchInternal),255);
  ComputeSQL;
end;

function TSQLModelRecordPropertiesExternal.MapField(
  const InternalName, ExternalName: RawUTF8): PSQLModelRecordPropertiesExternal;
begin
  MapFields([InternalName,ExternalName]);
  result := @self;
end;

procedure TSQLModelRecordPropertiesExternal.MapFields(
  const InternalExternalPairs: array of RawUTF8);
var i,int: Integer;
begin
  for i := 0 to (length(InternalExternalPairs) shr 1)-1 do begin
    int := fProps.Props.Fields.IndexByNameOrExcept(InternalExternalPairs[i*2]);
    if int<0 then begin
      fRowIDFieldName := InternalExternalPairs[i*2+1];
      if IdemPropNameU(fRowIDFieldName,'ID') then
        include(fFieldNamesMatchInternal,0) else     // [0]=ID
        exclude(fFieldNamesMatchInternal,0);
    end else begin
      fFieldNames[int] := InternalExternalPairs[i*2+1];
      if IdemPropNameU(fFieldNames[int],fProps.Props.Fields.List[int].Name) then
        include(fFieldNamesMatchInternal,int+1) else // [0]=ID
        exclude(fFieldNamesMatchInternal,int+1);
    end;
  end;
  ComputeSQL;
end;

procedure TSQLModelRecordPropertiesExternal.ComputeSQL;
  type // similar to TSQLModelRecordProperties.Create()/SetKind()
    TContent = (TableSimpleFields, UpdateSimple, UpdateSetAll, InsertAll);
  procedure SetSQL(W: TTextWriter;
    withID, withTableName: boolean; var result: RawUTF8;
    content: TContent=TableSimpleFields);
  var f: integer;
  begin
    W.CancelAll;
    if withID and (content=TableSimpleFields) then begin
      if withTableName then
        W.AddStrings([TableName,'.']);
      W.AddString(RowIDFieldName);
      if 0 in FieldNamesMatchInternal then
        W.Add(',') else
        W.AddShort(' as ID,');
    end;
    with fProps.Props do
    for f := 0 to Fields.Count-1 do
    with Fields.List[f] do
    if SQLFieldType in COPIABLE_FIELDS then // sftMany fields do not exist
      case content of
      TableSimpleFields:
        if f in SimpleFieldsBits[soSelect] then begin
          if withTableName then
            W.AddStrings([TableName,'.']);
          W.AddString(FieldNames[f]);
          if not(f+1 in FieldNamesMatchInternal) then
            W.AddStrings([' as ',Name]); // to get expected JSON column name
          W.Add(',');
        end;
      UpdateSimple:
        if f in SimpleFieldsBits[soSelect] then
          W.AddStrings([FieldNames[f],'=?,']);
      UpdateSetAll:
        W.AddStrings([FieldNames[f],'=?,']);
      InsertAll:
        W.AddStrings([FieldNames[f],',']);
      end;
    W.CancelLastComma;
    W.SetText(result);
  end;
var W: TTextWriter;
begin
  W := TTextWriter.CreateOwnedStream(1024);
  try // SQL.TableSimpleFields[withID: boolean; withTableName: boolean]
    SetSQL(W,false,false,fSQL.TableSimpleFields[false,false]);
    SetSQL(W,false,true,fSQL.TableSimpleFields[false,true]);
    SetSQL(W,true,false,fSQL.TableSimpleFields[true,false]);
    SetSQL(W,true,true,fSQL.TableSimpleFields[true,true]);
    // SQL.SelectAll: array[withRowID: boolean]
    fSQL.SelectAllWithRowID := SQLFromSelect(TableName,'*','',
      fSQL.TableSimpleFields[true,false]);
    fSQL.SelectAllWithID := fSQL.SelectAllWithRowID;
    SetSQL(W,false,false,fSQL.UpdateSetSimple,UpdateSimple);
    SetSQL(W,false,false,fSQL.UpdateSetAll,UpdateSetAll);
    SetSQL(W,false,false,fSQL.InsertSet,InsertAll);
  finally
    W.Free;
  end;
end;

function TSQLModelRecordPropertiesExternal.InternalToExternal(const FieldName: RawUTF8): RawUTF8;
var int: integer;
begin
  int := fProps.Props.Fields.IndexByNameOrExcept(FieldName);
  if int<0 then
    result := RowIDFieldName else 
    result := fFieldNames[int];
end;

function TSQLModelRecordPropertiesExternal.InternalCSVToExternalCSV(
  const CSVFieldNames, Sep, SepEnd: RawUTF8): RawUTF8;
var IntFields,ExtFields: TRawUTF8DynArray;
begin
  CSVToRawUTF8DynArray(CSVFieldNames,Sep,SepEnd,IntFields);
  InternalToExternalDynArray(IntFields,ExtFields);
  result := RawUTF8ArrayToCSV(ExtFields,Sep)+SepEnd;
end;

procedure TSQLModelRecordPropertiesExternal.InternalToExternalDynArray(
  const IntFieldNames: array of RawUTF8; out result: TRawUTF8DynArray);
var i: integer;
begin
  SetLength(result,length(IntFieldNames));
  for i := 0 to high(IntFieldNames) do
    result[i] := InternalToExternal(IntFieldNames[i]);
end;

function TSQLModelRecordPropertiesExternal.ExternalToInternalIndex(
  const ExtFieldName: RawUTF8): integer;
begin
  if IdemPropNameU(ExtFieldName,RowIDFieldName) then
    result := -1 else begin
    // search for customized field mapping
    for result := 0 to high(fFieldNames) do
      if IdemPropNameU(ExtFieldName,fFieldNames[result]) then
        exit;
    result := -2; // indicates not found
  end;
end;

function TSQLModelRecordPropertiesExternal.ExternalToInternalOrNull(
  const ExtFieldName: RawUTF8): RawUTF8;
var i: integer;
begin
  i := ExternalToInternalIndex(ExtFieldName);
  if i=-1 then
    result := 'ID' else
  if i>=0 then
    result := fProps.Props.Fields.List[i].Name else
    result := ''; // indicates not found
end;

function TSQLModelRecordPropertiesExternal.AppendFieldName(
  FieldIndex: Integer; var Text: RawUTF8): boolean;
begin
  result := false; // success
  if FieldIndex=VIRTUAL_TABLE_ROWID_COLUMN then
    Text := Text+RowIDFieldName else
  if cardinal(FieldIndex)>=cardinal(Length(FieldNames)) then
    result := true else // FieldIndex out of range
    Text := Text+FieldNames[FieldIndex];
end;

function TSQLModelRecordPropertiesExternal.FieldNameByIndex(FieldIndex: Integer): RawUTF8;
begin
  if FieldIndex=VIRTUAL_TABLE_ROWID_COLUMN then
    result := RowIDFieldName else
  if cardinal(FieldIndex)>=cardinal(Length(FieldNames)) then
    result := '' else // FieldIndex out of range
    result := FieldNames[FieldIndex];
end;

{ TSQLModelRecordProperties }

constructor TSQLModelRecordProperties.Create(aModel: TSQLModel;
  aTable: TSQLRecordClass; aKind: TSQLRecordVirtualKind);
var f: integer;
begin // similar to TSQLModelRecordPropertiesExternal.ComputeSQL
  fModel := aModel;
  fTableIndex := fModel.GetTableIndexExisting(aTable);
  fProps := aTable.RecordProps;
  SetKind(aKind);
  with Props do
    for f := 0 to Fields.Count-1 do
    with Fields.List[f] do
    if SQLFieldType in COPIABLE_FIELDS then begin // sftMany fields do not exist
      // pre-computation of SQL statements
      SQL.UpdateSetAll := SQL.UpdateSetAll+Name+'=?,';
      SQL.InsertSet := SQL.InsertSet+Name+',';
      if f in SimpleFieldsBits[soUpdate] then
        SQL.UpdateSetSimple := SQL.UpdateSetSimple+Name+'=?,';
      // filter + validation of unique fields, i.e. if marked as "stored false"
      if f in IsUniqueFieldsBits then begin
        // must trim() text value before storage, and validate for unicity
        if SQLFieldType in [sftUTF8Text,sftAnsiText] then
          AddFilterOrValidate(f,TSynFilterTrim.Create);
        // register unique field pre-validation
        AddFilterOrValidate(f,TSynValidateUniqueField.Create);
      end;
    end;
  SetLength(SQL.InsertSet,length(SQL.InsertSet)-1);
  SetLength(SQL.UpdateSetAll,length(SQL.UpdateSetAll)-1); // 'COL1=?,COL2=?'
  if SQL.UpdateSetSimple<>'' then
    SetLength(SQL.UpdateSetSimple,length(SQL.UpdateSetSimple)-1); // 'COL1=?,COL2=?'
  Props.InternalRegisterModel(aModel,aModel.GetTableIndexExisting(aTable),self);
end;

constructor TSQLModelRecordProperties.CreateFrom(aModel: TSQLModel;
  aSource: TSQLModelRecordProperties);
begin
  inherited Create;
  fModel := aModel;
  fTableIndex := aSource.fTableIndex;
  fProps := aSource.fProps;
  fKind := aSource.Kind;
  SQL := aSource.SQL;
  ExternalDB := aSource.ExternalDB;
  Props.InternalRegisterModel(fModel,fModel.GetTableIndexExisting(fProps.Table),self);
end;

procedure TSQLModelRecordProperties.SetKind(Value: TSQLRecordVirtualKind);
function IntSQLTableSimpleFields(withID, withTableName: boolean): RawUTF8;
const IDComma: array[TSQLRecordVirtualKind] of rawUTF8 =
  ('ID,','RowID,','RowID,','RowID,','RowID,','RowID,');
// rSQLite3, rFTS3, rFTS4, rRTree, rCustomForcedID, rCustomAutoID
var TableName: RawUTF8;
    i: integer;
begin
  if withTableName then
    TableName := Props.SQLTableName+'.'; // calc TableName once
  if withID then
    if withTableName then
      result := TableName+IDComma[Kind] else
      result := IDComma[Kind] else
    result := '';
  for i := 0 to high(Props.SimpleFields) do begin
    if withTableName then
      result := result+TableName;
    result := result+Props.SimpleFields[i].Name+','; // valid simple fields
  end;
  if result<>'' then
    SetLength(result,length(result)-1); // trim last ','
end;
begin
  fKind := Value;
  // SQL.TableSimpleFields[withID: boolean; withTableName: boolean]
  SQL.TableSimpleFields[false,false] := IntSQLTableSimpleFields(false,false);
  SQL.TableSimpleFields[false,true] := IntSQLTableSimpleFields(false,true);
  SQL.TableSimpleFields[true,false] := IntSQLTableSimpleFields(true,false);
  SQL.TableSimpleFields[true,true] := IntSQLTableSimpleFields(true,true);
  assert(Props.SQLTableSimpleFieldsNoRowID=SQL.TableSimpleFields[false,false]);
  SQL.SelectAllWithRowID := SQLFromSelectWhere('*','');
  SQL.SelectAllWithID := SQL.SelectAllWithRowID;
  if IdemPChar(PUTF8Char(pointer(SQL.SelectAllWithID))+7,'ROWID') then
    delete(SQL.SelectAllWithID,8,3); // 'SELECT RowID,..' -> 'SELECT ID,'
end;

function TSQLModelRecordProperties.SQLFromSelectWhere(
  const SelectFields, Where: RawUTF8): RawUTF8;
begin
  result := SQLFromSelect(Props.SQLTableName,SelectFields,Where,
    SQL.TableSimpleFields[true,false]);
end;


{ TSQLModel }

procedure TSQLModel.SetTableProps(aIndex: integer);
var i, j, f, R: integer;
    Kind: TSQLRecordVirtualKind;
    Table: TSQLRecordClass;
    aTableName: RawUTF8;
    Props: TSQLModelRecordProperties;
    Search: TClass;
    W: TTextWriter;
begin
  assert((cardinal(aIndex)<=cardinal(fTablesMax)) and (fTableProps[aIndex]=nil));
  Table := fTables[aIndex];
  if Table.InheritsFrom(TSQLRecordFTS4) then
    Kind := rFTS4 else
  if Table.InheritsFrom(TSQLRecordFTS3) then
    Kind := rFTS3 else
  if Table.InheritsFrom(TSQLRecordVirtualTableForcedID) then
    Kind := rCustomForcedID else
  if Table.InheritsFrom(TSQLRecordRTree) then
    Kind := rRTree else
  if Table.InheritsFrom(TSQLRecordVirtual) then
    Kind := rCustomAutoID else
    Kind := rSQLite3;
  Props := TSQLModelRecordProperties.Create(self,Table,Kind);
  Props.Props.InternalRegisterModel(Self,aIndex,Props);
  if fCustomCollationForAllRawUTF8<>'' then
    Props.Props.SetCustomCollationForAllRawUTF8(fCustomCollationForAllRawUTF8);
  fTableProps[aIndex] := Props;
  aTableName := Props.Props.SQLTableName;
  fSortedTablesName[aIndex] := aTableName;
  fSortedTablesNameIndex[aIndex] := aIndex;
  with Props.Props.Fields do
  for f := 0 to Count-1 do begin
    case List[f].SQLFieldType of
    sftRecord, sftID: begin
      R := length(fRecordReferences);
      SetLength(fRecordReferences,R+1);
      with fRecordReferences[R] do begin
        TableIndex := aIndex;
        FieldType := List[f] as TSQLPropInfoRTTIInstance;
      end;
    end;
    sftMany: begin
      Search := (List[f] as TSQLPropInfoRTTIMany).ObjectClass;
      for i := 0 to fTablesMax do // manual search:  GetTableIndex() may fail
        if fTables[i]=Search then begin
          Search := nil;
          break;
        end;
      if Search<>nil then
        raise EModelException.CreateFmt('%s must include %s for %s.%s',
          [ClassName,Search.ClassName,Tables[aIndex].ClassName,List[f].Name]);
    end;
    end;
  end;
  if Props.Props.JoinedFieldsTable<>nil then begin
    W := TTextWriter.CreateOwnedStream;
    try
      W.AddShort('SELECT ');
      for j := 0 to high(Props.Props.JoinedFieldsTable) do
      with Props.Props.JoinedFieldsTable[j].RecordProps do begin
        W.Add('%.RowID as `%.RowID`,',[SQLTableName,SQLTableName]);
        for f := 0 to High(SimpleFields) do
          if SimpleFields[f].SQLFieldType<>sftID then
            W.Add('%.% as `%.%`,',[SQLTableName,SimpleFields[f].Name,
              SQLTableName,SimpleFields[f].Name]);
      end;
      W.CancelLastComma;
      W.AddStrings([' FROM ',aTableName]);
      for f := 1 to high(Props.Props.JoinedFieldsTable) do
        with Props.Props.JoinedFieldsTable[f].RecordProps do
          W.Add(' LEFT JOIN % ON %.%=%.RowID',[
            SQLTableName,aTableName,Props.Props.JoinedFields[f-1].Name,SQLTableName]);
      W.SetText(Props.SQL.SelectAllJoined);
    finally
      W.Free;
    end;
  end;
end;

function TSQLModel.GetTableProps(aClass: TSQLRecordClass): TSQLModelRecordProperties;
begin
  result := fTableProps[GetTableIndexExisting(aClass)];
end;

function TSQLModel.AddTable(aTable: TSQLRecordClass; aTableIndexCreated: PInteger=nil): boolean;
var n: integer;
begin
  if GetTableIndex(aTable)>=0 then begin
    result := false;
    exit;
  end;
  inc(fTablesMax);
  n := fTablesMax+1;
  SetLength(fTables,n);
  SetLength(fSortedTablesName,n);
  SetLength(fSortedTablesNameIndex,n);
  SetLength(fTableProps,n);
  fTables[fTablesMax] := aTable;
  SetTableProps(fTablesMax);
  QuickSortRawUTF8(fSortedTablesName,fTablesMax+1,@fSortedTablesNameIndex,@StrIComp);
  if aTableIndexCreated<>nil then
    aTableIndexCreated^ := fTablesMax;
  result := true;
end;

constructor TSQLModel.Create(CloneFrom: TSQLModel);
var i: integer;
begin
  if CloneFrom=nil then
    raise EModelException.Create('TSQLModel.Create(CloneFrom=nil)');
  fTables := CloneFrom.fTables;
  fTablesMax := CloneFrom.fTablesMax;
  fRoot := CloneFrom.fRoot;
  fActions := CloneFrom.fActions;
  fEvents := CloneFrom.fEvents;
  fRestOwner := CloneFrom.fRestOwner;
  fSortedTablesName := CloneFrom.fSortedTablesName;
  fSortedTablesNameIndex := CloneFrom.fSortedTablesNameIndex;
  fRecordReferences := CloneFrom.fRecordReferences;
  fVirtualTableModule := CloneFrom.fVirtualTableModule;
  fCustomCollationForAllRawUTF8 := CloneFrom.fCustomCollationForAllRawUTF8;
  SetLength(fTableProps,fTablesMax+1);
  for i := 0 to fTablesMax do
    fTableProps[i] := TSQLModelRecordProperties.CreateFrom(
      self,CloneFrom.fTableProps[i]);
end;

constructor TSQLModel.Create(Owner: TSQLRest; TabParameters: PSQLRibbonTabParameters;
  TabParametersCount, TabParametersSize: integer;
  const NonVisibleTables: array of TSQLRecordClass;
  Actions, Events: PTypeInfo; const aRoot: RawUTF8);
var i: integer;
    Tables: array of TSQLRecordClass;
begin
  if (TabParameters=nil) or (TabParametersCount<=0) or
     (cardinal(TabParametersSize)<sizeof(TSQLRibbonTabParameters)) then
    raise EModelException.Create('TSQLModel.Create(TabParameters?)');
  SetLength(Tables,TabParametersCount+length(NonVisibleTables));
  for i := 0 to TabParametersCount-1 do begin
    Tables[i] := TabParameters^.Table;
    inc(PtrUInt(TabParameters),TabParametersSize);
  end;
  for i := 0 to high(NonVisibleTables) do
    Tables[i+TabParametersCount] := NonVisibleTables[i];
  Create(Tables,aRoot);
  fRestOwner := Owner;
  SetActions(Actions);
  SetEvents(Events);
end;

constructor TSQLModel.Create(const Tables: array of TSQLRecordClass; const aRoot: RawUTF8);
var N, i: integer;
begin
  N := length(Tables);
  if N>sizeof(SUPERVISOR_ACCESS_RIGHTS.Get)*8 then // TSQLAccessRights bits size
    raise EModelException.CreateFmt('%s has too many Tables: %d>%d',
      [ClassName,N,sizeof(SUPERVISOR_ACCESS_RIGHTS.Get)*8]); // e.g. N>64
  // set the Tables to be associated with this Model, as TSQLRecord classes
  fTablesMax := N-1;
  SetLength(fTables,N);
  move(Tables[0],fTables[0],N*Sizeof(Tables[0]));
  SetLength(fSortedTablesName,N);
  SetLength(fSortedTablesNameIndex,N);
  SetLength(fTableProps,N);
  // initialize internal properties
  for i := 0 to fTablesMax do
    SetTableProps(i);
  QuickSortRawUTF8(fSortedTablesName,fTablesMax+1,@fSortedTablesNameIndex,@StrIComp);
  // set the optional Root URI path of this Model
  if aRoot<>'' then
    if aRoot[length(aRoot)]='/' then
      fRoot := copy(aRoot,1,Length(aRoot)-1) else
      fRoot := aRoot;
end;

function TSQLModel.GetIsUnique(aTable: TSQLRecordClass; aFieldIndex: integer): boolean;
var i: integer;
begin
  i := GetTableIndex(aTable);
  if (i<0) or (Cardinal(aFieldIndex)>=MAX_SQLFIELDS) then
    Result := false else
    Result := aFieldIndex in TableProps[i].Props.IsUniqueFieldsBits;
end;

function TSQLModel.GetTableIndexFromSQLSelect(const SQL: RawUTF8;
  EnsureUniqueTableInFrom: boolean): integer;
var i,j,k: integer;
    TableName: RawUTF8;
begin
  i := PosI(' FROM ',SQL);
  if i>0 then begin
    inc(i,6);
    while SQL[i] in [#1..' '] do inc(i);
    j := 0;
    while ord(SQL[i+j]) in IsIdentifier do inc(j);
    if j>0 then begin
      k := i+j;
      while SQL[k] in [#1..' '] do inc(k);
      if (not EnsureUniqueTableInFrom) or (SQL[k]<>',') then begin 
        SetString(TableName,PAnsiChar(PtrInt(SQL)+i-1),j);
        result := GetTableIndex(TableName);
        exit;
      end;
    end;
  end;
  result := -1;
end;

function TSQLModel.GetTable(const SQLTableName: RawUTF8): TSQLRecordClass;
var i: integer;
begin
  i := GetTableIndex(SQLTableName);
  if i>=0 then
    result := Tables[i] else
    result := nil;
end;

function TSQLModel.GetTableExactClass(const TableName: RawUTF8): TSQLRecordClass;
var i: integer;
begin
  i := GetTableExactIndex(TableName);
  if i>=0 then
    result := Tables[i] else
    result := nil;
end;

function TSQLModel.GetTableIndex(aTable: TSQLRecordClass): integer;
var i: integer;
    Props: TSQLRecordProperties;
begin
  if (self<>nil) and (aTable<>nil) then begin
    Props := PPointer(PtrInt(aTable)+vmtAutoTable)^;
    if (Props<>nil) and (Props.fModelMax>=0) and (Props.fModelMax<fTablesMax) then
      // fastest O(1) search in all registered models (if worth it)
      for i := 0 to Props.fModelMax do
        if Props.fModel[i].Model=self then begin
          result := Props.fModel[i].TableIndex;
          exit;
        end;
    // manual search e.g. if fModel[] is not yet set
    for result := 0 to fTablesMax do
      if Tables[result]=aTable then
        exit;
  end;
  result := -1;
end;

function TSQLModel.GetTableIndexInheritsFrom(aTable: TSQLRecordClass): integer;
begin
  if (self<>nil) and (aTable<>nil) and (aTable<>TSQLRecord) then
    for result := 0 to fTablesMax do
      if Tables[result].InheritsFrom(aTable) then
        exit;
  result := -1;
end;

function TSQLModel.GetTableIndexExisting(aTable: TSQLRecordClass): integer;
begin
  if aTable=nil then
    raise EModelException.Create('TSQLRecordClass=nil');
  result := GetTableIndex(aTable);
  if result<0 then
    raise EModelException.CreateFmt('%s should be part of the Model',
      [PShortString(PPointer(PtrInt(aTable)+vmtClassName)^)^]);
end;

function TSQLModel.GetTableExactIndex(const TableName: RawUTF8): integer;
var L: integer;
begin
  if self<>nil then begin
  L := length(TableName);
  for result := 0 to fTablesMax do
    if Tables[result]<>nil then // avoid GPF
    if IdemPropName(
       // new TObject.ClassName is UnicodeString (Delphi 20009) -> inline code with
       // vmtClassName = UTF-8 encoded text stored in a shortstring
       PShortString(PPointer(PtrInt(Tables[result])+vmtClassName)^)^,
       pointer(TableName),L) then
      exit;  // case insensitive search
  end;
  result := -1;
end;

function TSQLModel.GetTableIndex(const SQLTableName: RawUTF8): integer;
begin
  if (self<>nil) and (SQLTableName<>'') then begin
    // fast binary search
    result := FastFindPUTF8CharSorted(pointer(fSortedTablesName),fTablesMax,pointer(SQLTableName),@StrIComp);
    if result>=0 then
      result := fSortedTablesNameIndex[result];
  end else
    result := -1;
end;

function TSQLModel.GetTableIndex(SQLTableName: PUTF8Char): integer;
begin
  if (self<>nil) and (SQLTableName<>nil) then begin
    // fast binary search
    result := FastFindPUTF8CharSorted(pointer(fSortedTablesName),fTablesMax,SQLTableName,@StrIComp);
    if result>=0 then
      result := fSortedTablesNameIndex[result];
  end else
    result := -1;
end;

function TSQLModel.getURI(aTable: TSQLRecordClass): RawUTF8;
begin
  result := '';
  if self=nil then
    exit;
  if aTable<>nil then
    result := aTable.RecordProps.SQLTableName else begin
    result := Root;
    exit;
  end;
  if Root<>'' then
    result := Root+'/'+result;
end;

function TSQLModel.URIMatch(const URI: RawUTF8): boolean;
begin
  result := false;
  if (self=nil) or (fRoot='') or (URI='') then
    exit;
  if fRootUpper='' then
    UpperCaseCopy(fRoot,fRootUpper);
  if IdemPChar(pointer(URI),pointer(fRootUpper)) then
    if URI[length(fRootUpper)+1] in [#0,'/','?'] then
      result := true;
end;

function TSQLModel.SQLFromSelectWhere(const Tables: array of TSQLRecordClass;
   const SQLSelect, SQLWhere: RawUTF8): RawUTF8;
var i: integer;
    aProps: array[0..31] of TSQLModelRecordProperties;
begin
  if self=nil then
    raise EORMException.Create('Model required');
  if high(Tables)=0 then begin
    // fastest common call with one TSQLRecordClass
    result := Props[Tables[0]].SQLFromSelectWhere(SQLSelect,SQLWhere);
    exit;
  end;
  // 'SELECT T1.F1,T1.F2,T1.F3,T2.F1,T2.F2 FROM T1,T2 WHERE ..' e.g.
  if PtrUInt(high(Tables))>high(aProps) then
    raise EModelException.Create('SQLFromSelectWhere');
  for i := 0 to high(Tables) do
    aProps[i] := Props[Tables[i]]; // raise EModelException if not found
  if SQLSelect='*' then
     // don't send BLOB values to query: retrieve all other fields
    if high(Tables)=0 then
      result := 'SELECT '+aProps[0].SQL.TableSimpleFields[true,false] else begin
      result := 'SELECT '+aProps[0].SQL.TableSimpleFields[true,true];
      for i := 1 to high(Tables) do
        result := result+','+aProps[i].SQL.TableSimpleFields[true,true];
    end else
    result := 'SELECT '+SQLSelect;
  result := result+' FROM '+aProps[0].Props.SQLTableName;
  for i := 1 to high(Tables) do
    result := result+','+aProps[i].Props.SQLTableName;
  if SQLWhere<>'' then
    if IdemPChar(pointer(SQLWhere),'ORDER BY ') or
       IdemPChar(pointer(SQLWhere),'GROUP BY ') or
       IdemPChar(pointer(SQLWhere),'LIMIT ') then
      result := result+' '+SQLWhere else
      result := result+' WHERE '+SQLWhere;
  result := result+';';
end;

procedure TSQLModel.SetCustomCollationForAllRawUTF8(const aCollationName: RawUTF8);
var i: integer;
begin
  if self=nil then
    exit;
  if fCustomCollationForAllRawUTF8<>'' then
    raise EModelException.CreateFmt(
      'TSQLModel.SetCustomCollationForAllRawUTF8(%s) shall be called only once',
      [aCollationName]);
  fCustomCollationForAllRawUTF8 := aCollationName;
  for i := 0 to high(fTableProps) do
    fTableProps[i].fProps.SetCustomCollationForAllRawUTF8(aCollationName);
end;

function TSQLModel.NewRecord(const SQLTableName: RawUTF8): TSQLRecord;
var aClass: TSQLRecordClass;
begin
  aClass := Table[SQLTableName];
  if aClass=nil then
    result := nil else
    result := aClass.Create;
end;

procedure TSQLModel.SetActions(aActions: PTypeInfo);
begin
  if (aActions=nil) or not (aActions^.Kind=tkEnumeration) then
    fActions := nil else
    fActions := aActions^.EnumBaseType;
end;

procedure TSQLModel.SetEvents(aEvents: PTypeInfo);
begin
  if (aEvents=nil) or not (aEvents^.Kind=tkEnumeration) then
    fEvents := nil else
    fEvents := aEvents^.EnumBaseType;
end;

function TSQLModel.GetSQLCreate(aTableIndex: integer): RawUTF8;
begin
  if (self=nil) or (cardinal(aTableIndex)>cardinal(fTablesMax)) then
    result := '' else
    result := Tables[aTableIndex].GetSQLCreate(self);
end;

function TSQLModel.GetSQLAddField(aTableIndex, aFieldIndex: integer): RawUTF8;
begin
  if (self=nil) or (cardinal(aTableIndex)>cardinal(fTablesMax)) then
    result := '' else
    result := TableProps[aTableIndex].Props.SQLAddField(aFieldIndex);
end;

function TSQLModel.isLocked(aTable: TSQLRecordClass; aID: integer): boolean;
begin
  result := GetLocks(aTable)^.isLocked(aID);
end;

function TSQLModel.isLocked(aRec: TSQLRecord): boolean;
begin
  if aRec=nil then
    result := false else
    result := isLocked(PSQLRecordClass(aRec)^,aRec.fID);
end;

function TSQLModel.Lock(aTable: TSQLRecordClass; aID: integer): boolean;
begin
  if self=nil then
    result := false else begin
    if fLocks=nil then
      SetLength(fLocks,fTablesMax+1); // initialize fLocks[] if necessary
    result :=  GetLocks(aTable)^.Lock(aID);
  end;
end;

function TSQLModel.Lock(aTableIndex, aID: integer): boolean;
begin
  if (self=nil) or (Cardinal(aTableIndex)>cardinal(fTablesMax)) then
    result := false else begin
    if fLocks=nil then
      SetLength(fLocks,fTablesMax+1); // initialize fLocks[] if necessary
    result := fLocks[aTableIndex].Lock(aID);
  end;
end;

function TSQLModel.Lock(aRec: TSQLRecord): boolean;
begin
  if aRec=nil then
    result := false else
    result := Lock(PSQLRecordClass(aRec)^,aRec.fID);
end;

procedure TSQLModel.PurgeOlderThan(MinutesFromNow: cardinal);
var i: integer;
begin
  if fLocks<>nil then
    for i := 0 to high(fLocks) do
     fLocks[i].PurgeOlderThan(MinutesFromNow);
end;

function TSQLModel.UnLock(aTable: TSQLRecordClass; aID: integer): boolean;
begin
  if (self=nil) or (fLocks=nil) then
    result := false else
    result := GetLocks(aTable)^.UnLock(aID);
end;

function TSQLModel.UnLock(aTableIndex: integer; aID: integer): boolean;
begin
  if (self=nil) or (cardinal(aTableIndex)>=cardinal(length(fLocks))) then
    result := false else
    result := fLocks[aTableIndex].UnLock(aID);
end;

function TSQLModel.UnLock(aRec: TSQLRecord): boolean;
begin
  if aRec=nil then
    result := false else
    result := UnLock(PSQLRecordClass(aRec)^,aRec.fID);
end;

function TSQLModel.GetLocks(aTable: TSQLRecordClass): PSQLLocks;
begin
  if (self=nil) or (fLocks=nil) then
    result := nil else
    result := @fLocks[GetTableIndexExisting(aTable)];
end;

procedure TSQLModel.UnLockAll;
var i: integer;
begin
  for i := 0 to high(fLocks) do
    fLocks[i].Count := 0;
end;

function TSQLModel.getURIID(aTable: TSQLRecordClass; aID: integer): RawUTF8;
begin
  result := getURI(aTable);
  if aID>0 then
    result := result+'/'+{$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(aID);
end;

function TSQLModel.getURICallBack(const aMethodName: RawUTF8; aTable: TSQLRecordClass; aID: integer): RawUTF8;
begin
  result := getURIID(aTable,aID)+'/'+aMethodName;
end;

function TSQLModel.ActionName(const Action): string;
begin
  if (Self=nil) or (fActions=nil) then
    result := '' else
    result := TSQLRecord.CaptionNameFromRTTI(fActions^.GetEnumName(byte(Action)));
end;

function TSQLModel.EventName(const Event): string;
begin
  if (Self=nil) or (fEvents=nil) then
    result := '' else
    result := TSQLRecord.CaptionNameFromRTTI(fEvents^.GetEnumName(byte(Event)));
end;

function TSQLModel.RecordReference(Table: TSQLRecordClass; ID: integer): TRecordReference;
begin
  if (self=nil) or (ID<=0) then
    result := 0 else begin
    result := GetTableIndexExisting(Table);
    if result>63 then // TRecordReference handle up to 64=1 shl 6 tables
      result := 0 else
      inc(result,ID shl 6);
  end;
end;

function TSQLModel.VirtualTableRegister(aClass: TSQLRecordClass;
  aModule: TSQLVirtualTableClass; const aExternalTableName: RawUTF8='';
  aExternalDataBase: TObject=nil): boolean;
var i: integer;
begin
  result := false;
  if aClass=nil then exit;
  i := GetTableIndexExisting(aClass);
  with TableProps[i] do begin
    if not (Kind in IS_CUSTOM_VIRTUAL) then
      if Kind=rSQLite3 then
        SetKind(rCustomAutoID) else // SetKind() recompute all SQL
        raise EModelException.CreateFmt('Invalid VirtualTableRegister(%s) call: '+
          'impossible to set class as virtual',[aClass.ClassName]);
    ExternalDB.Init(TableProps[i],aExternalTableName,aExternalDataBase);
  end;
  if high(fVirtualTableModule)<>fTablesMax then
    SetLength(fVirtualTableModule,fTablesMax+1);
  fVirtualTableModule[i] := aModule;
  result := true;
end;

function TSQLModel.VirtualTableModule(aClass: TSQLRecordClass): TSQLVirtualTableClass;
var i: integer;
begin
  result := nil;
  if (self=nil) or (fVirtualTableModule=nil) then
    exit;
  i := GetTableIndexExisting(aClass);
  if TableProps[i].Kind in IS_CUSTOM_VIRTUAL then
    result := fVirtualTableModule[i];
end;

destructor TSQLModel.Destroy;
var i,j: integer;
begin
  for i := 0 to fTablesMax do begin
    with TableProps[i].Props do begin
      EnterCriticalSection(fLock); // may be called from several threads at once
      try
        for j := 0 to fModelMax do
          if fModel[j].Model=self then begin
            // un-associate this TSQLRecord with this model
            Move(fModel[j+1],fModel[j],(fModelMax-j)*sizeof(fModel[j]));
            dec(fModelMax);
            break;
          end;
        TableProps[i].Free;
      finally
        LeaveCriticalSection(fLock);
      end;
    end;
  end;
  inherited;
end;


{ TSQLRest }

constructor TSQLRest.Create(aModel: TSQLModel);
var cmd: TSQLRestServerURIContextCommand;
begin
  fModel := aModel;
  AcquireWriteMode := amLocked;
  AcquireWriteTimeOut := 2000; // default 2 seconds
  fRoutingClass := TSQLRestRoutingREST;
  for cmd := Low(cmd) to high(cmd) do
    InitializeCriticalSection(fAcquireExecution[cmd].Lock);
end;

destructor TSQLRest.Destroy;
var cmd: TSQLRestServerURIContextCommand;
begin
  if (fModel<>nil) and (fModel.fRestOwner=self) then
    // make sure we are the Owner (TSQLRestStorage has fModel<>nil e.g.)
    FreeAndNil(fModel);
  fServices.Free;
  fCache.Free;
  for cmd := Low(cmd) to high(cmd) do begin
    DeleteCriticalSection(fAcquireExecution[cmd].Lock);
    fAcquireExecution[cmd].Thread.Free;
  end;
  inherited Destroy;
end;

procedure TSQLRest.InternalLog(const Text: RawUTF8; Level: TSynLogInfo);
begin
  {$ifdef WITHLOG}
  SQLite3Log.Add.Log(Level,Text,self);
  {$endif}
end;

procedure TSQLRest.SetRoutingClass(aServicesRouting: TSQLRestServerURIContextClass);
begin
  if self<>nil then
    if aServicesRouting<>fRoutingClass then
      if (aServicesRouting=nil) or (aServicesRouting=TSQLRestServerURIContext) then
         raise EServiceException.Create('Unexpected routing class') else
         fRoutingClass := aServicesRouting;
end;

function TSQLRest.MultiFieldValue(Table: TSQLRecordClass;
  const FieldName: array of RawUTF8; var FieldValue: array of RawUTF8;
  WhereID: integer): boolean;
begin
  result := MultiFieldValue(Table,FieldName,FieldValue,'RowID=:('+
    {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(WhereID)+'):');
end;

function TSQLRest.OneFieldValue(Table: TSQLRecordClass; const FieldName,
  WhereClause: RawUTF8): RawUTF8;
var Res: array[0..0] of RawUTF8;
begin
  if MultiFieldValue(Table,[FieldName],Res,WhereClause) then
    result := Res[0] else
    result := '';
end;

function TSQLRest.OneFieldValue(Table: TSQLRecordClass; const FieldName: RawUTF8;
  FormatSQLWhere: PUTF8Char; const BoundsSQLWhere: array of const): RawUTF8;
begin
  result := OneFieldValue(Table,FieldName,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere));
end;

function TSQLRest.OneFieldValue(Table: TSQLRecordClass;
  const FieldName: RawUTF8; WhereClauseFmt: PUTF8Char;
  const Args, Bounds: array of const): RawUTF8;
begin
  result := OneFieldValue(Table,FieldName,FormatUTF8(WhereClauseFmt,Args,Bounds));
end;

function TSQLRest.OneFieldValue(Table: TSQLRecordClass;
  const FieldName: RawUTF8; WhereID: integer): RawUTF8;
var Res: array[0..0] of RawUTF8;
begin
  if (WhereID>0) and MultiFieldValue(Table,[FieldName],Res,'RowID=:('+
    {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(WhereID)+'):') then
    result := Res[0] else
    result := '';
end;

function TSQLRest.OneFieldValues(Table: TSQLRecordClass; const FieldName,
  WhereClause: RawUTF8; var Data: TRawUTF8DynArray): boolean;
var i: integer;
    T: TSQLTableJSON;
begin
  SetLength(Data,0);
  result := false;
  T := MultiFieldValues(Table,FieldName,WhereClause);
  if T<>nil then
  try
    if (T.FieldCount<>1) or (T.RowCount<=0) then
      exit;
    // get row values
    SetLength(Data,T.RowCount);
    for i := 1 to T.RowCount do // ignore fResults[0] i.e. field name
      Data[i-1] := T.fResults[i];
    result := true;
  finally
    T.Free;
  end;
end;

function TSQLRest.OneFieldValues(Table: TSQLRecordClass; const FieldName,
  WhereClause: RawUTF8; Strings: TStrings; IDToIndex: PInteger=nil): Boolean;
var Row, aID: integer;
    T: TSQLTableJSON;
begin
  result := false;
  if (Strings<>nil) and (self<>nil) and (Table<>nil) then
  try
    {$ifndef LVCL}
    Strings.BeginUpdate;
    {$endif}
    Strings.Clear;
    T := ExecuteList([Table],
      SQLFromSelect(Table.SQLTableName,'ID,'+FieldName,WhereClause,''));
    if T<>nil then
    try
      if (T.FieldCount=2) and (T.RowCount>0) then begin
        for Row := 1 to T.RowCount do begin // ignore Row 0 i.e. field names
          aID := GetInteger(T.Get(Row,0));
          Strings.AddObject(UTF8ToString(T.GetU(Row,1)),pointer(aID));
          if (IDToIndex<>nil) and (aID=IDToIndex^) then begin
            IDToIndex^ := Row-1;
            IDToIndex := nil; // set once
          end;
        end;
        result := true;
      end;
    finally
      T.Free;
    end;
  finally
    {$ifndef LVCL}
    Strings.EndUpdate;
    {$endif}
  end;
  if IDToIndex<>nil then
    IDToIndex^ := -1; // ID not found
end;

function TSQLRest.OneFieldValues(Table: TSQLRecordClass; const FieldName,
  WhereClause, Separator: RawUTF8): RawUTF8;
var i, Len, SepLen, L: integer;
    T: TSQLTableJSON;
    P: PUTF8Char;
begin
  result := '';
  T := MultiFieldValues(Table,FieldName,WhereClause);
  if T<>nil then
  try
    if (T.FieldCount<>1) or (T.RowCount<=0) then
      exit;
    // calculate row values CSV needed memory
    SepLen := length(Separator);
    Len := 0;
    for i := 1 to T.RowCount do // ignore fResults[0] i.e. field name
      inc(Len,StrLen(T.fResults[i])+SepLen);
    dec(Len,SepLen);
    SetLength(result,Len);
    // add row values as CSV
    P := pointer(result);
    for i := 1 to T.RowCount do begin // ignore fResults[0] i.e. field name
      L := StrLen(T.fResults[i]);
      if L<>0 then begin
        move(T.fResults[i]^,P^,L);
        inc(P,L);
      end;
      if i=T.RowCount then
        break;
      move(pointer(Separator)^,P^,SepLen);
      inc(P,SepLen);
    end;
    assert(P-pointer(result)=Len);
  finally
    T.Free;
  end;
end;

function TSQLRest.OneFieldValues(Table: TSQLRecordClass; const FieldName,
  WhereClause: RawUTF8; var Data: TIntegerDynArray; SQL: PRawUTF8=nil): boolean;
var T: TSQLTableJSON;
    V,err: integer;
    Prop: RawUTF8;
    P: PUTF8Char;
begin
  Data := nil;
  // handle naive expressions like SELECT ID from Table where ID=10
  if IsRowID(pointer(FieldName)) and (length(WhereClause)>2) then begin
    P := pointer(WhereClause);
    GetNextFieldProp(P,Prop);
    if IsRowIDShort(Prop) then
      case P^ of
      '=': begin
        inc(P);
        if PWord(P)^=ord(':')+ord('(')shl 8 then
          inc(P,2); // handle inlined parameters
        V := GetInteger(P,err);
        if err=0 then begin
          SetLength(Data,1);
          Data[0] := V;
          result := true;
          exit;
        end;
      end;
      'i','I': if P[1] in ['n','N'] then begin
        P := GotoNextNotSpace(P+2);
        if (P^='(') and (GotoNextNotSpace(P+1)^ in ['0'..'9']) then begin
          CSVToIntegerDynArray(P+1,Data);
          if Data<>nil then begin
            result := true;
            exit;
          end;
        end;
      end;
      end;
  end;
  // retrieve the content from database
  result := false;
  T := MultiFieldValues(Table,FieldName,WhereClause);
  if T<>nil then
  try
    if (T.FieldCount<>1) or (T.RowCount<=0) then
      exit;
    T.GetRowValues(0,Data);
    if SQL<>nil then
      SQL^ := T.QuerySQL;
    result := true;
  finally
    T.Free;
  end;
end;

function TSQLRest.MultiFieldValues(Table: TSQLRecordClass;
  const FieldNames, WhereClause: RawUTF8): TSQLTableJSON;
var sql: RawUTF8;
begin
  result := nil;
  if (self=nil) or (Table=nil) then
    exit;
  if FieldNames='' then
    sql := Model.Props[Table].SQLFromSelectWhere('*',WhereClause) else
  with Table.RecordProps do
  if FieldNames='*' then
    sql := SQLFromSelect(SQLTableName,SQLTableRetrieveAllFields,WhereClause,'') else
  if (PosEx(RawUTF8(','),FieldNames,1)=0) and not IsFieldName(FieldNames) then
    exit else // prevent SQL error
    sql := SQLFromSelect(SQLTableName,FieldNames,WhereClause,'');
  result := ExecuteList([Table],sql);
end;

function TSQLRest.MultiFieldValues(Table: TSQLRecordClass; const FieldNames: RawUTF8;
  WhereClauseFormat: PUTF8Char; const BoundsSQLWhere: array of const): TSQLTableJSON;
begin
  result := MultiFieldValues(Table,FieldNames,FormatUTF8(WhereClauseFormat,[],BoundsSQLWhere));
end;

function TSQLRest.MultiFieldValues(Table: TSQLRecordClass;
  const FieldNames: RawUTF8; WhereClauseFormat: PUTF8Char;
  const Args, Bounds: array of const): TSQLTableJSON;
begin
  result := MultiFieldValues(Table,FieldNames,FormatUTF8(WhereClauseFormat,Args,Bounds));
end;

function TSQLRest.MultiFieldValue(Table: TSQLRecordClass;
  const FieldName: array of RawUTF8; var FieldValue: array of RawUTF8;
  const WhereClause: RawUTF8): boolean;
var SQL: RawUTF8;
    i: integer;
    T: TSQLTableJSON;
begin
  result := false;
  if (self<>nil) and (Table<>nil) and (length(FieldName)=length(FieldValue)) then
  with Table.RecordProps do begin
    for i := 0 to high(FieldName) do
      if not IsFieldName(FieldName[i]) then
        exit else // prevent SQL error
        if SQL='' then
          SQL := 'SELECT '+FieldName[i] else
          SQL := SQL+','+FieldName[i];
    SQL := SQL+' FROM '+SQLTableName+' WHERE '+WhereClause+' LIMIT 1;';
    T := ExecuteList([Table],SQL);
    if T<>nil then
    try
      if (T.FieldCount<>length(FieldName)) or (T.RowCount<=0) then
        exit;
      // get field values from the first (and unique) row
      for i := 0 to T.FieldCount-1 do
        FieldValue[i] := T.fResults[T.FieldCount+i];
      result := true;
    finally
      T.Free;
    end;
  end;
end;

function TSQLRest.Retrieve(const SQLWhere: RawUTF8; Value: TSQLRecord): boolean;
var T: TSQLTable;
begin
  if (self=nil) or (Value=nil) then
    T := nil else
    T := ExecuteList([PSQLRecordClass(Value)^],
      Model.Props[PSQLRecordClass(Value)^].SQLFromSelectWhere('*',SQLWhere+' LIMIT 1'));
  if T=nil then
    result := false else
    try
      if T.RowCount>=1 then begin
        Value.FillFrom(T,1); // fetch data from first result row
        result := true;
      end else begin
        Value.fID := 0;
        result := false;
      end;
    finally
      T.Free;
    end;
end;

function TSQLRest.RetrieveList(Table: TSQLRecordClass; FormatSQLWhere: PUTF8Char;
  const BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8): TObjectList;
var T: TSQLTable;
begin
  result := nil;
  if (self=nil) or (Table=nil) then
    exit;
  T := MultiFieldValues(Table,aCustomFieldsCSV,FormatSQLWhere,BoundsSQLWhere);
  if T<>nil then
  try
    result := TObjectList.Create;
    T.ToObjectList(result,Table);
  finally
    T.Free;
  end;
end;

{$ifndef NOVARIANTS}
function TSQLRest.RetrieveDocVariantArray(Table: TSQLRecordClass;
  const ObjectName: RawUTF8;
  FormatSQLWhere: PUTF8Char; const BoundsSQLWhere: array of const;
  const CustomFieldsCSV: RawUTF8): variant;
var T: TSQLTable;
    res: variant;
begin
  TVarData(res).VType := varNull;
  if (self<>nil) and (Table<>nil) then begin
    T := MultiFieldValues(Table,CustomFieldsCSV,FormatSQLWhere,BoundsSQLWhere);
    if T<>nil then
    try
      T.ToDocVariant(res,false); // readonly=false -> TDocVariant dvArray
    finally
      T.Free;
    end;
  end;
  if ObjectName<>'' then
    result := _ObjFast([ObjectName,res]) else
    result := res;
end;

function TSQLRest.RetrieveDocVariantArray(Table: TSQLRecordClass;
  const ObjectName, CustomFieldsCSV: RawUTF8): variant;
begin
  result := RetrieveDocVariantArray(Table,ObjectName,nil,[],CustomFieldsCSV);
end;
{$endif}

function TSQLRest.Retrieve(aID: integer; Value: TSQLRecord;
  ForUpdate: boolean): boolean;
var TableIndex: integer; // used by EngineRetrieve() for SQL statement caching
    Resp: RawUTF8;
begin // this version handles locking and use fast EngineRetrieve() method
  // check parameters
  result := false;
  if Value=nil  then
    exit; // avoid GPF
  Value.fID := 0;
  if (self=nil) or (aID=0) then
    exit;
  TableIndex := Model.GetTableIndexExisting(PSQLRecordClass(Value)^);
  // try to lock before retrieval (if ForUpdate)
  if ForUpdate and not Model.Lock(TableIndex,aID) then
    exit;
  // try to retrieve existing JSON from internal cache
  Resp := fCache.Retrieve(TableIndex,aID);
  if Resp='' then begin
    // get JSON object '{...}' in Resp from corresponding EngineRetrieve() method
    Resp := EngineRetrieve(TableIndex,aID);
    if Resp='' then
      exit;
  end;
  // fill Value from JSON if was correctly retrieved
  Value.FillFrom(Resp);
  result := true;
end;

function TSQLRest.Retrieve(WhereClauseFmt: PUTF8Char; const Args,Bounds: array of const;
  Value: TSQLRecord): boolean;
begin
  result := Retrieve(FormatUTF8(WhereClauseFmt,Args,Bounds),Value);
end;

function TSQLRest.Retrieve(Reference: TRecordReference; ForUpdate: boolean=false): TSQLRecord;
var aClass: TSQLRecordClass;
begin
  result := nil;
  if (self=nil) or (RecordRef(Reference).ID=0) then
    exit;
  aClass := RecordRef(Reference).Table(Model);
  if aClass=nil then
    exit;
  result := aClass.Create(self,RecordRef(Reference).ID,ForUpdate);
  if result.fID=0 then
    FreeAndNil(result); // error during value retrieval
end;

function TSQLRest.Retrieve(aPublishedRecord, aValue: TSQLRecord): boolean;
begin
  result := Retrieve(aPublishedRecord.ID,aValue);
end;

function TSQLRest.UnLock(Rec: TSQLRecord): boolean;
begin
  if (self=nil) or (Rec=nil) or (Rec.fID<=0) then
    result := false else
    result := UnLock(PSQLRecordClass(Rec)^,Rec.fID);
end;

procedure TSQLRest.Commit(SessionID: cardinal);
begin
  if self<>nil then begin
    EnterCriticalSection(fAcquireExecution[execORMWrite].Lock);
    try
      if (fTransactionActiveSession<>0) and (fTransactionActiveSession=SessionID) then begin
        fTransactionActiveSession := 0; // by default, just release flag
        fTransactionTable := nil;
      end;
    finally
      LeaveCriticalSection(fAcquireExecution[execORMWrite].Lock);
    end;
  end;
end;

procedure TSQLRest.RollBack(SessionID: cardinal);
begin
  if self<>nil then begin
    EnterCriticalSection(fAcquireExecution[execORMWrite].Lock);
    try
      if (fTransactionActiveSession<>0) and (fTransactionActiveSession=SessionID) then begin
        fTransactionActiveSession := 0; // by default, just release flag
        fTransactionTable := nil;
      end;
    finally
      LeaveCriticalSection(fAcquireExecution[execORMWrite].Lock);
    end;
  end;
end;

function TSQLRest.TransactionBegin(aTable: TSQLRecordClass; SessionID: cardinal): boolean;
begin
  result := false;
  EnterCriticalSection(fAcquireExecution[execORMWrite].Lock);
  try
    if fTransactionActiveSession=0 then begin // nested transactions are not allowed
      fTransactionActiveSession := SessionID;
      fTransactionTable := aTable;
      result := true;
    end;
  finally
    LeaveCriticalSection(fAcquireExecution[execORMWrite].Lock);
  end;
end;

function TSQLRest.TransactionActiveSession: cardinal;
begin
  if self=nil then
    result := 0 else begin
    EnterCriticalSection(fAcquireExecution[execORMWrite].Lock);
    try
      result := fTransactionActiveSession;
    finally
      LeaveCriticalSection(fAcquireExecution[execORMWrite].Lock);
    end;
  end;
end;

function TSQLRest.RecordCanBeUpdated(Table: TSQLRecordClass; ID: integer; Action: TSQLEvent;
  ErrorMsg: PRawUTF8 = nil): boolean;
begin
  result := true; // accept by default -> override this method to customize this
end;

function TSQLRest.Delete(Table: TSQLRecordClass; ID: integer): boolean;
var TableIndex: integer;
begin
  TableIndex := Model.GetTableIndexExisting(Table);
  if not RecordCanBeUpdated(Table,ID,seDelete) then
    result := false else begin
    fCache.NotifyDeletion(TableIndex,ID);
    result := EngineDelete(TableIndex,ID);
  end;
end;

function TSQLRest.InternalDeleteNotifyAndGetIDs(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
  var IDs: TIntegerDynArray): boolean;
var i: integer;
begin
  result := false;
  if (not OneFieldValues(Table,'RowID',SQLWhere,IDs)) or
     (IDs=nil) then
    exit;
  for i := 0 to high(IDs) do
    if not RecordCanBeUpdated(Table,IDs[i],seDelete) then
      exit;
  for i := 0 to high(IDs) do
    fCache.NotifyDeletion(Table,IDs[i]);
  result := true;
end;

function TSQLRest.Delete(Table: TSQLRecordClass; const SQLWhere: RawUTF8): boolean;
var IDs: TIntegerDynArray;
begin
  if InternalDeleteNotifyAndGetIDs(Table,SQLWhere,IDs) then
    result := EngineDeleteWhere(Model.GetTableIndexExisting(Table),SQLWhere,IDs) else
    result := false;
end;

function TSQLRest.Delete(Table: TSQLRecordClass; FormatSQLWhere: PUTF8Char;
  const BoundsSQLWhere: array of const): boolean;
begin
  result := Delete(Table,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere));
end;

function TSQLRest.Update(Value: TSQLRecord; const CustomFields: TSQLFieldBits): boolean;
var JSONValues: RawUTF8;
    TableIndex: integer;
    FieldBits: TSQLFieldBits;
begin
  if (self=nil) or (Value=nil) or (Value.fID=0) or
    not RecordCanBeUpdated(PSQLRecordClass(Value)^,Value.fID,seUpdate) then begin
    result := false; // current user don't have enough right to update this record
    exit;
  end;
  TableIndex := Model.GetTableIndexExisting(PSQLRecordClass(Value)^);
  Value.ComputeFieldsBeforeWrite(self,seUpdate); // update sftModTime fields
  if IsZero(CustomFields) then
    if (Value.fFill<>nil) and (Value.fFill.Table<>nil) and
       (Value.fFill.fTableMapRecordManyInstances=nil) then
      // within FillPrepare/FillOne loop: update ID, TModTime and mapped fields
      FieldBits := Value.fFill.fTableMapFields+Value.RecordProps.ModTimeFieldsBits else
      // update all simple/custom fields (also for FillPrepareMany)
      FieldBits := Value.RecordProps.SimpleFieldsBits[soUpdate] else
    // CustomFields<>[] -> update specified and TModTime fields
    FieldBits := CustomFields+Value.RecordProps.ModTimeFieldsBits;
  if IsZero(FieldBits) then begin
    result := true; // a TSQLRecord with NO simple fields (e.g. ID/blob pair)
    exit;
  end;
  fCache.Notify(Value,soUpdate); // JSONValues on update may not be enough for cache
  JSONValues := Value.GetJSONValues(true,false,FieldBits);
  result := EngineUpdate(TableIndex,Value.fID,JSONValues);
end;

function TSQLRest.Update(Value: TSQLRecord; const CustomCSVFields: RawByteString): boolean;
begin
  if (self=nil) or (Value=nil) then
    result := false else
    result := Update(Value,Value.RecordProps.FieldIndexsFromCSV(CustomCSVFields));
end;

function TSQLRest.Update(aTable: TSQLRecordClass; aID: integer;
  const aSimpleFields: array of const): boolean;
var Value: TSQLRecord;
begin
  result := false; // means error
  if (self=nil) or (aTable=nil) or (aID=0) then
    exit;
  Value := aTable.Create;
  try
    if not Value.SimplePropertiesFill(aSimpleFields) then
      exit;
    Value.fID := aID;
    result := Update(Value);
  finally
    Value.Free;
  end;
end;

function TSQLRest.UpdateField(Table: TSQLRecordClass; ID: integer;
  const FieldName: RawUTF8; const FieldValue: array of const): boolean;
begin
  result := UpdateField(Table,'RowID',[ID],FieldName,FieldValue);
end;

function TSQLRest.UpdateField(Table: TSQLRecordClass;
  const WhereFieldName: RawUTF8; const WhereFieldValue: array of const;
  const FieldName: RawUTF8; const FieldValue: array of const): boolean;
var TableIndex: integer;
    SetValue,WhereValue: RawUTF8;
begin
  result := false;
  if (length(FieldValue)<>1) or (WhereFieldName='') or (length(WhereFieldValue)<>1) then
    exit;
  VarRecToInlineValue(WhereFieldValue[0],WhereValue);
  VarRecToInlineValue(FieldValue[0],SetValue);
  TableIndex := Model.GetTableIndexExisting(Table);
  result := EngineUpdateField(TableIndex,FieldName,SetValue,WhereFieldName,WhereValue);
end;

{$ifndef NOVARIANTS}
function TSQLRest.UpdateField(Table: TSQLRecordClass; ID: integer;
  const FieldName: RawUTF8; const FieldValue: Variant): boolean;
begin
  result := UpdateField(Table,'RowID',ID,FieldName,FieldValue);
end;

function TSQLRest.UpdateField(Table: TSQLRecordClass;
  const WhereFieldName: RawUTF8; const WhereFieldValue: Variant;
  const FieldName: RawUTF8; const FieldValue: Variant): boolean;
var TableIndex: integer;
    SetValue,WhereValue: RawUTF8;
begin
  VariantToInlineValue(WhereFieldValue[0],WhereValue);
  VariantToInlineValue(FieldValue[0],SetValue);
  TableIndex := Model.GetTableIndexExisting(Table);
  result := EngineUpdateField(TableIndex,FieldName,SetValue,WhereFieldName,WhereValue);
end;
{$endif NOVARIANTS}

function TSQLRest.Add(Value: TSQLRecord; SendData: boolean;
  ForceID: boolean=false): integer;
var JSONValues: RawUTF8;
    TableIndex: integer;
begin
  if Value=nil then begin
    result := 0;
    exit;
  end;
  TableIndex := Model.GetTableIndexExisting(PSQLRecordClass(Value)^);
  if SendData then begin
    Value.ComputeFieldsBeforeWrite(self,seAdd); // update TModTime/TCreateTime fields
    if Model.TableProps[TableIndex].Kind in INSERT_WITH_ID then
      ForceID := true;
    JSONValues := Value.GetJSONValues(true, // true=expanded
      (Value.fID<>0) and ForceID,soInsert);
  end else
    JSONValues := '';
  // on success, returns the new ROWID value; on error, returns 0
  result := EngineAdd(TableIndex,JSONValues); // will call static
  // on success, Value.ID is updated with the new ROWID
  Value.fID := result;
  if SendData then
    fCache.Notify(PSQLRecordClass(Value)^,result,JSONValues,soInsert);
end;

function TSQLRest.Add(aTable: TSQLRecordClass; const aSimpleFields: array of const;
  ForcedID: integer=0): integer;
var Value: TSQLRecord;
begin
  result := 0; // means error
  if (self=nil) or (aTable=nil) then
    exit;
  Value := aTable.Create;
  try
    if Value.SimplePropertiesFill(aSimpleFields) then begin
      if ForcedID<>0 then
        Value.fID := ForcedID;
      result := Add(Value,true,(ForcedID<>0));
    end;
  finally
    Value.Free;
  end;
end;

procedure TSQLRest.QueryAddCustom(aTypeInfo: pointer; aEvent: TSQLQueryEvent;
  const aOperators: TSQLQueryOperators);
var Enum: PEnumType;
    i,n: integer;
begin
  if (self=nil) or not Assigned(aEvent)  or
     (aTypeInfo=nil) or (PTypeInfo(aTypeInfo)^.Kind<>tkEnumeration) then
    exit;
  Enum := PTypeInfo(aTypeInfo)^.EnumBaseType;
  n := length(QueryCustom);
  SetLength(QueryCustom,n+Enum^.MaxValue+1);
  for i := 0 to Enum^.MaxValue do
    with QueryCustom[i+n] do begin
      EnumType := Enum;
      EnumIndex := i;
      Event := aEvent;
      Operators := aOperators;
    end;
end;

class function TSQLRest.QueryIsTrue(aTable: TSQLRecordClass; aID: integer;
  FieldType: TSQLFieldType; Value: PUTF8Char; Operator: integer;
  Reference: PUTF8Char): boolean;
begin // use mostly the same fast comparison functions as for sorting  
  result := false;
  if aID=0 then
    exit; // invalid input field
  if Reference=nil then
    exit; // avoid most GPF
  if FieldType=sftMany then
    exit; // nothing is stored directly, but in a separate pivot table
  if FieldType in [sftUnknown,sftBlob,sftBlobDynArray,sftBlobCustom,sftObject,
    sftUTF8Custom{$ifndef NOVARIANTS},sftVariant{$endif}] then
    FieldType := sftUTF8Text; // unknown or blob fields are compared as UTF-8
  { TODO: handle sftBlobDynArray/sftBlobCustom/sftBlobRecord comparison }
  case TSQLQueryOperator(Operator) of
    qoNone:
      result := true;
    qoEqualTo:
      result := SQLFieldTypeComp[FieldType](Value,Reference)=0;
    qoNotEqualTo:
      result := SQLFieldTypeComp[FieldType](Value,Reference)<>0;
    qoLessThan:
      result := SQLFieldTypeComp[FieldType](Value,Reference)<0;
    qoLessThanOrEqualTo:
      result := SQLFieldTypeComp[FieldType](Value,Reference)<=0;
    qoGreaterThan:
      result := SQLFieldTypeComp[FieldType](Value,Reference)>0;
    qoGreaterThanOrEqualTo:
      result := SQLFieldTypeComp[FieldType](Value,Reference)>=0;
    qoEqualToWithCase:
      result := StrComp(Value,Reference)=0;
    qoNotEqualToWithCase:
      result := StrComp(Value,Reference)<>0;
    qoContains:
      result := PosIU(Reference,Value)<>0;
    qoBeginWith:
      result := IdemPCharU(Value,Reference);
    qoSoundsLikeEnglish,
    qoSoundsLikeFrench,
    qoSoundsLikeSpanish:
      result := PSynSoundEx(Reference)^.UTF8(Value);
  end;
end;

function TSQLRest.RetrieveBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; out BlobStream: THeapMemoryStream): boolean;
var BlobData: TSQLRawBlob;
begin
  BlobStream := THeapMemoryStream.Create;
  result := RetrieveBlob(Table,aID,BlobFieldName,BlobData);
  if not result or (BlobData='') then
    exit;
  BlobStream.Write(pointer(BlobData)^,length(BlobData));
  BlobStream.Seek(0,soFromBeginning); // rewind
end;

function TSQLRest.UpdateBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; BlobData: TStream): boolean;
var Blob: TSQLRawBlob;
    L: integer;
begin
  result := false;
  if (self=nil) or (BlobData=nil) then
    exit;
  L := BlobData.Seek(0,soFromEnd);
  SetLength(Blob,L);
  BlobData.Seek(0,soFromBeginning);
  if BlobData.Read(pointer(Blob)^,L)<>L then
    exit;
  result := UpdateBlob(Table,aID,BlobFieldName,Blob);
end;

function TSQLRest.UpdateBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; BlobData: pointer; BlobSize: integer): boolean;
var Blob: TSQLRawBlob;
begin
  if (self=nil) or (BlobData=nil) or (BlobSize<0) then
    result := false else begin
    SetString(Blob,PAnsiChar(BlobData),BlobSize);
    result := UpdateBlob(Table,aID,BlobFieldName,Blob);
  end;
end;

function TSQLRest.RetrieveBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; out BlobData: TSQLRawBlob): boolean;
var BlobField: PPropInfo;
begin
  result := false;
  if (self=nil) or (aID<=0) then
    exit;
  BlobField := Table.RecordProps.BlobFieldPropFromRawUTF8(BlobFieldName);
  if BlobField=nil then
    exit;
  result := EngineRetrieveBlob(
    Model.GetTableIndexExisting(Table),aID,BlobField,BlobData);
end;

function TSQLRest.UpdateBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; const BlobData: TSQLRawBlob): boolean;
var BlobField: PPropInfo;
begin
  result := false;
  if (self=nil) or (aID<=0) or not RecordCanBeUpdated(Table,aID,seUpdate) then
    exit;
  BlobField := Table.RecordProps.BlobFieldPropFromRawUTF8(BlobFieldName);
  if BlobField=nil then
    exit;
  result := EngineUpdateBlob(
    Model.GetTableIndexExisting(Table),aID,BlobField,BlobData);
end;

function TSQLRest.UpdateBlobFields(Value: TSQLRecord): boolean;
var BlobData: RawByteString;
    TableIndex, i: integer;
begin
  result := false;
  if (Value=nil) or (Value.fID<=0) then
    exit;
  with Value.RecordProps do
  if BlobFields<>nil then begin
    TableIndex := self.fModel.GetTableIndexExisting(PSQLRecordClass(Value)^);
    for i := 0 to high(BlobFields) do begin
      GetLongStrProp(Value,BlobFields[i].PropInfo,BlobData);
      if not EngineUpdateBlob(TableIndex,Value.fID,BlobFields[i].PropInfo,BlobData) then
        exit;
    end;
  end;
  result := true;
end;

function TSQLRest.RetrieveBlobFields(Value: TSQLRecord): boolean;
var BlobData: TSQLRawBlob;
    TableIndex, i: integer;
begin
  result := false;
  if (Self=nil) or (Value=nil) or (Value.fID<=0) then
    exit;
  with Value.RecordProps do
  if BlobFields<>nil then begin
    TableIndex := self.fModel.GetTableIndexExisting(PSQLRecordClass(Value)^);
    for i := 0 to high(BlobFields) do
      if EngineRetrieveBlob(TableIndex,Value.fID,BlobFields[i].PropInfo,BlobData) then
        SetLongStrProp(Value,BlobFields[i].PropInfo,BlobData) else
        exit;
  end;
  result := true;
end;

function TSQLRest.TableRowCount(Table: TSQLRecordClass): integer;
var T: TSQLTableJSON;
begin
  if (self=nil) or (Table=nil) then
    T := nil else
    T := ExecuteList([Table],
      'SELECT Count(*) FROM '+Table.RecordProps.SQLTableName);
  if T<>nil then
  try
    Result := T.GetAsInteger(1,0);
  finally
    T.Free;
  end else
    Result := -1;
end;

function TSQLRest.TableHasRows(Table: TSQLRecordClass): boolean;
var T: TSQLTableJSON;
begin
  if (self=nil) or (Table=nil) then
    T := nil else
    T := ExecuteList([Table],
      'SELECT RowID FROM '+Table.RecordProps.SQLTableName+' LIMIT 1');
  if T<>nil then
  try
    Result := T.RowCount>0;
  finally
    T.Free;
  end else
    Result := false;
end;

function TSQLRest.ExecuteList(const Tables: array of TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON;
var JSON: RawUTF8;
begin
  JSON := EngineList(SQL,false);
  if JSON<>'' then
    result := TSQLTableJSON.CreateFromTables(Tables,SQL,JSON) else
    result := nil;
end;

function TSQLRest.MainFieldValue(Table: TSQLRecordClass; ID: Integer;
   ReturnFirstIfNoUnique: boolean=false): RawUTF8;
begin
  if (self=nil) or (Table=nil) or (ID<=0) then
    result := '' else begin
    result := Table.RecordProps.MainFieldName(Table,ReturnFirstIfNoUnique);
    if result<>'' then
      result := OneFieldValue(Table,Result,ID);
  end;
end;

function TSQLRest.MainFieldID(Table: TSQLRecordClass; const Value: RawUTF8): integer;
var aMainField: integer;
begin
  result := 0;
  if (self<>nil) and (Value<>'') and (Table<>nil) then
  with Table.RecordProps do begin
    aMainField := MainField[false];
    if aMainField>=0 then
      result := GetInteger(pointer(OneFieldValue(Table,'RowID',
        Fields.List[aMainField].Name+'=:('+QuotedStr(Value,'''')+'):')));
  end;
end;

function TSQLRest.MainFieldIDs(Table: TSQLRecordClass; const Values: array of RawUTF8;
  var IDs: TIntegerDynArray): boolean;
var aMainField, id: integer;
begin
  SetLength(IDs,0);
  if (self<>nil) and (high(Values)>=0) and (Table<>nil) then
    if high(Values)=0 then begin // handle special case of one Values[] item
      id := MainFieldID(Table,Values[0]);
      if id>0 then begin
        SetLength(IDs,1);
        IDs[0] := id;
      end;
    end else
    with Table.RecordProps do begin // request all Values[] IDs at once
      aMainField := MainField[false];
      if aMainField>=0 then
        OneFieldValues(Table,'RowID',Fields.List[aMainField].Name+' in ('+
          RawUTF8ArrayToQuotedCSV(Values)+')',IDs);
    end;
  result := IDs<>nil;
end;

function TSQLRest.FTSMatch(Table: TSQLRecordFTS3Class;
  const WhereClause: RawUTF8; var DocID: TIntegerDynArray): boolean;
begin // FTS3 tables don't have any ID, but RowID or DocID
  result := OneFieldValues(Table,'RowID',WhereClause,DocID);
end;

function TSQLRest.FTSMatch(Table: TSQLRecordFTS3Class;
  const MatchClause: RawUTF8; var DocID: TIntegerDynArray;
  const PerFieldWeight: array of double): boolean;
var WhereClause: RawUTF8;
    i: integer;
begin
  result := false;
  with Table.RecordProps do
    if length(PerFieldWeight)<>length(SimpleFields) then
      exit else
    WhereClause := FormatUTF8('% MATCH :(''%''): ORDER BY rank(matchinfo(%)',
      [SQLTableName,MatchClause,SQLTableName]);
  for i := 0 to high(PerFieldWeight) do
    WhereClause := FormatUTF8('%,:(%):',[WhereClause,PerFieldWeight[i]]);
  result := FTSMatch(Table,WhereClause+') DESC',DocID);
end;

function TSQLRest.GetServerTimeStamp: TTimeLog;
var Tix: cardinal;
begin
  Tix := GetTickCount shr 9; // resolution change 1 ms -> 512 ms
  if fServerTimeStampCacheTix=Tix then
    result := fServerTimeStampCacheValue.Value else begin
    fServerTimeStampCacheTix := Tix;
    fServerTimeStampCacheValue.From(NowUTC+fServerTimeStampOffset);
    result := fServerTimeStampCacheValue.Value;
  end;
end;

procedure TSQLRest.SetServerTimeStamp(const Value: TTimeLog);
begin
  fServerTimeStampOffset := PTimeLogBits(@Value)^.ToDateTime-NowUTC;
  if fServerTimeStampOffset=0 then
    fServerTimeStampOffset := 0.0001; // retrieve server date/time only once
end;

function TSQLRest.GetCache: TSQLRestCache;
begin
  if self=nil then
    result := nil else begin
    if fCache=nil then
      fCache := TSQLRestCache.Create(self);
    result := fCache;
  end;
end;

function TSQLRest.CacheWorthItForTable(aTableIndex: cardinal): boolean;
begin
  result := true; // always worth caching by default
end;

function TSQLRest.GetAcquireExecutionMode(Cmd: TSQLRestServerURIContextCommand): TSQLRestServerAcquireMode;
begin
  result := fAcquireExecution[Cmd].Mode;
end;

procedure TSQLRest.SetAcquireExecutionMode(Cmd: TSQLRestServerURIContextCommand; Value: TSQLRestServerAcquireMode);
begin
  fAcquireExecution[Cmd].Mode := Value;
end;

function TSQLRest.GetAcquireExecutionLockedTimeOut(Cmd: TSQLRestServerURIContextCommand): cardinal;
begin
  result := fAcquireExecution[Cmd].LockedTimeOut;
end;

procedure TSQLRest.SetAcquireExecutionLockedTimeOut(Cmd: TSQLRestServerURIContextCommand; Value: cardinal);
begin
  fAcquireExecution[Cmd].LockedTimeOut := Value;
end;

function TSQLRest.InternalBatchStart(Method: TSQLURIMethod): boolean;
begin
  result := false;
end;

procedure TSQLRest.InternalBatchStop;
begin
  raise EORMException.CreateFmt('Unexpected %s.InternalBatchStop',[ClassName]);
end;

{$ifdef ISDELPHI2010} // Delphi 2009 generics support is buggy :(

function TSQLRest.Service<T>: T;
var service: TServiceFactory;
begin
  service := fServices.Info(TypeInfo(T));
  if (service=nil) or not service.Get(result) then
    result := Default(T);
end;

function TSQLRest.RetrieveList<T>(const aCustomFieldsCSV: RawUTF8): TObjectList<T>;
begin
  result := RetrieveList<T>(nil,[],aCustomFieldsCSV);
end;

function TSQLRest.RetrieveList<T>(FormatSQLWhere: PUTF8Char;
  const BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8): TObjectList<T>;
var Table: TSQLTable;
begin
  result := nil;
  if self=nil then
    exit;
  Table := MultiFieldValues(TSQLRecordClass(T),aCustomFieldsCSV,FormatSQLWhere,BoundsSQLWhere);
  if Table<>nil then
  try
    result := Table.ToObjectList<T>;
  finally
    Table.Free;
  end;
end;

{$endif}

procedure TSQLRest.BatchAbort;
begin
  if self<>nil then begin
    fBatchCount := 0;
    fBatchTable := nil;
    fBatchTablePreviousSendData := nil;
    FreeAndNil(fBatch);
  end;
end;

function TSQLRest.BatchAdd(Value: TSQLRecord; SendData: boolean;
  ForceID: boolean=false; const CustomFields: TSQLFieldBits=[]): integer;
var Props: TSQLRecordProperties;
    FieldBits: TSQLFieldBits;
begin
  result := -1;
  if (self=nil) or (Value=nil) or (fBatch=nil) then
    exit; // invalid parameters, or not opened BATCH sequence
  Props := Value.RecordProps;
  if fBatchTable<>nil then
    if PSQLRecordClass(Value)^<>fBatchTable then
      exit else // '{"Table":[...,"POST":{object},...]}'
      fBatch.AddShort('"POST":') else begin
      fBatch.AddShort('"POST@'); // '[...,"POST@Table":{object}',...]'
      fBatch.AddString(Props.SQLTableName);
      fBatch.Add('"',':');
    end;
  if SendData then begin
    if Model.Props[PSQLRecordClass(Value)^].Kind in INSERT_WITH_ID then
      ForceID := true; // same format as TSQLRestClient.Add
    if IsZero(CustomFields) then
      FieldBits := Props.SimpleFieldsBits[soInsert] else
      FieldBits := CustomFields+Props.ModCreateTimeFieldsBits;
    Props.SetExpandedJSONWriter(fBatch,
      fBatchTablePreviousSendData<>PSQLRecordClass(Value)^,
      (Value.fID<>0) and ForceID,FieldBits);
    fBatchTablePreviousSendData := PSQLRecordClass(Value)^;
    Value.ComputeFieldsBeforeWrite(self,seAdd); // update TModTime/TCreateTime fields
    Value.GetJSONValues(fBatch);
    if ForceID then
      fCache.Notify(Value,soInsert);
  end else
    fBatch.Add('{','}'); // '{"Table":[...,"POST":{},...]}'
  fBatch.Add(',');
  result := fBatchCount;
  inc(fBatchCount);
end;

function TSQLRest.BatchCount: integer;
begin
  if self=nil then
    result := 0 else
    result := fBatchCount;
end;

function TSQLRest.BatchDelete(ID: integer): integer;
begin
  if (self=nil) or (fBatchTable=nil) or
     (ID<=0) or not RecordCanBeUpdated(fBatchTable,ID,seDelete) then begin
    result := -1; // invalid parameters, or not opened BATCH sequence
    exit;
  end;
  fCache.NotifyDeletion(fBatchTable,ID);
  fBatch.AddShort('"DELETE":'); // '{"Table":[...,"DELETE":ID,...]}'
  fBatch.Add(ID);
  fBatch.Add(',');
  result := fBatchCount;
  inc(fBatchCount);
end;

function TSQLRest.BatchDelete(Table: TSQLRecordClass; ID: integer): integer;
begin
  if (self=nil) or (fBatch=nil) or (Table=nil) or
     (ID<=0) or not RecordCanBeUpdated(Table,ID,seDelete) then begin
    result := -1; // invalid parameters, or not opened BATCH sequence
    exit;
  end;
  fCache.NotifyDeletion(Table,ID);
  fBatch.AddShort('"DELETE@'); // '[...,"DELETE@Table":ID,...]}'
  fBatch.AddString(Table.RecordProps.SQLTableName);
  fBatch.Add('"',':');
  fBatch.Add(ID);
  fBatch.Add(',');
  result := fBatchCount;
  inc(fBatchCount);
end;

function TSQLRest.BatchSend(var Results: TIntegerDynArray): integer;
var Data: RawUTF8;
begin
  if (self=nil) or (fBatch=nil) then // no opened BATCH sequence
    result := HTML_BADREQUEST else
  try
    if fBatchCount>0 then begin // if something to send
      fBatch.CancelLastComma;
      fBatch.Add(']');
      if fBatchTable<>nil then
        fBatch.Add('}'); // end sequence array '{"Table":["cmd":values,...]}'
      fBatch.SetText(Data);
      try
        result := EngineBatchSend(fBatchTable,Data,Results);
      except
        on Exception do // e.g. from TSQLRestServer.EngineBatchSend()
          result := HTML_NOTMODIFIED;
      end;
    end else
      result := HTML_SUCCESS; // returns OK
  finally
    BatchAbort;
  end;
end;

const
  AUTOMATICTRANSACTIONPERROW_PATTERN = '"AUTOMATICTRANSACTIONPERROW":';

function TSQLRest.BatchStart(aTable: TSQLRecordClass;
  AutomaticTransactionPerRow: cardinal): boolean;
begin
  if (fBatchCount>0) or (fBatch<>nil) then begin
    // already opened BATCH sequence
    result := false;
    exit;
  end;
  fBatch := TJSONSerializer.CreateOwnedStream;
  if aTable<>nil then begin
    fBatch.Add('{'); // sending data is '{"Table":["cmd":values,...]}'
    fBatch.AddFieldName(aTable.SQLTableName);
  end;
  fBatch.Add('[');
  if AutomaticTransactionPerRow>0 then begin // should be the first command
    fBatch.AddShort(AUTOMATICTRANSACTIONPERROW_PATTERN);
    fBatch.Add(AutomaticTransactionPerRow);
    fBatch.Add(',');
  end;
  fBatchTable := aTable;
  fBatchCount := 0;
  result := true;
end;

function TSQLRest.BatchUpdate(Value: TSQLRecord;
  const CustomFields: TSQLFieldBits=[]): integer;
var Props: TSQLRecordProperties;
    FieldBits: TSQLFieldBits;
begin
  result := -1;
  if (Value=nil) or (fBatch=nil) or (Value.fID<=0) or
     not RecordCanBeUpdated(Value.RecordClass,Value.fID,seUpdate) then
    exit; // invalid parameters, or not opened BATCH sequence
  Props := Value.RecordProps;
  if fBatchTable<>nil then
    if PSQLRecordClass(Value)^<>fBatchTable then
      exit else // '{"Table":[...,"PUT":{object},...]}'
      fBatch.AddShort('"PUT":') else begin
      fBatch.AddShort('"PUT@'); // '[...,"PUT@Table":{object}',...]'
      fBatch.AddString(Props.SQLTableName);
      fBatch.Add('"',':');
    end;
  // same format as TSQLRest.Update, BUT including the ID
  if IsZero(CustomFields) then
    if (Value.fFill<>nil) and (Value.fFill.Table<>nil) and
       (Value.fFill.fTableMapRecordManyInstances=nil) then
      // within FillPrepare/FillOne loop: update ID, TModTime and mapped fields
      FieldBits := Value.fFill.fTableMapFields+Props.ModTimeFieldsBits else
      // update all simple/custom fields (also for FillPrepareMany)
      FieldBits := Props.SimpleFieldsBits[soUpdate] else
    // update custom fields
    FieldBits := CustomFields+Value.RecordProps.ModTimeFieldsBits;
  Props.SetExpandedJSONWriter(fBatch,
    fBatchTablePreviousSendData<>PSQLRecordClass(Value)^,True,FieldBits);
  fBatchTablePreviousSendData := PSQLRecordClass(Value)^;
  Value.ComputeFieldsBeforeWrite(self,seUpdate); // update sftModTime fields
  Value.GetJSONValues(fBatch);
  fBatch.Add(',');
  if FieldBits-Props.SimpleFieldsBits[soUpdate]<>[] then
    // may not contain all cached fields -> delete from cache
    fCache.NotifyDeletion(Value.RecordClass,Value.fID) else
    fCache.Notify(Value,soUpdate);
  result := fBatchCount;
  inc(fBatchCount);
end;

function TSQLRest.EngineBatchSend(Table: TSQLRecordClass; const Data: RawUTF8;
  var Results: TIntegerDynArray): integer;
begin
  raise EORMException.CreateFmt('%s.BatchStart() not supported yet',[ClassName]);
end;


{ TSQLRestCacheEntry }

procedure TSQLRestCacheEntry.FlushCacheEntry(Index: Integer);
begin
  if cardinal(Index)<cardinal(Count) then
    if CacheAll then
      Value.Delete(Index) else
      with Values[Index] do begin
        TimeStamp64 := 0;
        JSON := '';
      end;
end;

procedure TSQLRestCacheEntry.FlushCacheAllEntries;
var i: integer;
begin
  if not CacheEnable then
    exit;
  EnterCriticalSection(Mutex);
  try
    if CacheAll then
      Value.Clear else
      for i := 0 to Count-1 do
      with Values[i] do begin
        TimeStamp64 := 0;
        JSON := '';
      end;
  finally
    LeaveCriticalSection(Mutex);
  end;
end;

procedure TSQLRestCacheEntry.SetJSON(aID: integer; const aJSON: RawUTF8);
var Rec: TSQLRestCacheEntryValue;
    i: integer;
begin
  EnterCriticalSection(Mutex);
  try
    Rec.ID := aID;
    Rec.TimeStamp64 := GetTickCount64;
    Rec.JSON := aJSON;
    i := Value.Find(Rec);
    if i>=0 then
      Values[i] := Rec else
      if CacheAll then begin
        Value.Add(Rec);
        Value.Sort; // will sort by ID for faster retrieval
      end;
  finally
    LeaveCriticalSection(Mutex);
  end;
end;

procedure TSQLRestCacheEntry.SetJSON(aRecord: TSQLRecord);
begin  // soInsert = include all fields
  SetJSON(aRecord.fID,aRecord.GetJSONValues(true,false,soInsert));
end;

function TSQLRestCacheEntry.RetrieveJSON(aID: integer; var aJSON: RawUTF8): boolean;
var i: integer;
begin
  EnterCriticalSection(Mutex);
  try
    result := false;
    i := Value.Find(aID);
    if i>=0 then
      with Values[i] do
      if TimeStamp64<>0 then // 0 when there is no JSON value cached
        if (TimeOutMS<>0) and (GetTickCount64>TimeStamp64+TimeOutMS) then 
          FlushCacheEntry(i) else begin
          aJSON := JSON;
          result := true; // found a non outdated serialized value in cache
        end else
  finally
    LeaveCriticalSection(Mutex);
  end;
end;

function TSQLRestCacheEntry.RetrieveJSON(aID: integer; aValue: TSQLRecord): boolean;
var JSON: RawUTF8;
begin
  if RetrieveJSON(aID,JSON) then begin
    aValue.FillFrom(JSON);
    aValue.fID := aID; // override RowID field if not present
    result := true;
  end else
    result := false;
end;


{ TSQLRestCache }

function TSQLRestCache.CachedEntries: cardinal;
var i,j: integer;
begin
  result := 0;
  if self<>nil then
    for i := 0 to high(fCache) do
      with fCache[i] do
      if CacheEnable then
      for j := 0 to Count-1 do
        if Values[j].TimeStamp64<>0 then
          inc(result);
end;

function TSQLRestCache.CachedMemory: cardinal;
var i,j: integer;
begin
  result := 0;
  if self<>nil then
    for i := 0 to high(fCache) do
      with fCache[i] do
      if CacheEnable then
      for j := 0 to Count-1 do
        if Values[j].TimeStamp64<>0 then
          inc(result,length(Values[j].JSON)+(sizeof(Values[j])+16));
end;

function TSQLRestCache.SetTimeOut(aTable: TSQLRecordClass; aTimeoutMS: Cardinal): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or (aTable=nil) then
    exit;
  i := Rest.Model.GetTableIndexExisting(aTable);
  if Rest.CacheWorthItForTable(i) then
    if Cardinal(i)<Cardinal(Length(fCache)) then
      with fCache[i] do begin
        EnterCriticalSection(Mutex);
        TimeOutMS := aTimeOutMS;
        LeaveCriticalSection(Mutex);
        result := true;
      end;
end;

function TSQLRestCache.SetCache(aTable: TSQLRecordClass): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or (aTable=nil) then
    exit;
  i := Rest.Model.GetTableIndexExisting(aTable);
  if Rest.CacheWorthItForTable(i) then
    if Cardinal(i)<Cardinal(Length(fCache)) then
      with fCache[i] do begin
        // global cache of all records of this table
        EnterCriticalSection(Mutex);
        try
          CacheEnable := true;
          CacheAll := True;
          Value.Clear;
          result := true;
        finally
          LeaveCriticalSection(Mutex);
        end;
      end;
end;

function TSQLRestCache.SetCache(aTable: TSQLRecordClass; aID: Integer): boolean;
var i: integer;
    Rec: TSQLRestCacheEntryValue;
begin
  result := false;
  if (self=nil) or (aTable=nil) or (aID<=0) then
    exit;
  i := Rest.Model.GetTableIndexExisting(aTable);
  if Cardinal(i)>=Cardinal(Length(fCache)) then
    exit;
  if Rest.CacheWorthItForTable(i) then
    with fCache[i] do begin
      EnterCriticalSection(Mutex);
      try
        CacheEnable := true;
        if not CacheAll then begin
          i := Value.Find(aID);
          if i<0 then begin
            Rec.ID := aID;
            Rec.TimeStamp64 := 0;
            Value.Add(Rec);
            Value.Sort; // will sort by ID for faster retrieval
          end;
        end;
      finally
        LeaveCriticalSection(Mutex);
      end;
    end;
  result := True;
end;

function TSQLRestCache.SetCache(aRecord: TSQLRecord): boolean;
begin
  if (self=nil) or (aRecord=nil) or (aRecord.fID<=0) then
    result := false else
    result := SetCache(PSQLRecordClass(aRecord)^,aRecord.fID);
end;

constructor TSQLRestCache.Create(aRest: TSQLRest);
var i: integer;
begin
  if aRest=nil then
    EBusinessLayerException.CreateFmt('%s.Create',[ClassName]);
  fRest := aRest;
  SetLength(fCache,length(fRest.Model.Tables));
  for i := 0 to high(fCache) do
    with fCache[i] do begin // will search/sort by ID
      Value.InitSpecific(TypeInfo(TSQLRestCacheEntryValueDynArray),Values,djInteger,@Count);
      InitializeCriticalSection(Mutex);
    end;
end;

destructor TSQLRestCache.Destroy;
var i: integer;
begin
  for i := 0 to high(fCache) do
    DeleteCriticalSection(fCache[i].Mutex);
  inherited;
end;

procedure TSQLRestCache.Clear;
var i: integer;
begin
  if self<>nil then
  for i := 0 to high(fCache) do
  with fCache[i] do begin
    EnterCriticalSection(Mutex);
    try
      Value.Clear;
      CacheAll := false;
      CacheEnable := false;
      TimeOutMS := 0;
    finally
      LeaveCriticalSection(Mutex);
    end;
  end;
end;

procedure TSQLRestCache.Flush;
var i: integer;
begin
  if self<>nil then
  for i := 0 to high(fCache) do
    fCache[i].FlushCacheAllEntries; // include *CriticalSection(Mutex)
end;

procedure TSQLRestCache.Flush(aTable: TSQLRecordClass);
begin
  if self<>nil then // includes *CriticalSection(Mutex):
    fCache[fRest.Model.GetTableIndexExisting(aTable)].FlushCacheAllEntries;
end;

procedure TSQLRestCache.Flush(aTable: TSQLRecordClass; aID: integer);
begin
  if self<>nil then
    with fCache[fRest.Model.GetTableIndexExisting(aTable)] do
    if CacheEnable then begin
      EnterCriticalSection(Mutex);
      try
        FlushCacheEntry(Value.Find(aID));
      finally
        LeaveCriticalSection(Mutex);
      end;
    end;
end;

procedure TSQLRestCache.Notify(aTable: TSQLRecordClass; aID: integer;
  const aJSON: RawUTF8; aAction: TSQLOccasion);
begin
  if (self<>nil) and (aTable<>nil) and (aID>0) then
    Notify(fRest.Model.GetTableIndex(aTable),aID,aJSON,aAction);
end;

procedure TSQLRestCache.Notify(aRecord: TSQLRecord; aAction: TSQLOccasion);
var aTableIndex: cardinal;
begin
  if (self=nil) or (aRecord=nil) or (aRecord.fID<=0) or
     not (aAction in [soInsert,soUpdate]) then
    exit;
  aTableIndex := fRest.Model.GetTableIndex(PSQLRecordClass(aRecord)^);
  if aTableIndex<Cardinal(Length(fCache)) then
    with fCache[aTableIndex] do
      if CacheEnable then
        SetJSON(aRecord);
end;

procedure TSQLRestCache.Notify(aTableIndex: integer; aID: integer;
  const aJSON: RawUTF8; aAction: TSQLOccasion);
begin
  if (self<>nil) and (aID>0) and (aAction in [soSelect,soInsert,soUpdate]) and
     (aJSON<>'') and (Cardinal(aTableIndex)<Cardinal(Length(fCache))) then
    with fCache[aTableIndex] do
      if CacheEnable then
        SetJSON(aID,aJSON);
end;

procedure TSQLRestCache.NotifyDeletion(aTableIndex, aID: integer);
begin
  if (self<>nil) and (aID>0) and
     (Cardinal(aTableIndex)<Cardinal(Length(fCache))) then
    with fCache[aTableIndex] do
    if CacheEnable then begin
      EnterCriticalSection(Mutex);
      try
        FlushCacheEntry(Value.Find(aID));
      finally
        LeaveCriticalSection(Mutex);
      end;
    end;
end;

procedure TSQLRestCache.NotifyDeletion(aTable: TSQLRecordClass; aID: integer);
begin
  if (self<>nil) and (aTable<>nil) and (aID>0) then
    NotifyDeletion(fRest.Model.GetTableIndex(aTable),aID);
end;

function TSQLRestCache.Retrieve(aID: Integer; aValue: TSQLRecord): boolean;
var TableIndex: cardinal;
begin
  result := false;
  if (self=nil) or (aValue=nil) or (aID<=0) then
    exit;
  TableIndex := fRest.Model.GetTableIndex(PSQLRecordClass(aValue)^);
  if TableIndex<Cardinal(Length(fCache)) then
    with fCache[TableIndex] do
    if CacheEnable and RetrieveJSON(aID,aValue) then
      result := true;
end;

function TSQLRestCache.Retrieve(aTableIndex, aID: integer): RawUTF8;
begin
  result := '';
  if (self<>nil) and (aID>0) and
     (Cardinal(aTableIndex)<Cardinal(Length(fCache))) then
    with fCache[aTableIndex] do
    if CacheEnable then
      RetrieveJSON(aID,result);
end;


{ TSQLRestClientURI }

function TSQLRestClientURI.EngineExecute(const SQL: RawUTF8): boolean;
begin
  result := URI(Model.Root,'POST',nil,nil,@SQL).Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.URIGet(Table: TSQLRecordClass; ID: integer;
  var Resp: RawUTF8; ForUpdate: boolean=false): Int64Rec;
const METHOD: array[boolean] of RawUTF8 = ('GET','LOCK');
begin
  result := URI(Model.getURIID(Table,ID),METHOD[ForUpdate],@Resp,nil,nil);
end;

function TSQLRestClientURI.UnLock(Table: TSQLRecordClass; aID: integer): boolean;
begin
  if (self=nil) or not Model.UnLock(Table,aID) then
    result := false else // was not locked by the client
    result := URI(Model.getURIID(Table,aID),'UNLOCK').Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.ExecuteList(const Tables: array of TSQLRecordClass;
  const SQL: RawUTF8): TSQLTableJSON;
var Resp: RawUTF8;
begin
  if self=nil then
    result := nil else
  with URI(Model.Root,'GET',@Resp,nil,@SQL) do
    if Lo=HTML_SUCCESS then begin // GET with SQL sent
      if high(Tables)=0 then
        result := TSQLTableJSON.CreateFromTables([Tables[0]],SQL,Resp) else
        result := TSQLTableJSON.CreateFromTables(Tables,SQL,Resp);
      result.fInternalState := Hi;
    end else // get data
    result := nil;
end;

function TSQLRestClientURI.ServerInternalState: cardinal;
begin
  if (Self=nil) or (Model=nil) then // avoid GPF
    result := cardinal(-1) else
    result := URI(Model.Root,'STATE').Hi;
end;

function TSQLRestClientURI.ServerCacheFlush(aTable: TSQLRecordClass; aID: integer): boolean;
var aResp: RawUTF8;
begin
  if (Self=nil) or (Model=nil) then // avoid GPF
    result := false else
    result := CallBackGet('CacheFlush',[],aResp,aTable,aID)=HTML_SUCCESS;
end;

function TSQLRestClientURI.ServerTimeStampSynchronize: boolean;
var status: integer;
    aResp: RawUTF8;
begin
  fServerTimeStampOffset := 0.0001; // avoid endless recursive call
  status := CallBackGet('TimeStamp',[],aResp);
  result := (status=HTML_SUCCESS) and (aResp<>'');
  if result then
    SetServerTimeStamp(GetInt64(pointer(aResp))) else begin
    InternalLog('/TimeStamp call failed -> Server not available',sllWarning);
    fLastErrorMessage := 'Server not available  - '+Trim(fLastErrorMessage);
  end;
end;

function TSQLRestClientURI.UpdateFromServer(const Data: array of TObject; out Refreshed: boolean;
  PCurrentRow: PInteger): boolean;
// notes about refresh mechanism:
// - if server doesn't implement InternalState, its value is 0 -> always refresh
// - if any TSQLTableJSON or TSQLRecord belongs to a TSQLRestStorage,
// the Server stated fInternalState=cardinal(-1) for them -> always refresh
var i: integer;
    State: cardinal;
    Resp: RawUTF8;
    T: TSQLTableJSON;
    TRefreshed: boolean; // to check for each Table refresh
const TState: array[boolean] of TOnTableUpdateState = (tusNoChange,tusChanged);
begin
  result := self<>nil;
  Refreshed := false;
  if not result then
    exit; // avoid GPF
  State := ServerInternalState; // get revision state from server
  for i := 0 to high(Data) do
    if Data[i]<>nil then
    if TObject(Data[i]).InheritsFrom(TSQLTableJSON) then begin
      T := TSQLTableJSON((Data[i]));
      if (T.QuerySQL<>'') and (T.InternalState<>State) then begin // refresh needed?
        with URI(Model.Root,'GET',@Resp,nil,@T.QuerySQL) do
          if Lo=HTML_SUCCESS then begin // GET with SQL sent
            if Assigned(OnTableUpdate) then
              OnTableUpdate(T,tusPrepare);
            TRefreshed := false;
            if not T.UpdateFrom(Resp,TRefreshed,PCurrentRow) then
              result := false else // mark error retrieving new content
              T.fInternalState := Hi;
            if TRefreshed then
              Refreshed := true;
            if Assigned(OnTableUpdate) then
              OnTableUpdate(T,TState[TRefreshed]);
          end
          else result := false; // mark error retrieving new content
        end;
    end else
    if TObject(Data[i]).InheritsFrom(TSQLRecord) then
    with TSQLRecord(Data[i]) do
      if (fID<>0) and (InternalState<>State) then begin // refresh needed?
        if not Refresh(fID,TSQLRecord(Data[i]),Refreshed) then
          result := false; // mark error retrieving new content
      end;
end;

function TSQLRestClientURI.List(const Tables: array of TSQLRecordClass;
  const SQLSelect, SQLWhere: RawUTF8): TSQLTableJSON;
var Resp, SQL: RawUTF8;
    U: RawUTF8;
    InternalState: cardinal;
begin
  result := nil;
  if high(Tables)<0 then exit;
  // GET Collection
  SQL := Model.SQLFromSelectWhere(Tables,SQLSelect,SQLWhere);
  if high(Tables)=0 then begin
    // one Table -> use REST protocol (SQL as parameters)
    if not IsRowID(pointer(SQLSelect)) then
      // ID selected by default
      U := '?select='+UrlEncode(SQLSelect) else
      U := '';
    if SQLWhere<>'' then begin
      if U<>'' then
        U := U+'&where=' else
        U := U+'?where=';
      U := U+UrlEncode(SQLWhere);
    end;
    with URI(Model.URI[TSQLRecordClass(Tables[0])]+U,'GET',@Resp) do
      if Lo<>HTML_SUCCESS then
        exit else
        InternalState := Hi;
    result := TSQLTableJSON.CreateFromTables([Tables[0]],SQL,Resp); // get data
  end else begin
    // multiple tables -> send SQL statement as HTTP body
    with URI(Model.Root,'GET',@Resp,nil,@SQL) do
      if Lo<>HTML_SUCCESS then
        exit else
        InternalState := Hi;
    result := TSQLTableJSON.CreateFromTables(Tables,SQL,Resp); // get data
  end;
  result.fInternalState := InternalState;
end;

procedure TSQLRestClientURI.SessionClose;
var tmp: RawUTF8;
begin
  if (self<>nil) and (fSessionUser<>nil) and
     (fSessionID<>CONST_AUTHENTICATION_SESSION_NOT_STARTED) then
  try
    // notify session closed to server
    CallBackGet('auth',['UserName',fSessionUser.LogonName,'Session',fSessionID],tmp);
  finally
    fSessionID := CONST_AUTHENTICATION_SESSION_NOT_STARTED;
    fSessionIDHexa8 := '';
    fSessionPrivateKey := 0;
    fSessionAuthentication := nil;
    FreeAndNil(fSessionUser);
  end;
end;

function TSQLRestClientURI.SessionCreate(aAuth: TSQLRestServerAuthenticationClass;
  var aUser: TSQLAuthUser; const aSessionKey: RawUTF8): boolean;
var i: integer;
begin
  result := false;
  i := PosEx(RawUTF8('+'),aSessionKey,1);
  if i=0 then
    exit; // expect SessionID+HexaSessionPrivateKey
  fSessionID := GetCardinal(pointer(aSessionKey));
  if fSessionID=0 then
    exit;
  fSessionIDHexa8 := CardinalToHex(fSessionID);
  fSessionPrivateKey := crc32(crc32(0,Pointer(aSessionKey),length(aSessionKey)),
    pointer(aUser.PasswordHashHexa),length(aUser.PasswordHashHexa));
  fSessionUser := aUser;
  fSessionAuthentication := aAuth;
  aUser := nil;
  result := true;
end;

constructor TSQLRestClientURI.Create(aModel: TSQLModel);
begin
  inherited Create(aModel);
  fSessionID := CONST_AUTHENTICATION_NOT_USED;
  InitializeCriticalSection(fMutex);
end;

destructor TSQLRestClientURI.Destroy;
var t,i,aID: integer;
    Table: TSQLRecordClass;
begin
  fBatch.Free;
  try
    // unlock all still locked records by this client
    if Model<>nil then
    for t := 0 to high(Model.Locks) do begin
      Table := Model.Tables[t];
      with Model.Locks[t] do
      for i := 0 to Count-1 do begin
        aID := IDs[i];
        if aID<>0 then // 0 is empty after unlock
          self.UnLock(Table,aID);
      end;
    end;
    SessionClose; // if not already notified
  finally
    // release memory and associated classes
    fSessionUser.Free;
    try
      inherited Destroy; // fModel.Free if owned by this TSQLRest instance
      {$ifndef LVCL}
      FreeAndNil(fBackgroundThread); // should be done after fServices.Free
      fOnIdle := nil;
      {$endif}
    finally
      InternalClose;
      DeleteCriticalSection(fMutex);
    end;
  end;
end;

procedure TSQLRestClientURI.Commit(SessionID: cardinal);
begin
  inherited Commit(CONST_AUTHENTICATION_NOT_USED); // reset fTransactionActiveSession flag
  URI(Model.Root,'END');
end;

procedure TSQLRestClientURI.RollBack(SessionID: cardinal);
begin
  inherited RollBack(CONST_AUTHENTICATION_NOT_USED); // reset fTransactionActiveSession flag
  URI(Model.Root,'ABORT');
end;

function TSQLRestClientURI.TransactionBegin(aTable: TSQLRecordClass;
  SessionID: cardinal): boolean;
begin
  result := inherited TransactionBegin(aTable,CONST_AUTHENTICATION_NOT_USED);
  if result then
    // fTransactionActiveSession flag was not already set
    if aTable=nil then
      result := URI(Model.Root,'BEGIN').Lo=HTML_SUCCESS else
      result := URI(Model.URI[aTable],'BEGIN').Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.TransactionBeginRetry(aTable: TSQLRecordClass;
  Retries: integer): boolean;
begin
  if Retries>50 then
    Retries := 50; // avoid loop for more than 10 seconds
  repeat
    result := TransactionBegin(aTable);
    if result then
      exit;
    dec(Retries);
    if Retries<=0 then break;
    sleep(100);
  until false;
end;

const
  // log up to 20 KB of JSON response, to save space
  MAX_SIZE_RESPONSE_LOG = 20*1024;

function TSQLRestClientURI.CallBackGet(const aMethodName: RawUTF8;
  const aNameValueParameters: array of const; out aResponse: RawUTF8;
  aTable: TSQLRecordClass; aID: integer; aResponseHead: PRawUTF8): integer;
var url, header: RawUTF8;
begin
  if self=nil then
    result := HTML_UNAVAILABLE else begin
{$ifdef WITHLOG}
    SQLite3Log.Enter(Self,pointer(aMethodName),true);
{$endif}
    url := Model.getURICallBack(aMethodName,aTable,aID)+
      UrlEncode(aNameValueParameters);
    result := URI(url,'GET',@aResponse,@header).Lo;
    if aResponseHead<>nil then
      aResponseHead^ := header;
{$ifdef WITHLOG}
    if aResponse<>'' then
    with SQLite3Log.Family do
      if sllServiceReturn in Level then
        if IsHTMLContentTypeTextual(pointer(header)) then
          SynLog.Log(sllServiceReturn,aResponse,nil,MAX_SIZE_RESPONSE_LOG) else
          SynLog.Log(sllServiceReturn,'% bytes "%"',[length(aResponse),header]);
{$endif}
  end;
end;

function TSQLRestClientURI.SetUser(const aUserName, aPassword: RawUTF8;
  aHashedPassword: Boolean): boolean;
const HASH: array[boolean] of TSQLRestServerAuthenticationClientSetUserPassword =
  (passClear, passHashed);
begin
  if self=nil then begin
    result := false;
    exit;
  end;
{$ifdef SSPIAUTH} // try Windows authentication with the current logged user
  result := true;
  if (trim(aUserName)='') and
    TSQLRestServerAuthenticationSSPI.ClientSetUser(self,'',aPassword) then
      exit;
{$endif}
  result := TSQLRestServerAuthenticationDefault.
    ClientSetUser(self,aUserName,aPassword,HASH[aHashedPassword]);
end;

procedure TSQLRestClientURI.SetLastException(E: Exception; ErrorCode: integer);
begin
  fLastErrorCode := ErrorCode;
  if E=nil then begin
    fLastErrorException := nil;
    if ErrorCode=HTML_SUCCESS then
      fLastErrorMessage := '' else
      StatusCodeToErrorMsg(ErrorCode,fLastErrorMessage);
  end else begin
    fLastErrorException := PPointer(E)^;
    StringToUTF8(E.Message,fLastErrorMessage);
  end;
end;

{$ifndef LVCL} // SyncObjs.TEvent not available in LVCL yet

procedure TSQLRestClientURI.OnBackgroundProcess(Sender: TSynBackgroundThreadEvent;
  ProcessOpaqueParam: pointer);
var Call: ^TSQLRestURIParams absolute ProcessOpaqueParam;
begin
  if Call=nil then
    exit;
  InternalURI(Call^);
  if OnIdleBackgroundThreadActive then
    if Call^.OutStatus=HTML_NOTIMPLEMENTED then begin
      // InternalCheckOpen failed -> force recreate connection
      InternalClose;
      if OnIdleBackgroundThreadActive then
        InternalURI(Call^); // try request again
    end;
end;

function TSQLRestClientURI.GetOnIdleBackgroundThreadActive: boolean;
begin
  result := (self<>nil) and Assigned(fOnIdle) and
    fBackgroundThread.OnIdleBackgroundThreadActive;
end;

{$endif LVCL}

function TSQLRestClientURI.URI(const url, method: RawUTF8;
  Resp, Head, SendData: PRawUTF8): Int64Rec;
var Retry: integer;
    aUserName, aPassword: string;
    StatusMsg: RawUTF8;
    Call: TSQLRestURIParams;
    aRetryOnceOnTimeout: boolean;
label DoRetry;
begin
  if self=nil then begin
    Int64(result) := HTML_UNAVAILABLE;
    SetLastException(nil,HTML_UNAVAILABLE);
    exit;
  end;
  aRetryOnceOnTimeout := RetryOnceOnTimeout;
  fLastErrorMessage := '';
  fLastErrorException := nil;
  if fServerTimeStampOffset=0 then
    if not ServerTimeStampSynchronize then begin
      Int64(result) := HTML_UNAVAILABLE;
      exit; // if /TimeStamp is not available, server is down!
    end;
  Call.RestAccessRights := nil;
  Call.OutStatus := 0;
  Call.OutInternalState := 0;
  for Retry := -1 to MaximumAuthentificationRetry do
  try
DoRetry:
    if fSessionAuthentication=nil then
      Call.Url := url else
      Call.Url := fSessionAuthentication.ClientSessionSign(self,url);
    Call.Method := method;
    if SendData<>nil then
      Call.InBody := SendData^;
{$ifndef LVCL}
    if Assigned(fOnIdle) then begin
      if fBackgroundThread=nil then
        fBackgroundThread := TSynBackgroundThreadEvent.Create(OnBackgroundProcess,OnIdle);
      if not fBackgroundThread.RunAndWait(@Call) then
        Call.OutStatus := HTML_UNAVAILABLE;
    end else
{$endif}
    begin
      InternalURI(Call);
      if Call.OutStatus=HTML_NOTIMPLEMENTED then begin // InternalCheckOpen failed
        InternalClose;     // force recreate connection
        InternalURI(Call); // try request again
      end;
    end;
    result.Lo := Call.OutStatus;
    result.Hi := Call.OutInternalState;
    if Head<>nil then
      Head^ := Call.OutHead;
    if Resp<>nil then
      Resp^ := Call.OutBody;
    fLastErrorCode := Call.OutStatus;
    if (Call.OutStatus=HTML_TIMEOUT) and aRetryOnceOnTimeout then begin
      aRetryOnceOnTimeout := false;
{$ifdef WITHLOG}
      SQLite3Log.Add.Log(sllError,'% % returned "408 Request Timeout" -> RETRY',
        [method,url],self);
{$endif}
      goto DoRetry;
    end;
    if not (Call.OutStatus in [HTML_SUCCESS,HTML_CREATED]) then begin
      StatusCodeToErrorMsg(Call.OutStatus,StatusMsg);
      if Call.OutBody='' then
        fLastErrorMessage := StatusMsg else
        fLastErrorMessage := Call.OutBody;
{$ifdef WITHLOG}
      SQLite3Log.Add.Log(sllError,'% % returned % % with message  %',
        [method,url,Call.OutStatus,StatusMsg,fLastErrorMessage],self);
{$endif}
    end;
    if (Call.OutStatus<>HTML_FORBIDDEN) or not Assigned(OnAuthentificationFailed) then
      break;
    // "403 Forbidden" in case of authentication failure -> try relog
    if not OnAuthentificationFailed(Retry+2,aUserName,aPassword) or
       not SetUser(StringToUTF8(aUserName),StringToUTF8(aPassword)) then
      break;
  except
    on E: Exception do begin
      Int64(result) := HTML_NOTIMPLEMENTED; // 501
      SetLastException(E,HTML_NOTIMPLEMENTED);
      exit;
    end;
  end;
end;

function TSQLRestClientURI.CallBackGetResult(const aMethodName: RawUTF8;
  const aNameValueParameters: array of const; aTable: TSQLRecordClass; aID: integer): RawUTF8;
var aResponse: RawUTF8;
begin
  if CallBackGet(aMethodName,aNameValueParameters,aResponse,aTable,aID)=HTML_SUCCESS then
    result := JSONDecode(aResponse) else
    result := '';
end;

function TSQLRestClientURI.CallBackPut(const aMethodName,
  aSentData: RawUTF8; out aResponse: RawUTF8; aTable: TSQLRecordClass;
  aID: integer; aResponseHead: PRawUTF8): integer;
begin
  if self=nil then
    result := HTML_UNAVAILABLE else begin
{$ifdef WITHLOG}
    SQLite3Log.Enter(self,pointer(aMethodName),true);
{$endif}
    result := URI(Model.getURICallBack(aMethodName,aTable,aID),
      'PUT',@aResponse,aResponseHead,@aSentData).Lo;
{$ifdef WITHLOG}
    SQLite3Log.Add.Log(sllServiceReturn,'result=%',result);
{$endif}
  end;
end;

function TSQLRestClientURI.ServiceRegister(const aInterfaces: array of PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation=sicSingle;
  const aContractExpected: RawUTF8=''): boolean;
begin
  result := False;
  if (self=nil) or (high(aInterfaces)<0) then
    exit;
  if fServices=nil then
    fServices := TServiceContainerClient.Create(self);
  result := (fServices as TServiceContainerClient).AddInterface(
    aInterfaces,aInstanceCreation,aContractExpected);
end;

function TSQLRestClientURI.ServiceRegister(aInterface: PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation=sicSingle;
  const aContractExpected: RawUTF8=''): TServiceFactory;
begin
  result := nil;
  if (self=nil) or (aInterface=nil) then begin
    SetLastException;
    exit;
  end;
  if fServices=nil then
    fServices := TServiceContainerClient.Create(self);
  with fServices as TServiceContainerClient do
  try
    result := AddInterface(aInterface,aInstanceCreation,aContractExpected);
  except
    on E: Exception do
      SetLastException(E);
  end;
end;

function TSQLRestClientURI.ServiceRegisterClientDriven(aInterface: PTypeInfo;
  out Obj; const aContractExpected: RawUTF8=''): boolean;
var Factory: TServiceFactory;
begin
  Factory := ServiceRegister(aInterface,sicClientDriven,aContractExpected);
  if Factory<>nil then begin
    result := true;
    Factory.Get(Obj);
  end else
    result := false;
end;

function TSQLRestClientURI.EngineAdd(TableModelIndex: integer;
  const SentData: RawUTF8): integer;
var P: PUTF8Char;
    url, Head: RawUTF8;
begin
  result := 0;
  url := Model.URI[Model.Tables[TableModelIndex]];
  if URI(url,'POST',nil,@Head,@SentData).Lo<>HTML_CREATED then
    exit; // response must be '201 Created'
  P := pointer(Head); // we need to check the headers
  if P<>nil then
  repeat
    // find ID from 'Location: Member Entry URI' header entry
    if IdemPChar(P,'LOCATION:') then begin // 'Location: root/People/11012' e.g.
      inc(P,9);
      while P^>#13 do inc(P); // go to end of line
      P^ := #0; // make line asciiz, even if ended with #13
      while P[-1] in ['0'..'9'] do dec(P); // get all number chars
      if P[-1]='-' then dec(P); 
      result := GetInteger(P); // get numerical value at the end of the URI
      exit;
    end;
    while not (P^ in [#0,#13]) do inc(P);
    if P^=#0 then break else inc(P);
    if P^=#10 then inc(P);
  until false;
end;

function TSQLRestClientURI.EngineDelete(TableModelIndex, ID: integer): boolean;
var url: RawUTF8;
begin
  url := Model.getURIID(Model.Tables[TableModelIndex],ID);
  result := URI(url,'DELETE').Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.EngineDeleteWhere(TableModelIndex: Integer;
  const SQLWhere: RawUTF8; const IDs: TIntegerDynArray): boolean;
var url: RawUTF8;
begin  // ModelRoot/TableName?where=WhereClause to delete members
  url := Model.getURI(Model.Tables[TableModelIndex])+'?where='+UrlEncode(SQLWhere);
  result := URI(url,'DELETE').Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.EngineList(const SQL: RawUTF8;
  ForceAJAX: Boolean; ReturnedRowCount: PPtrInt): RawUTF8;
begin
  if (self=nil) or (SQL='') or (ReturnedRowCount<>nil) or 
     (URI(Model.Root,'GET',@result,nil,@SQL).Lo<>HTML_SUCCESS) then
    result := ''
end;

function TSQLRestClientURI.ClientRetrieve(TableModelIndex, ID: integer;
  ForUpdate: boolean; var InternalState: cardinal; var Resp: RawUTF8): boolean;
begin
  if cardinal(TableModelIndex)<=cardinal(Model.fTablesMax) then
  with URIGet(Model.Tables[TableModelIndex],ID,Resp,ForUpdate) do
    if Lo=HTML_SUCCESS then begin
      InternalState := Hi;
      result := true;
    end else
      result := false else
      result := false;
end;

function TSQLRestClientURI.EngineRetrieveBlob(TableModelIndex, aID: integer;
  BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean;
var url: RawUTF8;
begin
  if (self=nil) or (aID<=0) or (BlobField=nil) then
    result := false else begin
    // URI is 'ModelRoot/TableName/TableID/BlobFieldName' with GET method
    url := Model.getURICallBack(BlobField^.Name,Model.Tables[TableModelIndex],aID);
    result := URI(url,'GET',@BlobData).Lo=HTML_SUCCESS;
  end;
end;

function TSQLRestClientURI.EngineUpdate(TableModelIndex, ID: integer;
  const SentData: RawUTF8): boolean;
var url: RawUTF8;
begin
  url := Model.getURIID(Model.Tables[TableModelIndex],ID);
  result := URI(url,'PUT',nil,nil,@SentData).Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.EngineUpdateBlob(TableModelIndex, aID: integer;
  BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean;
var url, Head: RawUTF8;
begin
  Head := 'Content-Type: application/octet-stream';
  if (self=nil) or (aID<=0) or (BlobField=nil) then
    result := false else begin
    // PUT ModelRoot/TableName/TableID/BlobFieldName
    url := FormatUTF8('%/%/%',[Model.URI[Model.Tables[TableModelIndex]],aID,BlobField^.Name]);
    result := URI(url,'PUT',nil,@Head,@BlobData).Lo=HTML_SUCCESS;
  end;
end;

function TSQLRestClientURI.EngineUpdateField(TableModelIndex: integer;
  const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
var url: RawUTF8;
begin
  if (self=nil) or (TableModelIndex<0) then
    result := false else begin
    // PUT ModelRoot/TableName?setname=..&set=..&wherename=..&where=..
    url := FormatUTF8('%?setname=%&set=%&wherename=%&where=%',
      [Model.URI[Model.Tables[TableModelIndex]],
       SetFieldName,UrlEncode(SetValue),WhereFieldName,UrlEncode(WhereValue)]);
    result := URI(url,'PUT').Lo=HTML_SUCCESS;
  end;
end;

function TSQLRestClientURI.EngineBatchSend(Table: TSQLRecordClass; const Data: RawUTF8;
  var Results: TIntegerDynArray): integer;
var Resp: RawUTF8;
    R: PUTF8Char;
    i: integer;
begin // TSQLRest.BatchSend() ensured that Batch contains some data
  try
    // URI is 'ModelRoot/Batch' or 'ModelRoot/Batch/TableName' with PUT method
    result := URI(Model.getURICallBack('Batch',Table,0),'PUT',@Resp,nil,@Data).Lo;
    if result<>HTML_SUCCESS then
      exit;
    // returned Resp shall be an array of integers: '[200,200,...]'
    R := pointer(Resp);
    if R<>nil then
      while not (R^ in ['[',#0]) do inc(R);
    result := HTML_BADREQUEST;
    if (R=nil) or (R^<>'[') then
      // invalid response
      exit;
    SetLength(Results,fBatchCount);
    if IdemPChar(R,'["OK"]') then begin // to save bandwith if no adding
      for i := 0 to fBatchCount-1 do
        Results[i] := HTML_SUCCESS;
    end else begin
      inc(R); // jump first '['
      for i := 0 to fBatchCount-1 do begin
        Results[i] := GetJSONIntegerVar(R);
        while R^ in [#1..' '] do inc(R);
        case R^ of
          ',': inc(R);
          ']': break;
          else exit;
        end;
      end;
      if R^<>']' then
        exit;
    end;
    result := HTML_SUCCESS; // returns OK
  finally
    BatchAbort;
  end;
end;

function TSQLRestClientURI.BatchUpdate(Value: TSQLRecord;
  const CustomFields: TSQLFieldBits=[]): integer;
begin
  if (Value=nil) or (fBatch=nil) or (Value.fID<=0) or
     not BeforeUpdateEvent(Value) then
    result := -1 else
    result := inherited BatchUpdate(Value,CustomFields);
end;


{ TSQLRestServer }

{$ifdef MSWINDOWS}
const
  ServerPipeNamePrefix: TFileName = '\\.\pipe\mORMot_';

var
  GlobalURIRequestServer: TSQLRestServer = nil;

function URIRequest(url, method, SendData: PUTF8Char; Resp, Head: PPUTF8Char): Int64Rec; cdecl;
function StringToPCharCopy(const s: RawUTF8): PUTF8Char;
var L: integer;
begin
  L := length(s);
  if L=0 then
    result := nil else begin
    inc(L); // copy also last #0 from s
    if USEFASTMM4ALLOC then
      GetMem(result,L) else
      result := pointer(GlobalAlloc(GMEM_FIXED,L));
    move(pointer(s)^,result^,L);
  end;
end;
var call: TSQLRestURIParams;
begin
  if GlobalURIRequestServer=nil then begin
    Int64(result) := HTML_NOTIMPLEMENTED; // 501 
    exit;
  end;
  call.Url := url;
  call.Method := method;
  call.InHead := 'RemoteIP: 127.0.0.1'#13#10'ConnectionID: 0001';
  if (Head<>nil) and (Head^<>nil) then
    call.InHead := RawUTF8(Head^)+#13#10+call.InHead;
  call.InBody := SendData;
  call.RestAccessRights := @SUPERVISOR_ACCESS_RIGHTS;
  GlobalURIRequestServer.URI(call);
  result.Lo := call.OutStatus;
  result.Hi := call.OutInternalState;
  if Head<>nil then
    Head^ := StringToPCharCopy(call.OutHead);
  if Resp<>nil then
    Resp^ := StringToPCharCopy(call.OutBody); 
end;

function ReadString(Handle: cardinal): RawUTF8;
var L, Read: cardinal;
    P: PUTF8Char;
begin
  result := '';
  if (FileRead(Handle,L,4)=4) and (L<>0) then begin
    SetLength(result,L);
    P := pointer(result);
    repeat
      Read := FileRead(Handle,P^,L);
      if Read=0 then begin
        sleep(100); // nothing available -> wait a little and retry
        Read := FileRead(Handle,P^,L);
        if Read=0 then begin // server may be down -> abort
          raise ECommunicationException.Create('ReadString');
          exit;
        end;
      end;
      inc(P,Read);
      dec(L,Read);
    until L=0; // loop until received all expected data
  end;
end;

procedure WriteString(Handle: cardinal; const Text: RawUTF8);
var L: cardinal;
begin
  L := length(Text);
  if L=0 then
    // write cardinal 0 if Text=''
    FileWrite(Handle,L,4) else
    // write length+content at once
    FileWrite(Handle,pointer(PtrInt(Text)-4)^,L+4);
end;

function TSQLRestServer.ExportServerNamedPipe(const ServerApplicationName: TFileName): boolean;
var PipeName: TFileName;
    Pipe: THandle;
begin
  result := false;
  if fExportServerNamedPipeThread<>nil then
    exit; // only one ExportServer() by running process
  if {$ifdef UNICODE}IdemPCharW{$else}IdemPChar{$endif}(pointer(ServerApplicationName),'\\') then
    PipeName := ServerApplicationName else
    PipeName := ServerPipeNamePrefix+ServerApplicationName;
  Pipe := FileOpen(PipeName,fmOpenReadWrite); // is this pipe existing?
  if Pipe<>Invalid_Handle_Value then begin
    WriteString(Pipe,''); // send integer=0 -> force server disconnect
    FileClose(Pipe);
    exit; // only one pipe server with this name at once
  end;
  fExportServerNamedPipeThread := TSQLRestServerNamedPipe.Create(self, PipeName);
  NoAJAXJSON := true; // use smaller JSON size in this not HTTP use (never AJAX)
  result := true; // success
end;

function TSQLRestServer.ExportServerMessage(const ServerWindowName: string): boolean;
begin
  result := false;
  if (self=nil) or (fServerWindow<>0) then
    exit;  // only one ExportServerMessage() by running process
  fServerWindow := CreateInternalWindow(ServerWindowName,self);
  if fServerWindow=0 then
    exit; // impossible to create window -> fail
  fServerWindowName := ServerWindowName;
  result := true;
end;

const
  MAGIC_SYN: cardinal = $A5ABA5AB;

procedure TSQLRestServer.AnswerToMessage(var Msg: TWMCopyData);
var call: TSQLRestURIParams;
    P: PUTF8Char;
    Res: packed record
      Magic: cardinal;
      Status: cardinal;
      InternalState: cardinal;
    end;
    Data: TCopyDataStruct;
    Header, ResStr: RawUTF8;
begin
  Msg.Result := HTML_NOTFOUND;
  if (self=nil) or (Msg.From=0) then
    exit;
  P := Msg.CopyDataStruct^.lpData;
  if (P=nil) or (Msg.CopyDataStruct^.cbData<=7) then
    exit;
  if PCardinal(P)^<>MAGIC_SYN then
    exit; // invalid layout: a broadcasted WM_COPYDATA message? :(
  inc(P,4);
  // #1 is a field delimiter below, since Get*Item() functions return nil for #0
  Msg.Result := HTML_SUCCESS; // Send something back
  call.Url := GetNextItem(P,#1);
  call.Method := GetNextItem(P,#1);
  call.InHead := GetNextItem(P,#1);
  Header := 'RemoteIP: 127.0.0.1'#13#10'ConnectionID: '+CardinalToHex(Msg.From);
  if call.InHead='' then
    call.InHead := Header else
    call.InHead := call.InHead+#13#10+Header;
  with Msg.CopyDataStruct^ do
    SetString(call.InBody,P,PtrInt(cbData)-(P-lpData));
  call.RestAccessRights := @SUPERVISOR_ACCESS_RIGHTS;
  // note: it's up to URI overridden method to implement access rights
  URI(call);
  Res.Magic := MAGIC_SYN;
  Res.Status := call.OutStatus;
  Res.InternalState := call.OutInternalState;
  SetString(ResStr,PAnsiChar(@Res),sizeof(Res));
  ResStr := ResStr+call.OutHead+#1+call.OutBody;
  Data.dwData := fServerWindow;
  Data.cbData := length(ResStr);
  Data.lpData := pointer(ResStr);
  SendMessage(Msg.From,WM_COPYDATA,fServerWindow,PtrInt(@Data));
end;

function TSQLRestServer.CloseServerNamedPipe: boolean;
begin
  if fExportServerNamedPipeThread<>nil then begin
    fExportServerNamedPipeThread.Terminate;
    Sleep(200); // we have sleep(128) in TSQLRestServerNamedPipe.EngineExecute
    FreeAndNil(fExportServerNamedPipeThread);
    result := true;
  end else
    result := false;
end;

function TSQLRestServer.CloseServerMessage: boolean;
begin
  result := ReleaseInternalWindow(fServerWindowName,fServerWindow);
end;

function TSQLRestServer.ExportServer: boolean;
begin
  if (fServerWindow<>0) or (fExportServerNamedPipeThread<>nil) then
    result := false else // another server was running
  if (GlobalURIRequestServer=nil) or (GlobalURIRequestServer=self) then begin
    GlobalURIRequestServer := self;
    result := true;
  end else
    result := false;
end;

{$endif MSWINDOWS}

procedure TSQLRestServer.ServiceMethodRegisterPublishedMethods(const aPrefix: RawUTF8;
  aInstance: TObject);
var i,n: integer;
    C: PtrInt;
    M: PMethodInfo;
    MethodName: RawUTF8;
//    RI: PReturnInfo; // such RTTI info not available at least in Delphi 7
begin
  if aInstance=nil then
    exit;
  if PosEx('/',aPrefix)>0 then
    raise EServiceException.CreateFmt('"%s" method name prefix should not contain "/"',[aPrefix]);  
  C := PtrInt(aInstance.ClassType);
  while C<>0 do begin
    M := PPointer(C+vmtMethodTable)^;
    if M<>nil then begin
      {$ifdef FPC}
      n := PCardinal(M)^;
      inc(PCardinal(M));
      {$else}
      n := PWord(M)^;
      inc(PWord(M));
      {$endif}
      for i := 1 to n do begin
{        RI := M^.ReturnInfo;
        if (RI=nil) or
           ((RI<>nil) and (RI^.ParamCount=1) and (RI^.CallingConvention=ccRegister) and
            (RI^.ReturnType<>nil) and (RI^.ReturnType^.Kind=tkInteger) and
            (RI^.Param^.ParamType^=TypeInfo(TSQLRestServerURIContext)) and
            not(pfVar in RI^.Param^.Flags)) then }
        MethodName := aPrefix+RawUTF8(M^.Name{$ifdef FPC}^{$endif});
        if Model.GetTableIndex(MethodName)>=0 then
          raise EServiceException.CreateFmt(
            'Published method name "%s" conflicts with a Table in Model!',[MethodName]);
        with TMethod(PSQLRestServerMethod(fPublishedMethods.AddUniqueName(MethodName,
            'Duplicated published method name "%s"',[MethodName]))^.CallBack) do begin
          Data := aInstance;
          Code := M^.Addr;
        end;
        {$ifdef FPC}
        inc(M);
        {$else}
        inc(PByte(M),M^.Len);
        {$endif}
      end;
    end;
    C := PPtrInt(C+vmtParent)^;
    if C=0 then
      break else
      C := PPtrInt(C)^;
  end;
end;

constructor TSQLRestServer.Create(aModel: TSQLModel; aHandleUserAuthentication: boolean);
var t,n: integer;
begin
  // specific server initialization
  fVirtualTableDirect := true; // faster direct Static call by default
  // needed by AuthenticationRegister() below
  InitializeCriticalSection(fSessionCriticalSection);
  fModel := aModel;
  fSQLAuthUserClass := TSQLAuthUser;
  fSQLAuthGroupClass := TSQLAuthGroup;
  fSessionClass := TAuthSession;
  fSessionAuthentications := TObjectDynArrayWrapper.Create(fSessionAuthentication);
  if aHandleUserAuthentication then
    // default mORMot authentication schemes
    AuthenticationRegister([TSQLRestServerAuthenticationDefault
      {$ifdef SSPIAUTH},TSQLRestServerAuthenticationSSPI{$endif}]);
  n := length(Model.Tables);
  SetLength(fTrackChangesHistory,n);
  if n>64 then
    n := 64;
  SetLength(fTrackChangesHistoryTableIndex,n);
  for t := 0 to n-1 do
    fTrackChangesHistoryTableIndex[t] := -1;
  // abstract MVC initalization
  inherited Create(aModel);
  fAfterCreation := true;
  fStats := TSQLRestServerStats.Create;
  URIPagingParameters := PAGINGPARAMETERS_YAHOO;
  fSessionCounter := GetTickCount; // force almost-random session ID
  if fSessionCounter>cardinal(maxInt) then
    dec(fSessionCounter,maxInt);
  // retrieve published methods
  fPublishedMethods.InitSpecific(TypeInfo(TSQLRestServerMethods),
    fPublishedMethod,djRawUTF8,nil,true);
  ServiceMethodRegisterPublishedMethods('',self);
  ServiceMethodByPassAuthentication('Auth');
  ServiceMethodByPassAuthentication('TimeStamp');
end;

procedure TSQLRestServer.CreateMissingTables(user_version: cardinal=0);
begin // nothing to do by default
end;

destructor TSQLRestServer.Destroy;
var i: integer;
begin
{$ifdef MSWINDOWS}
  if GlobalURIRequestServer=self then begin
    GlobalURIRequestServer := nil;
    sleep(200); // way some time any request is finished in another thread
  end;
  // close any running named-pipe or GDI-messages server instance
  CloseServerNamedPipe;
  CloseServerMessage;
{$endif}
  for i := 0 to high(fStaticData) do
    // free all TSQLRestStorage objects and update file if necessary
    fStaticData[i].Free;
  fSessions.Free;
  DeleteCriticalSection(fSessionCriticalSection);
  inherited Destroy; // calls fServices.Free which will update fStats
  {$ifdef WITHLOG}
  SQLite3Log.Add.Log(sllInfo,'%.Destroy -> %',[ClassType,self]);
  {$endif}
  fStats.Free; 
end;

function TSQLRestServer.GetStaticDataServer(aClass: TSQLRecordClass): TSQLRest;
begin
  if (self<>nil) and (fStaticData<>nil) then
   result := fStaticData[Model.GetTableIndexExisting(aClass)] else
   result := nil;
end;

function TSQLRestServer.GetStaticDataServerOrVirtualTable(
  aClass: TSQLRecordClass): TSQLRest;
begin
  if (aClass=nil) or ((fStaticData=nil) and (fStaticVirtualTable=nil)) then
    result := nil else
    result := GetStaticDataServerOrVirtualTable(Model.GetTableIndexExisting(aClass));
end;

function TSQLRestServer.GetStaticDataServerOrVirtualTable(aTableIndex: integer): TSQLRest;
begin
  result := nil;
  if aTableIndex>=0 then begin
    if fStaticData<>nil then
      result := fStaticData[aTableIndex];
    if result=nil then
      if fVirtualTableDirect and (fStaticVirtualTable<>nil) then
        result := fStaticVirtualTable[aTableIndex];
  end;
end;

function TSQLRestServer.GetStaticDataServerOrVirtualTable(aTableIndex: integer;
  out Kind: TSQLRestServerKind): TSQLRest;
begin
  result := nil;
  Kind := sMainEngine;
  if aTableIndex>=0 then begin
    if fStaticData<>nil then begin
      result := fStaticData[aTableIndex];
      if result<>nil then begin
        Kind := sStaticDataTable;
        exit;
      end;
    end;
    if fVirtualTableDirect and (fStaticVirtualTable<>nil) then begin
      result := fStaticVirtualTable[aTableIndex];
      if result<>nil then
        Kind := sVirtualTable;
    end;
  end;
end;

function TSQLRestServer.GetVirtualTable(aClass: TSQLRecordClass): TSQLRest;
var i: integer;
begin
  result := nil;
  if fStaticVirtualTable<>nil then begin
    i := Model.GetTableIndexExisting(aClass);
    if (i>=0) and (Model.TableProps[i].Kind in IS_CUSTOM_VIRTUAL) then
      result := fStaticVirtualTable[i];
  end;
end;

function TSQLRestServer.StaticDataCreate(aClass: TSQLRecordClass;
  const aFileName: TFileName; aBinaryFile: boolean;
  aServerClass: TSQLRestStorageClass): TSQLRest;
var i: integer;
begin
  result := nil;
  i := Model.GetTableIndexExisting(aClass);
  if fStaticData<>nil then
    result := fStaticData[i];
  if result<>nil then
    // class already registered -> update file name
    (result as aServerClass).fFileName := aFileName else begin
    // class not already registered -> register now
    if aServerClass=nil then
      aServerClass := TSQLRestStorageInMemory; // default in-memory engine
    result := aServerClass.Create(aClass,self,aFileName,aBinaryFile);
    if length(fStaticData)<length(Model.Tables) then
      SetLength(fStaticData,length(Model.Tables));
    fStaticData[i] := result;
  end;
end;

procedure TSQLRestServer.FlushInternalDBCache;
begin
  // do nothing by default
end;

function SQLGetOrder(const SQL: RawUTF8): RawUTF8;
var P: PUTF8Char;
    i: integer;
begin
  i := PosI('ORDER BY ',SQL);
  if i>0 then begin
    inc(i,9);
    while SQL[i] in [#1..' '] do inc(i); // trim left
    result := copy(SQL,i,maxInt);
    P := PosChar(Pointer(Result),' ');
    if P=nil then
      P := PosChar(Pointer(Result),';');
    if P<>nil then
      SetLength(result,P-pointer(Result)); // trim right
  end;
  if result='' then // by default, a SQLite3 query is ordered by ID
    result := 'RowID';
end;

procedure TSQLRestServer.SetNoAJAXJSON(const Value: boolean);
begin
  fNoAJAXJSON := Value;
end;

function TSQLRestServer.InternalAdaptSQL(TableIndex: integer; var SQL: RawUTF8): TSQLRest;
begin
  result := nil;
  if (self<>nil) and (TableIndex>=0) then begin // SQL refers to this unique table
    if fStaticData<>nil then
      // no SQLite3 module available for fStaticData[] -> we need to
      // retrieve manualy any static table from the SQL SELECT statement
      result := fStaticData[TableIndex];
    if (result=nil) and fVirtualTableDirect and (fStaticVirtualTable<>nil) then begin
      result := fStaticVirtualTable[TableIndex];
      // virtual table may need adaptation (e.g. RowID -> ID)
      if result<>nil then
        if result.InheritsFrom(TSQLRestStorage) and
           not TSQLRestStorage(result).AdaptSQLForEngineList(SQL) then
          // complex request will use SQlite3 virtual engine module
          result := nil;
    end;
  end;
end;

function TSQLRestServer.InternalListRawUTF8(TableIndex: integer; const SQL: RawUTF8): RawUTF8;
var aSQL: RawUTF8;
    Static: TSQLRest;
begin
  aSQL := SQL;
  Static := InternalAdaptSQL(TableIndex,aSQL);
  if Static<>nil then
     // this SQL statement is handled by direct connection, faster adaptation
    result := Static.EngineList(aSQL) else
    // complex TSQLVirtualTableJSON/External queries will rely on virtual table
    result := MainEngineList(SQL,false,nil);
  if result='[]'#$A then
    result := '';
end;

function TSQLRestServer.UnLock(Table: TSQLRecordClass; aID: integer): boolean;
begin
  result := Model.UnLock(Table,aID);
end;

procedure TSQLRestServer.Commit(SessionID: cardinal);
var i: integer;
begin
  inherited Commit(SessionID);
  if self<>nil then
    for i := 0 to high(fStaticVirtualTable) do
    if fStaticVirtualTable[i]<>nil then
    with TSQLRestStorageInMemory(fStaticVirtualTable[i]) do
      if InheritsFrom(TSQLRestStorageInMemory) and not CommitShouldNotUpdateFile then
        UpdateFile; // will do nothing if not Modified
end;

function TSQLRestServer.Delete(Table: TSQLRecordClass; ID: integer): boolean;
begin
  result := inherited Delete(Table,ID); // call EngineDelete
  if result then
    // force relational database coherency (i.e. our FOREIGN KEY implementation)
    AfterDeleteForceCoherency(Table,ID);
end;

function TSQLRestServer.Delete(Table: TSQLRecordClass; const SQLWhere: RawUTF8): boolean;
var IDs: TIntegerDynArray;
    i: integer;
begin
  result := false;
  if not InternalDeleteNotifyAndGetIDs(Table,SQLWhere,IDs) then
    exit;
  result := EngineDeleteWhere(Model.GetTableIndexExisting(Table),SQLWhere,IDs);
  if result then
    // force relational database coherency (i.e. our FOREIGN KEY implementation)
    for i := 0 to high(IDs) do
      AfterDeleteForceCoherency(Table,IDs[i]);
end;

function TSQLRestServer.TableRowCount(Table: TSQLRecordClass): integer;
var Static: TSQLRest;
begin
  Static := GetStaticDataServerOrVirtualTable(Table);
  if Static<>nil then // faster direct call
    result := Static.TableRowCount(Table) else
    result := inherited TableRowCount(Table);
end;

function TSQLRestServer.TableHasRows(Table: TSQLRecordClass): boolean;
var Static: TSQLRest;
begin
  Static := GetStaticDataServerOrVirtualTable(Table);
  if Static<>nil then // faster direct call
    result := Static.TableHasRows(Table) else
    result := inherited TableHasRows(Table);
end;

function TSQLRestServer.UpdateBlobFields(Value: TSQLRecord): boolean;
var Static: TSQLRest;
begin // overridden method to update all BLOB fields at once
  if (Value=nil) or (Value.fID<=0) then
    result := false else begin
    Static := GetStaticDataServerOrVirtualTable(PSQLRecordClass(Value)^);
    if Static<>nil then // faster direct call
      result := Static.UpdateBlobFields(Value) else
      result := inherited UpdateBlobFields(Value);
  end;
end;

function TSQLRestServer.RetrieveBlobFields(Value: TSQLRecord): boolean;
var Static: TSQLRest;
begin // overridden method to update all BLOB fields at once
  if Value=nil then
    result := false else begin
    Static := GetStaticDataServerOrVirtualTable(PSQLRecordClass(Value)^);
    if Static<>nil then // faster direct call
      result := Static.RetrieveBlobFields(Value) else
      result := inherited RetrieveBlobFields(Value);
  end;
end;

function TSQLRestServer.AfterDeleteForceCoherency(Table: TSQLRecordClass;
  aID: integer): boolean;
var T: integer;
    Tab: TSQLRecordClass;
    Where: PtrUInt;
    RecRef: TRecordReference;
    Static: TSQLRest;
    ToDo: (toVoidField, toDeleteRecord);
    W: RawUTF8;
begin
  result := true; // success if no property found
  {$ifndef CPU64}
  Where := 0; // make compiler happy
  {$endif}
  RecRef := RecordReference(Model,Table,aID);
  if RecRef<>0 then
  for T := 0 to high(Model.fRecordReferences) do
  with Model.fRecordReferences[T] do begin
    ToDo := toVoidField;
    case FieldType.SQLFieldType of
    sftRecord: begin // TRecordReference published field
      if IdemPropName((FieldType as TSQLPropInfoRTTIInstance).PropInfo^.Name,
          'TRecordReferenceToBeDeleted') then
        ToDo := toDeleteRecord;
      Where := RecRef;
    end;
    sftID:     // TSQLRecord published field
      if FieldType.ObjectClass=Table then
        Where := aID else
        continue;
    else continue;
    end;
    // set Field=0 where Field references aID
    UInt32ToUTF8(Where,W);
    Tab := Model.Tables[TableIndex];
    case ToDo of
    toVoidField: begin
      Static := GetStaticDataServerOrVirtualTable(Tab);
      if Static<>nil then // fast direct call
        result := Static.EngineUpdateField(TableIndex,
          FieldType.Name,'0',FieldType.Name,W) else
        result := MainEngineUpdateField(TableIndex,
          FieldType.Name,'0',FieldType.Name,W);
    end;
    toDeleteRecord:
      Delete(Tab,FieldType.Name+'=:('+W+'):');
    end;
  end;
end;

function TSQLRestServer.CreateSQLMultiIndex(Table: TSQLRecordClass;
  const FieldNames: array of RawUTF8; Unique: boolean; IndexName: RawUTF8=''): boolean;
var SQL: RawUTF8;
    i, TableIndex: integer;
    Props: TSQLRecordProperties;
    Static: TSQLRest;
begin
  result := false;
  if high(FieldNames)<0 then
    exit; // avoid endless loop for TSQLRestStorage with no overridden method
  TableIndex := Model.GetTableIndexExisting(Table);
  if fStaticVirtualTable<>nil then begin
    Static := fStaticVirtualTable[TableIndex];
    if Static<>nil then begin
      if Static.InheritsFrom(TSQLRestStorage) then
         // will try to create an index on the static table (e.g. for external DB)
         result := TSQLRestStorage(Static).
           CreateSQLMultiIndex(Table,FieldNames,Unique,IndexName);
      exit;
    end;
  end;
  if (high(FieldNames)=0) and IsRowID(pointer(FieldNames[0])) then begin
    result := true; // SQLite3 has always its ID/RowID primary key indexed
    exit;
  end;
  Props := Model.TableProps[TableIndex].Props;
  for i := 0 to high(FieldNames) do
    if Props.Fields.IndexByName(FieldNames[i])<0 then
      exit; // wrong field name
  if Unique then
    SQL := 'UNIQUE ' else
    SQL := '';
  if IndexName='' then
    IndexName := RawUTF8ArrayToCSV(FieldNames,'');
  SQL := FormatUTF8('CREATE %INDEX IF NOT EXISTS Index%% ON %(%);',
    [SQL,Props.SQLTableName,IndexName,Props.SQLTableName,RawUTF8ArrayToCSV(FieldNames,',')]);
  result := EngineExecuteAll(SQL);
end;

function TSQLRestServer.CreateSQLIndex(Table: TSQLRecordClass; const FieldName: RawUTF8;
  Unique: boolean; const IndexName: RawUTF8=''): boolean;
begin
  result := CreateSQLMultiIndex(Table,[FieldName],Unique,IndexName);
end;

function TSQLRestServer.CreateSQLIndex(Table: TSQLRecordClass;
  const FieldNames: array of RawUTF8; Unique: boolean): boolean;
var i: integer;
begin
  result := true;
  for i := 0 to high(FieldNames) do
    if not CreateSQLMultiIndex(Table,[FieldNames[i]],Unique) then
     result := false;
end;

procedure TSQLRestServer.AuthenticationRegister(aMethod: TSQLRestServerAuthenticationClass);
var i, TableIndex: integer;
begin
  if self=nil then
    exit;
  EnterCriticalSection(fSessionCriticalSection);
  try
    for i := 0 to fSessionAuthentications.Count-1 do
      if fSessionAuthentication[i].ClassType=aMethod then
        exit; // check not already there 
    fSessionAuthentications.Add(aMethod.Create(self));
    fHandleAuthentication := true;
    // we need both AuthUser+AuthGroup tables for authentication -> create now
    TableIndex := Model.GetTableIndexInheritsFrom(TSQLAuthUser);
    if TableIndex<0 then
      Model.AddTable(fSQLAuthUserClass,@TableIndex);
    fSQLAuthUserClass := TSQLAuthUserClass(Model.fTables[TableIndex]);
    TableIndex := Model.GetTableIndexInheritsFrom(TSQLAuthGroup);
    if TableIndex<0 then
      Model.AddTable(fSQLAuthGroupClass,@TableIndex);
    fSQLAuthGroupClass := TSQLAuthGroupClass(Model.fTables[TableIndex]);
    if fAfterCreation and
      ((not TableHasRows(fSQLAuthUserClass)) or
       (not TableHasRows(fSQLAuthGroupClass))) then
      CreateMissingTables(0);
  finally
    LeaveCriticalSection(fSessionCriticalSection);
  end;
end;

procedure TSQLRestServer.AuthenticationRegister(
  const aMethods: array of TSQLRestServerAuthenticationClass);
var i: integer;
begin
  for i := 0 to high(aMethods) do
    AuthenticationRegister(aMethods[i]);
end;

procedure TSQLRestServer.AuthenticationUnregister(aMethod: TSQLRestServerAuthenticationClass);
var i: integer;
begin
  if (self=nil) or (fSessionAuthentication=nil) then
    exit;
  EnterCriticalSection(fSessionCriticalSection);
  try
    for i := 0 to fSessionAuthentications.Count-1 do
      if fSessionAuthentication[i].ClassType=aMethod then begin
        fSessionAuthentications.Delete(i);
        fHandleAuthentication := (fSessionAuthentications.Count>0);
        break;
      end;
  finally
    LeaveCriticalSection(fSessionCriticalSection);
  end;
end;

procedure TSQLRestServer.AuthenticationUnregister(
  const aMethods: array of TSQLRestServerAuthenticationClass);
var i: integer;
begin
  for i := 0 to high(aMethods) do
    AuthenticationUnregister(aMethods[i]);
end;

procedure TSQLRestServer.ServiceMethodByPassAuthentication(const aMethodName: RawUTF8);
var i: Integer;
begin
  if self=nil then
    exit;
  i :=  fPublishedMethods.FindHashed(aMethodName);
  if i>=0 then
    fPublishedMethod[i].ByPassAuthentication := true;
end;

procedure StatusCodeToErrorMsg(Code: integer; var result: RawUTF8);
begin // see http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
  case Code of
    HTML_CONTINUE:            result := 'Continue';
    HTML_SWITCHINGPROTOCOLS:  result := 'Switching Protocols';
    HTML_SUCCESS:             result := 'OK';
    HTML_CREATED:             result := 'Created';
    HTML_ACCEPTED:            result := 'Accepted';
    HTML_NONAUTHORIZEDINFO:   result := 'Non-Authoritative Information';
    HTML_NOCONTENT:           result := 'No Content';
    HTML_MULTIPLECHOICES:     result := 'Multiple Choices';
    HTML_MOVEDPERMANENTLY:    result := 'Moved Permanently';
    HTML_FOUND:               result := 'Found';
    HTML_SEEOTHER:            result := 'See Other';
    HTML_NOTMODIFIED:         result := 'Not Modified';
    HTML_USEPROXY:            result := 'Use Proxy';
    HTML_TEMPORARYREDIRECT:   result := 'Temporary Redirect';
    HTML_BADREQUEST:          result := 'Bad Request';
    HTML_UNAUTHORIZED:        result := 'Unauthorized';
    HTML_FORBIDDEN:           result := 'Forbidden';
    HTML_NOTFOUND:            result := 'Not Found';
    HTML_NOTALLOWED:          result := 'Method Not Allowed';
    HTML_NOTACCEPTABLE:       result := 'Not Acceptable';
    HTML_PROXYAUTHREQUIRED:   result := 'Proxy Authentication Required';
    HTML_TIMEOUT:             result := 'Request Timeout';
    HTML_SERVERERROR:         result := 'Internal Server Error';
    HTML_BADGATEWAY:          result := 'Bad Gateway';
    HTML_GATEWAYTIMEOUT:      result := 'Gateway Timeout';
    HTML_UNAVAILABLE:         result := 'Service Unavailable';
    HTML_HTTPVERSIONNONSUPPORTED: result := 'HTTP Version Not Supported';
    else                      result := 'Invalid Request';
  end;
end;

function StringToMethod(const method: RawUTF8): TSQLURIMethod;
const NAME: array[mGET..high(TSQLURIMethod)] of string[7] = ( // sorted by occurence
  'GET','POST','PUT','DELETE','HEAD','BEGIN','END','ABORT','LOCK','UNLOCK','STATE');
var URIMethodUp: string[7];
begin
  if Length(method)<7 then begin
    URIMethodUp[0] := AnsiChar(UpperCopy(@URIMethodUp[1],method)-@URIMethodUp[1]);
    for result := low(NAME) to high(NAME) do
      if URIMethodUp=NAME[result] then
        exit;
  end;
  result := mNone;
end;

constructor TSQLRestServerURIContext.Create(aServer: TSQLRestServer;
  const aCall: TSQLRestURIParams);
var L: integer;
begin
  Server := aServer;
  Call := @aCall;
  Method := StringToMethod(aCall.method);;
  L := length(aCall.url);
  URISessionSignaturePos := L-(17+24+1);
  if (URISessionSignaturePos<0) or // signature should be LAST parameter in URL
     not IdemPChar(PUTF8Char(pointer(aCall.url))+URISessionSignaturePos,'SESSION_SIGNATURE=') then
    URISessionSignaturePos := 0;
  if URISessionSignaturePos=0 then
    URIWithoutSignature := aCall.Url else
    URIWithoutSignature := Copy(aCall.Url,1,URISessionSignaturePos-1);
end;

procedure TSQLRestServerURIContext.InternalSetTableFromTableName(const TableName: RawUTF8);
begin
  TableEngine := Server;
  TableIndex := Server.Model.GetTableIndex(TableName);
  if TableIndex>=0 then begin
    Table := Server.Model.Tables[TableIndex];
    TableRecordProps := Server.Model.TableProps[TableIndex];
    Static := Server.GetStaticDataServerOrVirtualTable(TableIndex,StaticKind);
    if Static<>nil then
      TableEngine := Static;
  end;
end;

function TSQLRestServerURIContext.URIDecodeREST: boolean;
var i,j: integer;
    P: PUTF8Char;
begin // expects 'ModelRoot[/TableName[/TableID][/BlobFieldName]][?param=...]' format
  i := 0;
  if (Call^.url<>'') and (Call^.url[1]='/') then
    inc(i); // URL may be '/path'
  j := length(Server.Model.Root);
  if (i+j>length(Call^.Url)) or (not(Call^.Url[i+j+1] in [#0,'/','?'])) or
     (StrCompIL(pointer(PtrInt(Call^.url)+i),pointer(Server.Model.Root),j,0)<>0) then begin
    result := False;
    exit; // bad ModelRoot -> caller can try another TSQLRestServer
  end;
  URI := copy(Call^.url,j+i+2,maxInt);
  i := PosEx(RawUTF8('/'),URI,1);
  if i>0 then begin
    Parameters := @URI[i+1];
    if Parameters^ in ['0'..'9'] then // "ModelRoot/TableName/TableID/BlobFieldName"
      TableID := GetNextItemCardinal(Parameters,'/') else
      TableID := -1; // URI like "ModelRoot/TableName/MethodName"
    if (Parameters<>nil) and (Parameters^<>#0) then begin
      P := PosChar(Parameters,'?');
      if P=nil then
        URIBlobFieldName := Parameters else begin
        SetString(URIBlobFieldName,PAnsiChar(Parameters),P-Parameters);
        j := PosEx('/',URIBlobFieldName);
        if j>0 then begin // handle "ModelRoot/TableName/BlobFieldName/ID"
          TableID := GetCardinalDef(pointer(PtrInt(URIBlobFieldName)+j),cardinal(-1));
          SetLength(URIBlobFieldName,j-1);
        end;
      end;
    end;
    SetLength(URI,i-1);
    j := PosEx(RawUTF8('?'),Call^.url,1);
    if j>0 then // '?select=...&where=...' or '?where=...'
      Parameters := @Call^.url[j+1] else
      Parameters := nil;
  end else begin
    TableID := -1;
    i := PosEx(RawUTF8('?'),Call^.url,1);
    if i>0 then begin // '?select=...&where=...' or '?where=...'
      Parameters := @Call^.url[i+1];
      i := PosEx(RawUTF8('?'),URI);
      if i>0 then
        dec(i);
      SetLength(URI,i);
    end;
  end;
  InternalSetTableFromTableName(URI);
  result := True;
end;

procedure TSQLRestServerURIContext.URIDecodeSOAByMethod;
begin
  if Table=nil then
    // check URI as 'ModelRoot/MethodName'
    MethodIndex := Server.fPublishedMethods.FindHashed(URI) else
  if URIBlobFieldName<>'' then
    // check URI as 'ModelRoot/TableName[/TableID]/MethodName'
    MethodIndex := Server.fPublishedMethods.FindHashed(URIBlobFieldName) else
    MethodIndex := -1;
end;

function TSQLRestServerURIContext.Authenticate: boolean;
var aSession: TAuthSession;
    i: integer;
begin
  if Server.HandleAuthentication then begin
    Session := CONST_AUTHENTICATION_SESSION_NOT_STARTED;
    EnterCriticalSection(Server.fSessionCriticalSection);
    try
      aSession := nil;
      if Server.fSessionAuthentication<>nil then
        for i := 0 to Server.fSessionAuthentications.Count-1 do begin
          aSession := Server.fSessionAuthentication[i].RetrieveSession(self);
          if aSession<>nil then begin
            {$ifdef WITHLOG}
            Log.Log(sllUserAuth,'%/%',[aSession.User.LogonName,aSession],self);
            {$endif}
            SetString(fSessionAccessRights,PAnsiChar(@aSession.fAccessRights),
              sizeof(TSQLAccessRights)); // override access rights
            Call^.RestAccessRights := pointer(fSessionAccessRights);
            break;
          end;
        end;
    finally
      LeaveCriticalSection(Server.fSessionCriticalSection);
    end;
    if aSession=nil then 
      if (Service=nil) or not Service.ByPassAuthentication then
        // /auth + /timestamp are e.g. allowed services without signature
        if (MethodIndex<0) or not Server.fPublishedMethod[MethodIndex].ByPassAuthentication then begin
          result := false; // authentication error -> caller can try another session
          exit;
        end;
  end else // default unique session if authentication is not enabled
    Session := CONST_AUTHENTICATION_NOT_USED;
  result := true;
end;

{$ifndef LVCL}
type
  TThreadHook = class(TThread);
{$endif}

type
  TCallMethodSynchro = record
    Action: (syncCallMethod, syncInstanceRelease);
    CallMethodArgs: pointer;
    InstanceToRelease: TInterfacedObjectWithCustomCreate;
  end;

procedure TSQLRestServerURIContext.Execute(Command: TSQLRestServerURIContextCommand);
procedure TimeOut;
begin
  {$ifdef WITHLOG}
  Log.Log(sllServer,'TimeOut %.Execute(%) after % ms',[self,
    GetEnumName(TypeInfo(TSQLRestServerURIContextCommand),ord(Command))^,
    Server.fAcquireExecution[Command].LockedTimeOut],self);
  {$endif}
  if Call<>nil then
    Call^.OutStatus := HTML_TIMEOUT; // 408 Request Time-out
end;
var Method: TThreadMethod;
    Start64: Int64;
begin
  with Server.fAcquireExecution[Command] do begin
    case Command of
      execSOAByMethod:
        Method := ExecuteSOAByMethod;
      execSOAByInterface:
        Method := ExecuteSOAByInterface;
      execORMGet:
        Method := ExecuteORMGet;
      execORMWrite: begin // special behavior to handle transactions at writing
        Method := ExecuteORMWrite;
        Start64 := GetTickCount64;
        repeat
          if TryEnterCriticalSection(Lock) then
          try
            if (Server.fTransactionActiveSession=0) or // avoid transaction mixups
               (Server.fTransactionActiveSession=Session) then begin
              if Mode=amLocked then begin
                ExecuteORMWrite; // process within the obtained write mutex
                exit;
              end;
              break;   // will handle Mode<>amLocked below
            end;
          finally
            LeaveCriticalSection(Lock);
          end;
          if (LockedTimeOut<>0) and (GetTickCount64>Start64+LockedTimeOut) then begin
            TimeOut; // wait up to 2 second by default
            exit;
          end;
          Sleep(1); // retry every 1 ms
        until false;
      end;
      else raise EORMException.CreateFmt('Unexpected Command=%d',[ord(Command)]);
    end;
    case Mode of
    amUnlocked:
      Method;
    amLocked:
      if LockedTimeOut=0 then begin
        EnterCriticalSection(Lock);
        try
          Method;
        finally
          LeaveCriticalSection(Lock);
        end;
      end else begin
      Start64 := GetTickCount64;
      repeat
        if TryEnterCriticalSection(Lock) then
        try
          Method;
        finally
          LeaveCriticalSection(Lock);
        end;
        if GetTickCount64>Start64+LockedTimeOut then
          break; // wait up to 2 second by default
        Sleep(1); // retry every 1 ms
      until false;
      TimeOut;
    end;
    {$ifndef LVCL}
    amMainThread:
      if GetCurrentThreadID=MainThreadID then
        Method else
        {$ifdef DELPHI6OROLDER}
        TThreadHook(nil).Synchronize(Method); {$else}
        TThread.Synchronize(nil,Method);
        {$endif}
    {$endif}
    amBackgroundThread: begin
      if Thread=nil then
        Thread := TSynBackgroundThreadSQLRestServerMethod.Create(Server);
      Thread.RunAndWait(Method);
    end;
    end;
  end;
end;

procedure TSQLRestServerURIContext.ExecuteSOAByMethod;
begin
  with Server.fPublishedMethod[MethodIndex] do begin
    Server.InternalLog(Name,sllServiceCall);
    CallBack(self);
  end;
  inc(Server.fStats.fServices);
end;

type
  TServiceInternalMethod = (imFree, imContract, imSignature);

const
  SERVICE_PSEUDO_METHOD: array[TServiceInternalMethod] of RawUTF8 = (
    '_free_','_contract_','_signature_');

procedure TSQLRestServerURIContext.ServiceResultStart(WR: TTextWriter);
const JSONSTART: array[boolean] of RawUTF8 =
    ('{"result":[','{"result":{');
begin // InternalExecuteSOAByInterface has set ForceServiceResultAsJSONObject 
  WR.AddString(JSONSTART[ForceServiceResultAsJSONObject]);
end;

procedure TSQLRestServerURIContext.ServiceResultEnd(WR: TTextWriter; ID: integer);
const JSONSEND_WITHID: array[boolean] of RawUTF8 = ('],"id":','},"id":');
      JSONSEND_NOID: array[boolean] of AnsiChar = (']','}');
begin // InternalExecuteSOAByInterface has set ForceServiceResultAsJSONObject
  if ID=0 then
    WR.Add(JSONSEND_NOID[ForceServiceResultAsJSONObject]) else begin
    WR.AddString(JSONSEND_WITHID[ForceServiceResultAsJSONObject]);
    WR.Add(ID); // only used in sicClientDriven mode
  end;
  WR.Add('}');
end;

procedure TSQLRestServerURIContext.InternalExecuteSOAByInterface;
  procedure ServiceResult(const Name,JSONValue: RawUTF8);
  var WR: TTextWriter;
  begin
    WR := TJSONSerializer.CreateOwnedStream;
    try
      ServiceResultStart(WR);
      if ForceServiceResultAsJSONObject then
        WR.AddFieldName(Name);
      WR.AddString(JSONValue);
      ServiceResultEnd(WR,0);
      Returns(WR.Text);
    finally
      WR.Free;
    end;
  end;
begin // expects Service, ServiceParameters, ServiceMethodIndex to be set
  {$ifdef WITHLOG}
  Log.Log(sllServiceCall,URI,Server);
  {$endif}
  if ServiceParameters=nil then begin
    Error('Parameters required');
    exit;
  end;
  ForceServiceResultAsJSONObject :=
    ForceServiceResultAsJSONObject or Service.ResultAsJSONObject;
  inc(Server.fStats.fServices);
  case ServiceMethodIndex of
  ord(imFree):
    // "method":"_free_" to release sicClientDriven..sicPerGroup
    if ServiceInstanceID<=0 then begin
      Error('Expects an instance ID to be released');
      exit;
    end else
      ServiceMethodIndex := -1; // notify ExecuteMethod() to release the instance
  ord(imContract): begin
    // "method":"_contract_" to retrieve the implementation contract
    ServiceResult('contract',Service.ContractExpected);
    exit; // "id":0 for this method -> no instance was created
  end;
  ord(imSignature): begin
    // "method":"_signature_" to retrieve the implementation signature
    if TServiceContainerServer(Server.Services).PublishSignature then
      ServiceResult('signature',Service.Contract) else 
      // "id":0 for this method -> no instance was created
      Error('Not allowed to publish signature');
    exit;
  end;
  else // TServiceFactoryServer.ExecuteMethod() expects index in fMethods[]:
    dec(ServiceMethodIndex,length(SERVICE_PSEUDO_METHOD));
  end;
  if (Session>CONST_AUTHENTICATION_NOT_USED) and (ServiceMethodIndex>=0) and
     (SessionGroup-1 in Service.fExecution[ServiceMethodIndex].Denied) then begin
    Error('Unauthorized method');
    exit;
  end;
  // if we reached here, we have to run the service method
  Service.ExecuteMethod(self);
end;

procedure TSQLRestServerURIContext.ExecuteORMGet;
var SQLSelect, SQLWhere, SQLSort, SQLDir, SQL: RawUTF8;
    SQLStartIndex, SQLResults, SQLTotalRowsCount: integer;
    NonStandardSQLSelectParameter, NonStandardSQLWhereParameter: boolean;
    SQLisSelect: boolean;
    ResultList: TSQLTableJSON;
    P: PUTF8Char;
    i,j,L: integer;
    Blob: PPropInfo;
begin
  case Method of
  mLOCK,mGET: begin
    if Table=nil then begin
      if (Method<>mLOCK) then begin
        if (Call.InBody='') and (Parameters<>nil) and
           (reUrlEncodedSQL in Call.RestAccessRights^.AllowRemoteExecute) then begin
          // GET with a SQL statement sent in URI, as sql=....
          while not UrlDecodeValue(Parameters,'SQL=',SQL,@Parameters) do
            if Parameters=nil then break;
        end else
          // GET with a SQL statement sent as UTF-8 body
          SQL := Call.InBody;
        SQLisSelect := isSelect(pointer(SQL));
        if (SQL<>'') and
          (SQLisSelect or (reSQL in Call.RestAccessRights^.AllowRemoteExecute)) then begin
          // no user check for SELECT: see TSQLAccessRights.GET comment
          Static := Server.InternalAdaptSQL(
            Server.Model.GetTableIndexFromSQLSelect(SQL,false),SQL);
          if Static<>nil then  begin
            TableEngine := Static;
            Call.OutBody := TableEngine.EngineList(SQL);
          end else
            Call.OutBody := Server.MainEngineList(SQL,false,nil);
          // security note: only first statement is run by EngineList()
          if Call.OutBody<>'' then begin // got JSON list '[{...}]' ?
            Call.OutStatus := HTML_SUCCESS;  // 200 OK
            if not SQLisSelect then
              inc(Server.fStats.fModified);
          end;
        end;
      end;
    end else
    // here, Table<>nil and TableIndex in [0..MAX_SQLTABLES-1]
    if not (TableIndex in Call.RestAccessRights^.GET) then // check User Access
      Call.OutStatus := HTML_NOTALLOWED else begin
      if TableID>0 then begin
        // GET ModelRoot/TableName/TableID[/BlobFieldName] to retrieve one member,
        // with or w/out locking, or a specified BLOB field content
        if Method=mLOCK then // LOCK is to be followed by PUT -> check user
          if not (TableIndex in Call.RestAccessRights^.PUT) then
            Call.OutStatus := HTML_NOTALLOWED else
            if Server.Model.Lock(TableIndex,TableID) then
              Method := mGET; // mark successfully locked
        if Method<>mLOCK then
          if URIBlobFieldName<>'' then begin
            // GET ModelRoot/TableName/TableID/BlobFieldName: retrieve BLOB field content
            Blob := Table.RecordProps.BlobFieldPropFromRawUTF8(URIBlobFieldName);
            if Blob<>nil then begin
              if TableEngine.EngineRetrieveBlob(TableIndex,
                   TableID,Blob,TSQLRawBlob(Call.OutBody)) then begin
                Call.OutHead := HEADER_CONTENT_TYPE+
                  GetMimeContentType(pointer(Call.OutBody),Length(Call.OutBody));
                Call.OutStatus := HTML_SUCCESS; // 200 OK
              end;
            end;
          end else begin
            // GET ModelRoot/TableName/TableID: retrieve a member content, JSON encoded
            Call.OutBody := Server.fCache.Retrieve(TableIndex,TableID);
            if Call.OutBody='' then begin
              // get JSON object '{...}'
              if Static<>nil then
                Call.OutBody := Static.EngineRetrieve(TableIndex,TableID) else
                Call.OutBody := Server.MainEngineRetrieve(TableIndex,TableID);
              // cache if expected
              Server.fCache.Notify(TableIndex,TableID,Call.OutBody,soSelect);
            end;
            if Call.OutBody<>'' then // if something was found
              Call.OutStatus := HTML_SUCCESS; // 200 OK
          end;
      end else
      // ModelRoot/TableName with 'select=..&where=' or YUI paging
      if Method<>mLOCK then begin // LOCK not available here
        SQLSelect := 'RowID'; // if no select is specified (i.e. ModelRoot/TableName)
        // all IDs of this table are returned to the client
        SQLTotalRowsCount := 0;
        if Parameters<>nil then begin // '?select=...&where=...' or '?where=...'
          SQLStartIndex := 0;
          SQLResults := 0;
          if Parameters^<>#0 then
          with Server.URIPagingParameters do begin
            NonStandardSQLSelectParameter := StrComp(Select,PAGINGPARAMETERS_YAHOO.Select)<>0;
            NonStandardSQLWhereParameter := StrComp(Where,PAGINGPARAMETERS_YAHOO.Where)<>0;
            repeat
              UrlDecodeValue(Parameters,Sort,SQLSort);
              UrlDecodeValue(Parameters,Dir,SQLDir);
              UrlDecodeInteger(Parameters,StartIndex,SQLStartIndex);
              UrlDecodeInteger(Parameters,Results,SQLResults);
              UrlDecodeValue(Parameters,Select,SQLSelect);
              if NonStandardSQLSelectParameter and (SQLSelect='') then
                UrlDecodeValue(Parameters,PAGINGPARAMETERS_YAHOO.Select,SQLSelect);
              if NonStandardSQLWhereParameter and (SQLWhere='') then
                UrlDecodeValue(Parameters,PAGINGPARAMETERS_YAHOO.Where,SQLWhere);
              UrlDecodeValue(Parameters,Server.URIPagingParameters.Where,SQLWhere,@Parameters);
            until Parameters=nil;
          end;
          // let SQLite3 do the sort and the paging (will be ignored by Static)
          if (SQLSort<>'') and
             not ContainsUTF8(pointer(SQLWhere),'ORDER BY') then begin
            if SameTextU(SQLDir,'DESC') then
              SQLSort := SQLSort+' DESC'; // allow DESC, default is ASC
            SQLWhere := SQLWhere+' ORDER BY '+SQLSort;
          end;
          SQLWhere := trim(SQLWhere);
          if (SQLResults<>0) and not ContainsUTF8(pointer(SQLWhere),'LIMIT ') then begin
            if (Server.URIPagingParameters.SendTotalRowsCountFmt<>nil) then begin
              ResultList := Server.ExecuteList([Table],
                Server.Model.TableProps[TableIndex].SQLFromSelectWhere('Count(*)',SQLWhere));
              if ResultList<>nil then begin
                SQLTotalRowsCount := ResultList.GetAsInteger(1,0);
                ResultList.Free;
              end;
            end;
            SQLWhere := FormatUTF8('% LIMIT % OFFSET %',[SQLWhere,SQLResults,SQLStartIndex]);
          end;
        end;
        SQL := Server.Model.TableProps[TableIndex].
          SQLFromSelectWhere(SQLSelect,trim(SQLWhere));
        Call.OutBody := Server.InternalListRawUTF8(TableIndex,SQL);
        if Call.OutBody<>'' then begin // got JSON list '[{...}]' ?
          Call.OutStatus := HTML_SUCCESS;  // 200 OK
          if Server.URIPagingParameters.SendTotalRowsCountFmt<>nil then
            if Server.NoAJAXJSON then begin
              P := pointer(Call.OutBody);
              L := length(Call.OutBody);
              P := NotExpandedBufferRowCountPos(P,P+L);
              j := 0;
              if P<>nil then
                j := P-pointer(Call.OutBody)-11 else
                 for i := 1 to 10 do
                   if Call.OutBody[L]='}' then begin
                     j := L;
                     break;
                   end else
                   dec(L);
              if j>0 then
                Insert(FormatUTF8(Server.URIPagingParameters.SendTotalRowsCountFmt,
                  [SQLTotalRowsCount]),Call.OutBody,j);
            end else begin// expanded format -> as {"values":[...],"total":n}
              if SQLTotalRowsCount=0 then // avoid sending fields array
                Call.OutBody := '[]' else
                Call.OutBody := trim(Call.OutBody);
              Call.OutBody := '{"values":'+Call.OutBody+
                FormatUTF8(Server.URIPagingParameters.SendTotalRowsCountFmt,[SQLTotalRowsCount])+'}';
            end;
        end;
      end;
    end;
  end;
  mUNLOCK: begin
    // ModelRoot/TableName/TableID to unlock a member
    if not (TableIndex in Call.RestAccessRights^.PUT) then
      Call.OutStatus := HTML_NOTALLOWED else
    if (Table<>nil) and (TableID>0) and
       Server.Model.UnLock(Table,TableID) then
      Call.OutStatus := HTML_SUCCESS; // 200 OK
  end;
  mSTATE: begin
    // STATE method for TSQLRestClientServerInternalState
    // this method is called with Root (-> Table=nil -> Static=nil)
    // we need a specialized method in order to avoid fStats.Invalid increase
    Call.OutStatus := HTML_SUCCESS;
    for i := 0 to high(Server.fStaticData) do
      if (Server.fStaticData[i]<>nil) and
         Server.fStaticData[i].InheritsFrom(TSQLRestStorage) then
        if TSQLRestStorage(Server.fStaticData[i]).RefreshedAndModified then begin
          inc(Server.InternalState); // force refresh
          break;
        end;
  end else
    raise EORMException.Create('Invalid status');
  end;
end;

procedure TSQLRestServerURIContext.ExecuteORMWrite;
var OK: boolean;
    Blob: PPropInfo;
    SQLSelect, SQLWhere, SQLSort, SQLDir: RawUTF8;
begin
  case Method of
  mPOST: begin       // POST=ADD=INSERT
    if Table=nil then begin
      // ModelRoot with free SQL statement sent as UTF-8 (only for Admin group)
      // security note: multiple SQL statements can be run in EngineExecuteAll()
      if (reSQL in Call.RestAccessRights^.AllowRemoteExecute) and
         Server.EngineExecuteAll(Call.InBody) then begin
        Call.OutStatus := HTML_SUCCESS; // 200 OK
        inc(Server.fStats.fModified);
      end;
    end else
    // here, Table<>nil and TableIndex in [0..MAX_SQLTABLES-1]
    if not (TableIndex in Call.RestAccessRights^.POST) then // check User
      Call.OutStatus := HTML_NOTALLOWED else
    if TableID<0 then begin
      // ModelRoot/TableName with possible JSON SentData: create a new member
      TableID := TableEngine.EngineAdd(TableIndex,Call.InBody);
      if TableID<>0 then begin
        Call.OutStatus := HTML_CREATED; // 201 Created
        Call.OutHead := 'Location: '+URI+'/'+
          {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(TableID);
        Server.fCache.Notify(TableIndex,TableID,Call.InBody,soInsert);
        inc(Server.fStats.fModified);
      end;
    end else
      Call.OutStatus := HTML_NOTALLOWED;
  end;
  mPUT: begin        // PUT=UPDATE
    if TableID>0 then begin
      // PUT ModelRoot/TableName/TableID[/BlobFieldName] to update member/BLOB content
      if not (TableIndex in Call.RestAccessRights^.PUT) then // check User
        Call.OutStatus := HTML_NOTALLOWED else
      if not Server.RecordCanBeUpdated(Table,TableID,seUpdate,@CustomErrorMsg) then
        Call.OutStatus := HTML_NOTMODIFIED else begin
        OK := false;
        if URIBlobFieldName<>'' then begin
          // PUT ModelRoot/TableName/TableID/BlobFieldName: update BLOB field content
          Blob := Table.RecordProps.BlobFieldPropFromRawUTF8(URIBlobFieldName);
          if Blob<>nil then
            OK := TableEngine.EngineUpdateBlob(TableIndex,TableID,Blob,Call.InBody);
        end else begin
          // ModelRoot/TableName/TableID with JSON SentData: update a member
          OK := TableEngine.EngineUpdate(TableIndex,TableID,Call.InBody);
          if OK then
            Server.fCache.NotifyDeletion(TableIndex,TableID); // flush (no CreateTime in JSON)
        end;
        if OK then begin
          Call.OutStatus := HTML_SUCCESS; // 200 OK
          inc(Server.fStats.fModified);
        end;
      end;
    end else
    if Parameters<>nil then // e.g. from TSQLRestClient.EngineUpdateField
      // PUT ModelRoot/TableName?setname=..&set=..&wherename=..&where=..
      if not (TableIndex in Call.RestAccessRights^.PUT) then // check User
        Call.OutStatus := HTML_NOTALLOWED else begin
        repeat
          UrlDecodeValue(Parameters,'SETNAME=',SQLSelect);
          UrlDecodeValue(Parameters,'SET=',SQLDir);
          UrlDecodeValue(Parameters,'WHERENAME=',SQLSort);
          UrlDecodeValue(Parameters,'WHERE=',SQLWhere,@Parameters);
        until Parameters=nil;
        if (SQLSelect<>'') and (SQLDir<>'') and (SQLSort<>'') and (SQLWhere<>'') then
          if TableEngine.EngineUpdateField(TableIndex,
               SQLSelect,SQLDir,SQLSort,SQLWhere) then begin
            Call.OutStatus := HTML_SUCCESS; // 200 OK
            inc(Server.fStats.fModified);
          end;
      end;
  end;
  mDELETE:
    if Table<>nil then
      if TableID>0 then
        // ModelRoot/TableName/TableID to delete a member
        if not (TableIndex in Call.RestAccessRights^.DELETE) then // check User
          Call.OutStatus := HTML_NOTALLOWED else
        if not Server.RecordCanBeUpdated(Table,TableID,seDelete,@CustomErrorMsg) then
          Call.OutStatus := HTML_NOTMODIFIED else begin
          if TableEngine.EngineDelete(TableIndex,TableID) and
             Server.AfterDeleteForceCoherency(Table,TableID) then begin
            Call.OutStatus := HTML_SUCCESS; // 200 OK
            Server.fCache.NotifyDeletion(TableIndex,TableID);
            inc(Server.fStats.fModified);
          end;
        end else
      if Parameters<>nil then
        if (not (TableIndex in Call.RestAccessRights^.DELETE)) or
           (not (reUrlEncodedDelete in Call.RestAccessRights^.AllowRemoteExecute)) then
          Call.OutStatus := HTML_NOTALLOWED else begin
          // ModelRoot/TableName?where=WhereClause to delete members
          repeat
            if UrlDecodeValue(Parameters,'WHERE=',SQLWhere,@Parameters) then begin
              SQLWhere := trim(SQLWhere);
              if SQLWhere<>'' then begin
                if Server.Delete(Table,SQLWhere) then begin
                  Call.OutStatus := HTML_SUCCESS; // 200 OK
                  inc(Server.fStats.fModified);
                end;
              end;
              break;
            end;
          until Parameters=nil;
        end;
  mBEGIN: begin      // BEGIN TRANSACTION
    // TSQLVirtualTableJSON/External will rely on SQLite3 module
    // and also TSQLRestStorageInMemory, since COMMIT/ROLLBACK have Static=nil
    // mBEGIN logic is just the opposite of mEND/mABORT: lock main, then static
    if Server.TransactionBegin(Table,Session) then begin
      if (Static<>nil) and (StaticKind=sVirtualTable) then
        Static.TransactionBegin(Table,Session) else
      if (Static=nil) and (Server.fTransactionTable<>nil) then begin
        Static := Server.StaticVirtualTable[Server.fTransactionTable];
        if Static<>nil then
          Static.TransactionBegin(Table,Session);
      end;
      Call.OutStatus := HTML_SUCCESS; // 200 OK
    end;
  end;
  mEND: begin        // END=COMMIT
    // this method is called with Root (-> Table=nil -> Static=nil)
    // mEND logic is just the opposite of mBEGIN: release static, then main
    if (Static<>nil) and (StaticKind=sVirtualTable) then
      Static.Commit(Session) else
    if (Static=nil) and (Server.fTransactionTable<>nil) then begin
      Static := Server.StaticVirtualTable[Server.fTransactionTable];
      if Static<>nil then
        Static.Commit(Session);
    end;
    Server.Commit(Session);
    Call.OutStatus := HTML_SUCCESS; // 200 OK
  end;
  mABORT: begin      // ABORT=ROLLBACK
    // this method is called with Root (-> Table=nil -> Static=nil)
    // mABORT logic is just the opposite of mBEGIN: release static, then main
    if (Static<>nil) and (StaticKind=sVirtualTable) then
      Static.RollBack(Session) else
    if (Static=nil) and (Server.fTransactionTable<>nil) then begin
      Static := Server.StaticVirtualTable[Server.fTransactionTable];
      if Static<>nil then
        Static.RollBack(Session);
    end;
    Server.RollBack(Session);
    Call.OutStatus := HTML_SUCCESS; // 200 OK
  end;
  end;
end;

procedure TSQLRestServerURIContext.FillInput;
var n,max: integer;
    P: PUTF8Char;
begin
  if fInput<>nil then
    exit; // only do it once
  P := Parameters;
  n := 0;
  max := 0;
  repeat
    if n>=max then begin
      inc(max,16);
      SetLength(fInput,max);
    end;
    P := UrlDecodeNextNameValue(P,fInput[n],fInput[n+1]);
    if P=nil then
      break;
    inc(n,2);
  until P^=#0;
  SetLength(fInput,n);
end;

function TSQLRestServerURIContext.GetInputInt(const ParamName: RawUTF8): Int64;
var err: integer;
begin
  result := GetInt64(pointer(GetInputUTF8(ParamName)),err);
  if err<>0 then
    raise EParsingException.CreateFmt('Invalid parameter %s as Int64 in URI',[ParamName]);
end;

function TSQLRestServerURIContext.GetInputDouble(const ParamName: RawUTF8): double;
var err: integer;
begin
  result := GetExtended(pointer(GetInputUTF8(ParamName)),err);
  if err<>0 then
    raise EParsingException.CreateFmt('Invalid parameter %s as Double in URI',[ParamName]);
end;

function TSQLRestServerURIContext.GetInputUTF8(const ParamName: RawUTF8): RawUTF8;
var i: integer;
begin
  if (fInput=nil) and (Parameters<>nil) then
    FillInput;
  for i := 0 to (length(fInput)shr 1)-1 do
    if IdemPropNameU(ParamName,fInput[i*2]) then begin
      result := fInput[i*2+1];
      exit;
    end;
  raise EParsingException.CreateFmt('Parameter %s not found in URI',[ParamName]);
end;

{$ifndef NOVARIANTS}
function TSQLRestServerURIContext.GetInput(const ParamName: RawUTF8): variant;
begin
  GetVariantFromJSON(pointer(GetInputUTF8(ParamName)),false,Result);
end;
{$endif}

procedure TSQLRestServerURIContext.Returns(const Result: RawUTF8;
  Status: integer; const CustomHeader: RawUTF8; Handle304NotModified: boolean);
var clientHash, serverHash: RawUTF8;
begin 
  if Status in [HTML_SUCCESS,HTML_CREATED] then begin
    Call.OutStatus := Status;
    Call.OutBody := Result;
    if CustomHeader<>'' then
      Call.OutHead := CustomHeader else
      if Call.OutHead='' then
        Call.OutHead := JSON_CONTENT_TYPE_HEADER;
    if Handle304NotModified and (Status=HTML_SUCCESS) and
       (Length(Result)>64) then begin
      clientHash := FindIniNameValue(pointer(Call.InHead),'IF-NONE-MATCH: ');
      serverHash := '"'+CardinalToHex(crc32c(0,pointer(Result),Length(Result)))+'"';
      if clientHash<>serverHash then
        Call.OutHead := Call.OutHead+#13#10'ETag: '+serverHash else begin
        Call.OutBody := ''; // save bandwidth for "304 Not Modified"
        Call.OutStatus := HTML_NOTMODIFIED;
      end;
    end;
  end else
    Error(Result,Status);
end;

procedure TSQLRestServerURIContext.ReturnFile(const FileName: TFileName;
  Handle304NotModified: boolean; const ContentType: RawUTF8);
var FileTime: TDateTime;
    clientHash, serverHash: RawUTF8;
begin
  FileTime := FileAgeToDateTime(FileName);
  if FileTime=0 then
    Error('',HTML_NOTFOUND) else begin
    if ContentType<>'' then
      Call.OutHead := HEADER_CONTENT_TYPE+ContentType else
      Call.OutHead := HEADER_CONTENT_TYPE+GetMimeContentType(nil,0,FileName);
    Call.OutStatus := HTML_SUCCESS;
    if Handle304NotModified then begin
      clientHash := FindIniNameValue(pointer(Call.InHead),'IF-NONE-MATCH: ');
      serverHash := '"'+DateTimeToIso8601(FileTime,false)+'"';
      if clientHash<>serverHash then
        Call.OutHead := Call.OutHead+#13#10'ETag: '+serverHash else begin
        Call.OutBody := ''; // save bandwidth for "304 Not Modified"
        Call.OutStatus := HTML_NOTMODIFIED;
        exit;
      end;
    end;
    // Content-Type: appears twice: 1st to notify static file, 2nd for mime type
    Call.OutHead := STATICFILE_CONTENT_TYPE_HEADER+#13#10+Call.OutHead;
    StringToUTF8(FileName,Call.OutBody);
  end;
end;

procedure TSQLRestServerURIContext.Returns(const NameValuePairs: array of const;
  Status: integer; Handle304NotModified: boolean);
begin
  Returns(JSONEncode(NameValuePairs),Status,'',Handle304NotModified);
end;

procedure TSQLRestServerURIContext.Results(const Values: array of const;
  Status: integer; Handle304NotModified: boolean);
var i,h: integer;
    result: RawUTF8;
begin
  h := high(Values);
  if h<0 then
    result := '{"result":null}' else
    with TTextWriter.CreateOwnedStream do
    try
      AddShort('{"result":');
      if h=0 then
        // result is one value
        AddJSONEscape(Values[0]) else begin
        // result is one array of values
        Add('[');
        i := 0;
        repeat
          AddJSONEscape(Values[i]);
          if i=h then break;
          Add(',');
          inc(i);
        until false;
        Add(']');
      end;
      Add('}');
      SetText(result);
    finally
      Free;
    end;
  Returns(result,Status,'',Handle304NotModified);
end;


procedure TSQLRestServerURIContext.Success(Status: integer);
begin
  if (Status in [HTML_SUCCESS,HTML_CREATED]) or (Status=HTML_NOTMODIFIED) then
    Call.OutStatus := Status else
    Error('',Status);
end;

procedure TSQLRestServerURIContext.Error(Format: PUTF8Char;
  const Args: array of const; Status: integer);
begin
  Error(FormatUTF8(Format,Args),Status);
end;

procedure TSQLRestServerURIContext.Error(const ErrorMessage: RawUTF8; Status: integer);
var ErrorMsg: RawUTF8;
begin
  Call.OutStatus := Status;
  if (Status in [HTML_SUCCESS,HTML_CREATED]) or (Status=HTML_NOTMODIFIED) then begin // not an error
    Call.OutBody := ErrorMessage;
    exit;
  end;
  if ErrorMessage='' then
    StatusCodeToErrorMsg(Status,ErrorMsg) else
    ErrorMsg := ErrorMessage;
  {$ifdef WITHLOG}
  Log.Log(sllServer,'% % ERROR=% (%)',[Call.Method,URIWithoutSignature,Call.OutStatus,ErrorMsg]);
  {$endif}
  with TTextWriter.CreateOwnedStream do
  try
    AddShort('{'#13#10'"ErrorCode":');
    Add(call.OutStatus);
    AddShort(','#13#10'"ErrorText":"');
    AddJSONEscape(pointer(ErrorMsg));
    AddShort('"'#13#10'}');
    SetText(Call.OutBody);
  finally
    Free;
  end;
end;


{ TSQLRestRoutingREST }

procedure TSQLRestRoutingREST.URIDecodeSOAByInterface;
var i: integer;
begin
  if (Table=nil) and (MethodIndex<0) and (URI<>'') and (Server.Services<>nil) then begin
    // check URI as '/Model/Interface.Method[/ClientDrivenID]'
    i := Server.Services.fListInterfaceMethods.FindHashed(URI);
    if i>=0 then // no specific message: it may be a valid request
      with Server.Services.fListInterfaceMethod[i] do begin
        Service := TServiceFactoryServer(InterfaceService);
        ServiceMethodIndex := InterfaceMethodIndex;
      end else
      if URIBlobFieldName<>'' then begin
        // check URI as '/Model/Interface/Method[/ClientDrivenID]''
        i := Server.Services.fList.IndexOf(URI);
        if i>=0 then begin // identified as a valid JSON-RPC service
          Service := TServiceFactoryServer(Server.Services.fList.Objects[i]);
          ServiceMethodIndex := Service.InterfaceFactory.FindMethodIndex(URIBlobFieldName);
          if ServiceMethodIndex<0 then
            Service := nil else begin
            inc(ServiceMethodIndex,length(SERVICE_PSEUDO_METHOD));
          end;
        end;
      end;
  end;
end;

procedure TSQLRestRoutingREST.ExecuteSOAByInterface;
var JSON: RawUTF8;
    Par: PUTF8Char;
    meth,a,i,i1: Integer;
    WR: TTextWriter;
    argDone: boolean;
begin // here Ctxt.Service and ServiceMethodIndex are set
  if (Server.Services=nil) or (Service=nil) then
    raise EServiceException.Create('Invalid call');
  //  URI as '/Model/Interface.Method[/ClientDrivenID]'
  if Call.InBody<>'' then
    // either parameters were sent as JSON array (the Delphi/AJAX way)
    ServiceParameters := pointer(Call.InBody) else begin
    // or parameters were URI-encoded (the HTML way)
    Par := Parameters;
    if Par<>nil then
      while Par^='+' do inc(Par); // ignore trailing spaces
    if IdemPChar(Par,'%5B') then
      // either as JSON array (input is e.g. '+%5B...' for ' [...')
      JSON := UrlDecode(Parameters) else begin
      // either as a list of parameters (input is 'Param1=Value1&Param2=Value2...')
      FillInput; // fInput[0]='Param1',fInput[1]='Value1',fInput[2]='Param2'...
      if fInput<>nil then begin
        meth := ServiceMethodIndex-length(SERVICE_PSEUDO_METHOD);
        if cardinal(meth)<Service.InterfaceFactory.MethodsCount then begin
          WR := TTextWriter.CreateOwnedStream;
          try // convert URI parameters into the expected ordered JSON array
            WR.Add('[');
            with Service.InterfaceFactory.fMethods[meth] do begin
              i1 := 0;
              for a := ArgsInFirst to ArgsInLast do
              with Args[a] do
              if ValueDirection<>smdOut then begin
                argDone := false;
                for i := i1 to high(fInput)shr 1 do // search argument in URI 
                  if IdemPropName(ParamName^,pointer(fInput[i*2]),length(fInput[i*2])) then begin
                    AddValueJSON(WR,fInput[i*2+1]); // will add "" if needed
                    if i=i1 then
                      inc(i1); // optimistic in-order search, but allow any order
                    argDone := true;
                    break;
                  end;
                if not argDone then
                  AddDefaultJSON(WR); // allow missing argument
              end;
            end;
            WR.CancelLastComma;
            WR.Add(']');
            WR.SetText(JSON);
          finally
            WR.Free;
          end;
        end;
      end;
    end;
    ServiceParameters := pointer(JSON);
  end;
  if TableID<0 then  
    ServiceInstanceID := 0 else
    ServiceInstanceID := TableID;
  // now Service, ServiceParameters, ServiceMethodIndex are set
  InternalExecuteSOAByInterface;
end;

class procedure TSQLRestRoutingREST.ClientSideInvoke(var uri: RawUTF8;
  const method, params, clientDrivenID: RawUTF8; out sent: RawUTF8);
begin
  if clientDrivenID<>'' then
    uri := uri+'.'+method+'/'+clientDrivenID else
    uri := uri+'.'+method;
  sent := '['+params+']'; // we may also encode them within the URI
end;


{ TSQLRestRoutingJSON_RPC }

procedure TSQLRestRoutingJSON_RPC.URIDecodeSOAByInterface;
var i: integer;
begin
  if (Table=nil) and (MethodIndex<0) and (URI<>'') and (Server.Services<>nil) then begin
    //  URI as '/Model/Interface'
    i := Server.Services.fList.IndexOf(URI);
    if i>=0 then // identified as a valid JSON-RPC service
      Service := TServiceFactoryServer(Server.Services.fList.Objects[i]);
  end; // ServiceMethodIndex will be retrieved from "method": in body
end;

procedure TSQLRestRoutingJSON_RPC.ExecuteSOAByInterface;
var method, JSON: RawUTF8;
    Values: TPUtf8CharDynArray;
    internal: TServiceInternalMethod;
begin // here Ctxt.Service is set (not ServiceMethodIndex yet)
  if (Server.Services=nil) or (Service=nil) then
    raise EServiceException.Create('Invalid call');
  JSON := Call.InBody; // in-place parsing -> private copy
  JSONDecode(JSON,['method','params','id'],Values,True);
  if Values[0]=nil then // Method name required
    exit;
  method := Values[0];
  ServiceParameters := Values[1];
  ServiceInstanceID := GetCardinal(Values[2]); // retrieve "id":ClientDrivenID 
  ServiceMethodIndex := Service.fInterface.FindMethodIndex(method);
  if ServiceMethodIndex>=0 then
    inc(ServiceMethodIndex,length(SERVICE_PSEUDO_METHOD)) else begin
    for internal := low(TServiceInternalMethod) to high(TServiceInternalMethod) do
      if IdemPropNameU(method,SERVICE_PSEUDO_METHOD[internal]) then begin
        ServiceMethodIndex := ord(internal);
        break;
      end;
    if ServiceMethodIndex<0 then begin
      Error('Unknown method');
      exit;
    end;
  end;
  // now Service, ServiceParameters, ServiceMethodIndex are set
  InternalExecuteSOAByInterface;
end;

class procedure TSQLRestRoutingJSON_RPC.ClientSideInvoke(var uri: RawUTF8;
  const method, params, clientDrivenID: RawUTF8; out sent: RawUTF8);
begin
  sent := '{"method":"'+method+'","params":['+params;
  if clientDrivenID='' then
    sent := sent+']}' else
    sent := sent+'],"id":'+clientDrivenID+'}';
end;


function TSQLRestServer.ServiceRegister(
  aImplementationClass: TInterfacedClass; const aInterfaces: array of PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation): TServiceFactoryServer;
begin
  result := nil;
  if (self=nil) or (aImplementationClass=nil) or (high(aInterfaces)<0) then
    exit;
  if fServices=nil then
    fServices := TServiceContainerServer.Create(self);
  result := (fServices as TServiceContainerServer).
    AddImplementation(aImplementationClass,aInterfaces,aInstanceCreation,nil);
end;

function TSQLRestServer.ServiceRegister(aSharedImplementation: TInterfacedObject;
  const aInterfaces: array of PTypeInfo): TServiceFactoryServer;
begin
  result := nil;
  if (self=nil) or (aSharedImplementation=nil) or (high(aInterfaces)<0) then
    exit;
  if fServices=nil then
    fServices := TServiceContainerServer.Create(self);
  result := (fServices as TServiceContainerServer).
    AddImplementation(TInterfacedClass(aSharedImplementation.ClassType),
      aInterfaces,sicShared,aSharedImplementation);
end;

function TSQLRestServer.ServiceRegister(aClient: TSQLRest; const aInterfaces: array of PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation=sicSingle;
  const aContractExpected: RawUTF8=''): boolean;
begin
  result := False;
  if (self=nil) or (high(aInterfaces)<0) or (aClient=nil) then
    exit;
  if fServices=nil then
    fServices := TServiceContainerServer.Create(self);
  result := (fServices as TServiceContainerServer).AddInterface(
    aInterfaces,aInstanceCreation,aContractExpected);
end;

procedure TSQLRestServer.URI(var Call: TSQLRestURIParams);
var Ctxt: TSQLRestServerURIContext;
{$ifdef WITHSTATPROCESS}
    timeStart,timeEnd: Int64;
begin
  QueryPerformanceCounter(timeStart);
{$else}
begin
{$endif}
  inc(fStats.fIncomingBytes,length(Call.url)+length(call.method)+length(call.InHead)+length(call.InBody)+12);
  Call.OutInternalState := InternalState; // other threads may change it
  Call.OutStatus := HTML_BADREQUEST; // default error code is 400 BAD REQUEST
  Ctxt := ServicesRouting.Create(self,Call);
  try
    {$ifdef WITHLOG}
    Ctxt.Log := SQLite3Log.Add;
    Ctxt.Log.Enter(Self,pointer(Ctxt.URIWithoutSignature),true);
    {$endif}
    if Ctxt.Method=mNone then
      Ctxt.Error('Unknown VERB') else
    // 1. decode URI
    if not Ctxt.URIDecodeREST then
      Ctxt.Error('Invalid Root',HTML_NOTFOUND) else begin
      Ctxt.URIDecodeSOAByMethod;
      if (Ctxt.MethodIndex<0) and (Ctxt.URI<>'') then
        Ctxt.URIDecodeSOAByInterface;
      // 2. handle security
      if (not Ctxt.Authenticate) or
         ((Ctxt.Service<>nil) and
           not (reService in Call.RestAccessRights^.AllowRemoteExecute)) then
        // 401 Unauthorized response MUST include a WWW-Authenticate header,
        // which is not what we used, so we won't send 401 error code but 403
        Call.OutStatus := HTML_FORBIDDEN else
      // 3. call appropriate ORM / SOA commands in fAcquireExecution[] context
      try
        if Ctxt.MethodIndex>=0 then
          Ctxt.Execute(execSOAByMethod) else
        if Ctxt.Service<>nil then
          Ctxt.Execute(execSOAByInterface) else
        if Ctxt.Method in [mLOCK,mGET,mUNLOCK,mSTATE] then
          // handle read methods
          Ctxt.Execute(execORMGet) else
          // write methods (mPOST, mPUT, mDELETE...) 
          Ctxt.Execute(execORMWrite);
      except
        on E: Exception do // return 500 internal server error
          Ctxt.Error('Exception %: %',[E,E.Message],HTML_SERVERERROR);
      end;
    end;
    // 4. returns expected result to the client and update Server statistics
    if (Call.OutStatus in [HTML_SUCCESS,HTML_CREATED]) or
       (Call.OutStatus=HTML_NOTMODIFIED) then begin
      inc(fStats.fResponses);
      {$ifdef WITHLOG}
      Ctxt.Log.Log(sllServer,'% % -> %',[Call.Method,Ctxt.URI,Call.OutStatus],self);
      {$endif}
    end else begin
      inc(fStats.fInvalid);
      if Call.OutBody='' then // if no custom error message, compute it now as JSON
        Ctxt.Error(Ctxt.CustomErrorMsg,Call.OutStatus);
    end;
    inc(fStats.fOutcomingBytes,length(Call.OutHead)+length(Call.OutBody)+16);
    if (Call.OutBody<>'') and
       (length(Call.OutHead)=Length(STATICFILE_CONTENT_TYPE_HEADER)) and
       (Call.OutHead[Length(HEADER_CONTENT_TYPE)+1]='!') and
       IdemPChar(pointer(Call.OutHead),STATICFILE_CONTENT_TYPE_HEADER) then
      inc(fStats.fOutcomingFiles);
    if (Ctxt.Static<>nil) and Ctxt.Static.InheritsFrom(TSQLRestStorage) and
       TSQLRestStorage(Ctxt.Static).fOutInternalStateForcedRefresh then
      // force always refresh for Static table which demands it
      Call.OutInternalState := cardinal(-1) else
      // database state may have changed above
      Call.OutInternalState := InternalState;
    {$ifdef WITHSTATPROCESS}
    QueryPerformanceCounter(timeEnd);
    inc(fStats.ProcessTimeCounter,timeEnd-timeStart);
    {$endif}
  finally
    Ctxt.Free;
  end;
end;

procedure TSQLRestServer.Stat(Ctxt: TSQLRestServerURIContext);
begin
  Ctxt.Returns(Stats.DebugMessage); // transmitted as JSON object
end;

procedure TSQLRestServer.TimeStamp(Ctxt: TSQLRestServerURIContext);
begin
  Ctxt.Returns(Int64ToUtf8(ServerTimeStamp),HTML_SUCCESS,TEXT_CONTENT_TYPE_HEADER);
end;

procedure TSQLRestServer.CacheFlush(Ctxt: TSQLRestServerURIContext);
begin
  if Ctxt.Table=nil then
    Cache.Flush else
    if Ctxt.TableID=0 then
      Cache.Flush(Ctxt.Table) else
      Cache.SetCache(Ctxt.Table,Ctxt.TableID);
  Ctxt.Success;
end;

procedure TSQLRestServer.Batch(Ctxt: TSQLRestServerURIContext);
var Results: TIntegerDynArray;
    i: integer;
begin 
  if Ctxt.Method<>mPUT then begin
    Ctxt.Error('PUT only');
    exit;
  end;
  try
    EngineBatchSend(Ctxt.Table,Ctxt.Call.InBody,Results);
  except
    on E: Exception do begin
      Ctxt.Error('Exception % "%" did break % BATCH process',
        [E,E.Message,Ctxt.Table]);
      exit;
    end;
  end;
  // send back operation status array
  Ctxt.Call.OutStatus := HTML_SUCCESS;
  for i := 0 to length(Results)-1 do
    if Results[i]<>HTML_SUCCESS then begin
      Ctxt.Call.OutBody := IntegerDynArrayToCSV(Results,length(Results),'[',']');
      exit;
    end;
  Ctxt.Call.OutBody := '["OK"]';  // to save bandwith if no adding
end;

function Nonce(Previous: boolean): RawUTF8;
var Tix64: cardinal;
begin
  Tix64 := GetTickCount64 div (1000*60*5); // valid for 5*60*1000 ms = 5 minutes
  if Previous then
    dec(Tix64);
  result := SHA256(@Tix64,sizeof(Tix64));
end;

procedure TSQLRestServer.SessionCreate(var User: TSQLAuthUser;
  Ctxt: TSQLRestServerURIContext; out Session: TAuthSession);
var i: integer;
begin
  Session := nil;
  if (reOneSessionPerUser in Ctxt.Call^.RestAccessRights^.AllowRemoteExecute) and
     (fSessions<>nil) then
    for i := 0 to fSessions.Count-1 do
      if TAuthSession(fSessions.List[i]).User.fID=User.fID then begin
        {$ifdef WITHLOG}
        with TAuthSession(fSessions.List[i]) do
          Ctxt.Log.Log(sllUserAuth,'User.LogonName=% already connected from "%/%"',
            [User.LogonName,RemoteIP,ConnectionID],self);
        {$endif}
        Ctxt.Call^.OutStatus := HTML_NOTALLOWED;
        exit; // user already connected -> error 404
      end;
  if fSessions=nil then
    fSessions := TObjectList.Create;
  Session := fSessionClass.Create(Ctxt,User);
  if Assigned(OnSessionCreate) then
    if OnSessionCreate(self,Session,Ctxt) then begin
      {$ifdef WITHLOG}
      Ctxt.Log.Log(sllUserAuth,'Session aborted by OnSessionCreate() callback for User.LogonName=% (connected from "%/%")',
        [User.LogonName,Session.RemoteIP,Session.ConnectionID],self);
      {$endif}
      User := nil;
      FreeAndNil(Session); // returning TRUE aborts the session creation
      exit;
    end;
  User := nil; // will be freed by TAuthSession.Destroy
  fSessions.Add(Session);
  fStats.ClientConnect;
end;

procedure TSQLRestServer.Auth(Ctxt: TSQLRestServerURIContext);
var i: integer;
begin
  if not UrlDecodeNeedParameters(Ctxt.Parameters,'UserName') then begin
    Ctxt.Error('Expect UserName parameter');
    exit;
  end;
  if fSessionAuthentication=nil then
    exit;
  EnterCriticalSection(fSessionCriticalSection);
  try
    for i := 0 to fSessionAuthentications.Count-1 do
      if fSessionAuthentication[i].Auth(Ctxt) then
        exit;
  finally
    LeaveCriticalSection(fSessionCriticalSection);
  end;
end;

procedure TSQLRestServer.SessionDelete(aSessionIndex: integer;
  Ctxt: TSQLRestServerURIContext);
begin
  if (self<>nil) and (cardinal(aSessionIndex)<cardinal(fSessions.Count)) then
  with TAuthSession(fSessions.List[aSessionIndex]) do begin
    if Services is TServiceContainerServer then
      TServiceContainerServer(Services).OnCloseSession(IDCardinal);
    {$ifdef WITHLOG}
    SQLite3Log.Family.SynLog.Log(sllUserAuth,'Deleted session %/% from %/%',
      [User.LogonName,IDCardinal,RemoteIP,ConnectionID],self);
    {$endif}
    if Assigned(OnSessionClosed) then
      OnSessionClosed(self,fSessions.List[aSessionIndex],Ctxt);
    fSessions.Delete(aSessionIndex);
    fStats.ClientDisconnect;
  end;
end;

function TSQLRestServer.SessionAccess(Ctxt: TSQLRestServerURIContext): TAuthSession;
var i: integer;
    Tix64: Int64;
begin // caller shall be locked via fSessionCriticalSection
  if (self<>nil) and (fSessions<>nil) then begin
    // first check for outdated sessions to be deleted
    Tix64 := GetTickCount64;
    for i := fSessions.Count-1 downto 0 do
      with TAuthSession(fSessions.List[i]) do
        if Tix64>LastAccess64+TimeOutMS then  
          SessionDelete(i,nil);
    // retrieve session
    for i := 0 to fSessions.Count-1 do begin
      result := TAuthSession(fSessions.List[i]);
      if result.IDCardinal=Ctxt.Session then begin
        result.fLastAccess64 := Tix64; // refresh session access timestamp
        Ctxt.SessionUser := result.User.fID;
        Ctxt.SessionGroup := result.User.GroupRights.fID;
        exit;
      end;
    end;
  end;
  result := nil;
end;

function TSQLRestServer.SessionGetUser(aSessionID: Cardinal): TSQLAuthUser;
var i: integer;
begin
  result := nil;
  if (self=nil) or (fSessions=nil) then
    exit;
  EnterCriticalSection(fSessionCriticalSection);
  try
    for i := 0 to fSessions.Count-1 do
      with TAuthSession(fSessions.List[i]) do
      if IDCardinal=aSessionID then begin
        if User<>nil then begin
          result := User.CreateCopy as fSQLAuthUserClass;
          result.GroupRights := nil;
        end;
        Break;  
      end;
  finally
    LeaveCriticalSection(fSessionCriticalSection);
  end;
end;

function TSQLRestServer.CacheWorthItForTable(aTableIndex: cardinal): boolean;
begin
  if self=nil then
    result := false else
    result := (aTableIndex>=cardinal(length(fStaticData))) or
      (not fStaticData[aTableIndex].InheritsFrom(TSQLRestStorageInMemory));
end;

procedure TSQLRestServer.BeginCurrentThread(Sender: TThread);
var i: integer;
    CurrentThreadId: cardinal;
begin
  InterlockedIncrement(fStats.fCurrentThreadCount);
  CurrentThreadId := GetCurrentThreadId;
  {$ifdef WITHLOG}
  SQLite3Log.Add.Log(sllTrace,'%.BeginCurrentThread(%) ThreadID=% ThreadCount=%',
    [self,Sender,CurrentThreadId,fStats.CurrentThreadCount]);
  {$endif}
  if Sender=nil then
    raise ECommunicationException.Create('BeginCurrentThread(nil)');
  if Sender.ThreadID<>CurrentThreadId then
    raise ECommunicationException.CreateFmt(
      'BeginCurrentThread(Thread.ID=%d) and CurrentThreadID=%d',[Sender.ThreadID,CurrentThreadId]);
  with PServiceRunningContext(@ServiceContext)^ do // P..(@..)^ for ONE GetTls()
    if RunningThread<>Sender then // e.g. if length(TSQLHttpServer.fDBServers)>1
      if RunningThread<>nil then
        raise ECommunicationException.Create('BeginCurrentThread() twice') else
        RunningThread := Sender;
  if fStaticVirtualTable<>nil then
    for i := 0 to high(fStaticVirtualTable) do
      if (fStaticVirtualTable[i]<>nil) and
         fStaticVirtualTable[i].InheritsFrom(TSQLRestStorage) then
        TSQLRestStorage(fStaticVirtualTable[i]).BeginCurrentThread(Sender);
end;

const
  INTERNALINSTANCERETRIEVE_FREEINSTANCE = -1;

procedure TSQLRestServer.EndCurrentThread(Sender: TThread);
var i: integer;
    CurrentThreadId: cardinal;
    Inst: TServiceFactoryServerInstance;
begin
  InterlockedDecrement(fStats.fCurrentThreadCount);
  CurrentThreadId := GetCurrentThreadId;
  {$ifdef WITHLOG}
  SQLite3Log.Add.Log(sllTrace,'%.EndCurrentThread(%) ThreadID=% ThreadCount=%',
    [self,Sender,CurrentThreadId,fStats.CurrentThreadCount]);
  {$endif}
  if Sender=nil then
    raise ECommunicationException.Create('EndCurrentThread(nil)');
  if Sender.ThreadID<>CurrentThreadId then
    raise ECommunicationException.CreateFmt(
      'EndCurrentThread(Thread.ID=%d) and CurrentThreadID=%d',[Sender.ThreadID,CurrentThreadId]);
 if fStaticVirtualTable<>nil then
   for i := 0 to high(fStaticVirtualTable) do
     if (fStaticVirtualTable[i]<>nil) and
        fStaticVirtualTable[i].InheritsFrom(TSQLRestStorage) then
       TSQLRestStorage(fStaticVirtualTable[i]).EndCurrentThread(Sender);
  if Services<>nil then begin
    Inst.InstanceID := GetCurrentThreadId;
    for i := 0 to Services.Count-1 do
      with TServiceFactoryServer(Services.fList.Objects[i]) do
      if InstanceCreation=sicPerThread then
        InternalInstanceRetrieve(Inst,INTERNALINSTANCERETRIEVE_FREEINSTANCE);
  end;
  with PServiceRunningContext(@ServiceContext)^ do // P..(@..)^ for ONE GetTls()
    if RunningThread<>nil then  // e.g. if length(TSQLHttpServer.fDBServers)>1
      if RunningThread<>Sender then
        raise ECommunicationException.Create('Unexpected EndCurrentThread()') else
        RunningThread := nil;
end;

{ TSQLRecordHistory }

function TSQLRecordHistory.ModifiedTableIndex: integer;
begin
  if self=nil then
    result := 0 else
    result := RecordRef(fModifiedRecord).TableIndex;
end;

function TSQLRecordHistory.ModifiedTable(Model: TSQLModel): TSQLRecordClass;
begin
  if (self=nil) or (Model=nil) then
    result := nil else
    result := RecordRef(fModifiedRecord).Table(Model);
end;

function TSQLRecordHistory.ModifiedID: PtrInt;
begin
  if self=nil then
    result := 0 else
    result := RecordRef(fModifiedRecord).ID;
end;

class procedure TSQLRecordHistory.InitializeTable(Server: TSQLRestServer;
  const FieldName: RawUTF8);
begin
  inherited InitializeTable(Server,FieldName);
  if FieldName='' then
    Server.CreateSQLMultiIndex(Self,['ModifiedRecord','History'],false);
end;

destructor TSQLRecordHistory.Destroy;
begin
  inherited;
  fHistoryAdd.Free;
end;

constructor TSQLRecordHistory.CreateHistory(aClient: TSQLRest;
  aTable: TSQLRecordClass; aID: integer);
var Reference: RecordRef;
    Rec: TSQLRecord;
    HistJson: TSQLRecordHistory;
begin
  if (aClient=nil) or (aID<=0) then
    raise EORMException.Create('Invalid CreateHistory() call');
  // read BLOB changes
  Reference.From(aClient.Model,aTable,aID);
  fModifiedRecord := Reference.Value;
  Create(aClient,'ModifiedRecord=? and History is not null',[],[fModifiedRecord]);
  if fID<>0 then
    aClient.RetrieveBlobFields(self); // load former fHistory field
  if not HistoryOpen(aClient.Model) then
    raise EORMException.CreateFmt('Invalid History for %s.ID=%d',
      [aTable.RecordProps.SQLTableName,aID]);
  // append JSON changes
  HistJson := RecordClass.CreateAndFillPrepare(aClient,
    'ModifiedRecord=? and History is null',[fModifiedRecord]) as TSQLRecordHistory;
  try
    if HistJson.FillTable.RowCount=0 then
      exit; // no JSON to append
    Rec := HistoryGetLast;
    try
      while HistJson.FillOne do begin
        Rec.FillFrom(pointer(HistJson.SentDataJSON));
        HistoryAdd(Rec,HistJson);
      end;
      HistorySave(nil); // update internal fHistory field
    finally
      Rec.Free;
    end;
  finally
    HistJson.Free;
  end;
  // prepare for HistoryCount and HistoryGet() from internal fHistory field
  HistoryOpen(aClient.Model);
end;

function TSQLRecordHistory.HistoryOpen(Model: TSQLModel): boolean;
var len: cardinal;
    start,i: integer;
    R: TFileBufferReader;
    tmp: RawByteString;
begin
  result := false;
  fHistoryModel := Model;
  fHistoryUncompressed := '';
  fHistoryTable := ModifiedTable(Model);
  fHistoryUncompressedCount := 0;
  fHistoryUncompressedOffset := nil;
  if fHistoryTable=nil then
    exit; // invalid Model or ModifiedRecord
  tmp := SynLZDecompress(fHistory);
  len := length(tmp);
  if len>4 then begin
    R.OpenFrom(pointer(tmp),len);
    if not fHistoryTable.RecordProps.CheckBinaryHeader(R) then
      exit; // invalid content: TSQLRecord layout may have changed
    R.ReadVarUInt32Array(fHistoryUncompressedOffset);
    fHistoryUncompressedCount := length(fHistoryUncompressedOffset);
    start := R.CurrentPosition;
    for i := 0 to fHistoryUncompressedCount-1 do
      inc(fHistoryUncompressedOffset[i],start);
    fHistoryUncompressed := tmp;
  end;
  result := true;
end;

function TSQLRecordHistory.HistoryCount: integer;
begin
  if (self=nil) or (fHistoryUncompressed='') then
    result := 0 else
    result := fHistoryUncompressedCount;
end;

function TSQLRecordHistory.HistoryGet(Index: integer;
  out Event: TSQLEvent; out TimeStamp: TModTime; Rec: TSQLRecord): boolean;
var P: PAnsiChar;
begin
  if cardinal(Index)>=cardinal(HistoryCount) then
    result := false else begin
    P := pointer(fHistoryUncompressed);
    inc(P,fHistoryUncompressedOffset[Index]);
    Event := TSQLEvent(P^); inc(P);
    TimeStamp := FromVarUInt64(PByte(P));
    if (Rec<>nil) and (Rec.RecordClass=fHistoryTable)  then begin
      if Event=seDelete then
        Rec.ClearProperties else
        Rec.SetBinaryValuesSimpleFields(P);
      Rec.fID := ModifiedID;
    end;
    result := true;
  end;
end;

function TSQLRecordHistory.HistoryGetLast(Rec: TSQLRecord): boolean;
var Event: TSQLEvent;
    TimeStamp: TModTime;
begin
  result := HistoryGet(fHistoryUncompressedCount-1,Event,TimeStamp,Rec);
end;

function TSQLRecordHistory.HistoryGetLast: TSQLRecord;
var Event: TSQLEvent;
    TimeStamp: TModTime;
begin
  if fHistoryTable=nil then
    result := nil else begin
    result := fHistoryTable.Create;
    HistoryGet(fHistoryUncompressedCount-1,Event,TimeStamp,result);
  end;
end;

procedure TSQLRecordHistory.HistoryAdd(Rec: TSQLRecord; Hist: TSQLRecordHistory);
begin
  if (self=nil) or (fHistoryModel=nil) or (Rec.RecordClass<>fHistoryTable) then
    exit;
  if fHistoryAdd=nil then
    fHistoryAdd := TFileBufferWriter.Create(TRawByteStringStream);
  AddInteger(fHistoryAddOffset,fHistoryAddCount,fHistoryAdd.TotalWritten);
  fHistoryAdd.Write1(Ord(Hist.Event));
  fHistoryAdd.WriteVarUInt64(Hist.TimeStamp);
  if Hist.Event<>seDelete then
    Rec.GetBinaryValuesSimpleFields(fHistoryAdd);
end;

function TSQLRecordHistory.HistorySave(Server: TSQLRestServer;
  LastRec: TSQLRecord): boolean;
var size,i,maxSize,TableHistoryIndex: integer;
    firstOldIndex,firstOldOffset, firstNewIndex,firstNewOffset: integer;
    newOffset: TIntegerDynArray;
    DBRec: TSQLRecord;
    HistTemp: TSQLRecordHistory;
    W: TFileBufferWriter;
begin
  result := false;
  if (self=nil) or (fHistoryTable=nil) or (fModifiedRecord=0) then
    exit; // wrong call
  try
    // ensure latest item matches "official" one, as read from DB
    if (Server<>nil) and (LastRec<>nil) and (LastRec.fID=ModifiedID) then begin
      DBRec := Server.Retrieve(ModifiedRecord);
      if DBRec<>nil then
      try // may be just deleted
        if not DBRec.SameRecord(LastRec) then begin
          HistTemp := RecordClass.Create as TSQLRecordHistory;
          try
            HistTemp.fEvent := seUpdate;
            HistTemp.fTimeStamp := Server.ServerTimeStamp;
            HistoryAdd(DBRec,HistTemp);
          finally
            HistTemp.Free;
          end;
        end;
      finally
        DBRec.Free;
      end;
    end;
    if fHistoryAdd=nil then
      exit; // nothing new
    // ensure resulting size matches specified criteria
    firstOldIndex := 0;
    TableHistoryIndex := 0;
    if Server=nil then
      maxSize := maxInt else begin
      TableHistoryIndex := Server.Model.GetTableIndexExisting(RecordClass);
      maxSize := Server.fTrackChangesHistory[TableHistoryIndex].MaxUncompressedBlobSize;
    end;
    size := fHistoryAdd.TotalWritten;
    if (size>maxSize) or (fHistoryUncompressedCount=0) then
      // e.g. if fHistory.Add() is already bigger than expected
      firstOldIndex := fHistoryUncompressedCount else begin
      inc(size,Length(fHistoryUncompressed)-fHistoryUncompressedOffset[0]);
      while (firstOldIndex<fHistoryUncompressedCount-1) and (size>maxSize) do begin
        dec(size,fHistoryUncompressedOffset[firstOldIndex+1]-fHistoryUncompressedOffset[firstOldIndex]);
        inc(firstOldIndex);
      end;
    end;
    // creates and store new History BLOB
    W := TFileBufferWriter.Create(TRawByteStringStream);
    try
      // compute offsets
      if firstOldIndex=fHistoryUncompressedCount then
        firstOldOffset := length(fHistoryUncompressed) else
        firstOldOffset := fHistoryUncompressedOffset[firstOldIndex];
      SetLength(newOffset,fHistoryUncompressedCount-firstOldIndex+fHistoryAddCount);
      for i := firstOldIndex to fHistoryUncompressedCount-1 do
        newOffset[i-firstOldIndex] := fHistoryUncompressedOffset[i]-firstOldOffset;
      firstNewIndex := fHistoryUncompressedCount-firstOldIndex;
      firstNewOffset := Length(fHistoryUncompressed)-firstOldOffset;
      for i := 0 to fHistoryAddCount-1 do
        newOffset[firstNewIndex+i] := fHistoryAddOffset[i]+firstNewOffset;
      // write header
      fHistoryTable.RecordProps.SaveBinaryHeader(W);
      W.WriteVarUInt32Array(newOffset,length(newOffset),wkOffsetU);
      // write data
      W.Write(@PByteArray(fHistoryUncompressed)[firstOldOffset],firstNewOffset);
      fHistoryAdd.Flush;
      W.WriteBinary((fHistoryAdd.Stream as TRawByteStringStream).DataString);
      W.Flush;
      fHistoryUncompressed := (W.Stream as TRawByteStringStream).DataString;
      fHistory := SynLZCompress(fHistoryUncompressed);
      if (Server<>nil) and (fID<>0) then begin
        Server.EngineUpdateField(TableHistoryIndex,
          'TimeStamp',Int64ToUTF8(Server.ServerTimeStamp),'RowID',UInt32ToUtf8(fID));
        Server.EngineUpdateBlob(TableHistoryIndex,fID,
          RecordProps.BlobFields[0].PropInfo,fHistory);
      end;
      result := true;
    finally
      W.Free;
    end;
  finally
    fHistoryUncompressed := '';
    fHistoryUncompressedOffset := nil;
    FreeAndNil(fHistoryAdd);
    fHistoryAddOffset := nil;
    fHistoryAddCount := 0;
  end;
end;


procedure TSQLRestServer.TrackChangesFlush(aTableHistory: TSQLRecordHistoryClass);
var HistBlob: TSQLRecordHistory;
    Rec: TSQLRecord;
    HistJson: TSQLRecordHistory;
    WhereClause, JSON: RawUTF8;
    HistID, ModifiedRecord: TIntegerDynArray;
    TableHistoryIndex,i,HistIDCount,n: integer;
    ModifRecord, ModifRecordCount, MaxRevisionJSON: integer;
begin
  {$ifdef WITHLOG}
  SQLite3Log.Enter;
  {$endif}
  EnterCriticalSection(fAcquireExecution[execORMWrite].Lock); // avoid race condition
  try // low-level Add(TSQLRecordHistory) without cache
    TableHistoryIndex := Model.GetTableIndexExisting(aTableHistory);
    MaxRevisionJSON := fTrackChangesHistory[TableHistoryIndex].MaxRevisionJSON;
    if MaxRevisionJSON<=0 then
      MaxRevisionJSON := 10;
    // we will compress into BLOB only when we got more than 10 revisions of a record
    with MultiFieldValues(aTableHistory,'RowID,ModifiedRecord','History is null') do
    try
      GetRowValues(fFieldIndexID,HistID);
      GetRowValues(FieldIndex('ModifiedRecord'),ModifiedRecord);
    finally
      Free;
    end;
    QuickSortInteger(pointer(ModifiedRecord),pointer(HistID),0,high(ModifiedRecord));
    ModifRecord := 0;
    ModifRecordCount := 0;
    n := 0;
    HistIDCount := 0;
    for i := 0 to high(ModifiedRecord) do begin
      if (ModifiedRecord[i]=0) or (HistID[i]=0) then
        raise EORMException.CreateFmt('Invalid TSQLRecordHistory.ID=%d',[HistID[i]]);
      if ModifiedRecord[i]<>ModifRecord then begin
        if ModifRecordCount>MaxRevisionJSON then
          HistIDCount := n else
          n := HistIDCount;
        ModifRecord := ModifiedRecord[i];
        ModifRecordCount := 1;
      end else
        inc(ModifRecordCount);
      HistID[n] := HistID[i];
      inc(n);
    end;
    if ModifRecordCount>MaxRevisionJSON then
      HistIDCount := n;
    if HistIDCount=0 then
      exit; // nothing to compress
    QuickSortInteger(Pointer(HistID),0,HistIDCount-1);
    WhereClause := IntegerDynArrayToCSV(HistID,HistIDCount,'RowID in (',')');
    { following SQL is much slower with external tables, and won't work
      with TSQLRestStorageInMemory -> manual process instead
    WhereClause := FormatUTF8('ModifiedRecord in (select ModifiedRecord from '+
        '(select ModifiedRecord, count(*) NumItems from % group by ModifiedRecord) '+
        'where NumItems>% order by ModifiedRecord) and History is null',
        [aTableHistory.SQLTableName,MaxRevisionJSON]); }
    Rec := nil;
    HistBlob := nil;
    HistJson := aTableHistory.CreateAndFillPrepare(self,WhereClause);
    try
      HistBlob := aTableHistory.Create;
      while HistJson.FillOne do begin
        if HistJson.ModifiedRecord<>HistBlob.ModifiedRecord then begin
          if HistBlob.ModifiedRecord<>0 then
            HistBlob.HistorySave(self,Rec);
          FreeAndNil(Rec);
          HistBlob.fHistory := '';
          HistBlob.fID := 0;
          if not Retrieve('ModifiedRecord=? and History is not null',[],
              [HistJson.ModifiedRecord],HistBlob) then
            HistBlob.fModifiedRecord := HistJson.ModifiedRecord else
            RetrieveBlobFields(HistBlob);
          if not HistBlob.HistoryOpen(Model) then begin
            InternalLog(FormatUTF8('Invalid %.History BLOB content for ID=%: % '+
              'layout may have changed -> flush any previous content',
              [HistBlob.RecordClass,HistBlob.fID,HistJson.ModifiedTable(Model)]),sllError);
            HistBlob.fID := 0;
          end;
          if HistBlob.fID<>0 then // allow changes appending to HistBlob
            Rec := HistBlob.HistoryGetLast else begin
            // HistBlob.fID=0 -> no previous BLOB content
            JSON := JSONEncode(['ModifiedRecord',HistJson.ModifiedRecord,
              'TimeStamp',ServerTimeStamp]);
            if HistJson.Event=seAdd then begin // allow versioning from scratch
              HistBlob.fID := EngineAdd(TableHistoryIndex,JSON);
              Rec := HistJson.ModifiedTable(Model).Create;
              HistBlob.HistoryOpen(Model);
            end else begin
              Rec := Retrieve(HistJson.ModifiedRecord);
              if Rec<>nil then begin // initialize BLOB with latest revision
                HistBlob.fID := EngineAdd(TableHistoryIndex,JSON);
                HistBlob.HistoryOpen(Model);
                HistBlob.HistoryAdd(Rec,HistJson);
                FreeAndNil(Rec); // ignore partial SentDataJSON for this record
              end;
            end;
          end;
        end;
        if (Rec=nil) or (HistBlob.fID=0) then
          continue; // only append modifications to BLOB if valid
        Rec.FillFrom(pointer(HistJson.SentDataJSON));
        HistBlob.HistoryAdd(Rec,HistJson);
      end;
      if HistBlob.ModifiedRecord<>0 then
        HistBlob.HistorySave(self,Rec);
      SetLength(HistID,HistIDCount);
      EngineDeleteWhere(TableHistoryIndex,WhereClause,HistID);
    finally
      HistJson.Free;
      HistBlob.Free;
      Rec.Free;
    end;
  finally
    LeaveCriticalSection(fAcquireExecution[execORMWrite].Lock); 
  end;
end;

function TSQLRestServer.InternalUpdateEvent(aEvent: TSQLEvent; aTableIndex, aID: integer;
  const aSentData: RawUTF8; aIsBlobFields: PSQLFieldBits): boolean;
procedure DoTrackChanges;
var TableHistoryIndex: integer;
    JSON: RawUTF8;
begin
  TableHistoryIndex := fTrackChangesHistoryTableIndex[aTableIndex];
  EnterCriticalSection(fAcquireExecution[execORMWrite].Lock); // avoid race condition
  try // low-level Add(TSQLRecordHistory) without cache
    JSON := JSONEncode(['ModifiedRecord',aTableIndex+aID shl 6,'Event',ord(aEvent),
                        'SentDataJSON',aSentData,'TimeStamp',ServerTimeStamp]);
    EngineAdd(TableHistoryIndex,JSON);
    if fTrackChangesHistory[TableHistoryIndex].CurrentRow>
        fTrackChangesHistory[TableHistoryIndex].MaxSentDataJsonRow then begin
      // gather & compress TSQLRecordHistory.SentDataJson into History BLOB
      TrackChangesFlush(TSQLRecordHistoryClass(Model.Tables[TableHistoryIndex]));
      fTrackChangesHistory[TableHistoryIndex].CurrentRow := 0;
    end else
      // fast append as JSON until reached MaxSentDataJsonRow
      inc(fTrackChangesHistory[TableHistoryIndex].CurrentRow);
  finally
    LeaveCriticalSection(fAcquireExecution[execORMWrite].Lock);
  end;
end;
begin
  if aIsBlobFields<>nil then
    // BLOB fields update
    if (aEvent=seUpdateBlob) and Assigned(OnBlobUpdateEvent) then
      result := OnBlobUpdateEvent(self,seUpdate,fModel.Tables[aTableIndex],aID,aIsBlobFields^) else
      result := true else begin
    // simple fields modification
    if (aTableIndex<length(fTrackChangesHistoryTableIndex)) and
       (fTrackChangesHistoryTableIndex[aTableIndex]>=0) then
      DoTrackChanges;
    if Assigned(OnUpdateEvent) then
      result := OnUpdateEvent(self,aEvent,fModel.Tables[aTableIndex],aID) else
      result := true; // true on success, false if error (but action continues)
  end;
end;

procedure TSQLRestServer.TrackChanges(const aTable: array of TSQLRecordClass;
  aTableHistory: TSQLRecordHistoryClass; aMaxHistoryRowBeforeBlob,
  aMaxHistoryRowPerRecord, aMaxUncompressedBlobSize: integer);
var t, tableIndex, TableHistoryIndex: integer;
begin
  if (self=nil) or (high(aTable)<0) then
    exit;
  if aMaxHistoryRowBeforeBlob<=0 then // disable change tracking
    TableHistoryIndex := -1 else begin
    if aTableHistory=nil then
      aTableHistory := TSQLRecordHistory;
    TableHistoryIndex := Model.GetTableIndexExisting(aTableHistory);
  end;
  for t := 0 to high(aTable) do begin
    tableIndex := Model.GetTableIndexExisting(aTable[t]);
    if aTable[t].InheritsFrom(TSQLRecordHistory) then
      raise EORMException.CreateFmt('TrackChanges([%s]) not allowed',[aTable[t].ClassName]);
    if tableIndex<length(fTrackChangesHistoryTableIndex) then begin
      fTrackChangesHistoryTableIndex[tableIndex] := TableHistoryIndex;
      if TableHistoryIndex>=0 then
        with fTrackChangesHistory[TableHistoryIndex] do begin
          if CurrentRow=0 then
            CurrentRow := TableRowCount(aTableHistory);
          MaxSentDataJsonRow := aMaxHistoryRowBeforeBlob;
          MaxRevisionJSON := aMaxHistoryRowPerRecord;
          MaxUncompressedBlobSize := aMaxUncompressedBlobSize;
        end;
    end;
  end;
end;

function TSQLRestServer.InternalUpdateEventNeeded(aTableIndex: integer): boolean;
begin
  result := (self<>nil) and (Assigned(OnUpdateEvent) or
    ((aTableIndex<length(fTrackChangesHistoryTableIndex)) and
     (fTrackChangesHistoryTableIndex[aTableIndex]>=0)));
end;

function TSQLRestServer.EngineAdd(TableModelIndex: integer; const SentData: RawUTF8): integer;
var Static: TSQLRest;
begin
  Static := GetStaticDataServerOrVirtualTable(TableModelIndex);
  if Static=nil then
    result := MainEngineAdd(TableModelIndex,SentData) else
    result := Static.EngineAdd(TableModelIndex,SentData);
end;

function TSQLRestServer.EngineRetrieve(TableModelIndex, ID: integer): RawUTF8;
var Static: TSQLRest;
begin
  Static := GetStaticDataServerOrVirtualTable(TableModelIndex);
  if Static=nil then
    result := MainEngineRetrieve(TableModelIndex,ID) else
    result := Static.EngineRetrieve(TableModelIndex,ID);
end;

function TSQLRestServer.EngineList(const SQL: RawUTF8; ForceAJAX: Boolean;
  ReturnedRowCount: PPtrInt): RawUTF8;
var Static: TSQLRest;
    StaticSQL: RawUTF8;
begin
  StaticSQL := SQL;
  Static := InternalAdaptSQL(Model.GetTableIndexFromSQLSelect(SQL,false),StaticSQL);
  if Static=nil then
    result := MainEngineList(SQL,ForceAJAX,ReturnedRowCount) else
    result := Static.EngineList(StaticSQL,ForceAJAX,ReturnedRowCount);
end;

function TSQLRestServer.EngineUpdate(TableModelIndex, ID: integer;
  const SentData: RawUTF8): boolean;
var Static: TSQLRest;
begin
  Static := GetStaticDataServerOrVirtualTable(TableModelIndex);
  if Static=nil then
    result := MainEngineUpdate(TableModelIndex,ID,SentData) else
    result := Static.EngineUpdate(TableModelIndex,ID,SentData);
end;

function TSQLRestServer.EngineDelete(TableModelIndex, ID: integer): boolean;
var Static: TSQLRest;
begin
  Static := GetStaticDataServerOrVirtualTable(TableModelIndex);
  if Static=nil then
    result := MainEngineDelete(TableModelIndex,ID) else
    result := Static.EngineDelete(TableModelIndex,ID);
end;

function TSQLRestServer.EngineDeleteWhere(TableModelIndex: integer;
  const SQLWhere: RawUTF8; const IDs: TIntegerDynArray): boolean;
var Static: TSQLRest;
begin
  Static := GetStaticDataServerOrVirtualTable(TableModelIndex);
  if Static=nil then
    result := MainEngineDeleteWhere(TableModelIndex,SQLWhere,IDs) else
    result := Static.EngineDeleteWhere(TableModelIndex,SQLWhere,IDs);
end;

function TSQLRestServer.EngineRetrieveBlob(TableModelIndex, aID: integer;
  BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean;
var Static: TSQLRest;
begin
  Static := GetStaticDataServerOrVirtualTable(TableModelIndex);
  if Static=nil then
    result := MainEngineRetrieveBlob(TableModelIndex,aID,BlobField,BlobData) else
    result := Static.EngineRetrieveBlob(TableModelIndex,aID,BlobField,BlobData);
end;

function TSQLRestServer.EngineUpdateBlob(TableModelIndex, aID: integer;
  BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean;
var Static: TSQLRest;
begin
  Static := GetStaticDataServerOrVirtualTable(TableModelIndex);
  if Static=nil then
    result := MainEngineUpdateBlob(TableModelIndex,aID,BlobField,BlobData) else
    result := Static.EngineUpdateBlob(TableModelIndex,aID,BlobField,BlobData);
end;

function TSQLRestServer.EngineUpdateField(TableModelIndex: integer;
  const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
var Static: TSQLRest;
begin
  Static := GetStaticDataServerOrVirtualTable(TableModelIndex);
  if Static=nil then
    result := MainEngineUpdateField(TableModelIndex,SetFieldName,SetValue,
      WhereFieldName,WhereValue) else
    result := Static.EngineUpdateField(TableModelIndex,SetFieldName,SetValue,
      WhereFieldName,WhereValue);
end;

type
  EORMBatchException = class(EORMException);

function TSQLRestServer.EngineBatchSend(Table: TSQLRecordClass;
  const Data: RawUTF8; var Results: TIntegerDynArray): integer;
var EndOfObject: AnsiChar;
    wasString, OK: boolean;
    TableName, Value, ErrMsg: RawUTF8;
    URIMethod, RunningBatchURIMethod: TSQLURIMethod;
    RunningBatchStatic: TSQLRest; { TODO: allow nested batch between tables? }
    Sent, Method, MethodTable: PUTF8Char;
    AutomaticTransactionPerRow, RowCountForCurrentTransaction: cardinal;
    ID, Count: integer;
    RunTable, PrevRunTable: TSQLRecordClass;
    RunTableIndex: integer;
    RunStatic: TSQLRest;
    RunStaticKind: TSQLRestServerKind;
begin
  Sent := pointer(Data);
  if (self=nil) or (Sent=nil) then
    raise EORMBatchException.Create('No data');
  if Table<>nil then begin
    // unserialize expected sequence array as '{"Table":["cmd":values,...]}'
    while not (Sent^ in ['{',#0]) do inc(Sent);
    if Sent^<>'{' then
      raise EORMBatchException.Create('Missing {');
    inc(Sent);
    TableName := GetJSONPropName(Sent);
    if (TableName='') or (Sent=nil) then 
      raise EORMBatchException.CreateFmt('Wrong "Table":"%s"',[TableName]);
  end; // or '["cmd@Table":values,...]'
  while not (Sent^ in ['[',#0]) do inc(Sent);
  if Sent^<>'[' then
    raise EORMBatchException.Create('Missing [');
  inc(Sent);
  if IdemPChar(Sent,AUTOMATICTRANSACTIONPERROW_PATTERN) then begin
    inc(Sent,Length(AUTOMATICTRANSACTIONPERROW_PATTERN));
    AutomaticTransactionPerRow := GetNextItemCardinal(Sent,',');
    if (AutomaticTransactionPerRow>0) and (TransactionActiveSession<>0) then begin
      InternalLog('Active Transaction -> ignore AutomaticTransactionPerRow',sllWarning);
      AutomaticTransactionPerRow := 0;
    end;
  end else
    AutomaticTransactionPerRow := 0;
  RowCountForCurrentTransaction := 0;
  PrevRunTable := nil;
  RunningBatchStatic := nil;
  RunningBatchURIMethod := mNone;
  Count := 0;
  try // to protect automatic transactions
  try // to protect InternalBatchStart/Stop locking
    repeat // main loop: process one POST/PUT/DELETE per iteration
      // retrieve method name and associated (static) table
      Method := GetJSONPropName(Sent);
      if (Sent=nil) or (Method=nil) then
        raise EORMBatchException.Create('Missing CMD');
      MethodTable := PosChar(Method,'@');
      if MethodTable=nil then begin // e.g. '{"Table":[...,"POST":{object},...]}'
        RunTableIndex := Model.GetTableIndexExisting(Table);
        RunTable := Table;
      end else begin                // e.g. '[...,"POST@Table":{object},...]'
        RunTableIndex := Model.GetTableIndex(MethodTable+1);
        if RunTableIndex<0 then
          raise EORMBatchException.Create('Unknown @Table');
        RunTable := Model.Tables[RunTableIndex];
      end;
      RunStatic := GetStaticDataServerOrVirtualTable(RunTableIndex,RunStaticKind);
      if Count>=length(Results) then
        SetLength(Results,Count+256+Count shr 3);
      Results[Count] := HTML_NOTMODIFIED;
      // get CRUD method (ignoring @ char if appended after method name)
      if IdemPChar(Method,'DELETE') then
        URIMethod := mDELETE else
      if IdemPChar(Method,'POST') then
        URIMethod := mPOST else
      if IdemPChar(Method,'PUT') then
        URIMethod := mPUT else
        URIMethod := mNone;
      // handle batch pending request sending (if table or method changed)
      if (RunningBatchStatic<>nil) and
         ((RunStatic<>RunningBatchStatic) or (RunningBatchURIMethod<>URIMethod)) then begin
        RunningBatchStatic.InternalBatchStop; // send pending statements
        RunningBatchStatic := nil;
      end;
      if (RunStatic<>nil) and (RunStatic<>RunningBatchStatic) and
         RunStatic.InternalBatchStart(URIMethod) then begin
        RunningBatchStatic := RunStatic;
        RunningBatchURIMethod := URIMethod;
      end;
      // handle auto-committed transaction process
      if AutomaticTransactionPerRow>0 then begin
        if PrevRunTable<>RunTable then begin // allow method change for same table
          if RowCountForCurrentTransaction>0 then begin
            Commit(CONST_AUTHENTICATION_NOT_USED); // table changed -> commit previous trans
            RowCountForCurrentTransaction := 0;
          end;
          PrevRunTable := RunTable;
        end;
        if RowCountForCurrentTransaction=AutomaticTransactionPerRow then begin
          Commit(CONST_AUTHENTICATION_NOT_USED);
          RowCountForCurrentTransaction := 0;
        end;
        if RowCountForCurrentTransaction>0 then
          inc(RowCountForCurrentTransaction) else
          if TransactionBegin(RunTable,CONST_AUTHENTICATION_NOT_USED) then
            inc(RowCountForCurrentTransaction) else begin
            InternalLog('TransactionBegin error -> AutomaticTransactionPerRow ignored',sllWarning);
            AutomaticTransactionPerRow := 0;
          end;
      end;
      // process CRUD method operation
      case URIMethod of
      mDELETE: begin // '{"Table":[...,"DELETE":ID,...]}' or '[...,"DELETE@Table":ID,...]'
        ID := GetInteger(GetJSONField(Sent,Sent,@wasString,@EndOfObject));
        if (ID<=0) or wasString then
          raise EORMBatchException.Create('Wrong DELETE');
        if not RecordCanBeUpdated(RunTable,ID,seDelete,@ErrMsg) then
          raise EORMBatchException.CreateFmt('DELETE impossible: %s',[ErrMsg]);
        OK := EngineDelete(RunTableIndex,ID);
        if OK then begin
          fCache.NotifyDeletion(RunTable,ID);
          if (RunningBatchStatic<>nil) or
             AfterDeleteForceCoherency(RunTable,ID) then
            Results[Count] := HTML_SUCCESS; // 200 OK
        end;
      end;
      mPOST: begin // '{"Table":[...,"POST":{object},...]}' or '[...,"POST@Table":{object},...]'
        Value := JSONGetObject(Sent,nil,EndOfObject);
        if Sent=nil then
          raise EORMBatchException.Create('Wrong POST');
        if not RecordCanBeUpdated(RunTable,0,seAdd,@ErrMsg)  then
          raise EORMBatchException.CreateFmt('POST impossible: %s',[ErrMsg]);
        ID := EngineAdd(RunTableIndex,Value);
        Results[Count] := ID;
        fCache.Notify(RunTable,ID,Value,soInsert);
      end;
      mPUT: begin // '{"Table":[...,"PUT":{object},...]}' or '[...,"PUT@Table":{object},...]'
        Value := JSONGetObject(Sent,@ID,EndOfObject);
        if (Sent=nil) or (Value='') then
          raise EORMBatchException.Create('Wrong PUT');
        OK := EngineUpdate(RunTableIndex,ID,Value);
        if OK then begin
          Results[Count] := HTML_SUCCESS; // 200 OK
          fCache.NotifyDeletion(RunTable,ID); // Value does not have CreateTime e.g.
          // or may be complete -> update won't work as expected -> delete from cache
        end;
      end;
      else raise EORMBatchException.CreateFmt('Unknown "%s" method',[Method]);
      end;
      inc(Count);
    until EndOfObject=']';
    if (AutomaticTransactionPerRow>0) and (RowCountForCurrentTransaction>0) then
      Commit(CONST_AUTHENTICATION_NOT_USED);
  finally
    if RunningBatchStatic<>nil then
      RunningBatchStatic.InternalBatchStop; // send pending statements
  end;
  except
    on Exception do begin
      if (AutomaticTransactionPerRow>0) and (RowCountForCurrentTransaction>0) then begin
        RollBack(CONST_AUTHENTICATION_NOT_USED);
        InternalLog('PARTIAL rollback of latest auto-commited transaction',sllWarning);
      end;
      raise;
    end;
  end;
  if Table<>nil then begin // '{"Table":["cmd":values,...]}' format
    if Sent=nil then
      raise EORMBatchException.Create('Truncated');
    while not (Sent^ in ['}',#0]) do inc(Sent);
    if Sent^<>'}' then
      raise EORMBatchException.Create('Missing }');
  end;
  // if we reach here, process was OK
  SetLength(Results,Count);
  result := HTML_SUCCESS;
end;

function CurrentServiceContext: TServiceRunningContext;
begin
  result := ServiceContext;
end;


{$ifdef MSWINDOWS}

{ TSQLRestClientURIDll }

constructor TSQLRestClientURIDll.Create(aModel: TSQLModel; const DllName: TFileName);
var aRequest: TURIMapRequest;
    aDLL: cardinal;
begin
  aDLL := LoadLibrary(pointer(DllName));
  if aDLL=0 then
    raise ECommunicationException.Create(DllName);
  aRequest := GetProcAddress(aDLL,'URIRequest');
  if (@aRequest=nil) or (aRequest(nil,nil,nil,nil,nil).Lo<>HTML_NOTFOUND) then begin
    FreeLibrary(aDLL);
    raise ECommunicationException.CreateFmt('%s doesn''t export a valid URIRequest function',[DllName]);
  end;
  Create(aModel,aRequest);
  fLibraryHandle := aDLL;
end;

constructor TSQLRestClientURIDll.Create(aModel: TSQLModel; aRequest: TURIMapRequest);
begin
  inherited Create(aModel);
  Func := aRequest;
end;

destructor TSQLRestClientURIDll.Destroy;
begin
  if fLibraryHandle<>0 then
    FreeLibrary(fLibraryHandle);
  inherited;
end;

procedure TSQLRestClientURIDll.InternalURI(var Call: TSQLRestURIParams);
var result: Int64Rec;
    pHead, pResp: PUTF8Char;
begin
  if @Func=nil then begin
    Call.OutStatus := HTML_NOTIMPLEMENTED; // 501 (no valid application or library)
    exit;
  end;
  pResp := nil;
  pHead := nil;
  try
    result := Func(pointer(Call.Url),pointer(Call.Method),pointer(Call.InBody),
      @pResp,@pHead);
    Call.OutStatus := result.Lo;
    Call.OutInternalState := result.Hi;
    if pHead<>nil then
      Call.OutHead := pHead;
    if pResp<>nil then
      Call.OutBody := pResp;
  finally // always release response memory allocated by the server
    if pResp<>nil then
      if USEFASTMM4ALLOC then
        Freemem(pResp) else
        GlobalFree(PtrUInt(pResp));
    if pHead<>nil then
      if USEFASTMM4ALLOC then
        Freemem(pHead) else
        GlobalFree(PtrUInt(pHead));
  end;
end;

function TSQLRestClientURIDll.InternalCheckOpen: boolean;
begin
  result := true; // success
end;

procedure TSQLRestClientURIDll.InternalClose;
begin
end;

{$endif MSWINDOWS}


{$ifdef MSWINDOWS}

{$ifdef ANONYMOUSNAMEDPIPE}

// it should be necessary to Edit settings under Local Security Policy -> Local
// policies -> Security options -> Edit settings under "Network access" to allow
// for anonymous connections.

// BUT even with the pipe name added to the
//  SYSTEM\CurrentControlSet\Services\lanmanserver\parameters\NullSessionPipes
// registry key, code below didn't work

function GetUserSid(var SID: PSID; var Token: THandle): boolean;
var TokenUserSize: DWORD;
    TokenUserP: PSIDAndAttributes;
begin
  result := false;
  if not OpenThreadToken(GetCurrentThread, TOKEN_QUERY, True, Token) then
    if (GetLastError <> ERROR_NO_TOKEN) or
       not OpenProcessToken(GetCurrentProcess, TOKEN_QUERY, Token) then
      Exit;
  TokenUserP := nil;
  TokenUserSize := 0;
  try
    if not GetTokenInformation(Token, TokenUser, nil, 0, TokenUserSize) and
       (GetLastError <> ERROR_INSUFFICIENT_BUFFER) then
      Exit;
    TokenUserP := AllocMem(TokenUserSize);
    if not GetTokenInformation(Token, TokenUser, TokenUserP,
       TokenUserSize, TokenUserSize) then
      Exit;
    SID := TokenUserP^.Sid;
    result := true;
  finally
    FreeMem(TokenUserP);
  end;
end;

{$ALIGN ON}
type
    ACE_HEADER = record
      AceType: BYTE;
      AceFlags: BYTE;
      AceSize: WORD;
    end;
    ACCESS_ALLOWED_ACE = record
      Header: ACE_HEADER;
      Mask: ACCESS_MASK;
      SidStart: DWORD;
    end;
{$A8}

procedure InitializeSecurity(var SA: TSecurityAttributes; var SD);
const
  SECURITY_NT_AUTHORITY: TSIDIdentifierAuthority = (Value: (0, 0, 0, 0, 0, 5));
  SECURITY_ANONYMOUS_LOGON_RID = ($00000007);
  ACL_REVISION = 2;
var pSidAnonymous, pSidOwner: PSID;
    dwAclSize: integer;
    ACLP: PACL;
    Token: THandle;
begin
  fillchar(SD,SECURITY_DESCRIPTOR_MIN_LENGTH,0);
  // Initialize the new security descriptor
  if InitializeSecurityDescriptor(@SD, SECURITY_DESCRIPTOR_REVISION) and
      GetUserSid(pSidOwner,Token) then begin
    AllocateAndInitializeSid(SECURITY_NT_AUTHORITY,1,
      SECURITY_ANONYMOUS_LOGON_RID,0,0,0,0,0,0,0,pSidAnonymous);
    try
      dwAclSize := sizeof(TACL) +
        2 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(pSidAnonymous) + GetLengthSid(pSidOwner) ;
      ACLP := AllocMem(dwAclSize);
      try
        InitializeAcl(ACLP^,dwAclSize,ACL_REVISION);
        if not AddAccessAllowedAce(ACLP^,ACL_REVISION,
           GENERIC_ALL,pSidOwner) then
          exit;
        if not AddAccessAllowedAce(ACLP^,ACL_REVISION,
           GENERIC_READ or GENERIC_WRITE,pSidAnonymous) then
          exit;
        if SetSecurityDescriptorDacl(@SD,true,ACLP,false) then begin
           // Set up the security attributes structure
           SA.nLength := sizeof(TSecurityAttributes);
           SA.lpSecurityDescriptor := @SD;
           SA.bInheritHandle := true;
           exit; // mark OK
        end;
      finally
        FreeMem(ACLP);
      end;
    finally
      FreeSid(pSidAnonymous);
      CloseHandle(Token);
    end;
  end;
  fillchar(SA,sizeof(SA),0); // mark error: no security
end;

{$else}

{$ifndef NOSECURITYFORNAMEDPIPECLIENTS}

{$if CompilerVersion >= 22.0} // fix Delphi XE incompatilibility
function InitializeSecurityDescriptor(pSecurityDescriptor: PSecurityDescriptor;
  dwRevision: DWORD): BOOL; stdcall; external advapi32;
function SetSecurityDescriptorDacl(pSecurityDescriptor: PSecurityDescriptor;
  bDaclPresent: BOOL; pDacl: PACL; bDaclDefaulted: BOOL): BOOL; stdcall; external advapi32;
{$ifend}

procedure InitializeSecurity(var SA: TSecurityAttributes; var SD);
begin
  fillchar(SD,SECURITY_DESCRIPTOR_MIN_LENGTH,0);
  // Initialize the new security descriptor
  if InitializeSecurityDescriptor(@SD, SECURITY_DESCRIPTOR_REVISION) then begin
     // Add a NULL descriptor ACL to the security descriptor
     if SetSecurityDescriptorDacl(@SD, true, nil, false) then begin
        // Set up the security attributes structure
        SA.nLength := sizeof(TSecurityAttributes);
        SA.lpSecurityDescriptor := @SD;
        SA.bInheritHandle := true;
        exit; // mark OK
     end;
  end;
  fillchar(SA,sizeof(SA),0); // mark error: no security
end;

{$endif NOSECURITYFORNAMEDPIPECLIENTS}

{$endif ANONYMOUSNAMEDPIPE}


{ TSQLRestServerNamedPipe }

constructor TSQLRestServerNamedPipe.Create(aServer: TSQLRestServer;
  const PipeName: TFileName);
begin
  inherited Create(false);
  fServer := aServer;
  fPipeName := PipeName;
  fChild := TList.Create;
//  writeln('TSQLRestServerNamedPipe ',PipeName,' ThreadID=',ThreadID);
end;

destructor TSQLRestServerNamedPipe.Destroy;
var i: integer;
begin
  //writeln('TSQLRestServerNamedPipe.Destroy');
  for i := 0 to fChild.Count-1 do // close any still opened pipe
    if fChild[i]<>nil then begin
      {writeln('fChildCount=',fChildCount,' TSQLRestServerNamedPipeResponse=',
        integer(TSQLRestServerNamedPipeResponse),'.Terminated=',
        BoolToStr(TSQLRestServerNamedPipeResponse(fChild[i]).Terminated,true));}
      TSQLRestServerNamedPipeResponse(fChild[i]).Terminate;
    end;
  while fChildCount>0 do
    Sleep(64); // wait for all TSQLRestServerNamedPipeResponse.Destroy
  fChild.Free;
  inherited;
end;

procedure TSQLRestServerNamedPipe.Execute;
var aPipe: cardinal;
    Available: cardinal;
    {$ifndef NOSECURITYFORNAMEDPIPECLIENTS}
    fPipeSecurityAttributes: TSecurityAttributes;
    fPipeSecurityDescriptor: array[0..SECURITY_DESCRIPTOR_MIN_LENGTH] of byte;
    {$endif}
begin // see http://msdn.microsoft.com/en-us/library/aa365588(v=VS.85).aspx
  //writeln('TSQLRestServerNamedPipe=',integer(TSQLRestServerNamedPipe),'.Execute');
  {$ifndef NOSECURITYFORNAMEDPIPECLIENTS}
  InitializeSecurity(fPipeSecurityAttributes,fPipeSecurityDescriptor);
  {$endif}
  while not Terminated do begin
    //writeln('TSQLRestServerNamedPipe.CreateNamedPipe(',fPipeName,')');
    aPipe := CreateNamedPipe(pointer(fPipeName),
      PIPE_ACCESS_DUPLEX,
      PIPE_TYPE_BYTE or PIPE_READMODE_BYTE or PIPE_WAIT,
      PIPE_UNLIMITED_INSTANCES, 0, 0, 0,
      {$ifdef NOSECURITYFORNAMEDPIPECLIENTS}nil{$else}@fPipeSecurityAttributes{$endif});
    if aPipe=INVALID_HANDLE_VALUE then
      break;
    while not Terminated do
      if PeekNamedPipe(aPipe,nil,0,nil,@Available,nil) then
        if (Available>=4) then begin
          // PeekNamedPipe() made an implicit ConnectNamedPipe(aPipe,nil)
          InterlockedIncrement(fChildCount);
          TSQLRestServerNamedPipeResponse.Create(fServer,self,aPipe);
          aPipe := 0; // aPipe will be closed in TSQLRestServerNamedPipeResponse
          break;
        end
        else break // invalid request
      else Sleep(128); // doesn't slow down connection but decreases CSwitch
    if aPipe<>0 then begin
      DisconnectNamedPipe(aPipe);
      CloseHandle(aPipe);
    end;
  end;
end;


{ TSQLRestServerNamedPipeResponse }

constructor TSQLRestServerNamedPipeResponse.Create(aServer: TSQLRestServer;
  aMasterThread: TSQLRestServerNamedPipe; aPipe: cardinal);
begin
  inherited Create(false);
  fServer := aServer;
  fMasterThread := aMasterThread;
  with fMasterThread.fChild do begin
    fMasterThreadChildIndex := IndexOf(nil); // get free position in fChild[]
    if fMasterThreadChildIndex<0 then
      fMasterThreadChildIndex := Add(self) else
      Items[fMasterThreadChildIndex] := self;
  end;
  fPipe := aPipe;
  FreeOnTerminate := true;
{$ifdef LVCL}
  FOnTerminate := fServer.EndCurrentThread;
{$endif}
end;

{$ifndef LVCL}
procedure TSQLRestServerNamedPipeResponse.DoTerminate;
begin
  fServer.EndCurrentThread(self); // will release any thread-specific resource
end;
{$endif}

destructor TSQLRestServerNamedPipeResponse.Destroy;
begin
  if fMasterThread<>nil then
    with fMasterThread do begin
      fChild[fMasterThreadChildIndex] := nil;
      InterlockedDecrement(fChildCount);
    end;
  inherited;
end;

procedure TSQLRestServerNamedPipeResponse.Execute;
var call: TSQLRestURIParams;
    Code: integer;
    Ticks64, Sleeper64, ClientTimeOut64: Int64;
    Header: RawUTF8;
    Available: cardinal;
begin
  if (fPipe=0) or (fPipe=INVALID_HANDLE_VALUE) or (fServer=nil) then
    exit;
  Header := 'RemoteIP: 127.0.0.1'#13#10'ConnectionID: '+CardinalToHex(fPipe); 
  fServer.BeginCurrentThread(self);
  Ticks64 := 0;
  Sleeper64 := 0;
  ClientTimeOut64 := GetTickCount64+30*60*1000; // disconnect after 30 min of inactivity
  try
    while not Terminated do
    if // (WaitForSingleObject(fPipe,200)=WAIT_OBJECT_0) and  = don't wait
       PeekNamedPipe(fPipe,nil,0,nil,@Available,nil) and (Available>=4) then begin
      FileRead(fPipe,Code,4);
      if (Code=integer(MAGIC_SYN)) // magic word for URI like request
        and not Terminated then
        try
          call.Url := ReadString(fPipe);
          call.Method := ReadString(fPipe);
          call.InHead := ReadString(fPipe);
          if call.InHead='' then
            call.InHead := Header else
            call.InHead := call.InHead+#13#10+Header;
          call.InBody := ReadString(fPipe);
          call.RestAccessRights := @SUPERVISOR_ACCESS_RIGHTS;
          call.OutHead := ''; // may not be reset explicitly by fServer.URI()
          call.OutBody := '';
          // it's up to URI overridden method to implement access rights
          fServer.URI(call);
          FileWrite(fPipe,call.OutStatus,sizeof(cardinal)*2);
          WriteString(fPipe,call.OutHead);
          WriteString(fPipe,call.OutBody);
          FlushFileBuffers(fPipe); // Flush the pipe to allow the client to read
          Ticks64 := GetTickCount64+20; // start sleeping after 20 ms
          ClientTimeOut64 := Ticks64+30*60*1000;
          Sleeper64 := 0;
          Sleep(0);
        except
          on Exception do // error in ReadString() or fServer.URI()
            break; // disconnect client
        end else
          break; // invalid magic word: disconnect client
    end else
    if (Ticks64=0) or (GetTickCount64>Ticks64) then begin
      if Sleeper64<128 then
        inc(Sleeper64,16);
      Sleep(Sleeper64); // doesn't slow down connection but decreases CSwitch
      Ticks64 := 0;
      if GetTickCount64>ClientTimeOut64 then
        break; // disconnect client after 30 min of inactivity
    end else
      Sleep(0);
  finally
    DisconnectNamedPipe(fPipe);
    CloseHandle(fPipe);
  end;
end;


{ TSQLRestClientURINamedPipe }

function ImpersonateAnonymousToken(ThreadHandle: THANDLE): BOOL; stdcall; external advapi32;

constructor TSQLRestClientURINamedPipe.Create(aModel: TSQLModel;
  const ApplicationName: TFileName);
begin
  inherited Create(aModel);
  if {$ifdef UNICODE}IdemPCharW{$else}IdemPChar{$endif}(pointer(ApplicationName),'\\') then
    fPipeName := ApplicationName else // caller specified a full path
    fPipeName := ServerPipeNamePrefix+ApplicationName;
end;

function TSQLRestClientURINamedPipe.InternalCheckOpen: boolean;
procedure InternalCreateClientPipe;
var Pipe: THandle;
    StartTime64: Int64;
{$ifdef WITHLOG}
    Log: ISynLog;
{$endif}
procedure CreatePipe;
begin
  Pipe := CreateFile(pointer(fPipeName), GENERIC_READ or GENERIC_WRITE,
{$ifdef ANONYMOUSNAMEDPIPE}
    FILE_SHARE_READ or FILE_SHARE_WRITE,
    nil, OPEN_EXISTING, SECURITY_SQOS_PRESENT or SECURITY_ANONYMOUS, 0);
{$else}
    0, {$ifdef NOSECURITYFORNAMEDPIPECLIENTS}nil{$else}@fPipeSecurityAttributes{$endif},
    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL or FILE_FLAG_OVERLAPPED, 0);
{$endif}
end;
begin
{$ifdef WITHLOG}
  Log := SQLite3Log.Enter;
{$endif}
{$ifdef ANONYMOUSNAMEDPIPE}
  if not ImpersonateAnonymousToken(GetCurrentThread) then
     raise Exception.Create('ImpersonateAnonymousToken');
  try
{$else}
  {$ifndef NOSECURITYFORNAMEDPIPECLIENTS}
  InitializeSecurity(fPipeSecurityAttributes,fPipeSecurityDescriptor);
  {$endif}
{$endif}
  StartTime64 := GetTickCount64;
  CreatePipe;
  while (Pipe=INVALID_HANDLE_VALUE) and (GetLastError=ERROR_FILE_NOT_FOUND) do begin
    sleep(10); // wait for TSQLRestServerNamedPipe.EngineExecute to be reached
    CreatePipe;
    if (Pipe<>INVALID_HANDLE_VALUE) or (GetTickCount64>StartTime64+500) then
      break;
  end;
  StartTime64 := GetTickCount64;
  if (Pipe=INVALID_HANDLE_VALUE) and (GetLastError=ERROR_PIPE_BUSY) then
    {$ifdef WITHLOG}
    Log.Log(sllDebug,'Busy % -> retry',[fPipeName],self);
    {$endif}
    repeat
      sleep(10);
      if WaitNamedPipe(pointer(fPipeName),50) then begin
        CreatePipe;
        if GetLastError<>ERROR_PIPE_BUSY then
          break;
      end;
    until GetTickCount64>StartTime64+2000;
  if Pipe=INVALID_HANDLE_VALUE then begin
    {$ifdef WITHLOG}
    Log.Log(sllLastError,'when connecting to % after % ms',
      [fPipeName,GetTickCount64-StartTime64],self);
    {$endif}
    exit;
  end;
{$ifdef ANONYMOUSNAMEDPIPE}
  finally
    RevertToSelf; // we just needed to be anonymous during pipe connection
  end;
{$endif}
  {$ifdef WITHLOG}
  Log.Log(sllDebug,'Connected to %',[fPipeName],self);
  {$endif}
  fServerPipe := Pipe;
end;
begin
  if fServerPipe<>0 then begin
    result := true;
    exit; // only reconnect if forced by InternalClose call or at first access
  end;
  InternalCreateClientPipe; // local sub-procedure to reduce stack overhead 
  result := fServerPipe<>0;
end;

procedure TSQLRestClientURINamedPipe.InternalClose;
begin
  if fServerPipe<>0 then begin   // inherited; may use pipe -> close after
    WriteString(fServerPipe,''); // send integer=0 -> force server disconnect
    FileClose(fServerPipe);
  end;
end;

procedure TSQLRestClientURINamedPipe.InternalURI(var Call: TSQLRestURIParams);
var Card: cardinal;
{.$define TSQLRestClientURIDll_TIMEOUT} // to be tried over slow networks if errors
{$ifdef TSQLRestClientURIDll_TIMEOUT}
    i: integer;
{$endif}
{$ifdef WITHLOG}
    Log: ISynLog;
{$endif}
begin
{$ifdef WITHLOG}
  Log := SQLite3Log.Enter(self,nil,true);
{$endif}
  Call.OutStatus := HTML_NOTIMPLEMENTED; // 501 (no valid application or library)
  EnterCriticalSection(fMutex);
  try
    if InternalCheckOpen then
    try
      Card := MAGIC_SYN; // magic word
      if FileWrite(fServerPipe,Card,4)<>4 then begin
        Sleep(0); 
        WaitNamedPipe(pointer(fPipeName),200);
        if FileWrite(fServerPipe,Card,4)<>4 then begin // pipe may be broken
          Sleep(10); 
          FileClose(fServerPipe);
          fServerPipe := 0;
          if not InternalCheckOpen then // recreate connection
            exit;
          if (fServerPipe=Invalid_Handle_Value) or
             (FileWrite(fServerPipe,Card,4)<>4) then begin
            Card := GetLastError;
            {$ifdef WITHLOG}
            Log.Log(sllLastError,'reconnecting to %',[fPipeName],self);
            {$endif}
            if fServerPipe<>Invalid_Handle_Value then
              FileClose(fServerPipe);
            fServerPipe := 0;
            exit; // no existing pipe
          end;
        end;
      end;
      // send the request
      WriteString(fServerPipe,Call.Url);
      WriteString(fServerPipe,Call.Method);
      WriteString(fServerPipe,Call.InHead);
      WriteString(fServerPipe,Call.InBody);
      FlushFileBuffers(fServerPipe);
      // receive the answer
{$ifdef TSQLRestClientURIDll_TIMEOUT}
      for i := 0 to 25 do // wait up to 325 ms
        if PeekNamedPipe(fServerPipe,nil,0,nil,@Card,nil) and
           (Card>=sizeof(Int64)) then begin
          FileRead(fServerPipe,Call.OutStatus,sizeof(Int64));
          Call.OutHead := ReadString(fServerPipe);
          Call.OutBody := ReadString(fServerPipe);
          exit;
        end else
        Sleep(i);
      Call.OutStatus := HTML_TIMEOUT; // 408 Request Timeout Error
{$else}
      if FileRead(fServerPipe,Call.OutStatus,sizeof(Int64))=sizeof(Int64) then begin
        // FileRead() waits till response arrived
        Call.OutHead := ReadString(fServerPipe);
        Call.OutBody := ReadString(fServerPipe);
      end else
        Call.OutStatus := HTML_NOTFOUND;
{$endif}
     except
       on E: Exception do begin // error in ReadString()
         {$ifdef WITHLOG}
         Log.Log(sllLastError,'% for PipeName=%',[E,fPipeName],self);
         {$endif}
         Call.OutStatus := HTML_NOTIMPLEMENTED; // 501 (no valid application or library)
         WriteString(fServerPipe,''); // try to notify the server of client logout
         FileClose(fServerPipe);
         fServerPipe := 0;
       end;
     end;
  finally
    LeaveCriticalSection(fMutex);
  end;
{$ifdef WITHLOG}
  with Call do
    Log.Log(sllClient,'% % status=% state=%',[method,url,OutStatus,OutInternalState],self);
{$endif}
end;


{$endif MSWINDOWS}


{ TSQLRestServerStats }

function TSQLRestServerStats.Changed: boolean;
begin
  result := fLastIncomingBytes<>IncomingBytes;
  if result then
    fLastIncomingBytes := IncomingBytes;
end;

procedure TSQLRestServerStats.ClientConnect;
begin
  inc(fClientsCurrent);
  if fClientsCurrent>fClientsMax then
    fClientsMax := fClientsCurrent;
  inc(fIncomingBytes,4); // change IncomingBytes to trigger message update
end;

procedure TSQLRestServerStats.ClientDisconnect;
begin
  if fClientsCurrent>0 then
    dec(fClientsCurrent);
  inc(fIncomingBytes,4); // change IncomingBytes to trigger message update
end;

function TSQLRestServerStats.DebugMessage: RawUTF8;
begin
  result := ObjectToJSON(self,[woHumanReadable]);
end;

function TSQLRestServerStats.ModifPercent: cardinal;
begin
  if Responses=0 then
    result := 0 else
    result := (Modified*100)div Responses;
end;

{$ifdef WITHSTATPROCESS}
function TSQLRestServerStats.GetProcessTimeString: RawUTF8;
var Freq: Int64;
begin
  QueryPerformanceFrequency(Freq); // performance-counter frequency in counts per second
  if (self=nil) or (Freq=0) then
    result := '0' else
    result := MicroSecToString((ProcessTimeCounter*(1000*1000))div Freq);
end;
{$endif}


{ TSQLRestStorageRecordBased }

function TSQLRestStorageRecordBased.EngineAdd(TableModelIndex: integer;
  const SentData: RawUTF8): integer;
var Rec: TSQLRecord;
begin
  result := 0; // mark error
  if (TableModelIndex<0) or (Model.Tables[TableModelIndex]<>fStoredClass) then
    exit;
  Rec := fStoredClass.Create;
  try
    Rec.FillFrom(SentData);
    StorageLock(true);
    try
      result := AddOne(Rec,Rec.fID>0,SentData);
    finally
      StorageUnLock;
    end;
  finally
    if result<=0 then
      Rec.Free; // on success, will be freed by fValue TObjectList
  end;
end;

function TSQLRestStorageRecordBased.EngineUpdate(TableModelIndex, ID: integer;
  const SentData: RawUTF8): boolean;
var Rec: TSQLRecord;
begin
  // this implementation won't handle partial fields update (e.g. BatchUpdate
  // after FillPrepare) - but TSQLRestStorageInMemory.EngineUpdate will
  if (ID<=0) or (TableModelIndex<0) or
     (Model.Tables[TableModelIndex]<>fStoredClass) then begin
    result := false; // mark error
    exit;
  end;
  StorageLock(true);
  try
    Rec := fStoredClass.Create;
    try
      Rec.FillFrom(SentData);
      Rec.fID := ID;
      result := UpdateOne(Rec,SentData);
    finally
      Rec.Free;
    end;
  finally
    StorageUnLock;
  end;
end;

function TSQLRestStorageRecordBased.UpdateOne(ID: integer;
  const Values: TSQLVarDynArray): boolean;
var Rec: TSQLRecord;
begin
  if (ID<=0) then begin
    result := false; // mark error
    exit;
  end;
  StorageLock(true);
  try
    Rec := fStoredClass.Create;
    try
      Rec.SetFieldSQLVars(Values);
      Rec.fID := ID;
      result := UpdateOne(Rec,Rec.GetJSONValues(true,False,soUpdate));
    finally
      Rec.Free;
    end;
  finally
    StorageUnLock;
  end;
end;


{ TSQLRestStorageInMemory }

constructor TSQLRestStorageInMemory.Create(aClass: TSQLRecordClass; aServer: TSQLRestServer;
  const aFileName: TFileName = ''; aBinaryFile: boolean=false);
var JSON: RawUTF8;
    Stream: TStream;
    F: integer;
begin
  inherited Create(aClass,aServer,aFileName,aBinaryFile);
  if (fStoredClassProps<>nil) and (fStoredClassProps.Kind in INSERT_WITH_ID) then
    raise EModelException.CreateFmt('%s: %s virtual table can''t be static',
      [fStoredClassRecordProps.SQLTableName,aClass.ClassName]);
  fBinaryFile := aBinaryFile;
  fValue := TObjectList.Create;
  fSearchRec := fStoredClass.Create;
  fIDSorted := true; // sorted by design of this class (may change in children)
  if (ClassType<>TSQLRestStorageInMemory) and (fStoredClassProps<>nil) then
    with fStoredClassProps do begin // used by AdaptSQLForEngineList() method
      fBasicUpperSQLSelect[false] := SynCommons.UpperCase(SQL.SelectAllWithRowID);
      SetLength(fBasicUpperSQLSelect[false],length(fBasicUpperSQLSelect[false])-1); // trim right ';'
      fBasicUpperSQLSelect[true] := StringReplaceAll(fBasicUpperSQLSelect[false],' ROWID,',' ID,');
    end;
  if not IsZero(fIsUnique) then begin
    fUniqueFields := TObjectList.Create;
    with fStoredClassRecordProps do
    for F := 0 to Fields.Count-1 do
      if F in fIsUnique then
        // CaseInsensitive=true just like
        fUniqueFields.Add(TListFieldHash.Create(fValue,F,Fields.List[F],true));
  end;
  if (fFileName<>'') and FileExists(fFileName) then begin
    if aBinaryFile then begin
      Stream := TSynMemoryStreamMapped.Create(fFileName);
      try
        LoadFromBinary(Stream)
      finally
        Stream.Free;
      end;
    end else begin
      JSON := StringFromFile(fFileName);
      LoadFromJSON(JSON);
    end;
  end;
end;

function TSQLRestStorageInMemory.AddOne(Rec: TSQLRecord; ForceID: boolean;
  const SentData: RawUTF8): integer;
var ndx,i: integer;
begin
  if (self=nil) or (Rec=nil) then begin
    result := -1; // mark error
    exit;
  end;
  if ForceID then
    if Rec.fID=0 then
      raise EORMException.Create('AddOne called with ForceID=0') else
      result := Rec.fID else begin
    if fValue.Count=0 then
      result := 1 else // default ID for a void table
      result := TSQLRecord(fValue[fValue.Count-1]).fID+1; // new ID compute
    Rec.fID := result;
  end;
  ndx := fValue.Add(Rec);
  if fUniqueFields<>nil then
    for i := 0 to fUniqueFields.Count-1 do
    if not TListFieldHash(fUniqueFields.List[i]).JustAdded then begin
      fValue.List[ndx] := nil; // avoid GPF within Delete()
      fValue.Delete(ndx);
      result := -1; // duplicate unique fields -> error
      exit;
    end;
  fModified := true;
  if Owner<>nil then
    Owner.InternalUpdateEvent(seAdd,fStoredClassProps.TableIndex,result,SentData,nil);
end;

function TSQLRestStorageInMemory.UniqueFieldsUpdateOK(aRec: TSQLRecord; aUpdateIndex: integer): boolean;
var i,ndx: integer;
begin
  if fUniqueFields<>nil then begin
    result := false;
    with fUniqueFields do
      for i := 0 to Count-1 do begin
        ndx := TListFieldHash(List[i]).Find(aRec);
        if (ndx>=0) and (ndx<>aUpdateIndex) then
          exit; // duplicate found at another entry
      end;
  end;
  result := true;
end;

function TSQLRestStorageInMemory.UniqueFieldHash(aFieldIndex: integer): TListFieldHash;
var i: integer;
begin
  if (fUniqueFields<>nil) and
     (cardinal(aFieldIndex)<cardinal(fStoredClassRecordProps.Fields.Count)) then
    with fUniqueFields do
      for i := 0 to Count-1 do begin
        result := List[i];
        if result.FieldIndex=aFieldIndex then
          exit;
      end;
  result := nil;
end;

function TSQLRestStorageInMemory.EngineDelete(TableModelIndex, ID: integer): boolean;
var i,F: integer;
begin
  if (self=nil) or (ID<=0) or (TableModelIndex<0) or
     (Model.Tables[TableModelIndex]<>fStoredClass) then begin
    result := false;
    exit;
  end;
  StorageLock(True);
  try
    i := IDToIndex(ID);
    if i<0 then
      result := false else begin
      if fUniqueFields<>nil then
        for F := 0 to fUniqueFields.Count-1 do
          TListFieldHash(fUniqueFields.List[F]).Invalidate;
      if Owner<>nil then // notify BEFORE deletion
         Owner.InternalUpdateEvent(seDelete,fStoredClassProps.TableIndex,ID,'',nil);
      fValue.Delete(i);  // TObjectList.Delete() will Free record
      fModified := true;
      result := true;
    end;
  finally
    StorageUnLock;
  end;
end;

function TSQLRestStorageInMemory.EngineDeleteWhere(TableModelIndex: Integer;
  const SQLWhere: RawUTF8; const IDs: TIntegerDynArray): boolean;
var ndx: TIntegerDynArray;
    n,i: integer;
begin // RecordCanBeUpdated() has already been called
  result := false;
  n := length(IDs);
  SetLength(ndx,n);
  dec(n);
  StorageLock(True);
  try
    for i := 0 to n do begin
      ndx[i] := IDToIndex(IDs[i]);
      if ndx[i]<0 then
        exit;
    end;
    if fUniqueFields<>nil then
      for i := 0 to fUniqueFields.Count-1 do
        TListFieldHash(fUniqueFields.List[i]).Invalidate;
    if Owner<>nil then
      for i := 0 to n do
        Owner.InternalUpdateEvent(seDelete,fStoredClassProps.TableIndex,IDs[i],'',nil); // notify BEFORE deletion
    QuickSortInteger(pointer(ndx),0,n); // deletion a bit faster in reverse order
    for i := n downto 0 do
      fValue.Delete(ndx[i]);
    fModified := true;
    result := true;
  finally
    StorageUnLock;
  end;
end;

destructor TSQLRestStorageInMemory.Destroy;
begin
  UpdateFile;
  fValue.Free; // TObjectList.Destroy will free all stored TSQLRecord instances
  fUniqueFields.Free;
  fSearchRec.Free;
  inherited Destroy;
end;

function TSQLRestStorageInMemory.GetCount: integer;
begin
  if Self<>nil then
    result := fValue.Count else
    result := 0;
end;

function TSQLRestStorageInMemory.GetID(Index: integer): integer;
begin
  with fValue do
    if (self=nil) or (cardinal(Index)>=cardinal(Count)) then
      result := 0 else
      result := TSQLRecord(List[Index]).fID;
end;

function TSQLRestStorageInMemory.GetItem(Index: integer): TSQLRecord;
begin
  if self<>nil then
    with fValue do
      if cardinal(Index)>=cardinal(Count) then
        raise EORMException.Create('GetItem out of range') else
        result := List[Index] else
    result := nil;
end;

procedure TSQLRestStorageInMemory.GetJSONValuesEvent(aDest: pointer;
  aRec: TSQLRecord; aIndex: integer);
var W: TJSONSerializer absolute aDest;
begin
  aRec.GetJSONValues(W);
  W.Add(',');
end;

procedure TSQLRestStorageInMemory.AddIntegerDynArrayEvent(
  aDest: pointer; aRec: TSQLRecord; aIndex: integer);
var Ints: TList absolute aDest;
begin
  Ints.Add(pointer(aIndex));
end;

procedure TSQLRestStorageInMemory.DoNothingEvent(aDest: pointer; aRec: TSQLRecord; aIndex: integer);
begin
end;

function TSQLRestStorageInMemory.AdaptSQLForEngineList(var SQL: RawUTF8): boolean;
var P: PUTF8Char;
    Prop: RawUTF8;
    WithoutRowID: boolean;
begin
  result := inherited AdaptSQLForEngineList(SQL);
  if result then
    exit; // 'select * from table'
  if IdemPropNameU(fBasicSQLCount,SQL) or
     IdemPropNameU(fBasicSQLHasRows[false],SQL) or
     IdemPropNameU(fBasicSQLHasRows[true],SQL) then begin
    result := true;
    exit; // 'select count(*) from table' will be handled as static
  end;
  if fBasicUpperSQLSelect[false]='' then
   exit;
  if IdemPChar(pointer(SQL),pointer(fBasicUpperSQLSelect[false])) then
    WithoutRowID := false else
    if IdemPChar(pointer(SQL),pointer(fBasicUpperSQLSelect[true])) then
      WithoutRowID := true else
      exit;
  P := pointer(SQL);
  inc(P,length(fBasicUpperSQLSelect[WithoutRowID]));
  if P^ in [#0,';'] then begin
    result := true; // properly ended the WHERE clause as 'SELECT * FROM table'
    exit;
  end;
  P := GotoNextNotSpace(P);
  if not IdemPChar(P,'WHERE ') then
    exit;
  P := GotoNextNotSpace(P+6);
  Prop := GetNextItem(P,'=');
  if (P=nil) or (fStoredClassRecordProps.Fields.IndexByName(Prop)<0) then
    exit;
  if PWord(P)^=ord(':')+ord('(') shl 8 then
    inc(P,2); // +2 to ignore :(...): parameter
  if P^ in ['''','"'] then begin
    P := GotoEndOfQuotedString(P);
    if P^<>'"' then
      exit;
  end;
  repeat inc(P) until P^ in [#0..' ',';',')']; // go to end of value
  if PWord(P)^=ord(')')+ord(':')shl 8 then
    inc(P,2); // ignore :(...): parameter
  P := GotoNextNotSpace(P);
  if (P^ in [#0,';']) or IdemPChar(P,'LIMIT 1;') then
    result := true; // properly ended the WHERE clause as 'FIELDNAME=value'
end;

function TSQLRestStorageInMemory.FindWhereEqual(WhereField: integer;
  const WhereValue: RawUTF8; OnFind: TFindWhereEqualEvent; Dest: pointer;
  FoundLimit,FoundOffset: integer): PtrInt;
var i, ndx: integer;
    aValue: PtrInt;
    err, currentRow: integer;
    P: TSQLPropInfo;
    Hash: TListFieldHash;
    Offs: PtrInt;
begin
  result := 0;
  if FoundLimit<=0 then
    FoundLimit := maxInt;
  if Assigned(OnFind) then
  if WhereField=SYNTABLESTATEMENTWHEREID then begin
    if FoundOffset<=0 then begin // omit first FoundOffset rows
      aValue := GetInteger(pointer(WhereValue),err);
      if (err=0) and (aValue>0) then begin
        ndx := IDToIndex(aValue); // use fast binary search
        if ndx>=0 then begin
          OnFind(Dest,TSQLRecord(fValue.List[ndx]),ndx);
          result := 1;
        end;
      end;
    end;
  end else
  if cardinal(WhereField)<=cardinal(fStoredClassRecordProps.Fields.Count) then begin
    dec(WhereField); // WHERE WhereField=WhereValue (WhereField=RTTIfield+1)
    // use fUniqueFields[] hash array for O(1) search if available
    Hash := UniqueFieldHash(WhereField);
    if Hash<>nil then
      if FoundOffset>0 then // omit first FoundOffset rows, for ID unique field
        exit else
      with Hash do begin
        Field.SetValue(fSearchRec,pointer(WhereValue),false);
        ndx := Find(fSearchRec);
        if ndx>=0 then begin
          OnFind(Dest,fValue.List[ndx],ndx);
          result := 1;
        end;
        exit;
      end;
    // generic code below is as fast as possible, and works for all field types
    currentRow := 0;
    P := fStoredClassRecordProps.Fields.List[WhereField];
    if not (P.SQLFieldType in COPIABLE_FIELDS) then
      exit; // nothing to search (e.g. sftUnknown or sftMany)
    if ((P.SQLFieldType in [sftBoolean,sftEnumerate,sftSet,sftID,sftRecord
        {$ifdef CPU64},sftInteger]){$else}]){$endif} and P.InheritsFrom(TSQLPropInfoRTTI))
        {$ifndef CPU64}or (PPointer(P)^=TSQLPropInfoRTTIInt32){$endif} then begin
      // stored as a PtrInt value -> optimized search
      aValue := GetInteger(pointer(WhereValue),err);
      if err<>0 then
        exit;
      with TSQLPropInfoRTTI(P).PropInfo^ do
      if (PropType^^.Kind=tkClass) or
         ((PropType^^.Kind=tkInteger)and(PropType^^.OrdType=otSLong)) then
        if PropWrap(GetProc).Kind=$FF then begin
          // optimized version for fast retrieval of signed Int32 field value
          Offs := GetProc and $00FFFFFF; // no getter -> use PPtrInt()
          for i := 0 to fValue.Count-1 do
            if PInteger(PtrInt(fValue.List[i])+Offs)^=aValue then begin
              if FoundOffset>0 then begin // omit first FoundOffset rows
                inc(currentRow);
                if currentRow>FoundOffset then
                  FoundOffset := 0 else
                  continue;
              end;
              OnFind(Dest,TSQLRecord(fValue.List[i]),i);
              inc(result);
              if result>=FoundLimit then
                exit;
            end;
          exit;
        end;
      // not an Int32, or there is a getter procedure -> use GetOrdProp()
      for i := 0 to fValue.Count-1 do begin
        if GetOrdProp(TObject(fValue.List[i]),pointer(TSQLPropInfoRTTI(P).PropInfo))=aValue then begin
          if FoundOffset>0 then begin
            inc(currentRow);
            if currentRow>=FoundOffset then
              FoundOffset := 0 else
              continue;
          end;
          OnFind(Dest,fValue.List[i],i);
          inc(result);
          if result>=FoundLimit then
            exit;
        end;
      end;
      exit;
    end;
    // generic search of any value, using fast CompareValue() overridden method
    P.SetValue(fSearchRec,pointer(WhereValue),false);
    for i := 0 to fValue.Count-1 do  // ..,true)=SYSTEMNOCASE
      if P.CompareValue(fValue.List[i],fSearchRec,true)=0 then begin
        if FoundOffset>0 then begin
          inc(currentRow);
          if currentRow>=FoundOffset then
            FoundOffset := 0 else
            continue;
        end;
        OnFind(Dest,fValue.List[i],i);
        inc(result);
        if result>=FoundLimit then
          exit;
      end;
  end;
end;

function TSQLRestStorageInMemory.GetJSONValues(Stream: TStream;
  Expand: boolean; Stmt: TSynTableStatement): PtrInt;
var i,KnownRowsCount: integer;
    {$ifndef NOVARIANTS}
    j,id: integer;
    {$endif}
    W: TJSONSerializer;
    IsNull: boolean;
    Prop: TSQLPropInfo;
label err;
begin // exact same format as TSQLTable.GetJSONValues()
  result := 0;
  if Stmt.WhereField=SYNTABLESTATEMENTWHEREALL then
    // no WHERE statement -> get all rows -> set rows count
    if (Stmt.FoundLimit>0) and (fValue.Count>Stmt.FoundLimit) then
      KnownRowsCount := Stmt.FoundLimit else
      KnownRowsCount := fValue.Count else
    KnownRowsCount := 0;
  W := fStoredClassRecordProps.CreateJSONWriter(
    Stream,Expand,Stmt.withID,Stmt.Fields,KnownRowsCount);
  if W<>nil then
  try
    if Expand then
      W.Add('[');
    if Stmt.WhereField=SYNTABLESTATEMENTWHEREALL then begin
      // no WHERE statement -> all rows
      for i := 0 to KnownRowsCount-1 do begin
        if Expand then
          W.AddCR; // for better readability
        TSQLRecord(fValue.List[i]).GetJSONValues(W);
        W.Add(',');
      end;
      result := KnownRowsCount;
    end else
    case Stmt.WhereOperator of
    opEqualTo:
      result := FindWhereEqual(Stmt.WhereField,Stmt.WhereValue,
        GetJSONValuesEvent,W,Stmt.FoundLimit,Stmt.FoundOffset);
    {$ifndef NOVARIANTS}
    opIn:
      if (Stmt.WhereField<>0) or // only handle ID IN (..) by now
         (Stmt.FoundOffset>0) then
        goto err else
        with TDocVariantData(Stmt.WhereValueVariant) do
          for i := 0 to Count-1 do
            if VariantToInteger(Values[i],id) then begin
              j := IDToIndex(id);
              if j>=0 then begin
                TSQLRecord(fValue.List[j]).GetJSONValues(W);
                W.Add(',');
                inc(result);
                if (Stmt.FoundLimit>0) and (result>=Stmt.FoundLimit) then
                  break;
              end;
            end else
              goto err;
    {$endif}
    opIs: // handle IS NULL and IS NOT NULL operators
      if Stmt.WhereField>0 then begin
        Prop := fStoredClassRecordProps.Fields.List[Stmt.WhereField-1];
        if Prop.InheritsFrom(TSQLPropInfoRTTIRawBlob) then begin
          IsNull := IdemPropName(Stmt.WhereValue,'NULL');
          for i := 0 to fValue.Count-1 do
          if TSQLPropInfoRTTIRawBlob(Prop).IsNull(fValue.List[i])=IsNull then begin
            TSQLRecord(fValue.List[i]).GetJSONValues(W);
            W.Add(',');
            inc(result);
            if (Stmt.FoundLimit>0) and (result>=Stmt.FoundLimit) then
              break;
          end;
        end else
          goto err;
      end else
        goto err;
    else begin
err:  W.CancelAll;
      result := 0;
      exit; 
    end;
    end;
    if (result=0) and W.Expand then begin
      // we want the field names at least, even with no data
      W.Expand := false; //  {"fieldCount":2,"values":["col1","col2"]}
      W.CancelAll;
      fStoredClassRecordProps.SetJSONWriterColumnNames(W,0);
    end;
    W.EndJSONObject(KnownRowsCount,result);
  finally
    W.Free;
  end;
end;

function TSQLRestStorageInMemory.IDToIndex(ID: integer): integer;
var L, R, cmp: integer;
begin
  if self<>nil then
  with fValue do begin
    R := Count-1;
    if fIDSorted and (R>=8) then begin
      // IDs are sorted -> use fast binary search algorithm
      L := 0;
      repeat
        result := (L + R) shr 1;
        cmp := TSQLRecord(List[result]).fID-ID;
        if cmp=0 then
          exit;
        if cmp<0 then
          L := result + 1 else
          R := result - 1;
      until (L > R);
    end else
      // IDs are not sorted -> compare all from beginning to end
      for result := 0 to R do
        if TSQLRecord(List[result]).fID=ID then
          exit;
  end;
  result := -1;
end;

function TSQLRestStorageInMemory.EngineList(const SQL: RawUTF8;
  ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8;
// - GetJSONValues/FindWhereEqual will handle basic REST commands (not all SQL)
// only valid SQL command is "SELECT Field1,Field2 FROM Table WHERE ID=120;",
// i.e one Table SELECT with one optional "WHERE fieldname = value" statement
// - handle also basic "SELECT Count(*) FROM TableName;" SQL statement
// Note: this is sufficient for OneFieldValue() and MultiFieldValue() to work
var MS: TRawByteStringStream;
    ResCount: PtrInt;
    Stmt: TSynTableStatement;
procedure SetCount(aCount: integer);
begin
  result := FormatUTF8('[{"Count(*)":%}]'#$A,[aCount]);
  ResCount := 1;
end;
begin
  ResCount := 0;
  if self=nil then begin
    result := '';
    exit;
  end;
  StorageLock(false);
  try
    if IdemPropNameU(fBasicSQLCount,SQL) then
      SetCount(TableRowCount(fStoredClass)) else
    if IdemPropNameU(fBasicSQLHasRows[false],SQL) or
       IdemPropNameU(fBasicSQLHasRows[true],SQL) then
      if TableRowCount(fStoredClass)=0 then begin
        result := '{"fieldCount":1,"values":["RowID"]}'#$A;
        ResCount := 0;
      end else begin // return one row with fake ID=1
        result := '[{"RowID":1}]'#$A;
        ResCount := 1;
      end else begin
      Stmt := TSynTableStatement.Create(SQL,
        fStoredClassRecordProps.Fields.IndexByName,
        fStoredClassRecordProps.SimpleFieldsBits[soSelect]);
      try
        if (Stmt.WhereValue='') or 
           not IdemPropNameU(Stmt.TableName,fStoredClassRecordProps.SQLTableName) then
          // invalid request -> return ''
          result := '' else
        if Stmt.WhereField=SYNTABLESTATEMENTWHERECOUNT then
          // was "SELECT Count(*) FROM TableName;"
          SetCount(TableRowCount(fStoredClass)) else
        if IsZero(Stmt.Fields) and not Stmt.WithID then
          if Stmt.IsSelectCountWhere and (Stmt.FoundLimit=0) and (Stmt.FoundOffset=0) then
            // was "SELECT Count(*) FROM TableName WHERE ..."
            SetCount(FindWhereEqual(Stmt.WhereField,Stmt.WhereValue,DoNothingEvent,nil,0,0)) else
            // invalid "SELECT FROM Table" ?
            exit else begin
          // save rows as JSON, with appropriate search according to Where* arguments
          MS := TRawByteStringStream.Create;
          try
            ForceAJAX := ForceAJAX or (Owner=nil) or not Owner.NoAJAXJSON;
            ResCount := GetJSONValues(MS,ForceAJAX,Stmt);
            result := MS.DataString;
          finally
            MS.Free;
          end;
        end;
      finally
        Stmt.Free;
      end;
    end;
  finally
    StorageUnLock;
  end;
  if ReturnedRowCount<>nil then
    ReturnedRowCount^ := ResCount;
end;

procedure TSQLRestStorageInMemory.LoadFromJSON(const aJSON: RawUTF8);
begin
  LoadFromJSON(Pointer(aJSON),length(aJSON));
end;

procedure TSQLRestStorageInMemory.LoadFromJSON(JSONBuffer: PUTF8Char; JSONBufferLen: integer);
  function IsSorted(U: PPUTF8Char; RowCount, FieldCount: integer): boolean;
  var i, aID, lastID: integer;
  begin
    result := false;
    lastID := 0;
    for i := 1 to RowCount do begin
      aID := GetInteger(U^);
      if aID<=lastID then
        exit else
        lastID := aID;
      inc(U,FieldCount);
    end;
    result := true;
  end;
var T: TSQLTableJSON;
begin
  fModified := false;
  fValue.Clear;
  T := TSQLTableJSON.CreateFromTables([fStoredClass],'',JSONBuffer,JSONBufferLen);
  if T<>nil then  // use a temporary table
  try
    if T.fFieldIndexID<0 then
      exit; // no ID field -> load is impossible -> error
    // ensure ID were stored in an increasing order
    if not IsSorted(@T.fResults[T.fFieldIndexID+T.FieldCount],T.RowCount,T.FieldCount) then begin
      // force sorted by ID -> faster IDToIndex()
      T.SortFields(T.fFieldIndexID,true,nil,sftInteger);
      // if data is corrupted, IDs may not be unique -> check it now
      if not IsSorted(@T.fResults[T.fFieldIndexID+T.FieldCount],T.RowCount,T.FieldCount) then
        exit; // some duplicated ID fields -> error
    end;
    // create TSQLRecord instances with data from T
    T.ToObjectList(fValue,fStoredClass);
  finally
    T.Free;
  end;
end;

procedure TSQLRestStorageInMemory.SaveToJSON(Stream: TStream; Expand: Boolean);
var i: integer;
    W: TJSONSerializer;
begin
  if self=nil then
    exit;
  W := fStoredClassRecordProps.CreateJSONWriter(
    Stream,Expand,true,ALL_FIELDS,fValue.Count);
  try
    if Expand then
      W.Add('[');
    for i := 0 to fValue.Count-1 do begin
      if Expand then
        W.AddCR; // for better readability
      TSQLRecord(fValue.List[i]).GetJSONValues(W);
      W.Add(',');
    end;
    W.EndJSONObject(fValue.Count,fValue.Count);
  finally
    W.Free;
  end;
end;

function TSQLRestStorageInMemory.SaveToJSON(Expand: Boolean): RawUTF8;
var MS: TRawByteStringStream;
begin
  if self=nil then
    result := '' else begin
    MS := TRawByteStringStream.Create;
    try
      SaveToJSON(MS,Expand);
      result := MS.DataString;
    finally
      MS.Free;
    end;
  end;
end;

const
  TSQLRestStorageINMEMORY_MAGIC = $A5ABA5A5;

function TSQLRestStorageInMemory.LoadFromBinary(Stream: TStream): boolean;
var R: TFileBufferReader;
    MS: TMemoryStream;
    i, f: integer;
    IDs: TIntegerDynArray;
    P: PAnsiChar;
    aRecord: TSQLRecord;
begin
  result := false;
  if self=nil then
    exit;
  MS := StreamUnSynLZ(Stream,TSQLRestStorageINMEMORY_MAGIC);
  if MS<>nil then
  with fStoredClassRecordProps do
  try
    // check header: expect same exact RTTI
    R.OpenFrom(MS.Memory,MS.Size);
    if (R.ReadRawUTF8<>RawUTF8(ClassName)) or
       not CheckBinaryHeader(R) then
      exit;
    // read IDs
    fModified := false;
    fValue.Clear;
    fValue.Count := R.ReadVarUInt32Array(IDs); // faster than fValue.Add()
    for i := 0 to high(IDs) do begin
      aRecord := fStoredClass.Create;
      aRecord.fID := IDs[i];
      fValue.List[i] := aRecord;
    end;
    // read content, grouped by field (for better compression)
    P := R.CurrentMemory;
    for f := 0 to Fields.Count-1 do
      with Fields.List[f], fValue do
        for i := 0 to Count-1 do begin
          P := SetBinary(TSQLRecord(List[i]),P);
          if P=nil then begin
            fValue.Clear; // on error, reset whole 
            exit;
          end;
        end;
    Result := true;
  finally
    R.Close;
    MS.Free;
  end;
end;

function TSQLRestStorageInMemory.SaveToBinary(Stream: TStream): integer;
var W: TFileBufferWriter;
    MS: THeapMemoryStream;
    IDs: TIntegerDynArray;
    i, f: integer;
begin
  result := 0;
  if (self=nil) or (Stream=nil) then
    exit;
  MS := THeapMemoryStream.Create;
  W := TFileBufferWriter.Create(MS);
  with fStoredClassRecordProps do
  try
    // primitive magic and fields signature for file type identification
    W.Write(RawUTF8(ClassName));
    SaveBinaryHeader(W);
    // write IDs
    SetLength(IDs,Count);
    with fValue do
      for i := 0 to Count-1 do
        IDs[i] := TSQLRecord(List[i]).fID;
    W.WriteVarUInt32Array(IDs,Count,wkSorted); // efficient ID storage
    // write content, grouped by field (for better compression)
    for f := 0 to Fields.Count-1 do
      with Fields.List[f], fValue do
        for i := 0 to Count-1 do
          GetBinary(TSQLRecord(List[i]),W);
    W.Flush;
    result := StreamSynLZ(MS,Stream,TSQLRestStorageINMEMORY_MAGIC);
  finally
    W.Free;
    MS.Free;
  end;
end;

function TSQLRestStorageInMemory.EngineRetrieve(TableModelIndex, ID: integer): RawUTF8;
var i: integer;
begin // TableModelIndex is not useful here
  StorageLock(false);
  try
    i := IDToIndex(ID);
    if i<0 then
      result := '' else
      result := TSQLRecord(fValue.List[i]).GetJSONValues(true,true,soSelect);
  finally
    StorageUnLock;
  end;
end;

function TSQLRestStorageInMemory.GetOne(aID: integer): TSQLRecord;
var i: integer;
begin
  i := IDToIndex(aID);
  if i<0 then
    result := nil else begin
    result := fStoredClass.Create;
    CopyObject(fValue.List[i],Result);
    result.fID := aID;
  end;
end;

function TSQLRestStorageInMemory.EngineUpdate(TableModelIndex, ID: integer;
  const SentData: RawUTF8): boolean;
var i: integer;
    Orig,Rec: TSQLRecord;
begin
  // this implementation will handle partial fields update (e.g.
  // FillPrepare+BatchUpdate or TSQLRestServerRemoteDB.UpdateField)
  // but TSQLRestStorageRecordBased.EngineUpdate won't
  result := false;
  if (ID<0) or (TableModelIndex<0) or (Model.Tables[TableModelIndex]<>fStoredClass) then
    exit;
  if SentData='' then begin
    result := True;
    exit;
  end;
  StorageLock(true);
  try
    i := IDToIndex(ID);
    if (i<0) or not RecordCanBeUpdated(fStoredClass,ID,seUpdate) then
      exit;
    if fUniqueFields<>nil then begin
      Orig := TSQLRecord(fValue.List[i]);
      Rec := Orig.CreateCopy; // copy since can be a partial update
      Rec.FillFrom(SentData); // overwrite updated properties
      if not UniqueFieldsUpdateOK(Rec,i) then begin
        Rec.Free; // stored false property duplicated value -> error
        exit;
      end;
      Orig.Free; // avoid memory leak
      TSQLRecord(fValue.List[i]) := Rec; // update item in list
    end else
      // direct in-place partial update
      TSQLRecord(fValue.List[i]).FillFrom(SentData);
    fModified := true;
    result := true;
    if Owner<>nil then
      Owner.InternalUpdateEvent(seUpdate,fStoredClassProps.TableIndex,ID,SentData,nil);
  finally
    StorageUnLock;
  end;
end;

function TSQLRestStorageInMemory.UpdateOne(Rec: TSQLRecord; const SentData: RawUTF8): boolean;
var i: integer;
begin
  result := false;
  if (Rec=nil) or (PSQLRecordClass(Rec)^<>fStoredClass) or (Rec.fID<=0) then
    exit;
  StorageLock(true);
  try
    i := IDToIndex(Rec.fID);
    if (i<0) or not RecordCanBeUpdated(fStoredClass,Rec.fID,seUpdate) then
      exit;
    if (fUniqueFields<>nil) and not UniqueFieldsUpdateOK(Rec,i) then
      exit; // stored false property duplicated value -> error
    CopyObject(Rec,fValue.List[i]);
    fModified := true;
    result := true;
    if Owner<>nil then
      Owner.InternalUpdateEvent(seUpdate,fStoredClassProps.TableIndex,Rec.fID,SentData,nil);
  finally
    StorageUnLock;
  end;
end;

function TSQLRestStorageInMemory.UpdateOne(ID: integer;
  const Values: TSQLVarDynArray): boolean;
var i: integer;
    Orig,Rec: TSQLRecord;
begin
  result := false;
  if ID<=0 then
    exit;
  i := IDToIndex(ID);
  if (i<0) or not RecordCanBeUpdated(fStoredClass,ID,seUpdate) then
    exit;
  if fUniqueFields<>nil then begin
    Orig := TSQLRecord(fValue.List[i]);
    Rec := Orig.CreateCopy; // copy since can be a partial update
    if (not Rec.SetFieldSQLVars(Values)) or
       (not UniqueFieldsUpdateOK(Rec,i)) then begin
      Rec.Free; // stored false property duplicated value -> error
      exit;
    end;
    Orig.Free; // avoid memory leak
    TSQLRecord(fValue.List[i]) := Rec;
  end else
  if not TSQLRecord(fValue.List[i]).SetFieldSQLVars(Values) then
    exit;
  fModified := true;
  result := true;
  if Owner<>nil then
    Owner.InternalUpdateEvent(seUpdate,fStoredClassProps.TableIndex,ID,
      TSQLRecord(fValue.List[i]).GetJSONValues(True,False,soUpdate),nil);
end;

function TSQLRestStorageInMemory.EngineRetrieveBlob(TableModelIndex, aID: integer;
  BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean;
var i: integer;
begin
  result := false;
  if (TableModelIndex<0) or (not BlobField^.IsBlob) or
     (fModel.Tables[TableModelIndex]<>fStoredClass) then
    exit;
  StorageLock(false);
  try
    i := IDToIndex(aID);
    if i<0 then
      exit;
    // get result blob directly from RTTI property description
    GetLongStrProp(fValue.List[i],BlobField,RawByteString(BlobData));
    result := true;
  finally
    StorageUnLock;
  end;
end;

function TSQLRestStorageInMemory.RetrieveBlobFields(Value: TSQLRecord): boolean;
var i,f: integer;
begin
  result := false;
  if (Value<>nil) and (Value.fID>0) and (PSQLRecordClass(Value)^=fStoredClass) then
  with Value.RecordProps do
  if BlobFields<>nil then begin
    StorageLock(false);
    try
      i := IDToIndex(Value.fID);
      if i<0 then
        exit;
      for f := 0 to high(BlobFields) do
        BlobFields[f].CopyValue(fValue.List[i],Value);
      result := true;
    finally
      StorageUnLock;
    end;
  end;
end;

function TSQLRestStorageInMemory.EngineUpdateBlob(TableModelIndex, aID: integer;
  BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean;
var i: integer;
    AffectedField: TSQLFieldBits;
begin
  result := false;
  if (aID<0) or (TableModelIndex<0) or (not BlobField^.IsBlob) or
     (fModel.Tables[TableModelIndex]<>fStoredClass) then
    exit;
  StorageLock(true);
  try
    i := IDToIndex(aID);
    if (i<0) or not RecordCanBeUpdated(fStoredClass,aID,seUpdate) then
      exit;
    // set blob value directly from RTTI property description
    SetLongStrProp(fValue.List[i],BlobField,BlobData);
    if Owner<>nil then begin
      fStoredClassRecordProps.FieldIndexsFromBlobField(BlobField,AffectedField);
      Owner.InternalUpdateEvent(seUpdateBlob,fStoredClassProps.TableIndex,aID,'',@AffectedField);
    end;
    result := true;
  finally
    StorageUnLock;
  end;
end;

function TSQLRestStorageInMemory.UpdateBlobFields(Value: TSQLRecord): boolean;
var i,f: integer;
begin
  result := false;
  if (Value<>nil) and (Value.fID>0) and (PSQLRecordClass(Value)^=fStoredClass) then
  with Value.RecordProps do
  if BlobFields<>nil then begin
    StorageLock(true);
    try
      i := IDToIndex(Value.fID);
      if (i<0) or not RecordCanBeUpdated(Table,Value.fID,seUpdate) then
        exit;
      for f := 0 to high(BlobFields) do
        BlobFields[f].CopyValue(Value,fValue.List[i]);
      if Owner<>nil then
        Owner.InternalUpdateEvent(seUpdateBlob,fStoredClassProps.TableIndex,Value.fID,'',
          @fStoredClassRecordProps.BlobFieldsBits);
      result := true;
    finally
      StorageUnLock;
    end;
  end else
    result := true; // as TSQLRest.UpdateblobFields()
end;

function TSQLRestStorageInMemory.TableRowCount(Table: TSQLRecordClass): integer;
begin
  if Table<>fStoredClass then
    result := 0 else
    result := fValue.Count;
end;

function TSQLRestStorageInMemory.TableHasRows(Table: TSQLRecordClass): boolean;
begin
  if Table<>fStoredClass then
    result := false else
    result := fValue.Count>0;
end;

function TSQLRestStorageInMemory.EngineUpdateField(TableModelIndex: integer;
  const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
var SetField: TSQLPropInfo;
    WhereValueString, SetValueString, SetValueJson: RawUTF8;
    Where: TList;
    i, ndx, WhereFieldIndex: integer;
    SetValueWasString: boolean;
    Rec: TSQLRecord;
begin
  result := false;
  if (TableModelIndex<0) or (fModel.Tables[TableModelIndex]<>fStoredClass) or
     (SetFieldName='') or (SetValue='') or
     (WhereFieldName='') or (WhereValue='') then
    exit;
  // handle destination field RTTI
  SetField := fStoredClassRecordProps.Fields.ByRawUTF8Name(SetFieldName);
  if SetField=nil then
    exit; // don't allow setting ID field, which is Read Only
  SetValueWasString := SetValue[1]='"';
  if SetValueWasString then
    UnQuoteSQLString(pointer(SetValue),SetValueString) else
    SetValueString := SetValue;
  // handle search field RTTI
  if IsRowID(pointer(WhereFieldName)) then begin
    WhereFieldIndex := 0;
    WhereValueString := WhereValue;
  end else begin
    WhereFieldIndex := fStoredClassRecordProps.Fields.IndexByName(WhereFieldName);
    if WhereFieldIndex<0  then
      exit;
    inc(WhereFieldIndex); // FindWhereEqual() expects index = RTTI+1
  end;
  if WhereValue[1]='"' then
    UnQuoteSQLString(pointer(WhereValue),WhereValueString) else
    WhereValueString := WhereValue;
  // search indexes, then apply updates
  Where := TList.Create;
  StorageLock(true);
  try 
    // find matching Where[]
    if FindWhereEqual(WhereFieldIndex,WhereValueString,AddIntegerDynArrayEvent,Where,0,0)=0 then
      exit; // Where.Count=0 -> nothing to update
    // check that all records can be updated
    for i := 0 to Where.Count-1 do
      if not RecordCanBeUpdated(fStoredClass,
         TSQLRecord(fValue.List[PtrInt(Where.List[i])]).fID,seUpdate) then
        exit; // one record update fails -> abort all
    if fUniqueFields<>nil then
      for i := 0 to fUniqueFields.Count-1 do
      with TListFieldHash(fUniqueFields.List[i]) do
        if Field=SetField then
          if Where.Count>1 then // unique field can't allow multiple sets
            exit else begin
            SetField.SetValue(fSearchRec,pointer(SetValueString),false);
            ndx := Find(fSearchRec);
            if (ndx>=0) and (ndx<>PtrInt(Where.List[0])) then
              exit; // duplicated entry error
          end;
    // update field value
    for i := 0 to Where.Count-1 do begin
      Rec := fValue.List[PtrInt(Where.List[i])];
      SetField.SetValue(Rec,pointer(SetValueString),SetValueWasString);
      fModified := true;
      if Owner<>nil then begin
        if SetValueJson='' then
          SetValueJson := '{"'+SetField.Name+'":'+SetValue+'}';
        Owner.InternalUpdateEvent(seUpdate,fStoredClassProps.TableIndex,Rec.fID,SetValueJson,nil);
      end;
      result := true;
    end;
  finally
    StorageUnLock;
    Where.Free;
  end;
end;

procedure TSQLRestStorageInMemory.UpdateFile;
var F: TFileStream;
    Timer: TPrecisionTimer;
begin
  if (self=nil) or (not Modified) or (FileName='') then
    exit;
  Timer.Start;
  StorageLock(false);
  try
    if fValue.Count=0 then
      DeleteFile(FileName) else begin
      F := TFileStream.Create(FileName,fmCreate);
      try
        if BinaryFile then
          SaveToBinary(F) else
          SaveToJSON(F,true);
        F.Size := F.Position; // truncate file
      finally
        F.Free;
      end;
    end;
  finally
    StorageUnLock;
  end;
  {$ifdef WITHLOG}
  SQLite3Log.Add.Log(sllDB,'UpdateFile(%) done in %',
    [fStoredClassRecordProps.SQLTableName,Timer.Stop],self);
  {$endif}
  fModified := false;
end;

function TSQLRestStorageInMemory.SearchField(const FieldName, FieldValue: RawUTF8; var ResultID: TIntegerDynArray): boolean;
var n, WhereField: integer;
    {$ifdef CPU64}i: integer;{$endif}
    Where: TList;
begin
  result := false;
  SetLength(ResultID,0);
  if (self=nil) or (fValue.Count=0) then
    exit;
  if IsRowID(pointer(FieldName)) then
    WhereField := SYNTABLESTATEMENTWHEREID else begin
    WhereField := fStoredClassRecordProps.Fields.IndexByName(FieldName);
    if WhereField<0 then
      exit;
    inc(WhereField); // FindWhereEqual() expects index = RTTI+1
  end;
  Where := TList.Create;
  try
    n := FindWhereEqual(WhereField,FieldValue,AddIntegerDynArrayEvent,Where,0,0);
    if n=0 then
      exit;
    SetLength(ResultID,n);
    {$ifdef CPU64}
    with Where do
      for i := 0 to Count-1 do
        ResultID[i] := PPtrIntArray(List)^[i];
    {$else}
    move(Where.List[0],ResultID[0],n*sizeof(Integer));
    {$endif}
  finally
    Where.Free;
  end;
end;


{ TSQLRestStorageInMemoryExternal }

procedure TSQLRestStorageInMemoryExternal.StorageLock(WillModifyContent: boolean);
begin
  inherited StorageLock(WillModifyContent);
  if WillModifyContent and (Owner<>nil) then
    Owner.FlushInternalDBCache;
end;


{ TListFieldHash }

function TListFieldHash.Compare(Item1,Item2: TObject): boolean;
begin
  result := fProp.CompareValue(Item1,Item2,CaseInsensitive)=0;
end;

function TListFieldHash.Count: integer;
begin
  result := fValues.Count;
end;

constructor TListFieldHash.Create(aValues: TList; aFieldIndex: integer;
  aField: TSQLPropInfo; aCaseInsensitive: boolean);
begin
  fValues := aValues;
  fField := aFieldIndex;
  fProp := aField;
  fCaseInsensitive := aCaseInsensitive;
end;

function TListFieldHash.Hash(Item: TObject): cardinal;
begin
  result := fProp.GetHash(Item,CaseInsensitive);
  if result=0 then
    result := 1; // HASH=0 is used to indicate a void slot in fHash[]
end;

function TListFieldHash.Get(Index: integer): TObject;
begin
  with fValues do
    if cardinal(Index)<cardinal(Count) then
      result := List[Index] else
      result := nil;
end;


{ TSQLRestStorage }

constructor TSQLRestStorage.Create(aClass: TSQLRecordClass;
  aServer: TSQLRestServer; const aFileName: TFileName; aBinaryFile: boolean);
begin
  inherited Create(nil);
  if aClass=nil then
    raise EBusinessLayerException.CreateFmt('%s.Create expect a class',[ClassName]);
  InitializeCriticalSection(fStorageCriticalSection);
  fStoredClass := aClass;
  fStoredClassRecordProps := aClass.RecordProps;
  if aServer<>nil then begin
    fOwner := aServer;
    fModel := aServer.Model;
    fStoredClassProps := fModel.Props[aClass];
  end else
    // if no server is defined, simply use the first model using this class
    if fStoredClassRecordProps.fModel<>nil then
    with fStoredClassRecordProps.fModel[0] do begin
      fModel := Model;
      fStoredClassProps := Properties;
    end;
  fIsUnique := fStoredClassRecordProps.IsUniqueFieldsBits;
  fFileName := aFileName;
  fBasicSQLCount := 'SELECT COUNT(*) FROM '+fStoredClassRecordProps.SQLTableName;
  fBasicSQLHasRows[false] := 'SELECT RowID FROM '+fStoredClassRecordProps.SQLTableName+' LIMIT 1';
  fBasicSQLHasRows[true] := fBasicSQLHasRows[false];
  system.delete(fBasicSQLHasRows[true],8,3);
end;

destructor TSQLRestStorage.Destroy;
begin
  inherited;
  assert(fStorageCriticalSectionCount=0);
  DeleteCriticalSection(fStorageCriticalSection);
end;

procedure TSQLRestStorage.BeginCurrentThread(Sender: TThread);
begin
  // nothing to do in this basic REST static class
end;

procedure TSQLRestStorage.EndCurrentThread(Sender: TThread);
begin
  // nothing to do in this basic REST static class
end;

function TSQLRestStorage.EngineUpdateField(TableModelIndex: integer;
  const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
begin
  result := false; // not implemented in this basic REST static class
end;

function TSQLRestStorage.CreateSQLMultiIndex(Table: TSQLRecordClass;
  const FieldNames: array of RawUTF8; Unique: boolean; IndexName: RawUTF8): boolean;
begin
  result := false; // not implemented in this basic REST static class
end;

function TSQLRestStorage.SearchField(const FieldName: RawUTF8;
  FieldValue: Integer; var ResultID: TIntegerDynArray): boolean;
begin
  result := SearchField(FieldName,Int32ToUTF8(FieldValue),ResultID);
end;

function TSQLRestStorage.RecordCanBeUpdated(Table: TSQLRecordClass;
  ID: integer; Action: TSQLEvent; ErrorMsg: PRawUTF8 = nil): boolean;
begin
  result := ((Owner=nil) or Owner.RecordCanBeUpdated(Table,ID,Action,ErrorMsg));
end;

function TSQLRestStorage.RefreshedAndModified: boolean;
begin
  result := false; // no refresh necessary with "normal" static tables
end;

procedure TSQLRestStorage.StorageLock(WillModifyContent: boolean);
begin
  EnterCriticalSection(fStorageCriticalSection);
  inc(fStorageCriticalSectionCount);
end;

procedure TSQLRestStorage.StorageUnLock;
begin
  dec(fStorageCriticalSectionCount);
  assert(fStorageCriticalSectionCount>=0);
  LeaveCriticalSection(fStorageCriticalSection);
end;

function TSQLRestStorage.UnLock(Table: TSQLRecordClass; aID: integer): boolean;
begin
  result := Model.UnLock(Table,aID);
end;

function TSQLRestStorage.AdaptSQLForEngineList(var SQL: RawUTF8): boolean;
begin
  if fStoredClassProps=nil then
    result := false else begin
    result := IdemPropNameU(fStoredClassProps.SQL.SelectAllWithRowID,SQL);
    if result then
      SQL := fStoredClassProps.SQL.SelectAllWithID else
      result := IdemPropNameU(fStoredClassProps.SQL.SelectAllWithID,SQL);
  end;
end;

function TSQLRestStorage.BatchStart(aTable: TSQLRecordClass; AutomaticTransactionPerRow: cardinal=0): boolean;
begin
  raise EORMException.CreateFmt('%s.BatchStart() does not make sense',[ClassName]);
end;


{ TSQLRestServerFullMemory }

constructor TSQLRestServerFullMemory.Create(aModel: TSQLModel;
  const aFileName: TFileName; aBinaryFile, aHandleUserAuthentication: boolean);
var t: integer;
begin
  fFileName := aFileName;
  fBinaryFile := aBinaryFile;
  inherited Create(aModel,aHandleUserAuthentication);
  fStaticDataCount := length(fModel.Tables);
  SetLength(fStorage,fStaticDataCount);
  for t := 0 to fStaticDataCount-1 do
    fStorage[t] := (StaticDataCreate(fModel.Tables[t]) as TSQLRestStorageInMemory);
  LoadFromFile;
  CreateMissingTables(0);
end; 

procedure TSQLRestServerFullMemory.CreateMissingTables(user_version: cardinal=0);
var t: integer;
begin
  // create any missing static instances
  if integer(fStaticDataCount)<>length(fModel.Tables) then begin
    for t := fStaticDataCount to high(fModel.Tables) do
      StaticDataCreate(fModel.Tables[t]);
    fStaticDataCount := length(fModel.Tables);
  end;
  // initialize new tables
  for t := 0 to fStaticDataCount-1 do
    with TSQLRestStorageInMemory(fStaticData[t]) do
    if Count=0 then // emulates TSQLRestServerDB.CreateMissingTables
      StoredClass.InitializeTable(Self,'');
end;

destructor TSQLRestServerFullMemory.Destroy;
begin
  UpdateToFile;
  inherited;
end;

procedure TSQLRestServerFullMemory.DropDatabase;
var t: integer;
begin
  for t := 0 to fStaticDataCount-1 do
    TSQLRestStorageInMemory(fStaticData[t]).fValue.Clear;
end;

procedure TSQLRestServerFullMemory.LoadFromFile;
var JSON: RawUTF8;
    P, TableName, Data: PUTF8Char;
    t: integer;
    S: TFileStream;
    wasString: boolean;
begin
  if (self=nil) or (fFileName='') or not FileExists(fFileName) then
    exit;
  DropDatabase;
  if fBinaryFile then begin
    S := TFileStream.Create(FileName,fmOpenRead or fmShareDenyNone);
    try
      if ReadStringFromStream(S)=RawUTF8(ClassName)+'00' then
      repeat
        t := Model.GetTableIndex(ReadStringFromStream(S));
      until (t<0) or
        not TSQLRestStorageInMemory(fStaticData[t]).LoadFromBinary(S);
    finally
      S.Free;
    end;
  end else begin // [{"AuthUser":[{....},{...}]},{"AuthGroup":[{...},{...}]}]
    JSON := StringFromFile(fFileName);
    if JSON='' then
      exit;
    P := pointer(JSON);
    while (P^<>'[') do if P^=#0 then exit else inc(P);
    inc(P);
    repeat
      while (P^<>']') and (P^<>'{') do if P^=#0 then exit else inc(P);
      if P^=']' then break else inc(P);
      TableName := GetJSONField(P,P,@wasString);
      if not wasString or (P=nil) then
        exit;
      t := Model.GetTableIndex(TableName);
      if t<0 then
        exit;
      Data := P;
      P := GotoNextJSONObjectOrArray(P);
      if P=nil then
        break else
        TSQLRestStorageInMemory(fStaticData[t]).LoadFromJSON(Data,P-Data);
    until false;
  end;
end;

procedure TSQLRestServerFullMemory.UpdateToFile;
const CHARS: array[0..6] of AnsiChar = '[{":,}]';
var S: TFileStream;                //   0123456
    t: integer;
    Modified: boolean;
    Timer: TPrecisionTimer;
begin
  if (self=nil) or (FileName='') then
    exit;
  Modified := false;
  for t := 0 to fStaticDataCount-1 do
    if TSQLRestStorageInMemory(fStaticData[t]).Modified then begin
      Modified := true;
      break;
    end;
  if not Modified then
    exit;
  Timer.Start;
  S := TFileStream.Create(FileName,fmCreate);
  try
    if fBinaryFile then begin
      WriteStringToStream(S,RawUTF8(ClassName)+'00');
      for t := 0 to fStaticDataCount-1 do
      with TSQLRestStorageInMemory(fStaticData[t]) do begin
        WriteStringToStream(S,fStoredClassRecordProps.SQLTableName);
        SaveToBinary(S);
      end;
    end else begin
      S.Write(CHARS[0],1);
      for t := 0 to fStaticDataCount-1 do
      with TSQLRestStorageInMemory(fStaticData[t]) do begin
        S.Write(CHARS[1],2);
        with fStoredClassRecordProps do
          S.Write(pointer(SQLTableName)^,length(SQLTableName));
        S.Write(CHARS[2],2);
        SaveToJSON(S,true);
        S.Write(CHARS[5],1);
        if t<integer(fStaticDataCount-1) then
          S.Write(CHARS[4],1);
      end;
      S.Write(CHARS[6],1);
    end;
  finally
    S.Free;
  end;
  {$ifdef WITHLOG}
  SQLite3Log.Add.Log(sllDB,'UpdateToFile done in %',[Timer.Stop],self);
  {$endif}
end;

function TSQLRestServerFullMemory.EngineExecuteAll(const aSQL: RawUTF8): boolean;
begin
  result := false; // not implemented in this basic REST server class
end;

procedure TSQLRestServerFullMemory.Flush(Ctxt: TSQLRestServerURIContext);
begin
  if Ctxt.Method=mPUT then begin
    UpdateToFile;
    Ctxt.Success;
  end;
end;

function TSQLRestServerFullMemory.GetStorage(aTable: TSQLRecordClass): TSQLRestStorageInMemory;
var i: cardinal;
begin
  i := fModel.GetTableIndex(aTable);
  if i>=cardinal(length(fStorage)) then
    result := nil else
    result := fStorage[i];
end;

function TSQLRestServerFullMemory.MainEngineAdd(TableModelIndex: integer;
  const SentData: RawUTF8): integer; 
begin 
  result := 0; 
end;

function TSQLRestServerFullMemory.MainEngineRetrieve(TableModelIndex: integer; 
  ID: integer): RawUTF8; 
begin 
  result := ''; 
end;

function TSQLRestServerFullMemory.MainEngineList(const SQL: RawUTF8; 
  ForceAJAX: Boolean; ReturnedRowCount: PPtrInt): RawUTF8; 
begin 
  result := ''; 
end;

function TSQLRestServerFullMemory.MainEngineUpdate(TableModelIndex, ID: integer;
  const SentData: RawUTF8): boolean; 
begin 
  result := false; 
end;

function TSQLRestServerFullMemory.MainEngineDelete(TableModelIndex, ID: integer): boolean; 
begin 
  result := false; 
end;

function TSQLRestServerFullMemory.MainEngineDeleteWhere(TableModelIndex: integer; 
  const SQLWhere: RawUTF8; const IDs: TIntegerDynArray): boolean; 
begin 
  result := false; 
end;

function TSQLRestServerFullMemory.MainEngineRetrieveBlob(TableModelIndex, aID: integer;
  BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; 
begin 
  result := false; 
end;

function TSQLRestServerFullMemory.MainEngineUpdateBlob(TableModelIndex, aID: integer;
  BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; 
begin 
  result := false; 
end;

function TSQLRestServerFullMemory.MainEngineUpdateField(TableModelIndex: integer;
  const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; 
begin 
  result := false; 
end;


{ TSQLRestServerRemoteDB }

constructor TSQLRestServerRemoteDB.Create(aRemoteClient: TSQLRestClient;
  aHandleUserAuthentication: boolean);
begin
  if aRemoteClient=nil then
    raise EORMException.CreateFmt('%s creation with no remote client',[ClassName]);
  inherited Create(aRemoteClient.Model,aHandleUserAuthentication);
  fClient := aRemoteClient;
end;

function TSQLRestServerRemoteDB.EngineAdd(TableModelIndex: integer;
  const SentData: RawUTF8): integer;
begin
  result := fClient.EngineAdd(TableModelIndex,SentData);
end;

function TSQLRestServerRemoteDB.EngineDelete(TableModelIndex, ID: integer): boolean;
begin
  result := fClient.EngineDelete(TableModelIndex,ID);
end;

function TSQLRestServerRemoteDB.EngineDeleteWhere(TableModelIndex: Integer;
  const SQLWhere: RawUTF8; const IDs: TIntegerDynArray): boolean;
begin
  result := fClient.EngineDeleteWhere(TableModelIndex,SQLWhere,IDs);
end;

function TSQLRestServerRemoteDB.EngineExecuteAll(const aSQL: RawUTF8): boolean;
begin
  result := fClient.EngineExecute(aSQL);
end;

function TSQLRestServerRemoteDB.ExecuteList(const Tables: array of TSQLRecordClass;
  const SQL: RawUTF8): TSQLTableJSON;
begin
  result := fClient.ExecuteList(Tables,SQL);
end;

function TSQLRestServerRemoteDB.EngineList(const SQL: RawUTF8;
  ForceAJAX: Boolean; ReturnedRowCount: PPtrInt): RawUTF8;
begin
  result := fClient.EngineList(SQL,ForceAJAX,ReturnedRowCount);
end;

function TSQLRestServerRemoteDB.EngineRetrieve(TableModelIndex, ID: integer): RawUTF8;
begin
  result := fClient.EngineRetrieve(TableModelIndex,ID);
end;

function TSQLRestServerRemoteDB.EngineRetrieveBlob(TableModelIndex, aID: integer;
  BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean;
begin
  if (self=nil) or (BlobField=nil) then
    result := false else
    result := fClient.EngineRetrieveBlob(TableModelIndex,aID,BlobField,BlobData);
end;

function TSQLRestServerRemoteDB.EngineUpdate(TableModelIndex,
  ID: integer; const SentData: RawUTF8): boolean;
begin
  result := fClient.EngineUpdate(TableModelIndex,ID,SentData);
end;

function TSQLRestServerRemoteDB.EngineUpdateBlob(TableModelIndex, aID: integer;
  BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean;
begin
  if (self=nil) or (BlobField=nil) then
    result := false else
    result := fClient.EngineUpdateBlob(TableModelIndex,aID,BlobField,BlobData);
end;

function TSQLRestServerRemoteDB.EngineUpdateField(TableModelIndex: integer;
  const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
begin
  result := fClient.EngineUpdateField(TableModelIndex,SetFieldName,SetValue,WhereFieldName,WhereValue);
end;

function TSQLRestServerRemoteDB.AfterDeleteForceCoherency(Table: TSQLRecordClass;
  aID: integer): boolean;
begin
  result := true; // coherency will be performed on the server side
end;


{ TSQLRestClient }

function TSQLRestClient.GetForceBlobTransfert: Boolean;
var i: integer;
begin
  result := false;
  if fForceBlobTransfert=nil then
    exit;
  for i := 0 to fModel.fTablesMax do
    if not fForceBlobTransfert[i] then
      exit;
  result := true; // all Tables have BLOB transfert set
end;

procedure TSQLRestClient.SetForceBlobTransfert(Value: boolean);
var i: integer;
begin
  Finalize(fForceBlobTransfert);
  if Value then begin
    SetLength(fForceBlobTransfert,fModel.fTablesMax+1);
    for i := 0 to fModel.fTablesMax do
      fForceBlobTransfert[i] := true;
  end;
end;

function TSQLRestClient.GetForceBlobTransfertTable(aTable: TSQLRecordClass): Boolean;
begin
  if fForceBlobTransfert=nil then
    result := false else
    result := fForceBlobTransfert[fModel.GetTableIndexExisting(aTable)];
end;

procedure TSQLRestClient.SetForceBlobTransfertTable(aTable: TSQLRecordClass; aValue: Boolean);
var i: integer;
begin
  i := fModel.GetTableIndexExisting(aTable);
  if fForceBlobTransfert=nil then
    if aValue then
      SetLength(fForceBlobTransfert,fModel.fTablesMax+1) else
      exit; // nothing to set
  fForceBlobTransfert[i] := aValue;
end;

function TSQLRestClient.Add(Value: TSQLRecord; SendData: boolean; ForceID: boolean=false): integer;
begin
  result := inherited Add(Value,SendData,ForceID);
  if (result>0) and (fForceBlobTransfert<>nil) and
     fForceBlobTransfert[fModel.GetTableIndexExisting(PSQLRecordClass(Value)^)] then
     UpdateBlobFields(Value);
end;

function TSQLRestClient.EngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8;
var dummy: cardinal;
begin
  if not ClientRetrieve(TableModelIndex,ID,false,dummy,result) then
    result := '';
end;

function TSQLRestClient.Retrieve(aID: integer; Value: TSQLRecord;
  ForUpdate: boolean=false): boolean;
var Resp: RawUTF8;
    TableIndex: integer;
begin
  result := false;
  if (self=nil) or (aID<=0) or (Value=nil) then
    exit;
  TableIndex := Model.GetTableIndexExisting(PSQLRecordClass(Value)^);
  if ForUpdate then begin
    if not Model.Lock(TableIndex,aID) then
      exit; // error marking as locked by the client
  end else begin
    Resp := fCache.Retrieve(TableIndex,aID);
    if Resp<>'' then begin
      Value.FillFrom(Resp);
      Value.fID := aID; // JSON object may not contain the ID
      result := true;
      exit; // fast retrieved from internal Client cache (BLOBs ignored)
    end;
  end;
  try
    if ClientRetrieve(TableIndex,aID,ForUpdate,Value.fInternalState,Resp) then begin
      Value.FillFrom(Resp);
      Value.fID := aID; // JSON object may not contain the ID
      if (fForceBlobTransfert<>nil) and fForceBlobTransfert[TableIndex] then
        result := RetrieveBlobFields(Value) else
        result := true;
      ForUpdate := false; // any exception shall unlock the record
    end;
  finally
    if ForUpdate then
      Model.UnLock(TableIndex,aID);
  end;
end;

function TSQLRestClient.Update(Value: TSQLRecord; const CustomFields: TSQLFieldBits): boolean;
begin
  result := BeforeUpdateEvent(Value) and inherited Update(Value,CustomFields);
  if result then begin
    if (fForceBlobTransfert<>nil) and IsZero(CustomFields) and
       fForceBlobTransfert[Model.GetTableIndexExisting(PSQLRecordClass(Value)^)] then
      result := UpdateBlobFields(Value);
    if result and assigned(OnRecordUpdate) then
      OnRecordUpdate(Value);
  end;
end;

function TSQLRestClient.BeforeUpdateEvent(Value: TSQLRecord): Boolean;
begin
  Result := true; // by default, just allow the update to proceed
end;

function TSQLRestClient.Refresh(aID: integer; Value: TSQLRecord;
  var Refreshed: boolean): boolean;
var Resp, Original: RawUTF8;
begin
  result := false;
  if (aID>0) and (self<>nil) and (Value<>nil) then
    if ClientRetrieve(Model.GetTableIndexExisting(PSQLRecordClass(Value)^),aID,False,
       Value.fInternalState,Resp) then begin
      Original := Value.GetJSONValues(IsNotAjaxJSON(pointer(Resp)),true,soSelect);
      Resp := trim(Resp);
      if (Resp<>'') and (Resp[1]='[') then // '[{....}]' -> '{...}'
        Resp := copy(Resp,2,length(Resp)-2);
      if Original<>Resp then begin // did the content really change?
        Refreshed := true;
        Value.FillFrom(Resp);
      end;
      result := true;
    end;
end;

procedure TSQLRestClient.Commit(SessionID: cardinal);
begin
  inherited;
end;

function TSQLRestClient.TransactionBegin(aTable: TSQLRecordClass;
  SessionID: cardinal): boolean;
begin
  result := inherited TransactionBegin(aTable,SessionID);
end;

procedure TSQLRestClient.RollBack(SessionID: cardinal);
begin
  inherited;
end;

function TSQLRestClient.EngineExecuteFmt(SQLFormat: PUTF8Char;
  const Args: array of const): boolean;
begin
  result := EngineExecute(FormatUTF8(SQLFormat,Args));
end;

function TSQLRestClient.EngineExecuteFmt(SQLFormat: PUTF8Char;
  const Args, Bounds: array of const): boolean;
begin
  result := EngineExecute(FormatUTF8(SQLFormat,Args,Bounds));
end;

function TSQLRestClient.ListFmt(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8;
  SQLWhereFormat: PUTF8Char; const Args: array of const): TSQLTableJSON;
begin
  result := List(Tables,SQLSelect,FormatUTF8(SQLWhereFormat,Args));
end;

function TSQLRestClient.ListFmt(const Tables: array of TSQLRecordClass;
  const SQLSelect: RawUTF8; SQLWhereFormat: PUTF8Char;
  const Args, Bounds: array of const): TSQLTableJSON;
begin
  result := List(Tables,SQLSelect,FormatUTF8(SQLWhereFormat,Args,Bounds));
end;

function TSQLRestClient.RTreeMatch(DataTable: TSQLRecordClass;
  const DataTableBlobFieldName: RawUTF8; RTreeTable: TSQLRecordRTreeClass;
  const DataTableBlobField: RawByteString; var DataID: TIntegerDynArray): boolean;
var Blob: PPropInfo;
    Res: TSQLTableJSON;
    B: TSQLRecordTreeCoords;
    Where: RawUTF8;
    Data, RTree: TSQLRecordProperties;
    i: integer;
begin
  result := false;
  if (self=nil) or (DataTable=nil) or (RTreeTable=nil) or (DataTableBlobField='') then
    exit;
  RTree := RTreeTable.RecordProps;
  Data := DataTable.RecordProps;
  Blob :=  Data.BlobFieldPropFromRawUTF8(DataTableBlobFieldName);
  if Blob=nil then
    exit;
  for i := 0 to (RTree.Fields.Count shr 1)-1 do
    Where := FormatUTF8('%% >= :(%): AND % <= :(%): AND ',
      [Where,RTree.Fields.List[i*2].Name,B[i].Min,RTree.Fields.List[i*2+1].Name,
       B[i].Max]);
  RTreeTable.BlobToCoord(DataTableBlobField[1],B);
  Res := ListFmt([DataTable,RTreeTable],Data.SQLTableName+'.RowID',
    'WHERE %.RowID=%.RowID AND %%(%,:(%):);',
      [Data.SQLTableName,RTree.SQLTableName,Where,
       RTreeTable.RTreeSQLFunctionName,Data.SQLTableName,
       BinToBase64WithMagic(DataTableBlobField)]);
  if Res<>nil then
  try
    if (Res.FieldCount<>1) or (Res.RowCount<=0) then
      exit;
    Res.GetRowValues(0,DataID);
    result := true;
  finally
    Res.Free;
  end;
end;


{ TSQLRecordLog }

destructor TSQLRecordLog.Destroy;
begin
  fLogTableWriter.Free;
  fLogTableStorage.Free;
  inherited;
end;

constructor TSQLRecordLog.CreateFrom(OneLog: TSQLRecord; const aJSON: RawUTF8);
var L,FieldCount: integer;
    P: PUTF8Char;
begin
  inherited Create;
  L := length(aJSON);
  if (L<10) or (Copy(aJSON,L-1,2)<>']}') then
    exit;
  fLogTableStorage := THeapMemoryStream.Create;
  fLogTableWriter := OneLog.RecordProps.CreateJSONWriter(
    fLogTableStorage,false,true,ALL_ACCESS_RIGHTS,0);
  fLogTableWriter.Flush;
  P := pointer(aJSON);
  if not CompareMem(fLogTableStorage.Memory,P,fLogTableStorage.Position) or
     not IsNotExpandedBuffer(P,P+length(aJSON),FieldCount,fLogTableRowCount) or
     (fLogTableRowCount<0) then begin
    // field format changed or invalid
    FreeAndNil(fLogTableWriter);
    FreeAndNil(fLogTableStorage);
    exit;
  end;
  fLogTableStorage.Seek(0,soFromBeginning);
  fLogTableStorage.Write(Pointer(aJSON)^,L-2);
end;

procedure TSQLRecordLog.Log(OneLog: TSQLRecord);
begin
  if OneLog=nil then
    exit;
  // simulate adding a row: compute new ID
  inc(OneLog.fID);
  // adding a row, in not-expanded format
  if not Assigned(fLogTableStorage) then begin
    fLogTableStorage := THeapMemoryStream.Create;
    fLogTableWriter := OneLog.RecordProps.CreateJSONWriter(
      fLogTableStorage,false,true,ALL_ACCESS_RIGHTS,0);
    fLogTableRowCount := 1;
  end else begin
    fLogTableWriter.Add(',');
    if (fMaxLogTableRowCount<>0) and (fLogTableRowCount>=fMaxLogTableRowCount) then
      fLogTableWriter.TrimFirstRow else
      inc(fLogTableRowCount);
  end;
  OneLog.GetJSONValues(fLogTableWriter)
end;

function TSQLRecordLog.LogCurrentPosition: integer;
begin
  if not Assigned(fLogTableStorage) then
    result := 0 else begin
    fLogTableWriter.Flush;
    result := fLogTableStorage.Position;
  end;
end;

function TSQLRecordLog.LogTableJSON: RawUTF8;
begin
  result := LogTableJSONFrom(0);
end;

function TSQLRecordLog.LogTableJSONFrom(StartPosition: integer): RawUTF8;
var JSONStart: RawUTF8;
    Data: PAnsiChar;
begin
  if not Assigned(fLogTableStorage) or (StartPosition<0) then
    result := '' else begin
    fLogTableWriter.Flush;
    Data := fLogTableStorage.Memory;
    SetRawUTF8(result,Data+StartPosition,fLogTableStorage.Position-StartPosition);
    // format as valid not expanded JSON table content:
    if StartPosition<>0 then begin
      SetRawUTF8(JSONStart,Data,fLogTableWriter.StartDataPosition);
      result := JSONStart+result;
    end;
    result := result+']}';
  end;
end;


{ RecordRef }

function RecordReference(Model: TSQLModel; aTable: TSQLRecordClass; aID: integer): TRecordReference;
begin
  if aID=0 then
    result := 0 else begin
    result := Model.GetTableIndexExisting(aTable);
    if result>63 then // TRecordReference handle up to 64=1 shl 6 tables
      result := 0 else
      inc(result,aID shl 6); // 64=1 shl 6
  end;
end;

procedure RecordRefToID(var aArray: TPtrUIntDynArray);
var i: Integer;
begin
  for i := 0 to high(aArray) do
    aArray[i] := aArray[i] shr 6;
end;

procedure RecordRef.From(Model: TSQLModel; aTable: TSQLRecordClass; aID: integer);
begin
  Value := Model.GetTableIndexExisting(aTable);
  if Value>63 then // TRecordReference handle up to 64=1 shl 6 tables
    Value := 0 else
    inc(Value,aID shl 6); // 64=1 shl 6
end;

function RecordRef.ID: integer;
begin
  result := Value shr 6;  // 64=1 shl 6
end;

function RecordRef.Table(Model: TSQLModel): TSQLRecordClass;
var V: integer;
begin
  if (Model=nil) or (Value=0) then
    result := nil else begin
    V := Value and 63;
    if V>high(Model.Tables) then
      result := nil else
      result := Model.Tables[V];
  end;
end;

function RecordRef.TableIndex: integer;
begin
  result := Value and 63;
end;

function RecordRef.Text(Model: TSQLModel): RawUTF8;
var aTable: TSQLRecordClass;
begin
  if ((Value shr 6)=0) then
    // Value=0 or no valid ID
    result := '' else begin
    aTable := Table(Model);
    if aTable=nil then
      result := '' else
      result := Model.TableProps[Value and 63].Props.SQLTableName+' '+
        {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(Value shr 6);
  end;
end;

function RecordRef.Text(Rest: TSQLRest): RawUTF8;
var T: TSQLRecordClass;
    aID: integer;
begin
  result := '';
  if ((Value shr 6)=0) or (Rest=nil) then
    exit;
  T := Table(Rest.Model);
  if T=nil then
    exit;
  aID := ID;
  with Rest.Model.TableProps[Value and 63].Props do
  if aID<=0 then
    result := SQLTableName else begin
    result := Rest.MainFieldValue(T,aID,true);
    if result='' then
      result := FormatUTF8('% %',[SQLTableName,aID]) else
      result := FormatUTF8('% "%"',[SQLTableName,result]);
  end;
end;


{ TSQLLocks }

function TSQLLocks.isLocked(aID: integer): boolean;
begin
  result := (@self<>nil) and (Count<>0) and (aID<>0) and
    IntegerScanExists(pointer(IDs),Count,aID);
end;

function TSQLLocks.Lock(aID: integer): boolean;
var P: PCardinal;
begin
  if (@self=nil) or (aID=0) then
    // void or full
    result := false else begin
    P := IntegerScan(pointer(IDs),Count,aID);
    if P<>nil then
      // already locked
      result := false else begin
      // add to ID[] and Ticks[]
      P := IntegerScan(pointer(IDs),Count,0);
      if P=nil then begin
        // no free entry -> add at the end
        if Count>=length(IDs) then begin
          SetLength(IDs,Count+512);
          SetLength(Ticks64s,Count+512);
        end;
        IDs[Count] := aID;
        Ticks64s[Count] := GetTickCount64;
        inc(Count);
      end else begin
        // store at free entry
        P^ := aID;
        Ticks64s[(PtrUInt(P)-PtrUInt(IDs))shr 2] := GetTickCount64;
      end;
      result := true;
    end;
  end;
end;

procedure TSQLLocks.PurgeOlderThan(MinutesFromNow: cardinal);
var LastOK64: Int64;
    i, LastEntry: integer;
begin
  if (@self=nil) or (Count=0) then
    exit; // nothing to purge
  LastOK64 := GetTickCount64-MinutesFromNow*(1000*60); // GetTickCount64() unit is ms
  LastEntry := -1;
  for i := 0 to Count-1 do
    if IDs[i]<>0 then
    if Ticks64s[i]<LastOK64 then // too old?
      IDs[i] := 0 else // 0 frees entry
      LastEntry := i; // refresh last existing entry
  Count := LastEntry+1; // update count (may decrease list length)
end;

function TSQLLocks.UnLock(aID: integer): boolean;
var P: PCardinal;
begin
  if (@self=nil) or (Count=0) or (aID=0) then
    result := false else begin
    P := IntegerScan(pointer(IDs),Count,aID);
    if P=nil then
      result := false else begin
      P^ := 0; // 0 marks free entry
      if ((PtrUInt(P)-PtrUInt(IDs))shr 2>=PtrUInt(Count-1)) then
        dec(Count); // freed last entry -> decrease list length
      result := true;
    end;
  end;
end;

procedure CopyObject(aFrom, aTo: TObject);
var P: PPropInfo;
    i: integer;
    C: TClass;
    CP: PClassProp;
label I64;
begin
  if (aFrom=nil) or (aTo=nil) then
    exit;
  {$ifndef LVCL}
  if aFrom.InheritsFrom(TCollection) then begin
    CopyCollection(TCollection(aFrom),TCollection(aTo));
    exit;
  end;
  {$endif}
  C := PPointer(aFrom)^;
  if aTo.InheritsFrom(C) then
  while C<>nil do begin
    CP := InternalClassProp(C);
    if CP=nil then
      break; // no more RTTI information available
    P := @CP^.PropList;
    for i := 1 to CP^.PropCount do begin
      P^.CopyValue(aFrom,aTo); // shortstring not handled
      P := P^.Next;
    end;
    C := C.ClassParent;
  end;
end;

{$ifndef LVCL}
procedure CopyCollection(Source, Dest: TCollection);
var i: integer;
begin
  if (Source=nil) or (Dest=nil) or (Source.ClassType<>Dest.ClassType) then
    exit;
  Dest.BeginUpdate;
  try
    Dest.Clear;
    for i := 0 to Source.Count-1 do
      CopyObject(Source.Items[i],Dest.Add); // Assign() fails
  finally
    Dest.EndUpdate;
  end;
end;
{$endif}

procedure WriteObject(Value: TObject; var IniContent: RawUTF8; const Section: RawUTF8;
  const SubCompName: RawUTF8=''); overload;
var P: PPropInfo;
    i, V: integer;
{$ifdef UNICODE}
    VV: RawUTF8;
{$endif}
    Obj: TObject;
    CP: PClassProp;
begin
  if Value=nil then
    exit;
  CP := InternalClassProp(PPointer(Value)^);
  if CP=nil then
    exit; // no RTTI available
  P := @CP^.PropList;
  for i := 1 to CP^.PropCount do begin
    case P^.PropType^^.Kind of
      tkInt64{$ifdef FPC}, tkQWord{$endif}:
        UpdateIniEntry(IniContent,Section,SubCompName+RawUTF8(P^.Name),
          {$ifndef ENHANCEDRTL}Int64ToUtf8{$else}IntToStr{$endif}(
            GetInt64Prop(Value,pointer(P))));
      {$ifdef FPC}tkBool,{$endif} tkEnumeration, tkSet, tkInteger: begin
        V := GetOrdProp(Value,pointer(P)); // pointer() to call typinfo
        //if V<>P^.Default then NO DEFAULT: update INI -> must override previous
        UpdateIniEntry(IniContent,Section,SubCompName+RawUTF8(P^.Name),
          {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(V));
      end;
      {$ifdef FPC}tkAString,{$endif} tkLString:
        UpdateIniEntry(IniContent,Section,SubCompName+RawUTF8(P^.Name),
          P^.GetLongStrValue(Value));
      {$ifdef UNICODE}
      tkUString: begin
        VV := UnicodeStringToUtf8(GetUnicodeStrProp(Value,pointer(P)));
        UpdateIniEntry(IniContent,Section,SubCompName+RawUTF8(P^.Name),VV);
      end;
      {$endif}
      tkClass:
      if Section='' then begin // recursive call works only as plain object
        Obj := pointer(GetOrdProp(Value,pointer(P)));  // GetOrdProp() is OK for CPU64
        if (Obj<>nil) and Obj.InheritsFrom(TPersistent) then
          WriteObject(Value,IniContent,Section,SubCompName+RawUTF8(P^.Name)+'.');
      end;
      // tkString (shortstring) and tkWString are not handled
    end;
    P := P^.Next;
  end;
end;

function WriteObject(Value: TObject): RawUTF8; overload;
begin
  if Value<>nil then
    with TIniWriter.CreateOwnedStream do
    try
      WriteObject(Value,'');
      SetText(result);
    finally
      Free;
    end else
    result := '';
end;

function ObjectToJSON(Value: TObject; Options: TTextWriterWriteObjectOptions): RawUTF8;
begin
  with TJSONSerializer.CreateOwnedStream do
  try
    WriteObject(Value,Options);
    SetText(result);
  finally
    Free;
  end;
end;

function UrlEncode(const NameValuePairs: array of const): RawUTF8;
// (['select','*','where','ID=12','offset',23,'object',aObject]);
var A, n: PtrInt;
    name, value: RawUTF8;
  function Invalid(P: PAnsiChar): boolean;
  begin
    result := true;
    if P<>nil then begin
      repeat
        if not (P^ in ['a'..'z','A'..'Z']) then
          exit else
          inc(P);
      until P^=#0;
      result := false;
    end;
  end;
begin
  result := '';
  n := high(NameValuePairs);
  if n>0 then begin
    for A := 0 to n shr 1 do begin
      VarRecToUTF8(NameValuePairs[A*2],name);
      if Invalid(pointer(name)) then
        continue;
      with NameValuePairs[A*2+1] do
        if VType=vtObject then
          value := ObjectToJSON(VObject,[]) else
          VarRecToUTF8(NameValuePairs[A*2+1],value);
      result := result+'&'+name+'='+UrlEncode(value);
    end;
    result[1] := '?';
  end;
end;

var
  JSONCustomParsers: array of record
    Kind: TClass;
    Reader: TJSONSerializerCustomReader;
    Writer: TJSONSerializerCustomWriter;
  end;

type
  TJSONCustomParserExpectedDirection = (cpRead, cpWrite);
  TJSONCustomParserExpectedDirections = set of TJSONCustomParserExpectedDirection;

function JSONCustomParsersIndex(aClass: TClass;
  aExpectedReadWriteTypes: TJSONCustomParserExpectedDirections): integer;
    {$ifdef HASINLINE}inline;{$endif}
begin
  if JSONCustomParsers<>nil then
    for result := 0 to length(JSONCustomParsers)-1 do
      with JSONCustomParsers[result] do
      if Kind=aClass then
        if ((cpRead in aExpectedReadWriteTypes) and not Assigned(Reader)) or
           ((cpWrite in aExpectedReadWriteTypes) and not Assigned(Writer)) then
          break // any (un)serializer callbacks missing
        else
          exit; // found with appropriate (un)serializers callbacks
  result := -1;
end;

class procedure TJSONSerializer.RegisterCustomSerializer(aClass: TClass;
  aReader: TJSONSerializerCustomReader; aWriter: TJSONSerializerCustomWriter);
var i: integer;
begin
  i := JSONCustomParsersIndex(aClass,[]);
  if i<0 then begin
    i := length(JSONCustomParsers);
    SetLength(JSONCustomParsers,i+1);
  end;
  with JSONCustomParsers[i] do begin
    Kind := aClass;
    Writer := aWriter;
    Reader := aReader;
  end;
end;

type
  TJSONSerializerRegisteredClassAbstract = class(TList)
  protected
    LastClass: TClass;
    Lock: TRTLCriticalSection;
  public
    constructor Create;
    destructor Destroy; override;
  end;

  TJSONSerializerRegisteredClass = class(TJSONSerializerRegisteredClassAbstract)
  protected
  public
    procedure AddOnce(aItemClass: TClass);
    function Find(JSON: PUTF8Char; AndRegisterClass: boolean): TClass; overload;
    function Find(aClassName: PUTF8Char; aClassNameLen: integer): TClass; overload;
  end;

constructor TJSONSerializerRegisteredClassAbstract.Create;
begin
  InitializeCriticalSection(Lock);
end;

destructor TJSONSerializerRegisteredClassAbstract.Destroy;
begin
  DeleteCriticalSection(Lock);
  inherited;
end;

function TJSONSerializerRegisteredClass.Find(JSON: PUTF8Char; AndRegisterClass: boolean): TClass;
var ClassNameValue: PUTF8Char;
    ClassNameLen: integer;
begin // at input, JSON^='{'
  result := nil;
  if self<>nil then
  try
    EnterCriticalSection(Lock);
    JSON := JSONRetrieveStringField(JSON+1,ClassNameValue,ClassNameLen,true);
    if (JSON=nil) or not IdemPropName('ClassName',ClassNameValue,ClassNameLen) then
      exit; // we expect woStoreClassName option to have been used
    repeat inc(JSON) until not(JSON^ in [#1..' ']);
    if JSONRetrieveStringField(JSON,ClassNameValue,ClassNameLen,false)=nil then
      exit; //invalid JSON string value
    if (LastClass<>nil) and
       IdemPropName(PShortString(PPointer(PtrInt(LastClass)+vmtClassName)^)^,
       ClassNameValue,ClassNameLen) then begin
      result := LastClass; // for speed-up e.g. within a loop
      exit;
    end;
    result := Find(ClassNameValue,ClassNameLen);
    if result=nil then begin // not registered here -> try from Classes.pas
      {$ifndef LVCL}
      if AndRegisterClass then
        result := FindClass(UTF8DecodeToString(ClassNameValue,ClassNameLen));
      if result=nil then
      {$endif}
        exit; // unknown type
    end;
    LastClass  := result;
  finally
    LeaveCriticalSection(Lock)
  end;
end;

procedure TJSONSerializerRegisteredClass.AddOnce(aItemClass: TClass);
var i: integer;
begin
  try
    EnterCriticalSection(Lock);
    for i := 0 to Count-1 do
      if List[i]=aItemClass then
        exit; // already registered
    Add(aItemClass);
  finally
    LeaveCriticalSection(Lock)
  end;
end;

function TJSONSerializerRegisteredClass.Find(aClassName: PUTF8Char; aClassNameLen: integer): TClass;
var i: integer;
begin
  result := nil;
  try
    EnterCriticalSection(Lock);
    for i := 0 to Count-1 do
      // new TObject.ClassName is UnicodeString (since Delphi 20009) -> inline code
      // with vmtClassName = UTF-8 encoded text stored in a shortstring = -44
      if IdemPropName(PShortString(PPointer(PtrInt(List[i])+vmtClassName)^)^,
         aClassName,aClassNameLen) then begin
        result := List[i];
        exit;
      end;
  finally
    LeaveCriticalSection(Lock)
  end;
end;


{$ifndef LVCL}
type
  TJSONSerializerRegisteredCollection = class(TJSONSerializerRegisteredClassAbstract)
  protected
  public
    procedure AddOnce(aCollection: TCollectionClass; aItem: TCollectionItemClass);
    function Find(aCollClassName: PUTF8Char; aCollClassNameLen: integer): TCollectionItemClass; overload;
    function Find(aCollection: TCollectionClass): TCollectionItemClass; overload;
  end;

function TJSONSerializerRegisteredCollection.Find(aCollection: TCollectionClass): TCollectionItemClass;
var i: integer;
begin
  result := nil;
  if self<>nil then
    try
      EnterCriticalSection(Lock);
      for i := 0 to (Count shr 1)-1 do
        if List[i*2]=aCollection then begin
          result := List[i*2+1];
          exit;
        end;
    finally
      LeaveCriticalSection(Lock)
    end;
end;

procedure TJSONSerializerRegisteredCollection.AddOnce(aCollection: TCollectionClass; aItem: TCollectionItemClass);
begin
  if Find(aCollection)=nil then
    try
      EnterCriticalSection(Lock);
      Add(aCollection);
      Add(aItem);
    finally
      LeaveCriticalSection(Lock)
    end;
end;

function TJSONSerializerRegisteredCollection.Find(aCollClassName: PUTF8Char;
  aCollClassNameLen: integer): TCollectionItemClass;
var i: integer;
begin
  result := nil;
  try
    EnterCriticalSection(Lock);
    for i := 0 to (Count shr 1)-1 do
      // new TObject.ClassName is UnicodeString (since Delphi 20009) -> inline code
      // with vmtClassName = UTF-8 encoded text stored in a shortstring = -44
      if IdemPropName(PShortString(PPointer(PtrInt(List[i*2])+vmtClassName)^)^,
         aCollClassName,aCollClassNameLen) then begin
        result := List[i*2+1];
        exit;
      end;
  finally
    LeaveCriticalSection(Lock)
  end;
end;

var
  JSONSerializerRegisteredCollection: TJSONSerializerRegisteredCollection=nil;

class procedure TJSONSerializer.RegisterCollectionForJSON(aCollection: TCollectionClass;
  aItem: TCollectionItemClass);
begin
  if JSONSerializerRegisteredCollection=nil then
    GarbageCollectorFreeAndNil(JSONSerializerRegisteredCollection,
      TJSONSerializerRegisteredCollection.Create);
  JSONSerializerRegisteredCollection.AddOnce(aCollection,aItem);
  RegisterClassForJSON([aCollection,aItem]);
end;

{$endif LVCL}

var
  JSONSerializerRegisteredClass: TJSONSerializerRegisteredClass=nil;

class procedure TJSONSerializer.RegisterClassForJSON(aItemClass: TClass);
begin
  if JSONSerializerRegisteredClass=nil then
    GarbageCollectorFreeAndNil(JSONSerializerRegisteredClass,
      TJSONSerializerRegisteredClass.Create);
  JSONSerializerRegisteredClass.AddOnce(aItemClass);
end;

class procedure TJSONSerializer.RegisterClassForJSON(const aItemClass: array of TClass);
var i: integer;
begin
  for i := 0 to high(aItemClass) do
    RegisterClassForJSON(aItemClass[i]);
end;


function ClassInstanceCreate(aClass: TClass): TObject;
var C: TClass;
begin // guess constructor to be used (faster than multiple InheritsFrom calls)
  C := aClass;
  result := nil;
  if aClass<>nil then
  repeat
    if C<>TSQLRecord then
    if C<>TObjectList then
    if C<>TPersistentWithCustomCreate then
  {$ifndef LVCL}
    if C<>TInterfacedCollection then
    if C<>TCollection then
  {$endif}
    if PPointer(PtrInt(C)+vmtParent)^<>nil then begin
      C := PPointer(PPointer(PtrInt(C)+vmtParent)^)^;
      if C<>nil then
        continue else
        result := aClass.Create;
    end else
      result := aClass.Create else
  {$ifndef LVCL}
    begin // plain TCollection shall have been registered
      C := JSONSerializerRegisteredCollection.Find(TCollectionClass(aClass));
      if C<>nil then
        result := TCollectionClass(aClass).Create(TCollectionItemClass(C)) else
        raise EParsingException.CreateFmt('%s shall inherit from '+
         'TInterfacedCollection or call TJSONSerializer.RegisterCollectionForJSON()',
         [PShortString(PPointer(PtrInt(aClass)+vmtClassName)^)^]);
    end else
      result := TInterfacedCollectionClass(aClass).Create else
  {$endif}
      result := TPersistentWithCustomCreateClass(aClass).Create else
      result := TObjectList.Create else
      result := TSQLRecordClass(aClass).Create;
    break;
  until false;
end;

function ClassInstanceCreate(const aClassName: RawUTF8): TObject;
var C: TClass;
begin
  if JSONSerializerRegisteredClass=nil then
    C := nil else
    C := JSONSerializerRegisteredClass.Find(Pointer(aClassName),length(aClassName));
  {$ifndef LVCL}
  if C=nil then
    C := FindClass(UTF8ToString(aClassName));
  {$endif}
  result := ClassInstanceCreate(C);
end;

function JSONToNewObject(var From: PUTF8Char; var Valid: boolean;
  Options: TJSONToObjectOptions=[]): TObject;
var ItemClass: TClass;
begin
  Valid := false;
  result := nil;
  if From=nil then
    exit;
  while From^ in [#1..' '] do inc(From);
  if PInteger(From)^=NULL_LOW then begin
    Valid := true;
    exit;
  end;
  if From^<>'{' then
    exit; // input should be either null, either {"ClassName":"TMyClass",...}
  ItemClass := JSONSerializerRegisteredClass.Find(From,true);
  if ItemClass=nil then
    exit; // unknown type
  result := ClassInstanceCreate(ItemClass);
  From := JSONToObject(result,From,Valid,nil,Options);
  if not Valid then
    FreeAndNil(result); // avoid memory leak
end;

type
  TJSONObject =
    (oNone, oList, oObjectList, {$ifndef LVCL}oCollection,{$endif}
     oUtfs, oStrings, oSQLRecord, oSQLMany, oPersistent, oCustom);

function JSONObject(aClassType: TClass; out aCustomIndex: integer;
  aExpectedReadWriteTypes: TJSONCustomParserExpectedDirections): TJSONObject;
begin
  // guess class type (faster than multiple InheritsFrom calls)
  result := oNone;
  repeat
    if aClassType<>TList then
    if aClassType<>TObjectList then
    if aClassType<>TPersistent then
    if aClassType<>TSQLRecordMany then
    if aClassType<>TSQLRecord then
    if aClassType<>TStrings then
    if aClassType<>TRawUTF8List then
{$ifndef LVCL}
    if aClassType<>TCollection then
{$endif} begin
      aCustomIndex := JSONCustomParsersIndex(aClassType,aExpectedReadWriteTypes);
      if aCustomIndex<0 then
        if PPointer(PtrInt(aClassType)+vmtParent)^<>nil then begin
          aClassType := PPointer(PPointer(PtrInt(aClassType)+vmtParent)^)^;
          if aClassType<>nil then
            continue else
            break;
        end else
        break else
      result := oCustom;
    end else
{$ifndef LVCL}
      result := oCollection else
{$endif}
      result := oUtfs else
      result := oStrings else
      result := oSQLRecord else
      result := oSQLMany else
      result := oPersistent else
      result := oObjectList else
      result := oList;
    break;
  until false;
end;

function JSONToObject(var ObjectInstance; From: PUTF8Char; var Valid: boolean;
  TObjectListItemClass: TClass; Options: TJSONToObjectOptions): PUTF8Char;
var P: PPropInfo;
    Value: TObject absolute ObjectInstance;
{$ifndef LVCL}
    Coll: TCollection absolute ObjectInstance;
    CollItem: TObject;
{$endif}
    Str: TStrings absolute ObjectInstance;
    Utf: TRawUTF8List absolute ObjectInstance;
    Lst: TObjectList absolute ObjectInstance;
    Item: TObject;
    ItemClass: TClass;
    V: PtrInt;
    ndx,err: integer;
    E: extended;
    V64: Int64 absolute E;
    Obj: TObject absolute V;
    PropName: PUTF8Char;
    PropValue: PUTF8Char;
    EndOfObject: AnsiChar;
    Kind: TTypeKind;
    wasString, NestedValid: boolean;
    IsObj: TJSONObject;
    IsObjCustomIndex: integer;
    WS: WideString;
    {$ifndef NOVARIANTS}
    VVariant: variant;
    DocVariantOptionsSet: TDocVariantOptions;
    {$endif}
begin
  Valid := false;
  result := From;
  if (Value=nil) or (PPointer(Value)^=nil) then
    exit;
  IsObj := JSONObject(PPointer(Value)^,IsObjCustomIndex,[cpRead]); 
  if From=nil then begin
    case IsObj of // handle '' as Clear for arrays
{$ifndef LVCL}
    oCollection: Coll.Clear;
{$endif}
    oStrings:    Str.Clear;
    oUTfs:       Utf.Clear;
    oObjectList: Lst.Clear;
    end;
    exit;
  end;
  if PInteger(From)^=NULL_LOW then begin
    if (IsObj=oCustom) and Assigned(JSONCustomParsers[IsObjCustomIndex].Reader) then
      // custom JSON reader expects to be executed even if value is null
      result := JSONCustomParsers[IsObjCustomIndex].Reader(Value,From,Valid,Options) else begin
      FreeAndNil(Value);
      result := From+4;
      Valid := true; // null is a valid JSON object
    end;
    exit;
  end;
  while From^ in [#1..' '] do inc(From);
  if IsObj=oCustom then
  with JSONCustomParsers[IsObjCustomIndex] do begin
    if Assigned(Reader) then // leave Valid=false if Reader=nil
      result := Reader(Value,From,Valid,Options);
    exit;
  end;
  if From^='[' then begin
    // nested array = TObjectList, TCollection, TRawUTF8List or TStrings
    inc(From);
    case IsObj of
    oObjectList: begin // TList leaks memory, but TObjectList uses "ClassName":..
      Lst.Clear;
      repeat
        while From^ in [#1..' '] do inc(From);
        case From^ of
        #0: exit;
        ']': begin
          inc(From);
          break;
        end;
        ',':
          inc(From); // valid delimiter between objects
        '{': begin
          result := From;
          if TObjectListItemClass=nil then begin // recognize "ClassName":...
            ItemClass := JSONSerializerRegisteredClass.Find(From,true);
            if ItemClass=nil then
              exit; // unknown type
            Item := ClassInstanceCreate(ItemClass);
          end else
            Item := ClassInstanceCreate(TObjectListItemClass);
          From := JSONToObject(Item,From,NestedValid);
          if not NestedValid then begin
            result := From;
            exit;
          end else
          if From=nil then
            exit;
          Lst.Add(Item);
        end;
        else exit;
        end;
      until false;
      // only way of being here is to have an ending ] at expected place
      Valid := true;
    end;
{$ifndef LVCL}
    oCollection: begin
      Coll.BeginUpdate;  // Coll: TCollection absolute Value
      try
        Coll.Clear;
        repeat
          while From^ in [#1..' '] do inc(From);
          case From^ of
          #0: exit;
          ']': begin
            inc(From);
            break;
          end;
          ',':
            inc(From); // valid delimiter between objects
          '{': begin
            result := From;
            CollItem := Coll.Add;
            From := JSONToObject(CollItem,From,NestedValid);
            if not NestedValid then begin
              result := From;
              exit;
            end else
            if From=nil then
              exit;
          end;
          else exit;
          end;
        until false;
        // only way of being here is to have an ending ] at expected place
        Valid := true;
      finally
        Coll.EndUpdate;
      end;
    end;
{$endif}
    oStrings: begin
{$ifndef LVCL}
      Str.BeginUpdate; // Str: TStrings absolute Value
      try
{$endif}
        Str.Clear;
        repeat
          while From^ in [#1..' '] do inc(From);
          case From^ of
          #0: exit;
          ']': begin
            inc(From);
            break;
          end;
          '"': begin
            result := From;
            PropValue := GetJSONField(From,From,@wasString,@EndOfObject);
            if (PropValue=nil) or not wasString then
              exit;
            Str.Add(UTF8DecodeToString(PropValue,StrLen(PropValue)));
            case EndOfObject of
              ']': break;
              ',': continue;
              else exit;
            end;
          end;
          else exit;
          end;
        until false;
        Valid := true;
{$ifndef LVCL}
      finally
        Str.EndUpdate;
      end;
{$endif}
    end;
    oUtfs: begin
      utf.BeginUpdate; // utf: TStrings absolute Value
      try
        utf.Clear;
        repeat
          while From^ in [#1..' '] do inc(From);
          case From^ of
          #0: exit;
          ']': begin
            inc(From);
            break;
          end;
          '"': begin
            result := From;
            PropValue := GetJSONField(From,From,@wasString,@EndOfObject);
            if (PropValue=nil) or not wasString then
              exit;
            utf.Add(PropValue);
            case EndOfObject of
              ']': break;
              ',': if From=nil then exit else continue;
              else exit;
            end;
          end;
          else exit;
          end;
        until false;
        Valid := true;
      finally
        utf.EndUpdate;
      end;
    end;
    end; // case IsObj of
    // Valid=false if not TCollection, TRawUTF8List nor TStrings
    if Valid and (From<>nil) then begin
      while From^ in [#1..' '] do inc(From);
      if From^=#0 then
        From := nil;
    end;
    result := From;
    exit; // a JSON array begin with [
  end else
  if From^<>'{' then begin
    result := From;
    exit; // a JSON object MUST begin with {
  end;
  repeat inc(From) until (From^=#0) or (From^>' ');
  EndOfObject := #0;
  if From^='}' then begin
    // empty JSON object like {} (e.g. all properties having default values)
    EndOfObject := '}';
    Inc(From);
  end else
  repeat
    wasString := false;
    result := From;
    PropName := GetJSONPropName(From);  // get property name
    if (From=nil) or (PropName='') then
      exit; // invalid JSON content
    if IdemPropName('ClassName',PropName,StrLen(PropName)) then begin
      // WriteObject() was called with woStoreClassName option -> handle it
      PropValue := GetJSONField(From,From,@wasString,@EndOfObject);
      if (PropValue=nil) or (not wasString) or not (EndOfObject in ['}',',']) then
        exit; // invalid JSON content
      continue; // just ignore the field here
    end;
    if (IsObj in [oSQLRecord,oSQLMany]) and IsRowID(PropName) then begin
      // manual handling of TSQLRecord.ID property unserialization
      PropValue := GetJSONField(From,From,@wasString,@EndOfObject); 
      if (PropValue=nil) or wasString or not (EndOfObject in ['}',',']) then
        exit; // invalid JSON content
      V := GetInteger(PropValue,err);
      if err<>0 then
        exit;
      TSQLRecord(Value).fID := V;
      continue;
    end;
    P := ClassFieldPropWithParentsFromUTF8(PPointer(Value)^,PropName);
    if P=nil then // unknwown property
      if j2oIgnoreUnknownProperty in Options then begin
        From := GotoNextJSONItem(From,1,@EndOfObject);
        continue;
      end else
        exit; // by default, abort
    Kind := P^.PropType^^.Kind;
    while From^ in [#1..' '] do inc(From);
    result := From;
    if PInteger(result)^=NULL_LOW then begin
      // nested null object
      if (IsObj in [oSQLRecord,oSQLMany]) or (Kind<>tkClass) then
        exit; // null expect a plain TObject
      V := GetOrdProp(Value,pointer(P));
      if Obj<>nil then begin
        // null -> FreeAndNil(Obj)
        Obj.Free;
        SetOrdProp(Value,pointer(P),0);
      end;
    end else
    if From^ in ['[','{'] then begin
      // nested array or object
      if Kind=tkDynArray then begin
        From := P^.GetDynArray(Value).LoadFromJSON(From);
        if From=nil then
          exit; // invalid '[dynamic array]' content
      end else
      if (Kind=tkSet) and (From^='[') then begin // set as string array
        repeat inc(From) until not (From^ in [#1..' ']);
        V := 0;
        EndOfObject := From^;
        with P^.PropType^^.SetEnumType^ do
        while EndOfObject<>']' do begin
          PropValue := GetJSONField(From,From,@wasString,@EndOfObject);
          if (PropValue=nil) or (not wasString) then
            exit;
          if PropValue^='*' then begin
            if MaxValue<32 then
              V := ALLBITS_CARDINAL[MaxValue+1] else
              V := -1;
            break;
          end;
          ndx := GetEnumNameValue(PropValue);
          if ndx<0 then
            exit; // invalid enum string value
          SetBit(V,ndx);
        end;
        SetOrdProp(Value,pointer(P),V);
      end else begin
        if Kind<>tkClass then
          exit; // true nested object should begin with '[' or '{' 
        if (IsObj in [oSQLRecord,oSQLMany]) and
           (P^.PropType^^.ClassSQLFieldType=sftID) and
           not TSQLRecord(Value).fFill.JoinedFields then
          exit; // only TSQLRecordMany properties are true instances  
        // will handle '[TCollection...' '[TStrings...' '{TObject...'
        From := P^.ClassFromJSON(Value,From,NestedValid,Options);
        if not NestedValid then begin
          result := From;
          exit;
        end else
        if From=nil then
          exit; // invalid JSON content: we expect at least a last '}'
      end;
      while From^ in [#1..' '] do inc(From);
      EndOfObject := From^;
      if From^ in EndOfJSONField then
        inc(From);
    end else begin
      // normal property value
      PropValue := GetJSONFieldOrObjectOrArray(From,@wasString,@EndOfObject); // get value
      if (PropValue=nil) or not (EndOfObject in ['}',',']) then
        exit; // invalid JSON content
      case Kind of
      tkInt64{$ifdef FPC}, tkQWord{$endif}:
        if wasString then
          exit else begin
          V64 := GetInt64(PropValue,err);
          if err<>0 then
            exit;
          SetInt64Prop(Value,pointer(P),V64);
        end;
      tkClass: begin
        if wasString or (P^.PropType^^.ClassSQLFieldType<>sftID) then
          exit; // should have been handled above
        V := GetInteger(PropValue,err);
        if err<>0 then
          exit; // invalid value
        SetOrdProp(Value,pointer(P),V);
      end;
      tkEnumeration: begin
        if wasString then begin // in case enum stored as string
          V := P^.PropType^^.EnumBaseType^.GetEnumNameValue(PropValue);
          if V<0 then
            exit;
        end else begin
          V := GetInteger(PropValue,err);
          if err<>0 then
            exit; // invalid value
        end;
        SetOrdProp(Value,pointer(P),V);
      end;
      {$ifdef FPC} tkBool, {$endif}
      tkInteger, tkSet:
        if wasString then
          exit else begin
          // From='true' or From='false' were converted into '1 or '0'
          V := GetInteger(PropValue,err);
          if err<>0 then
            exit; // invalid value
          SetOrdProp(Value,pointer(P),V);
        end;
      {$ifdef FPC}tkAString,{$endif} tkLString:
        if not wasString then
          exit else
          P^.SetLongStrValue(Value,RawUTF8(PropValue));
      {$ifdef UNICODE}
      tkUString:
        if not wasString then
          exit else
          SetUnicodeStrProp(Value,pointer(P),UTF8DecodeToUnicodeString(PropValue,StrLen(PropValue)));
      {$endif}
      tkWString:
        if not wasString then
          exit else begin
          UTF8ToWideString(PropValue,StrLen(PropValue),WS);
          SetWideStrProp(Value,pointer(P),WS);
        end;
      {$ifdef PUBLISHRECORD}
      tkRecord:
        if not wasString then
          exit else
          RecordLoadJSON(P^.GetFieldAddr(Value)^,PropValue,P^.PropType^);
      {$endif}
      {$ifndef NOVARIANTS}
      tkVariant: begin
        if j2oHandleCustomVariants in Options then begin
          if j2oHandleCustomVariantsWithinString in Options then
            DocVariantOptionsSet := [dvoValueCopiedByReference,dvoJSONObjectParseWithinString] else
            DocVariantOptionsSet := [dvoValueCopiedByReference];
          GetVariantFromJSON(PropValue,wasString,VVariant,@DocVariantOptionsSet);
        end else
          GetVariantFromJSON(PropValue,wasString,VVariant);
        SetVariantProp(Value,P,VVariant);
      end;
      {$endif}
      tkFloat:
        if P^.PropType^=TypeInfo(TDateTime) then
          if wasString then
            SetFloatProp(Value,pointer(P),Iso8601ToDateTimePUTF8Char(PropValue,0)) else
            exit else
        if wasString then
          exit else
        if (P^.PropType^=TypeInfo(Currency)) and (PropWrap(P^.SetProc).Kind=$ff) then
          SetInt64Prop(Value,pointer(P),StrToCurr64(PropValue)) else begin
          E := GetExtended(pointer(PropValue),err);
          if err<>0 then
            exit else // invalid JSON content
            SetFloatProp(Value,pointer(P),E);
        end;
      end;
    end;
  until (From=nil) or (EndOfObject='}');
  if From<>nil then begin
    while From^ in [#1..' '] do inc(From);
    if From^=#0 then
      From := nil;
  end;
  Valid := (EndOfObject='}'); // mark parsing success
  result := From;
end;

function UrlDecodeObject(U: PUTF8Char; Upper: PAnsiChar; var ObjectInstance;
  Next: PPUTF8Char=nil; Options: TJSONToObjectOptions=[]): boolean;
var tmp: RawUTF8;
begin
  result := UrlDecodeValue(U, Upper, tmp, Next);
  if result then
    JSONToObject(ObjectInstance,Pointer(tmp),result,nil,Options);
end;

function JSONFileToObject(const JSONFile: TFileName; var ObjectInstance;
  TObjectListItemClass: TClass=nil; Options: TJSONToObjectOptions=[]): boolean;
var tmp: RawUTF8;
begin
  tmp := StringFromFile(JSONFile);
  if tmp='' then
    result := false else begin
    RemoveCommentsFromJSON(pointer(tmp));
    JSONToObject(ObjectInstance,pointer(tmp),result,TObjectListItemClass,Options);
  end;
end;

procedure ObjectToJSONFile(Value: TObject; const JSONFile: TFileName;
  Options: TTextWriterWriteObjectOptions);
begin
  FileFromString(ObjectToJSON(Value,Options),JSONFile);
end;

procedure ReadObject(Value: TObject; From: PUTF8Char; const SubCompName: RawUTF8=''); overload;
var P: PPropInfo;
    i, V, err: integer;
    V64: Int64;
    E: extended;
    Obj: TObject;
    UpperName: array[byte] of AnsiChar;
    U: RawUTF8;
    {$ifndef NOVARIANTS}
    VVariant: variant;
    {$endif}
    CP: PClassProp;
begin
  if Value=nil then // allow From=nil -> default values
    exit;
  CP := InternalClassProp(PPointer(Value)^);
  if CP=nil then
    exit; // no RTTI available
  P := @CP^.PropList;
  for i := 1 to CP^.PropCount do begin
    PWord(UpperCopyShort(UpperCopy255(UpperName,SubCompName),P^.Name))^ := ord('=');
    U := FindIniNameValue(From,UpperName);
    case P^.PropType^^.Kind of
      tkInt64{$ifdef FPC}, tkQWord{$endif}: begin
        V64 := GetInt64(pointer(U),err);
        if err=0 then
          SetInt64Prop(Value,pointer(P),V64); // pointer() to call typinfo
      end;
      {$ifdef FPC}tkBool,{$endif} tkEnumeration, tkSet, tkInteger: begin
        V := GetInteger(pointer(U),err);
        if err=0 then
          SetOrdProp(Value,pointer(P),V) else // pointer() to call typinfo
          if P^.Default<>longint($80000000) then
            SetOrdProp(Value,pointer(P),P^.Default);
      end;
      tkFloat:
      if U<>'' then
        if (P^.PropType^=TypeInfo(Currency)) and (PropWrap(P^.SetProc).Kind=$ff) then
          SetInt64Prop(Value,pointer(P),StrToCurr64(pointer(U))) else begin
          E := GetExtended(pointer(U),err);
          if err=0 then
            SetFloatProp(Value,pointer(P),E);
        end;
      {$ifdef FPC}tkAString,{$endif} tkLString:
        P^.SetLongStrValue(Value,U);
      tkWString:
         SetWideStrProp(Value,Pointer(P),UTF8ToWideString(U));
      {$ifdef UNICODE}
      tkUString:
         SetUnicodeStrProp(Value,Pointer(P),UTF8ToString(U));
      {$endif}
      tkDynArray:
        P^.GetDynArray(Value).LoadFrom(pointer(BlobToTSQLRawBlob(U)));
{$ifdef PUBLISHRECORD}
      tkRecord:
        RecordLoadJSON(P^.GetFieldAddr(Value)^,pointer(U),P^.PropType^);
{$endif PUBLISHRECORD}
      tkClass: begin
        Obj := pointer(GetOrdProp(Value,pointer(P))); // GetOrdProp() is OK for CPU64
        if (PtrUInt(Obj)>=PtrUInt(SystemInfo.lpMinimumApplicationAddress)) and
           Obj.InheritsFrom(TPersistent) then
          ReadObject(Obj,From,SubCompName+RawUTF8(P^.Name)+'.');
      end;
{$ifndef NOVARIANTS}
      tkVariant: begin
        VariantLoadJSON(VVariant,pointer(U));
        SetVariantProp(Value,P,VVariant);
      end;
{$endif} // tkString (shortstring) is not handled
    end;
    P := P^.Next; 
  end;
end;

procedure ReadObject(Value: TObject; const FromContent: RawUTF8;
  const SubCompName: RawUTF8=''); overload;
var source: PUTF8Char;
    UpperSection: array[byte] of AnsiChar;
begin
  if Value=nil then
    exit; // avoid GPF
  PWord(UpperCopyShort(UpperSection,PShortString(PPointer(
    PPtrInt(Value)^+vmtClassName)^)^))^ := ord(']');
  source := pointer(FromContent);
  if FindSectionFirstLine(source,UpperSection) then
    ReadObject(Value,source,SubCompName);
end;

procedure SetDefaultValuesObject(Value: TObject);
var P: PPropInfo;
    i: integer;
    Obj: TObject;
    CP: PClassProp;
begin
  if Value=nil then
    exit;
  CP := InternalClassProp(PPointer(Value)^);
  if CP=nil then
    exit; // no RTTI available
  P := @CP^.PropList;
  for i := 1 to CP^.PropCount do begin
    case P^.PropType^^.Kind of
      {$ifdef FPC}tkBool,{$endif} tkEnumeration, tkSet, tkInteger:
      if P^.Default<>longint($80000000) then
        SetOrdProp(Value,pointer(P),P^.Default); // pointer() to call typinfo
      tkClass: begin
        Obj := pointer(GetOrdProp(Value,pointer(P))); // GetOrdProp() is OK for CPU64
        if (Obj<>nil) and Obj.InheritsFrom(TPersistent) then
          SetDefaultValuesObject(Obj);
      end;
    end;
    P := P^.Next;
  end;
end;

{$ifdef MSWINDOWS}

{ TSQLRestClientURIMessage }

constructor TSQLRestClientURIMessage.Create(aModel: TSQLModel;
  const ServerWindowName: string; ClientWindow: HWND; TimeOutMS: cardinal);
begin
  inherited Create(aModel);
  fClientWindow := ClientWindow;
  fServerWindowName := ServerWindowName;
  fTimeOutMS := TimeOutMS;
end;

constructor TSQLRestClientURIMessage.Create(aModel: TSQLModel;
  const ServerWindowName, ClientWindowName: string; TimeOutMS: cardinal);
var H: HWND;
begin
  H := CreateInternalWindow(ClientWindowName,self);
  if H=0 then
    raise ECommunicationException.CreateFmt('Impossible to create "%s" client window',
      [ClientWindowName]);
  fClientWindowName := ClientWindowName;
  Create(aModel,ServerWindowName,H,TimeOutMS);
end;

destructor TSQLRestClientURIMessage.Destroy;
begin
  try
    inherited Destroy;
  finally
    ReleaseInternalWindow(fClientWindowName,fClientWindow);
  end;
end;

procedure TSQLRestClientURIMessage.InternalURI(var Call: TSQLRestURIParams);
var Msg: RawUTF8;
    Data: TCopyDataStruct;
    Finished64: Int64;
    P: PUTF8Char;
    aMsg: TMsg;
{$ifdef WITHLOG}
    Log: ISynLog;
{$endif}
begin
{$ifdef WITHLOG}
  Log := SQLite3Log.Enter(self,nil,true);
{$endif}
  if (fClientWindow=0) or not InternalCheckOpen then begin
    Call.OutStatus := HTML_NOTIMPLEMENTED; // 501
    {$ifdef WITHLOG}
    Log.Log(sllClient,'InternalCheckOpen failure',self);
    {$endif}
    exit;
  end;
  // 1. send request
  // #1 is a field delimiter below, since Get*Item() functions return nil for #0
  SetString(Msg,PAnsiChar(@MAGIC_SYN),4);
  Msg := Msg+Call.Url+#1+Call.Method+#1+Call.InHead+#1+Call.InBody;
  Data.dwData := fClientWindow;
  Data.cbData := length(Msg);
  Data.lpData := pointer(Msg);
  EnterCriticalSection(fMutex);
  try
    fCurrentResponse := #0; // mark expect some response
    Call.OutStatus := SendMessage(fServerWindow,WM_COPYDATA,fClientWindow,PtrInt(@Data));
    if not (Call.OutStatus in [HTML_SUCCESS,HTML_CREATED]) then begin
      fCurrentResponse := '';
  {$ifdef WITHLOG}
      with Call do
        Log.Log(sllError,'% % status=%',[Method,Url,OutStatus],self);
  {$endif}
      exit;
    end;
    // 2. expect answer from server
    if fCurrentResponse=#0 then begin
      // in practice, we never reach here since SendMessage() did wait for the
      // message to be processed by the receiver, so the Server should have
      // already answered and fCurrentResponse field should have been set
      Finished64 := GetTickCount64+fTimeOutMS;
      repeat
        // incoming WM_COPYDATA will set fCurrentResponse in WMCopyData() method
        if not DoNotProcessMessages then
          while PeekMessage(aMsg,0,0,0,PM_REMOVE) do begin
            TranslateMessage(aMsg);
            DispatchMessage(aMsg);
          end;
        Sleep(0);
        if GetTickCount64>Finished64 then begin
          Call.OutStatus := HTML_TIMEOUT; // 408 Request Timeout Error
          exit;
        end;
      until fCurrentResponse<>#0;
    end;
    // 3. return answer to caller
    if length(fCurrentResponse)<=sizeof(Int64) then
      Call.OutStatus := HTML_NOTIMPLEMENTED else begin
      P := pointer(fCurrentResponse);
      if PCardinal(P)^<>MAGIC_SYN then // broadcasted WM_COPYDATA message? :(
        Call.OutStatus := 0 else
        PInt64(@Call.OutStatus)^ := PInt64(P+4)^;
      if Call.OutStatus=0 then
        Call.OutStatus := HTML_NOTFOUND else begin
        inc(P,4+sizeof(Int64));
        Call.OutHead := GetNextItem(P,#1);
        if P<>nil then
          SetString(Call.OutBody,P,length(fCurrentResponse)-(P-pointer(fCurrentResponse)));
      end;
    end;
  finally
    LeaveCriticalSection(fMutex);
  end;
{$ifdef WITHLOG}
  with Call do
    Log.Log(sllClient,'% % status=% state=%',[Method,Url,OutStatus,OutInternalState],self);
{$endif}
end;

procedure TSQLRestClientURIMessage.WMCopyData(var Msg: TWMCopyData);
begin
  if (self=nil) or (Msg.From<>fServerWindow) or
     (Msg.CopyDataStruct^.dwData<>fServerWindow) then
    exit;
  Msg.Result := HTML_SUCCESS; // Send something back
  if fCurrentResponse=#0 then // expect some response?
    SetString(fCurrentResponse,PAnsiChar(Msg.CopyDataStruct^.lpData),
      Msg.CopyDataStruct^.cbData);
end;

function TSQLRestClientURIMessage.InternalCheckOpen: boolean;
begin
  EnterCriticalSection(fMutex);
  try
    if fServerWindow<>0 then begin
      result := true;
      exit; // only reconnect if forced by InternalClose call or at first access
    end;
    fServerWindow := FindWindow(pointer(fServerWindowName),nil);
    result := fServerWindow<>0;
  finally
    LeaveCriticalSection(fMutex);
  end;
end;

procedure TSQLRestClientURIMessage.InternalClose;
begin
  fServerWindow := 0;
end;


{$endif}



{ TSQLRecordSigned }

function TSQLRecordSigned.CheckSignature(const Content: RawByteString): boolean;
var tmp: RawUTF8;
    i: integer;
    SHA: TSHA256;
    Digest: TSHA256Digest;
begin
  result := false;
  i := PosEx(RawUTF8('/'),fSignature,1);
  if i=0 then exit;
  tmp := TTimeLogBits(fSignatureTime).Text(false)+RawUTF8(ClassName)+copy(fSignature,1,i-1);
  SHA.Init;
  SHA.Update(pointer(tmp),length(tmp));
  SHA.Update(pointer(Content),length(Content)); // hash in place: no Content copy
  SHA.Final(Digest);
  if SHA256DigestToString(Digest)=copy(fSignature,i+1,sizeof(Digest)*2) then
    result := true;
end;

function TSQLRecordSigned.SetAndSignContent(const UserName: RawUTF8;
  const Content: RawByteString; ForcedSignatureTime: Int64): boolean;
var tmp: RawUTF8;
    SHA: TSHA256;
    Digest: TSHA256Digest;
begin
  result := (fSignature='') and (fSignatureTime=0);
  if not result then
    exit; // sign is allowed only once
  if ForcedSignatureTime<>0 then
    fSignatureTime := ForcedSignatureTime else
    fSignatureTime := TimeLogNow;
  { content is hashed with User Name value }
  tmp := TTimeLogBits(fSignatureTime).Text(false)+RawUTF8(ClassName)+UserName;
  SHA.Init;
  SHA.Update(pointer(tmp),length(tmp));
  SHA.Update(pointer(Content),length(Content)); // hash in place: no Content copy
  SHA.Final(Digest);
  fSignature := UserName+'/'+SHA256DigestToString(Digest);
end;

function TSQLRecordSigned.SignedBy: RawUTF8;
var i: integer;
begin
  i := PosEx(RawUTF8('/'),fSignature,1);
  if i=0 then
    result := '' else
    result := copy(fSignature,1,i-1);
end;

procedure TSQLRecordSigned.UnSign;
begin
  fSignature := '';
  fSignatureTime := 0;
end;


{ TSQLRecordInterfaced }

class function TSQLRecordInterfaced.NewInstance: TObject;
begin
  result := inherited NewInstance;
  TSQLRecordInterfaced(result).fRefCount := 1;
end;

procedure TSQLRecordInterfaced.AfterConstruction;
{$ifdef PUREPASCAL}
begin
  InterlockedDecrement(fRefCount); // fRefCount=1 in NewInstance
end;
{$else}
asm
  lock dec [eax].TInterfacedObject.fRefCount
end;
{$endif}

procedure TSQLRecordInterfaced.BeforeDestruction;
begin
  if fRefCount<>0 then
    System.Error(reInvalidPtr);
end;

function TSQLRecordInterfaced.QueryInterface(const IID: TGUID; out Obj): HResult;
begin
  if GetInterface(IID,Obj) then
    result := 0 else
    result := E_NOINTERFACE;
end;

function TSQLRecordInterfaced._AddRef: Integer;
begin
  result := InterlockedIncrement(fRefCount);
end;

function TSQLRecordInterfaced._Release: Integer;
begin
  result := InterlockedDecrement(fRefCount);
  if result=0 then
    Destroy;
end;


{ TSQLRecordFTS3 }

class function TSQLRecordFTS3.OptimizeFTS3Index(Server: TSQLRestServer): boolean;
begin
  if (self=nil) or (Server=nil) then
    Result:= false else
    with RecordProps do
      Result := Server.EngineExecuteAll(FormatUTF8(
        'INSERT INTO %(%) VALUES(''optimize'');',[SQLTableName,SQLTableName]));
end;


{ TSQLRecordRTree }

class procedure TSQLRecordRTree.BlobToCoord(const InBlob;
  var OutCoord: TSQLRecordTreeCoords);
begin // direct memory copy with no memory check
  move(InBlob,OutCoord,(RecordProps.Fields.Count shr 1)*sizeof(double));
end;

class function TSQLRecordRTree.ContainedIn(const BlobA,BlobB): boolean;
var A,B: TSQLRecordTreeCoords;
    i: integer;
begin
  BlobToCoord(BlobA,A);
  BlobToCoord(BlobB,B);
  result := false;
  for i := 0 to (RecordProps.Fields.Count shr 1)-1 do
    if (A[i].max<B[i].min) or (A[i].min>B[i].max) then
      exit; // no match
  result := true; // box match
end;

class function TSQLRecordRTree.RTreeSQLFunctionName: RawUTF8;
begin
  result := RecordProps.SQLTableName+'_in';
end;


{ TSQLRecordMany }

constructor TSQLRecordMany.Create;
begin
  inherited Create;
  with RecordProps do
    if (fRecordManySourceProp<>nil) and (fRecordManyDestProp<>nil) then begin
      fSourceID := fRecordManySourceProp.GetFieldAddr(Self);
      fDestID := fRecordManyDestProp.GetFieldAddr(Self);
    end;
end;

function TSQLRecordMany.ManyAdd(aClient: TSQLRest; aSourceID, aDestID: Integer;
  NoDuplicates: boolean): boolean;
begin
  result := false;
  if (self=nil) or (aClient=nil) or (aSourceID=0) or (aDestID=0) or
     (fSourceID=nil) or (fDestID=nil) then
    exit; // invalid parameters
  if NoDuplicates and
     (InternalIDFromSourceDest(aClient,aSourceID,aDestID)<>0) then
      exit; // this TRecordReference pair already exists
  fSourceID^ := aSourceID;
  fDestID^ := aDestID;
  if aClient.Add(self,true)<>0 then
    result := true;
end;

function TSQLRecordMany.ManyAdd(aClient: TSQLRest; aDestID: Integer;
  NoDuplicates: boolean): boolean;
begin
  if (self=nil) or (fSourceID=nil) then
    result := false else // avoid GPF
    result := ManyAdd(aClient,fSourceID^,aDestID,NoDuplicates);
end;

function TSQLRecordMany.DestGet(aClient: TSQLRest; aSourceID: integer;
  out DestIDs: TIntegerDynArray): Boolean;
var Where: RawUTF8;
begin
  Where := IDWhereSQL(aClient,aSourceID,False);
  if Where='' then
    result := False else
    result := aClient.OneFieldValues(RecordClass,'Dest',Where,DestIDs);
end;

function TSQLRecordMany.DestGetJoined(aClient: TSQLRest;
  const aDestWhereSQL: RawUTF8; aSourceID: Integer;
  out DestIDs: TIntegerDynArray): boolean;
var aTable: TSQLTable;
begin
  aTable := DestGetJoinedTable(aClient,aDestWhereSQL,aSourceID,jkDestID);
  if aTable=nil then
    Result := False else
    try
      aTable.GetRowValues(0,DestIDs);
      Result := true;
    finally
      aTable.Free;
    end;
end;

function TSQLRecordMany.DestGetJoined(aClient: TSQLRest;
  const aDestWhereSQL: RawUTF8; aSourceID: Integer): TSQLRecord;
var aTable: TSQLTable;
begin
  aTable := DestGetJoinedTable(aClient,aDestWhereSQL,aSourceID,jkDestFields);
  if aTable=nil then
    Result := nil else begin
    Result := TSQLRecordClass(RecordProps.fRecordManyDestProp.ObjectClass).Create;
    aTable.OwnerMustFree := true;
    Result.FillPrepare(aTable,ctnTrimExisting); 
  end;
end;

function TSQLRecordMany.DestGetJoinedTable(aClient: TSQLRest;
  const aDestWhereSQL: RawUTF8; aSourceID: Integer; JoinKind: TSQLRecordManyJoinKind;
  const aCustomFieldsCSV: RawUTF8): TSQLTable;
var Select, SQL: RawUTF8;
    SelfProps, DestProps: TSQLModelRecordProperties;
procedure SelectFields(const Classes: array of TSQLModelRecordProperties);
var i: integer;
begin
  for i := 0 to high(Classes) do begin
    Select := Select+Classes[i].SQL.TableSimpleFields[True,True];
    if i<high(Classes) then
      Select := Select+',';
  end;
end;
begin
  result := nil;
  if (Self=nil) or (fSourceID=nil) or (fDestID=nil) or (aClient=nil) then
    exit;
  if aSourceID=0 then
    if fSourceID<>nil then
      aSourceID := fSourceID^;
  if aSourceID=0 then
    exit;
  SelfProps := aClient.Model.Props[PSQLRecordClass(self)^];
  DestProps := aClient.Model.Props[TSQLRecordClass(SelfProps.Props.fRecordManyDestProp.ObjectClass)];
  case JoinKind of
    jkDestID:
      Select := DestProps.Props.SQLTableName+'.RowID';
    jkPivotID:
      Select := SelfProps.Props.SQLTableName+'.RowID';
    jkDestFields:
      if aCustomFieldsCSV='' then
        SelectFields([DestProps]) else
        Select := AddPrefixToCSV(pointer(aCustomFieldsCSV),DestProps.Props.SQLTableName+'.');
    jkPivotFields:
      if aCustomFieldsCSV='' then
        SelectFields([SelfProps]) else
        Select := AddPrefixToCSV(pointer(aCustomFieldsCSV),SelfProps.Props.SQLTableName+'.');
    jkPivotAndDestFields:
      if aCustomFieldsCSV='' then
        SelectFields([SelfProps,DestProps]) else
        Select := aCustomFieldsCSV;
  end;
  if aDestWhereSQL='' then
    // fast inlined prepared statement
    SQL := 'SELECT % FROM %,% WHERE %.Source=:(%): AND %.Dest=%.RowID' else
    if PosEx(RawUTF8(':('),aDestWhereSQL,1)>0 then
      // statement is globaly inlined -> cache prepared statement
      SQL := 'SELECT % FROM %,% WHERE %.Source=:(%): AND %.Dest=%.RowID AND %' else
      // statement is not globaly inlined -> no caching of prepared statement
      SQL := 'SELECT % FROM %,% WHERE %.Source=% AND %.Dest=%.RowID AND %';
  result := aClient.ExecuteList([PSQLRecordClass(Self)^,
     TSQLRecordClass(SelfProps.Props.fRecordManyDestProp.ObjectClass)],
    FormatUTF8(pointer(SQL),
      [Select, DestProps.Props.SQLTableName,SelfProps.Props.SQLTableName,
       SelfProps.Props.SQLTableName,aSourceID, SelfProps.Props.SQLTableName,
       DestProps.Props.SQLTableName, aDestWhereSQL]));
end;

function TSQLRecordMany.DestGet(aClient: TSQLRest;
  out DestIDs: TIntegerDynArray): boolean;
begin
  if fSourceID=nil then
    result := false else // avoid GPF
    result := DestGet(aClient,fSourceID^,DestIDs);
   // fSourceID has been set by TSQLRecord.Create
end;

function TSQLRecordMany.ManyDelete(aClient: TSQLRest; aSourceID, aDestID: Integer;
  aUseBatchMode: boolean=false): boolean;
var aID: integer;
begin
  result := false;
  if (self=nil) or (aClient=nil) or (aSourceID=0) or (aDestID=0) then
    exit;
  aID := InternalIDFromSourceDest(aClient,aSourceID,aDestID);
  if aID<>0 then
    if aUseBatchMode and aClient.InheritsFrom(TSQLRestClientURI) then
      result := TSQLRestClientURI(aClient).BatchDelete(RecordClass,aID)>=0 else
      result := aClient.Delete(RecordClass,aID);
end;

function TSQLRecordMany.ManyDelete(aClient: TSQLRest; aDestID: Integer;
  aUseBatchMode: boolean=false): boolean;
begin
  if fSourceID=nil then
    result := false else // avoid GPF
    result := ManyDelete(aClient,fSourceID^,aDestID,aUseBatchMode);
end;

function TSQLRecordMany.ManySelect(aClient: TSQLRest; aSourceID, aDestID: Integer): boolean;
begin
  if (self=nil) or (aClient=nil) or (aSourceID=0) or (aDestID=0) then
    result := false else // invalid parameters
    result := aClient.Retrieve(FormatUTF8('Source=:(%): AND Dest=:(%):',
      [aSourceID,aDestID]),Self);
end;

function TSQLRecordMany.ManySelect(aClient: TSQLRest; aDestID: Integer): boolean;
begin
  if (self=nil) or (fSourceID=nil) then
    result := false else // avoid GPF
    result := ManySelect(aClient,fSourceID^,aDestID);
end;

function TSQLRecordMany.InternalFillMany(aClient: TSQLRest;
  aID: integer; const aAndWhereSQL: RawUTF8; isDest: boolean): integer;
var aTable: TSQLTable;
    Where: RawUTF8;
begin
  result := 0;
  if self=nil then
    exit;
  if not isDest and (aID=0)then
    if fSourceID<>nil then
      aID := fSourceID^; // has been set by TSQLRecord.Create
  Where := IDWhereSQL(aClient,aID,isDest,aAndWhereSQL);
  if Where='' then
    exit;
  aTable := aClient.MultiFieldValues(RecordClass,'',Where);
  if aTable=nil then
    exit;
  aTable.OwnerMustFree := true;
  FillPrepare(aTable); // temporary storage for FillRow, FillOne and FillRewind
  result := aTable.RowCount;
end;

function TSQLRecordMany.FillMany(aClient: TSQLRest; aSourceID: integer;
  const aAndWhereSQL: RawUTF8): integer;
begin
  result := InternalFillMany(aclient,aSourceID,aAndWhereSQL,false);
end;

function TSQLRecordMany.FillManyFromDest(aClient: TSQLRest; aDestID: integer;
  const aAndWhereSQL: RawUTF8): integer;
begin
  result := InternalFillMany(aclient,aDestID,aAndWhereSQL,true);
end;

function TSQLRecordMany.IDWhereSQL(aClient: TSQLRest; aID: integer; isDest: boolean;
  const aAndWhereSQL: RawUTF8=''): RawUTF8;
const FieldName: array[boolean] of RawUTF8 = ('Source=','Dest=');
begin
  if (self=nil) or (aID=0) or (fSourceID=nil) or (fDestID=nil) or
     (aClient=nil) then
    Result := '' else begin
    if aAndWhereSQL<>'' then
      if PosEx(RawUTF8(':('),aAndWhereSQL,1)>0 then
        Result := '%:(%): AND %' else // inlined parameters
        Result := '%% AND %' else // no inlined parameters -> not cached
      Result := '%:(%):'; // no additional where clause -> inline ID
    Result := FormatUTF8(pointer(result),[FieldName[isDest],aID,aAndWhereSQL]);
  end;
end;

function TSQLRecordMany.SourceGet(aClient: TSQLRest; aDestID: integer;
  out SourceIDs: TIntegerDynArray): boolean;
var Where: RawUTF8;
begin
  Where := IDWhereSQL(aClient,aDestID,True);
  if Where='' then
    Result := false else
    Result := aClient.OneFieldValues(RecordClass,'Source',Where,SourceIDs);
end;

function TSQLRecordMany.InternalIDFromSourceDest(aClient: TSQLRest; aSourceID, aDestID: integer): integer;
begin
  result := GetInteger(Pointer(aClient.OneFieldValue(RecordClass,'RowID',
    FormatUTF8('Source=:(%): AND Dest=:(%):',[aSourceID,aDestID]))));
end;


{ TSQLRecordProperties }

procedure TSQLRecordProperties.InternalRegisterModel(aModel: TSQLModel;
  aTableIndex: integer; aProperties: TSQLModelRecordProperties);
var i: integer;
begin
  assert(aTableIndex>=0);
  EnterCriticalSection(fLock); // may be called from several threads at once
  try
    for i := 0 to fModelMax do
      if fModel[i].Model=aModel then
        exit; // already registered
    inc(fModelMax);
    if fModelMax>=length(fModel) then
      SetLength(fModel,fModelMax+4);
    with fModel[fModelMax] do begin
      Model := aModel;
      Properties := aProperties;
      TableIndex := aTableIndex;
    end;
  finally
    LeaveCriticalSection(fLock);
  end;
end;

constructor TSQLRecordProperties.Create(aTable: TSQLRecordClass);

  procedure AddParentsFirst(aClassType: TClass);
  var CP: PClassProp;
      P: PPropInfo;
      i: Integer;
  begin
    if aClassType=nil then
      exit; // no RTTI information (e.g. reached TObject level)
    AddParentsFirst(aClassType.ClassParent);
    CP := InternalClassProp(aClassType);
    if CP<>nil then begin
      P := @CP^.PropList;
      for i := 1 to CP^.PropCount do begin
        Fields.Add(aTable,TSQLPropInfoRTTI.CreateFrom(P,Fields.Count));
        P := P^.Next;
      end;
    end;
  end;

var i,j, nProps: integer;
    nMany, nSQLRecord, nSimple, nDynArray, nBlob, nBlobCustom,
    nCopiableFields: integer;
    isTSQLRecordMany: boolean;
    F: TSQLPropInfo;
label Simple;
begin
  InitializeCriticalSection(fLock);
  assert(aTable<>nil); // should not be called directly, but via PropsCreate()
  // register to the JSONToObject() TObjectList "ClassName":".." feature
  TJSONSerializer.RegisterClassForJSON(aTable);
  // initialize internal structures
  fModelMax := -1;
  Table := aTable;
  SQLTableName := GetDisplayNameFromClass(aTable);
  SQLTableNameUpperWithDot := SynCommons.UpperCase(SQLTableName)+'.';
  isTSQLRecordMany := aTable.InheritsFrom(TSQLRecordMany);
  // add properties to internal Fields list
  ClassProp := InternalClassProp(aTable);
  assert(ClassProp<>nil);
  nProps := PClassProp(aTable)^.FieldCountWithParents;
  if nProps>MAX_SQLFIELDS_INCLUDINGID then
    raise EModelException.CreateFmt('%s has too many fields: %d>=%d',
      [SQLTableName,nProps,MAX_SQLFIELDS]);
  Fields := TSQLPropInfoList.Create;
  AddParentsFirst(aTable);
  aTable.InternalRegisterCustomProperties(self);
  if Fields.Count>MAX_SQLFIELDS_INCLUDINGID then
    raise EModelException.CreateFmt(
      '%s has too many fields after InternalRegisterCustomProperties: %d>=%d',
      [SQLTableName,Fields.Count,MAX_SQLFIELDS]);
  SetLength(Fields.fList,Fields.Count);
  // generate some internal lookup information
  SQLTableRetrieveAllFields := 'ID';
  SetLength(ManyFields,MAX_SQLFIELDS);
  SetLength(SimpleFields,MAX_SQLFIELDS);
  SetLength(JoinedFields,MAX_SQLFIELDS);
  SetLength(CopiableFields,MAX_SQLFIELDS);
  SetLength(DynArrayFields,MAX_SQLFIELDS);
  SetLength(BlobCustomFields,MAX_SQLFIELDS);
  SetLength(BlobFields,MAX_SQLFIELDS);
  MainField[false] := -1;
  MainField[true] := -1;
  nMany := 0;
  nSimple := 0;
  nSQLRecord := 0;
  nCopiableFields := 0;
  nDynArray := 0;
  nBlob := 0;
  nBlobCustom := 0;
  for i := 0 to Fields.Count-1  do begin
    F := Fields.List[i];
    include(HasTypeFields,F.SQLFieldType);
    //  handle unique fields, i.e. if marked as "stored false"
    if aIsUnique in F.Attributes then begin
      include(IsUniqueFieldsBits,i);
      // must trim() text value before storage, and validate for unicity
      if F.SQLFieldType in [sftUTF8Text,sftAnsiText] then
        AddFilterOrValidate(i,TSynFilterTrim.Create);
      AddFilterOrValidate(i,TSynValidateUniqueField.Create);
    end;
    // get corresponding properties content
    case F.SQLFieldType of
      sftUnknown: ;
      sftUTF8Text: begin
        if aIsUnique in F.Attributes then
          if MainField[false]<0 then
            MainField[false] := i;
        if MainField[true]<0 then
          MainField[true] := i;
        goto Simple;
      end;
      sftBlob: begin
        BlobFields[nBlob] := F as TSQLPropInfoRTTI;
        inc(nBlob);
        include(BlobFieldsBits,i);
        SQLTableUpdateBlobFields := SQLTableUpdateBlobFields+F.Name+'=?,';
        SQLTableRetrieveBlobFields := SQLTableRetrieveBlobFields+F.Name+',';
        SQLTableRetrieveAllFields := SQLTableRetrieveAllFields+','+F.Name;
        CopiableFields[nCopiableFields] := F;
        inc(nCopiableFields);
      end;
      sftID:
        if isTSQLRecordMany and
           (IdemPropNameU(F.Name,'Source') or IdemPropNameU(F.Name,'Dest')) then
          goto Simple else begin
          JoinedFields[nSQLRecord] := F as TSQLPropInfoRTTIID;
          inc(nSQLRecord);
          goto Simple;
        end;
      sftMany: begin
        ManyFields[nMany] := F as TSQLPropInfoRTTIMany;
        inc(nMany);
      end;
      sftBlobDynArray:
      with F as TSQLPropInfoRTTIDynArray do begin
        if DynArrayIndex>0 then
          for j := 0 to nDynArray-1 do
          if DynArrayFields[j].DynArrayIndex=DynArrayIndex then
            raise EModelException.CreateFmt('dup index %d for %s.%s and %s properties',
              [DynArrayIndex,aTable.ClassName,Name,DynArrayFields[j].Name]);
        DynArrayFields[nDynArray] := F as TSQLPropInfoRTTIDynArray;
        inc(nDynArray);
        goto Simple;
      end;
      sftBlobCustom, sftUTF8Custom: begin
        BlobCustomFields[nBlobCustom] := F;
        inc(nBlobCustom);
        goto Simple;
      end;
      sftCreateTime: begin
        include(ModCreateTimeFieldsBits,i);
        goto Simple;
      end;
      sftModTime: begin
        include(ModTimeFieldsBits,i);
        include(ModCreateTimeFieldsBits,i);
        goto Simple;
      end;
      else begin
        // this code follows NOT_SIMPLE_FIELDS const
Simple: SimpleFields[nSimple] := F;
        inc(nSimple);
        include(SimpleFieldsBits[soSelect],i);
        SQLTableSimpleFieldsNoRowID := SQLTableSimpleFieldsNoRowID+F.Name+',';
        SQLTableRetrieveAllFields := SQLTableRetrieveAllFields+','+F.Name;
        CopiableFields[nCopiableFields] := F;
        inc(nCopiableFields);
      end;
    end;
  end;
  if SQLTableSimpleFieldsNoRowID<>'' then
    SetLength(SQLTableSimpleFieldsNoRowID,length(SQLTableSimpleFieldsNoRowID)-1);
  if SQLTableUpdateBlobFields<>'' then
    SetLength(SQLTableUpdateBlobFields,length(SQLTableUpdateBlobFields)-1);
  if SQLTableRetrieveBlobFields<>'' then
    SetLength(SQLTableRetrieveBlobFields,length(SQLTableRetrieveBlobFields)-1);
  SetLength(ManyFields,nMany);
  SetLength(SimpleFields,nSimple);
  SetLength(JoinedFields,nSQLRecord);
  if nSQLRecord>0 then begin
    SetLength(JoinedFieldsTable,nSQLRecord+1);
    JoinedFieldsTable[0] := aTable;
    for i := 0 to nSQLRecord-1 do
      JoinedFieldsTable[i+1] := TSQLRecordClass(JoinedFields[i].ObjectClass);
  end;
  SetLength(CopiableFields,nCopiableFields);
  SetLength(DynArrayFields,nDynArray);
  SetLength(BlobCustomFields,nBlobCustom);
  SetLength(BlobFields,nBlob);
  SimpleFieldsBits[soInsert] := SimpleFieldsBits[soSelect];
  SimpleFieldsBits[soUpdate] := SimpleFieldsBits[soSelect];
  SimpleFieldsBits[soDelete] := SimpleFieldsBits[soSelect];
  SimpleFieldsCount[soInsert] := nSimple;
  SimpleFieldsCount[soUpdate] := nSimple;
  SimpleFieldsCount[soDelete] := nSimple;
  HasNotSimpleFields := nSimple<>Fields.Count;
  for i := 0 to Fields.Count-1 do
    if Fields.List[i].SQLFieldType=sftCreateTime then begin
      exclude(SimpleFieldsBits[soUpdate],i);
      dec(SimpleFieldsCount[soUpdate]);
    end;
  if isTSQLRecordMany then begin
    fRecordManySourceProp := Fields.ByRawUTF8Name('Source') as TSQLPropInfoRTTIInstance;
    if fRecordManySourceProp=nil then
      raise EORMException.CreateFmt('%s=class(TSQLRecordMany) expects a SOURCE field',[ClassName]) else
    fRecordManyDestProp := Fields.ByRawUTF8Name('Dest') as TSQLPropInfoRTTIInstance;
    if fRecordManyDestProp=nil then
      raise EORMException.CreateFmt('%s=class(TSQLRecordMany) expects a DEST field',[ClassName]);
  end;
end;

function TSQLRecordProperties.BlobFieldPropFromRawUTF8(const PropName: RawUTF8): PPropInfo;
var i: integer;
begin
  if (self<>nil) and (PropName<>'') then
  for i := 0 to high(BlobFields) do
    if IdemPropNameU(BlobFields[i].Name,PropName) then begin
      result := BlobFields[i].PropInfo;
      exit;
    end;
  result := nil;
end;

function TSQLRecordProperties.BlobFieldPropFromUTF8(PropName: PUTF8Char; PropNameLen: integer): PPropInfo;
var i: integer;
begin
  if (self<>nil) and (PropName<>'') then
  for i := 0 to high(BlobFields) do
    if IdemPropName(BlobFields[i].PropInfo^.Name,PropName,PropNameLen) then begin
      result := BlobFields[i].PropInfo;
      exit;
    end;
  result := nil;
end;

function TSQLRecordProperties.SQLFieldTypeToSQL(Fieldindex: integer): RawUTF8;
const
  /// simple wrapper from each SQL used type into SQLite3 field datatype
  // - set to '' for fields with no column created in the database
  DEFAULT_SQLFIELDTYPETOSQL: array[TSQLFieldType] of RawUTF8 =
   ('',                              // sftUnknown
    ' TEXT COLLATE NOCASE, ',        // sftAnsiText
    ' TEXT COLLATE SYSTEMNOCASE, ',  // sftUTF8Text
    ' INTEGER, ',                    // sftEnumerate
    ' INTEGER, ',                    // sftSet
    ' INTEGER, ',                    // sftInteger
    ' INTEGER, ',                    // sftID
    ' INTEGER, ',                    // sftRecord
    ' INTEGER, ',                    // sftBoolean
    ' FLOAT, ',                      // sftFloat
    ' TEXT COLLATE ISO8601, ',       // sftDateTime
    ' INTEGER, ',                    // sftTimeLog
    ' FLOAT, ',                      // sftCurrency
    ' TEXT COLLATE NOCASE, ',        // sftObject
{$ifndef NOVARIANTS}
    ' TEXT COLLATE NOCASE, ',        // sftVariant
{$endif}
    ' BLOB, ',                       // sftBlob
    ' BLOB, ',                       // sftBlobDynArray
    ' BLOB, ',                       // sftBlobCustom
    ' TEXT COLLATE NOCASE, ',        // sftUTF8Custom
    '',                              // sftMany
    ' INTEGER, ',                    // sftModTime
    ' INTEGER, ');                   // sftCreateTime
begin
  if (self=nil) or (cardinal(FieldIndex)>=cardinal(Fields.Count)) then
    result := '' else
  if (FieldIndex<length(fCustomCollation)) and (fCustomCollation[FieldIndex]<>'') then
    result := ' TEXT COLLATE '+fCustomCollation[FieldIndex]+', ' else
    result := DEFAULT_SQLFIELDTYPETOSQL[Fields.List[FieldIndex].SQLFieldType];
end;

function TSQLRecordProperties.SetCustomCollation(FieldIndex: integer; const aCollationName: RawUTF8): boolean;
begin
  result := (self<>nil) and (cardinal(FieldIndex)<cardinal(Fields.Count));
  if result then begin
    if Fields.Count>length(fCustomCollation) then
      SetLength(fCustomCollation,Fields.Count);
    fCustomCollation[FieldIndex] := aCollationName;
  end;
end;

procedure TSQLRecordProperties.SetCustomCollationForAllRawUTF8(const aCollationName: RawUTF8);
var i: integer;
begin
  if self=nil then
    exit;
  if Fields.Count>length(fCustomCollation) then
    SetLength(fCustomCollation,Fields.Count);
  for i := 0 to Fields.Count-1 do
    if Fields.List[i].SQLFieldType=sftUTF8Text then
      fCustomCollation[i] := aCollationName;
end;

function TSQLRecordProperties.SQLAddField(FieldIndex: integer): RawUTF8;
begin
  if (self=nil) or (cardinal(FieldIndex)>=cardinal(Fields.Count)) then begin
    result := '';
    exit;
  end;
  result := SQLFieldTypeToSQL(FieldIndex);
  if result='' then
    exit; // some fields won't have any column created in the database
  result := FormatUTF8('ALTER TABLE % ADD COLUMN %%',
    [SQLTableName,Fields.List[FieldIndex].Name,result]);
  if FieldIndex in IsUniqueFieldsBits then
    insert(' UNIQUE',result,length(result)-1);
  result[length(result)-1] := ';' // SQLFieldTypeToSQL[] ends with ','
end;

procedure TSQLRecordProperties.SetJSONWriterColumnNames(W: TJSONSerializer;
  KnownRowsCount: integer);
var i,n: integer;
begin
  // get col count overhead
  if W.withID then
    n := 1 else
    n := 0;
  // set col names
  SetLength(W.ColNames,Fields.Count+n);
  if W.withID then
    W.ColNames[0] := 'RowID'; // works for both normal and FTS3 records
  for i := 0 to Fields.Count-1 do
    if i in W.Fields then begin
      W.ColNames[n] := Fields.List[i].Name;
      inc(n);
    end;
  // adjust col count
  if n<>length(W.ColNames) then
    SetLength(W.ColNames,n);
  W.AddColumns(KnownRowsCount); // write or init field names for appropriate JSON Expand
end;

function TSQLRecordProperties.CreateJSONWriter(JSON: TStream; Expand,
  withID: boolean; const aFields: TSQLFieldBits; KnownRowsCount: integer): TJSONSerializer;
begin
  if (self=nil) or ((Int64(Fields)=0) and not withID) then  // no data
    result := nil else begin
    result := TJSONSerializer.Create(JSON,Expand,withID,aFields);
    SetJSONWriterColumnNames(result,KnownRowsCount);
  end;
end;

procedure TSQLRecordProperties.SetExpandedJSONWriter(W: TJSONWriter;
  ForceResetFields, withID: boolean; const WrittenFields: TSQLFieldBits);
var i, id, nFieldBits: integer;
begin
  if (self=nil) or (W=nil) then
    exit;
  if not ForceResetFields then
    if W.Expand and (W.WithID=withID) and IsEqual(W.Fields,WrittenFields) then
      exit; // already set -> do not compute it again
  if withID then
    id := 1 else
    id := 0;
  nFieldBits := id+GetBitsCount(WrittenFields,Fields.Count);
  SetLength(W.ColNames,nFieldBits);
  if withID then
    W.ColNames[0] := '"RowID":'; // works for both normal and FTS3 records
  W.Expand := true;
  W.WithID := withID;
  W.Fields := WrittenFields;
  for i := 0 to Fields.Count-1 do
    if i in W.Fields then begin
      W.ColNames[id] := '"'+Fields.List[i].Name+'":'; // as in TJSONWriter.AddColumns
      W.FieldMax := i;
      inc(id);
    end;
  assert(id=nFieldBits);
end;

procedure TSQLRecordProperties.SaveBinaryHeader(W: TFileBufferWriter);
var i: integer;
    FieldNames: TRawUTF8DynArray;
begin
  W.Write(SQLTableName);
  SetLength(FieldNames,Fields.Count);
  for i := 0 to Fields.Count-1 do
    FieldNames[i] := Fields.List[i].Name;
  W.WriteRawUTF8DynArray(FieldNames,Fields.Count);
  for i := 0 to Fields.Count-1 do
    W.Write(@Fields.List[i].fSQLFieldType,sizeof(TSQLFieldType));
end;                          

function TSQLRecordProperties.CheckBinaryHeader(var R: TFileBufferReader): boolean;
var n,i: integer;
    FieldNames: TRawUTF8DynArray;
    FieldTypes: array[0..MAX_SQLFIELDS-1] of TSQLFieldType;
begin
  result := false;
  if (R.ReadRawUTF8<>SQLTableName) or
     (R.ReadVarRawUTF8DynArray(FieldNames)<>Fields.Count) then
    exit;
  n := sizeof(TSQLFieldType)*Fields.Count;
  if R.Read(@FieldTypes,n)<>n then
    exit;
  for i := 0 to Fields.Count-1 do
    with Fields.List[i] do
    if (Name<>FieldNames[i]) or (SQLFieldType<>FieldTypes[i]) then
      exit;
  result := true;
end;

function TSQLRecordProperties.IsFieldName(const PropName: RawUTF8): boolean;
begin
  result := (PropName<>'') and
    (isRowID(pointer(PropName)) or (Fields.IndexByName(PropName)>=0));
end;

function TSQLRecordProperties.AddFilterOrValidate(aFieldIndex: integer;
  aFilter: TSynFilterOrValidate): TSynFilterOrValidate;
begin
  if (self=nil) or (cardinal(aFieldIndex)>=cardinal(Fields.Count)) or
    (aFilter=nil) then
    result := nil else begin
    if Filters=nil then
      SetLength(Filters,Fields.Count);
    if Filters[aFieldIndex]=nil then
      Filters[aFieldIndex] := TObjectList.Create;
    Filters[aFieldIndex].Add(aFilter);
    result := aFilter;
  end;
end;

function TSQLRecordProperties.AddFilterOrValidate(const aFieldName: RawUTF8;
  aFilter: TSynFilterOrValidate): TSynFilterOrValidate;
begin
  result := AddFilterOrValidate(Fields.IndexByName(aFieldName),aFilter);
end;

destructor TSQLRecordProperties.Destroy;
var f: integer;
begin
  for f := 0 to high(Filters) do
    Filters[f].Free; // will free any created TSynFilter instances
  inherited;
  DeleteCriticalSection(fLock);
  Fields.Free;
end;

function TSQLRecordProperties.FieldIndexsFromBlobField(aBlobField: PPropInfo;
  var Bits: TSQLFieldBits): boolean;
var f: integer;
begin
  fillchar(Bits,sizeof(TSQLFieldBits),0);
  if self<>nil then
  for f := 0 to high(BlobFields) do
    if BlobFields[f].fPropInfo=aBlobField then begin
      Include(Bits,BlobFields[f].PropertyIndex);
      result := true;
      exit;
    end;
  result := false;
end;

function TSQLRecordProperties.FieldIndexsFromCSV(const aFieldsCSV: RawUTF8;
  var Bits: TSQLFieldBits): boolean;
var ndx: integer;
    P: PUTF8Char;
    FieldName: ShortString;
begin
  fillchar(Bits,sizeof(TSQLFieldBits),0);
  result := false;
  if self=nil then
    exit;
  P := pointer(aFieldsCSV);
  while P<>nil do begin
    GetNextItemShortString(P,FieldName);
    FieldName[ord(FieldName[0])+1] := #0; // make PUTF8Char
    ndx := Fields.IndexByName(@FieldName[1]);
    if ndx<0 then
      exit; // invalid field name
    include(Bits,ndx);
  end;
  result := true;
end;

function TSQLRecordProperties.FieldIndexsFromCSV(const aFieldsCSV: RawUTF8): TSQLFieldBits;
begin
  FieldIndexsFromCSV(aFieldsCSV,Result);
end;

function TSQLRecordProperties.FieldIndexsFromRawUTF8(const aFields: array of RawUTF8;
  var Bits: TSQLFieldBits): boolean;
var f,ndx: integer;
begin
  fillchar(Bits,sizeof(TSQLFieldBits),0);
  result := false;
  if self=nil then
    exit;
  for f := 0 to high(aFields) do begin
    ndx := Fields.IndexByName(aFields[f]);
    if ndx<0 then
      exit; // invalid field name
    include(Bits,ndx);
  end;
  result := true;
end;

function TSQLRecordProperties.FieldIndexsFromRawUTF8(const aFields: array of RawUTF8): TSQLFieldBits;
begin
  FieldIndexsFromRawUTF8(aFields,Result);
end;

function TSQLRecordProperties.AppendFieldName(FieldIndex: Integer;
  var Text: RawUTF8; ForceNoRowID: boolean): boolean;
begin
  result := false; // success
  if FieldIndex=VIRTUAL_TABLE_ROWID_COLUMN then
    if ForceNoRowID then
      Text := Text+'ID' else
      Text := Text+'RowID' else
  if (self=nil) or (cardinal(FieldIndex)>=cardinal(Fields.Count)) then
    result := true else
    Text := Text+Fields.List[FieldIndex].Name;
end;

function TSQLRecordProperties.MainFieldName(Table: TSQLRecordClass;
  ReturnFirstIfNoUnique: boolean=false): RawUTF8;
begin
  if (self=nil) or (Table=nil) or (MainField[ReturnFirstIfNoUnique]<0) then
    result := '' else
    result := Fields.List[MainField[ReturnFirstIfNoUnique]].Name;
end;

procedure TSQLRecordProperties.RegisterCustomFixedSizeRecordProperty(
  aTable: TClass; aRecordSize: cardinal; const aName: RawUTF8;
  aPropertyPointer: pointer; aAttributes: TSQLPropInfoAttributes;
  aFieldWidth: integer; aData2Text: TOnSQLPropInfoRecord2Text;
  aText2Data: TOnSQLPropInfoRecord2Data);
begin
  Fields.Add(aTable,TSQLPropInfoRecordFixedSize.Create(aRecordSize,aName,Fields.Count,
    aPropertyPointer,aAttributes,aFieldWidth,aData2Text,aText2Data));
end;

procedure TSQLRecordProperties.RegisterCustomRTTIRecordProperty(aTable: TClass;
  aRecordInfo: PTypeInfo; const aName: RawUTF8;  aPropertyPointer: pointer;
  aAttributes: TSQLPropInfoAttributes=[]; aFieldWidth: integer=0;
  aData2Text: TOnSQLPropInfoRecord2Text=nil;
  aText2Data: TOnSQLPropInfoRecord2Data=nil);
begin
  Fields.Add(aTable,TSQLPropInfoRecordRTTI.Create(aRecordInfo,aName,Fields.Count,
    aPropertyPointer,aAttributes,aFieldWidth,aData2Text,aText2Data));
end;

procedure TSQLRecordProperties.RegisterCustomPropertyFromRTTI(aTable: TClass;
  aTypeInfo: PTypeInfo; const aName: RawUTF8; aPropertyPointer: pointer;
  aAttributes: TSQLPropInfoAttributes=[]; aFieldWidth: integer=0);
begin
  Fields.Add(aTable,TSQLPropInfoCustomJSON.Create(aTypeInfo,aName,Fields.Count,
    aPropertyPointer,aAttributes,aFieldWidth));
end;

procedure TSQLRecordProperties.RegisterCustomPropertyFromTypeName(aTable: TClass;
  const aTypeName, aName: RawUTF8; aPropertyPointer: pointer;
  aAttributes: TSQLPropInfoAttributes=[]; aFieldWidth: integer=0);
begin
  Fields.Add(aTable,TSQLPropInfoCustomJSON.Create(aTypeName,aName,Fields.Count,
    aPropertyPointer,aAttributes,aFieldWidth));
end;



{ TSynValidateUniqueField }

function TSynValidateUniqueField.Process(aFieldIndex: integer; const Value: RawUTF8;
  var ErrorMsg: string): boolean;
var aID: integer;
begin
  result := false;
  if Value='' then
    ErrorMsg := sValidationFieldVoid else
  if (fProcessRest=nil) or (fProcessRec=nil) then
    result := true else
  with fProcessRec.RecordProps do
    if cardinal(aFieldIndex)>=cardinal(Fields.Count) then
      result := true else begin
      aID := GetInteger(pointer(fProcessRest.OneFieldValue(Table,'RowID',
        Fields.List[aFieldIndex].Name+'=:('+QuotedStr(Value,'''')+'):')));
      if (aID>0) and (aID<>fProcessRec.fID) then
        ErrorMsg := sValidationFieldDuplicate else
        result := true;
    end;
end;


{ TJSONSerializer }

destructor TJSONSerializer.Destroy;
begin
  fInternalJSONWriter.Free;
  inherited;
end;

procedure TJSONSerializer.WriteObject(Value: TObject; Options: TTextWriterWriteObjectOptions);
var Added: boolean;
    CustomComment: RawUTF8;
procedure HR(P: PPropInfo=nil);
begin
  if woHumanReadable in Options then begin
    if CustomComment<>'' then begin
      AddShort(' // ');
      AddString(CustomComment);
      CustomComment := '';
    end;
    AddCRAndIndent;
  end;
  if P=nil then
    exit;
  AddPropName(P^.Name);
  if woHumanReadable in Options then
    Add(' ');
  Added := true;
end;
var P: PPropInfo;
    i, j, V, c: integer;
    Obj: TObject;
    List: TList absolute Value;
{$ifndef LVCL}
    Coll: TCollection absolute Value;
{$endif}
    Str: TStrings absolute Value;
    Utf: TRawUTF8List absolute Value;
    aClassType: TClass;
    CP: PClassProp;
    Kind: TTypeKind;
    PS: PShortString;
    UtfP: PPUtf8CharArray;
    IsObj: TJSONObject;
    IsObjCustomIndex: integer;
    WS: WideString;
    {$ifndef NOVARIANTS}
    VVariant: variant;
    {$endif}
label next;
begin
  if not (woHumanReadable in Options) or (fHumanReadableLevel<0) then
    fHumanReadableLevel := 0;
  if (self=nil) or (Value=nil) then
    aClassType := nil else
    aClassType := PPointer(Value)^;
  if aClassType=nil then begin
    AddShort('null'); // return void object
    exit;
  end;
  if woFullExpand in Options then begin
    Add('{');
    AddInstanceName(Value,':');
  end;
  IsObj := JSONObject(aClassType,IsObjCustomIndex,[cpWrite]);
  case IsObj of
  // handle custom class serialization
  oCustom:
    with JSONCustomParsers[IsObjCustomIndex] do begin
      if Assigned(Writer) then
        Writer(self,Value,Options);
      exit;
    end;
  // handle JSON arrays
  oList, oObjectList, {$ifndef LVCL}oCollection,{$endif} oUtfs, oStrings: begin
    HR;
    Add('['); // write as JSON array of JSON objects
    inc(fHumanReadableLevel);
    case IsObj of
    oList: // TList
      for c := 0 to List.Count-1 do begin
        WriteObject(List.List[c],Options);
        Add(',');
      end;
    oObjectList: // TObjectList will include "ClassName":"TMyObject" field
      for c := 0 to List.Count-1 do begin
        WriteObject(List.List[c],Options+[woStoreClassName]);
        Add(',');
      end;
{$ifndef LVCL}
    oCollection:
      for c := 0 to Coll.Count-1 do begin
        WriteObject(Coll.Items[c],Options);
        Add(',');
      end;
{$endif}
    oUtfs: begin
      UtfP := Utf.ListPtr;
      for c := 0 to Utf.Count-1 do begin
        HR;
        Add('"');
        AddJSONEscape(UtfP^[c]);
        Add('"',',');
      end;
    end;
    oStrings:
      for c := 0 to Str.Count-1 do begin
        HR;
        Add('"');
        AddJSONEscapeString(Str[c]);
        Add('"',',');
      end;
    end;
    CancelLastComma;
    dec(fHumanReadableLevel);
    HR;
    Add(']');
    if woFullExpand in Options then
      Add('}');
    exit;
  end;
  end;
  // handle JSON object
  Add('{');
  inc(fHumanReadableLevel);
  if woStoreClassName in Options then begin // optional "ClassName":"TObjectClass"
    HR;
    AddShort('"ClassName":"');
    AddShort(PShortString(PPointer(PPtrInt(Value)^+vmtClassName)^)^);
    Add('"',',');
  end;
  if IsObj in [oSQLRecord,oSQLMany] then begin
    // manual handling of TSQLRecord.ID property serialization
    HR;
    AddPropName('ID');
    if woHumanReadable in Options then
      Add(' ');
    Add(TSQLRecord(Value).fID);
    Add(',');
  end;
  repeat
    CP := InternalClassProp(aClassType);
    if CP=nil then
      break; // no more RTTI information available
    P := @CP^.PropList;
    for i := 1 to CP^.PropCount do begin
      if IsObj in [oSQLRecord,oSQLMany] then begin
        if IsRowIDShort(P^.Name) then
          goto next;
      end else
        if not P^.IsStored(Value) then
          goto next;
      Added := false;
      Kind := P^.PropType^^.Kind;
      case Kind of
        tkInt64{$ifdef FPC}, tkQWord{$endif}: begin
          HR(P);
          Add(GetInt64Prop(Value,pointer(P)));
        end;
        {$ifdef FPC} tkBool, {$endif}
        tkEnumeration, tkInteger, tkSet: begin
          V := GetOrdProp(Value,pointer(P)); // pointer() to call typinfo
          if (V<>P^.Default) or not (woDontStoreDefault in Options) then begin
            HR(P);
            if {$ifdef FPC}(Kind=tkBool){$else}
               (Kind=tkEnumeration) and (P^.PropType^=TypeInfo(boolean)){$endif} then
              AddString(JSON_BOOLEAN[boolean(V)]) else
              if (woFullExpand in Options) or (woHumanReadable in Options) then
              case Kind of
              tkEnumeration:
              with P^.PropType^^.EnumBaseType^ do begin
                 Add('"');
                 AddTrimLeftLowerCase(GetEnumNameOrd(V));
                 Add('"');
                 if woHumanReadableEnumSetAsComment in Options then
                   GetEnumNameTrimedAll(CustomComment);
              end;
              tkSet:
              with P^.PropType^^.SetEnumType^ do begin
                Add('[');
                if (woHumanReadableFullSetsAsStar in Options) and
                   (MaxValue<32) and GetAllBits(V,MaxValue+1) then
                  AddShort('"*"') else begin
                  PS := @NameList;
                  for j := MinValue to MaxValue do begin
                    if GetBit(V,j) then begin
                      Add('"');
                      AddTrimLeftLowerCase(PS);
                      Add('"',',');
                    end;
                    inc(PtrUInt(PS),ord(PS^[0])+1); // next item
                  end;
                end;
                CancelLastComma;
                Add(']');
               if woHumanReadableEnumSetAsComment in Options then
                 GetEnumNameTrimedAll(CustomComment);
              end;
              else
                Add(V);
              end else
                Add(V); // typecast enums and sets as plain integer by default
          end;
        end;
        {$ifdef FPC}tkAString,{$endif} tkLString: begin
          HR(P);
          Add('"');
          AddJSONEscape(pointer(P^.GetLongStrValue(Value)));
          Add('"');
        end;
        tkFloat: begin
          HR(P);
          if (P^.PropType^=TypeInfo(Currency)) and (PropWrap(P^.GetProc).Kind=$FF) then
            AddCurr64(PInt64(PtrInt(Value)+P^.GetProc and $00FFFFFF)^) else
          if P^.PropType^=TypeInfo(TDateTime) then begin
            Add('"');
            AddDateTime(GetDoubleProp(Value,pointer(P)));
            Add('"');
          end else
            Add(GetFloatProp(Value,pointer(P)));
        end;
        {$ifdef UNICODE}
        tkUString: begin // write converted to UTF-8
          HR(P);
          Add('"');
          AddJSONEscapeW(pointer(GetUnicodeStrProp(Value,pointer(P))));
          Add('"');
        end;
        {$endif}
        tkWString: begin // write converted to UTF-8
          HR(P);
          Add('"');
          GetWideStrProp(Value,pointer(P),WS);
          AddJSONEscapeW(pointer(WS));
          Add('"');
        end;
        tkDynArray: begin
          HR(P);
          AddDynArrayJSON(P^.GetDynArray(Value));
        end;
        {$ifdef PUBLISHRECORD}
        tkRecord: begin
          HR(P);
          AddRecordJSON(P^.GetFieldAddr(Value)^,P^.PropType^);
        end;
        {$endif}
        {$ifndef NOVARIANTS}
        tkVariant: begin // stored as JSON, e.g. '1.234' or '"text"'
          HR(P);
          GetVariantProp(Value,P,VVariant);
          AddVariantJSON(VVariant,twJSONEscape);
        end;
        {$endif}
        tkClass: begin
          Obj := pointer(GetOrdProp(Value,pointer(P)));  // works also for CPU64
          if (IsObj<>oSQLMany) or
             not(IdemPropName(P^.Name,'source') or IdemPropName(P^.Name,'dest')) then
            if (IsObj in [oSQLRecord,oSQLMany]) and
               (P^.PropType^^.ClassSQLFieldType=sftID) and
               not TSQLRecord(Value).fFill.JoinedFields then begin
              HR(P);
              Add(PtrInt(Obj)); // not true instances, but ID
            end else
            if Obj<>nil then begin
              HR(P);
              WriteObject(Obj,Options);
            end;
        end;
        // tkString (shortstring) is not handled
      end;
      if Added then
        Add(',');
next: P := P^.Next;
    end;
    aClassType := aClassType.ClassParent;
  until aClassType=nil;
  CancelLastComma;
  dec(fHumanReadableLevel);
  HR;
  Add('}');
  if woFullExpand in Options then
    Add('}');
end;

procedure TJSONSerializer.WriteObjectAsString(Value: TObject;
  Options: TTextWriterWriteObjectOptions);
begin
  Add('"');
  if fInternalJSONWriter=nil then
    fInternalJSONWriter := TJSONSerializer.CreateOwnedStream else
    fInternalJSONWriter.CancelAll;
  fInternalJSONWriter.WriteObject(Value,Options);
  AddJSONEscape(Pointer(fInternalJSONWriter.Text),0);
  Add('"');
end;

procedure TJSONSerializer.AddTypedJSON(aTypeInfo: pointer; const aValue);
var i: integer;
    PS: PShortString;
begin
  if aTypeInfo<>nil then
  case PTypeInfo(aTypeInfo)^.Kind of
  tkSet: begin
    Add('[');
    with PTypeInfo(aTypeInfo)^.SetEnumType^ do begin
      PS := @NameList;
      for i := MinValue to MaxValue do begin
        if GetBit(aValue,i) then begin
          Add('"');
          AddShort(PS^);
          Add('"');
          Add(',');
        end;
        inc(PtrUInt(PS),ord(PS^[0])+1);
      end;
    end;
    CancelLastComma;
    Add(']');
  end;
  else
    inherited; // handle other types
  end else
    AddShort('null');
end;

procedure TJSONSerializer.AddTypedJSONWithOptions(aTypeInfo: pointer; var aValue;
  Options: TTextWriterWriteObjectOptions); 
var i: integer;
    PS: PShortString;
begin
  if not ((woFullExpand in Options) or (woHumanReadable in Options)) then
    AddTypedJSON(aTypeInfo,aValue) else
  if aTypeInfo<>nil then
    case PTypeInfo(aTypeInfo)^.Kind of
      tkSet: begin
        Add('[');
        with PTypeInfo(aTypeInfo)^.SetEnumType^  do begin
          PS := @NameList;
          for i := MinValue to MaxValue do begin
            if GetBit(aValue,i) then begin
              Add('"');
              AddTrimLeftLowerCase(PS);
              Add('"',',');
            end;
            inc(PtrUInt(PS),ord(PS^[0])+1); // next item
          end;
        end;
        CancelLastComma;
        Add(']');
      end;
    else
      inherited AddTypedJSON(aTypeInfo, aValue);
    end
  else
    AddShort('null');
end;


{ TSQLVirtualTableModule }

constructor TSQLVirtualTableModule.Create(aTableClass: TSQLVirtualTableClass;
  aServer: TSQLRestServer);
begin
  fTableClass := aTableClass;
  fServer := aServer;
  fTableClass.GetTableModuleProperties(fFeatures);
  fModuleName := fTableClass.ModuleName;
  if fFeatures.FileExtension='' then // default extension is the module name 
    fFeatures.FileExtension := UTF8ToString(LowerCase(fModuleName));
end;

function TSQLVirtualTableModule.FileName(const aTableName: RawUTF8): TFileName;
begin
  result := UTF8ToString(aTableName)+'.'+FileExtension;;
  if fFilePath='' then
    result := ExtractFilePath(paramstr(0))+result else
    result := IncludeTrailingPathDelimiter(fFilePath)+result;
end;


{ TSQLVirtualTable }

constructor TSQLVirtualTable.Create(aModule: TSQLVirtualTableModule;
  const aTableName: RawUTF8; FieldCount: integer; Fields: PPUTF8CharArray);
begin
  if (aModule=nil) or (aTableName='') then
    raise EModelException.CreateFmt('Invalid parameters to %s.Create',[ClassName]);
  fModule := aModule;
  fTableName := aTableName;
  if fModule.fFeatures.StaticClass<>nil then
    // create new fStatic instance e.g. for TSQLVirtualTableLog
    if fModule.Server=nil then
      raise EModelException.CreateFmt('Missing aModule.Server for %s.Create',[ClassName]) else
    with fModule.Server do begin
      fStaticTableIndex := Model.GetTableIndex(aTableName);
      if fStaticTableIndex>=0 then begin
        fStaticTable := Model.Tables[fStaticTableIndex];
        fStatic := fModule.fFeatures.StaticClass.Create(fStaticTable,fModule.Server,
          fModule.FileName(aTableName),self.InheritsFrom(TSQLVirtualTableBinary));
        if length(fStaticVirtualTable)<>length(Model.Tables) then
          SetLength(fStaticVirtualTable,length(Model.Tables));
        fStaticVirtualTable[fStaticTableIndex] := fStatic;
        if fStatic.InheritsFrom(TSQLRestStorage) then
          fStaticStorage := TSQLRestStorage(fStatic);
      end;
    end;
end;

destructor TSQLVirtualTable.Destroy;
var aTableIndex: cardinal;
begin
  if fStatic<>nil then begin
    if (Module<>nil) and (Module.Server<>nil) then
      with Module.Server do begin
        aTableIndex := Model.GetTableIndex(TableName);
        if aTableIndex<cardinal(length(fStaticVirtualTable)) then begin
          fStaticVirtualTable[aTableIndex] := nil;
          if IsZero(fStaticVirtualTable,length(fStaticVirtualTable)*sizeof(pointer)) then
            SetLength(fStaticVirtualTable,0);
        end;
      end;
    fStatic.Free;
  end;
  inherited;
end;

function TSQLVirtualTable.Prepare(var Prepared: TSQLVirtualTablePrepared): boolean;
begin
  result := Self<>nil;
  if result then
    if (vtWhereIDPrepared in fModule.Features) and
       Prepared.IsWhereIDEquals(true) then
    with Prepared.Where[0] do begin // check ID=?
      Value.VType := ftNull; // mark TSQLVirtualTableCursorJSON expects it
      OmitCheck := true;
      Prepared.EstimatedCost := 1;
    end else
      Prepared.EstimatedCost := 1E10; // generic high cost  
end;

function TSQLVirtualTable.Drop: boolean;
begin
  result := false;  // no DROP TABLE to be implemented here
end;

function TSQLVirtualTable.Delete(aRowID: Int64): boolean;
begin
  result := false;  // no DELETE to be implemented here
end;

function TSQLVirtualTable.Insert(aRowID: Int64;
  var Values: TSQLVarDynArray; out insertedRowID: Int64): boolean;
begin
  result := false;  // no INSERT to be implemented here
end;

function TSQLVirtualTable.Update(oldRowID, newRowID: Int64;
  var Values: TSQLVarDynArray): boolean;
begin
  result := false;  // no UPDATE to be implemented here
end;

function TSQLVirtualTable.Transaction(aState: TSQLVirtualTableTransaction;
  aSavePoint: integer): boolean;
begin
  result := (Module<>nil) and (vtWrite in Module.Features) and
    (aState in [vttBegin, vttSync, vttCommit, vttSavePoint, vttRelease]);
end;

function TSQLVirtualTable.Rename(const NewName: RawUTF8): boolean;
begin
  result := false;
end;

class function TSQLVirtualTable.ModuleName: RawUTF8;
begin
  if self=nil then
    result := '' else begin
    result := RawUTF8(ClassName);
    if IdemPChar(pointer(result),'TSQLVIRTUALTABLE') then
      system.delete(result,1,16) else
    if IdemPChar(pointer(result),'TSQLVIRTUAL') then
      system.delete(result,1,11) else
    if IdemPChar(pointer(result),'TSQL') then
      system.delete(result,1,4) else
      system.delete(result,1,1);
  end;
end;

class function TSQLVirtualTable.StructureFromClass(aClass: TSQLRecordClass;
  const aTableName: RawUTF8): RawUTF8;
begin
  result := FormatUTF8('CREATE TABLE % (%',[aTableName,
    GetVirtualTableSQLCreate(aClass.RecordProps)]);
end;

function TSQLVirtualTable.Structure: RawUTF8;
begin
  result := '';
  if Self<>nil then
    if (Static<>nil) then
      // e.g. for TSQLVirtualTableJSON or TSQLVirtualTableExternal
      Result := StructureFromClass(StaticTable,TableName) else
    if (Module<>nil) and (Module.RecordClass<>nil) then
      // e.g. for TSQLVirtualTableLog
      Result := StructureFromClass(Module.RecordClass,TableName);
end;


{ TSQLVirtualTableCursor }

constructor TSQLVirtualTableCursor.Create(aTable: TSQLVirtualTable);
begin
  fTable := aTable;
end;

procedure TSQLVirtualTableCursor.SetColumn(var aResult: TSQLVar; aValue: Int64);
begin
  aResult.VType := ftInt64;
  aResult.VInt64 := aValue;
end;

procedure TSQLVirtualTableCursor.SetColumn(var aResult: TSQLVar; const aValue: double);
begin
  aResult.VType := ftDouble;
  aResult.VDouble := aValue;
end;

procedure TSQLVirtualTableCursor.SetColumn(var aResult: TSQLVar; const aValue: RawUTF8);
begin
  aResult.VType := ftUTF8;
  fColumnTemp := aValue; // temporary copy available until next Column() call
  aResult.VText := pointer(fColumnTemp);
end;

procedure TSQLVirtualTableCursor.SetColumn(var aResult: TSQLVar;
  aValue: PUTF8Char; aValueLength: integer);
begin
  aResult.VType := ftUTF8;
  SetString(fColumnTemp,PAnsiChar(aValue),aValueLength); // temporary copy
  aResult.VText := pointer(fColumnTemp);
end;

procedure TSQLVirtualTableCursor.SetColumnBlob(var aResult: TSQLVar;
  aValue: pointer; aValueLength: integer);
begin
  aResult.VType := ftBlob;
  SetString(fColumnTemp,PAnsiChar(aValue),aValueLength); // temporary copy
  aResult.VBlob := pointer(fColumnTemp);
  aResult.VBlobLen := aValueLength;
end;


{ TSQLLog }

procedure TSQLLog.CreateLogWriter;
begin
  if integer(fFamily.EchoToConsole)=0 then // force fWriter=TTextWriterEcho
    fWriter := TJSONSerializer.Create(nil,fFamily.BufferSize);
  inherited CreateLogWriter;
  fWriter.Stream := fWriterStream;
end;



{ TSQLVirtualTableCursorIndex }

function TSQLVirtualTableCursorIndex.HasData: boolean;
begin
  result := (self<>nil) and (fCurrent<=fMax);
end;

function TSQLVirtualTableCursorIndex.Next: boolean;
begin
  if self=nil then
    result := false else begin
    if fCurrent<=fMax then
      inc(fCurrent);
    result := true;
  end;
end;

function TSQLVirtualTableCursorIndex.Search(
  const Prepared: TSQLVirtualTablePrepared): boolean;
begin
  fCurrent := 0; // mark EOF by default
  fMax := -1;
  result := self<>nil;
end;


{ TSQLVirtualTablePrepared }

function TSQLVirtualTablePrepared.IsWhereIDEquals(CalledFromPrepare: Boolean): boolean;
begin
  result := (WhereCount=1) and (Where[0].Column=VIRTUAL_TABLE_ROWID_COLUMN) and
     (CalledFromPrepare or (Where[0].Value.VType=ftInt64)) and
     (Where[0].Operation=soEqualTo);
end;

function TSQLVirtualTablePrepared.IsWhereOneFieldEquals: boolean;
begin
  result := (WhereCount=1) and (Where[0].Column>=0) and
     (Where[0].Operation=soEqualTo);
end;


{ TSQLVirtualTableJSON }

constructor TSQLVirtualTableJSON.Create(aModule: TSQLVirtualTableModule;
  const aTableName: RawUTF8; FieldCount: integer; Fields: PPUTF8CharArray);
begin
  inherited Create(aModule,aTableName,FieldCount,Fields);
  fStaticInMemory := fStatic as TSQLRestStorageInMemory;
end;

function TSQLVirtualTableJSON.Delete(aRowID: Int64): boolean;
begin
  result := (Static<>nil) and Static.Delete(StaticTable,aRowID);
  if result and (StaticStorage<>nil) and (StaticStorage.Owner<>nil) then
    StaticStorage.Owner.fCache.NotifyDeletion(StaticTable,aRowID);
end;

function TSQLVirtualTableJSON.Drop: boolean;
begin
  if (self<>nil) and (Static<>nil) then begin
    fStaticInMemory.RollBack(0); // close any pending transaction
    fStaticInMemory.fValue.Clear;
    fStaticInMemory.Modified := true; // force update file after clear
    fStaticInMemory.UpdateFile;
    result := true;
  end else
    result := false;
end;

class procedure TSQLVirtualTableJSON.GetTableModuleProperties(
  var aProperties: TVirtualTableModuleProperties);
begin
  aProperties.Features := [vtWrite,vtWhereIDPrepared];
  aProperties.CursorClass := TSQLVirtualTableCursorJSON;
  aProperties.StaticClass := TSQLRestStorageInMemoryExternal; // will flush Cache
  if InheritsFrom(TSQLVirtualTableBinary) then
    aProperties.FileExtension := 'data';
  // default will follow the class name, e.g. '.json' for TSQLVirtualTableJSON
end;

function TSQLVirtualTableJSON.Insert(aRowID: Int64;
  var Values: TSQLVarDynArray; out insertedRowID: Int64): boolean;
var aRecord: TSQLRecord;
begin
  result := false;
  if (self=nil) or (Static=nil) then
    exit;
  aRecord := StaticTable.Create;
  try
    if aRecord.SetFieldSQLVars(Values) then begin
      if aRowID>0 then
        aRecord.fID := aRowID;
      insertedRowID := fStaticInMemory.AddOne(aRecord,aRowID>0,
        aRecord.GetJSONValues(true,False,soInsert));
      if insertedRowID>0 then begin
        if fStaticInMemory.Owner<>nil then
          fStaticInMemory.Owner.fCache.Notify(aRecord,soInsert);
        result := true;
      end;
    end;
  finally
    if not result then
      aRecord.Free; // on success, aRecord will stay in Values[]
  end;
end;

function TSQLVirtualTableJSON.Prepare(var Prepared: TSQLVirtualTablePrepared): boolean;
begin
  result := inherited Prepare(Prepared); // optimize ID=? WHERE clause
  if result and (Static<>nil) then begin
    if Prepared.IsWhereOneFieldEquals then
    with Prepared.Where[0] do
    if fStaticInMemory.UniqueFieldHash(Column)<>nil then begin
      Value.VType := ftNull; // mark TSQLVirtualTableCursorJSON expects it
      OmitCheck := true;
      Prepared.EstimatedCost := 1; 
    end;
    if Prepared.EstimatedCost>1E9 then
      Prepared.EstimatedCost := fStaticInMemory.Count;
    if fStaticInMemory.fIDSorted and (Prepared.OrderByCount=1) then
      // ascending IDs ?
      with Prepared.OrderBy[0] do
        if (Column=VIRTUAL_TABLE_ROWID_COLUMN) and not Desc then
          Prepared.OmitOrderBy := true;
  end;
end;

function TSQLVirtualTableJSON.Update(oldRowID, newRowID: Int64;
  var Values: TSQLVarDynArray): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or (Static=nil) or
     (oldRowID<>newRowID) or (newRowID<=0) then // don't allow ID change
    exit;
    if fStaticInMemory.UpdateOne(newRowID,Values) then begin
      if (fStaticInMemory.Owner<>nil) then begin
        i := fStaticInMemory.IDToIndex(newRowID);
        if i>=0 then
          fStaticInMemory.Owner.fCache.Notify(
            TSQLRecord(fStaticInMemory.fValue.List[i]),soUpdate);
      end;
      result := true;
    end;
end;


{ TSQLVirtualTableCursorJSON }

function TSQLVirtualTableCursorJSON.Column(aColumn: integer;
  var aResult: TSQLVar): boolean;
var Value: TObjectList;
begin
  if (self=nil) or (fCurrent>fMax) or
     (TSQLVirtualTableJSON(Table).Static=nil) then begin
    result := false;
    exit;
  end;
  Value := TSQLVirtualTableJSON(Table).fStaticInMemory.fValue;
  if Cardinal(fCurrent)>=Cardinal(Value.Count) then
    result := False else begin
    if aColumn=VIRTUAL_TABLE_ROWID_COLUMN then begin
      aResult.VType := ftInt64;
      aResult.VInt64 := TSQLRecord(Value.List[fCurrent]).fID;
    end else
    with TSQLVirtualTableJSON(Table).fStaticInMemory.fStoredClassRecordProps.Fields do
      if cardinal(aColumn)>=cardinal(Count) then
        aResult.VType := ftNull else
        List[aColumn].GetFieldSQLVar(Value.List[fCurrent],aResult,fColumnTemp);
    result := true;
  end;
end;

function TSQLVirtualTableCursorJSON.Search(
  const Prepared: TSQLVirtualTablePrepared): boolean;
var Hash: TListFieldHash;
begin
  result := inherited Search(Prepared); // mark EOF by default
  if (not result) or (not Table.InheritsFrom(TSQLVirtualTableJSON)) or
     (TSQLVirtualTableJSON(Table).fStaticInMemory=nil) then
    result := false else
    with TSQLVirtualTableJSON(Table).fStaticInMemory do begin
    if Count>0 then
      // if something to search in
      if Prepared.IsWhereIDEquals(false) then begin // ID=?
        fMax := IDToIndex(Prepared.Where[0].Value.VInt64); // binary search
        if fMax>=0 then
          fCurrent := fMax; // ID found
      end else
      if Prepared.IsWhereOneFieldEquals then
      with Prepared.Where[0] do begin
        Hash := UniqueFieldHash(Column);
        if Hash<>nil then begin // optimized hash-based search
          fStoredClassRecordProps.Fields.List[Column].SetFieldSQLVar(fSearchRec,Value);
          fMax := Hash.Find(fSearchRec);
          if fMax>=0 then
            fCurrent := fMax; // value found with O(1) search
        end else
         fMax := Count-1; // loop all records in ID order
      end else
        fMax := Count-1; // loop all records in ID order
    result := true; // no DB error
  end;                            
end;


{ TSQLVirtualTableLog }

type
  {/ Record associated to Virtual Table implemented in Delphi, for Read/Only
    access to a .log file, as created by TSynLog
   - not used as real instances, but only used by the TSQLVirtualTableLog module
     to provide the field layout needed to create the column layout for the
     CREATE TABLE statement }
  TSQLRecordLogFile = class(TSQLRecordVirtualTableAutoID)
  protected
    fContent: RawUTF8;
    fDateTime: TDateTime;
    fLevel: TSynLogInfo;
  published
    /// the log event time stamp
    property DateTime: TDateTime read fDateTime;
    /// the log event level
    property Level: TSynLogInfo read fLevel;
    /// the textual message associated to the log event
    property Content: RawUTF8 read fContent;
  end;


constructor TSQLVirtualTableLog.Create(aModule: TSQLVirtualTableModule;
  const aTableName: RawUTF8; FieldCount: integer; Fields: PPUTF8CharArray);
var aFileName: TFileName;
begin
  inherited Create(aModule,aTableName,Fieldcount,Fields); 
  if (FieldCount=1) then
    aFileName := UTF8ToString(Fields[0]) else
    aFileName := aModule.FileName(aTableName);
  fLogFile := TSynLogFile.Create(aFileName);
end;

destructor TSQLVirtualTableLog.Destroy;
begin
  fLogFile.Free;
  inherited;
end;

class procedure TSQLVirtualTableLog.GetTableModuleProperties(
  var aProperties: TVirtualTableModuleProperties);
begin
  aProperties.Features := [vtWhereIDPrepared];
  aProperties.CursorClass := TSQLVirtualTableCursorLog;
  aProperties.RecordClass := TSQLRecordLogFile;
end;


{ TSQLVirtualTableCursorLog }

function TSQLVirtualTableCursorLog.Column(aColumn: integer;
  var aResult: TSQLVar): boolean;
var LogFile: TSynLogFile;
begin
  result := false;
  if (self=nil) or (fCurrent>fMax) then
    exit;
  LogFile := TSQLVirtualTableLog(Table).fLogFile;
  if LogFile=nil then
    exit;
  case aColumn of
   -1: SetColumn(aResult,fCurrent+1); // ID = row index + 1
    0: SetColumn(aResult,LogFile.EventDateTime(fCurrent));
    1: SetColumn(aResult,ord(LogFile.EventLevel[fCurrent]));
    2: SetColumn(aResult,LogFile.LinePointers[fCurrent],LogFile.LineSize(fCurrent));
    else exit;
  end;
  result := true;
end;

function TSQLVirtualTableCursorLog.Search(
  const Prepared: TSQLVirtualTablePrepared): boolean;
begin
  result := inherited Search(Prepared); // mark EOF by default
  if result then begin
    fMax := TSQLVirtualTableLog(Table).fLogFile.Count-1; // search all range
    if Prepared.IsWhereIDEquals(false) then begin
      fCurrent := Prepared.Where[0].Value.VInt64-1; // ID=? -> index := ID-1
      if cardinal(fCurrent)<=cardinal(fMax) then
        fMax := fCurrent else // found one
        fMax := fCurrent-1;   // out of range ID
    end;
  end;
end;


{ TAuthSession }

constructor TAuthSession.Create(aCtxt: TSQLRestServerURIContext; aUser: TSQLAuthUser);
var GID: TSQLAuthGroup;
begin
  fUser := aUser;
  if (aCtxt<>nil) and (User<>nil) and (User.fID<>0) then begin
    GID := User.GroupRights; // save pseudo TSQLAuthGroup = ID
    User.GroupRights := aCtxt.Server.fSQLAuthGroupClass.Create(aCtxt.Server,User.GroupRights);
    if User.GroupRights.fID<>0 then begin
      // compute the next Session ID
      with aCtxt.Server do begin
        if fSessionCounter>=cardinal(maxInt) then
          fSessionCounter := 10 else
          if fSessionCounter=76 then // avoid IDCardinal=0 (77) or 1 (76)
            fSessionCounter := 78 else
            inc(fSessionCounter);
          fIDCardinal := fSessionCounter xor 77;
          UInt32ToUtf8(fIDCardinal,fID);
      end;
      // set session parameters
      fTimeOutMS := User.GroupRights.SessionTimeout*(1000*60); // min to ms
      fAccessRights := User.GroupRights.SQLAccessRights;
      fPrivateKey := SHA256(NowToString+fID);
      fPrivateSalt := fID+'+'+fPrivateKey;
      fPrivateSaltHash :=
        crc32(crc32(0,pointer(fPrivateSalt),length(fPrivateSalt)),
          pointer(User.PasswordHashHexa),length(User.PasswordHashHexa));
      fLastAccess64 := GetTickCount64;
      aCtxt.Server.RetrieveBlob(aCtxt.Server.fSQLAuthUserClass,User.fID,'Data',User.fData);
      if (aCtxt.Call<>nil) and (aCtxt.Call.InHead<>'') then begin
        fSentHeaders := aCtxt.Call.InHead;
        fRemoteIP := FindIniNameValue(pointer(fSentHeaders),'REMOTEIP: ');
        fConnectionID := FindIniNameValue(pointer(fSentHeaders),'CONNECTIONID: ');
      end;
      {$ifdef WITHLOG}
      SQLite3Log.Family.SynLog.Log(sllUserAuth,
        'New "%" session %/% created at %/% running %',
        [User.GroupRights.Ident,User.LogonName,fIDCardinal,fRemoteIP,fConnectionID,
         FindIniNameValue(pointer(fSentHeaders),'USER-AGENT: ')],self);
      {$endif}
      exit; // create successfull
    end;
    // on error: set GroupRights back to a pseudo TSQLAuthGroup = ID
    User.GroupRights.Free;
    User.GroupRights := GID;
  end;
  raise ESecurityException.Create('TAuthSession.Create');
end;

destructor TAuthSession.Destroy;
begin
  if User<>nil then begin
    User.GroupRights.Free;
    fUser.Free;
  end;
  inherited;
end;

function TAuthSession.IsValidURL(Ctxt: TSQLRestServerURIContext): boolean;
// expected format is 'session_signature='Hexa8(SessionID)+Hexa8(TimeStamp)+
// Hexa8(crc32('SessionID+HexaSessionPrivateKey'+Sha256('salt'+PassWord)+
//  Hexa8(TimeStamp)+url))
var aTimeStamp, aSignature: cardinal;
    PTimeStamp: PAnsiChar;
    aURLlength: Integer;
begin
  aURLlength := Ctxt.URISessionSignaturePos-1;
  PTimeStamp := @Ctxt.Call^.url[aURLLength+(20+8)]; // P^ points to Hexa8(TimeStamp)
  result := (self<>nil) and
     HexDisplayToCardinal(PTimeStamp,aTimeStamp) and
     (aTimeStamp>=fLastTimeStamp) and // check time stamp coherency
     HexDisplayToCardinal(PTimeStamp+8,aSignature) and
     (crc32(crc32(fPrivateSaltHash,PTimeStamp,8),pointer(Ctxt.Call^.url),aURLlength)=aSignature);
  if result then
    fLastTimeStamp := aTimeStamp;
end;


{ TSQLAccessRights }

procedure TSQLAccessRights.Edit(aTableIndex: integer; C, R, U, D: Boolean);
begin
  if C then
    Include(POST,aTableIndex) else
    Exclude(POST,aTableindex);
  if R then
    Include(GET,aTableIndex) else
    Exclude(GET,aTableindex);
  if U then
    Include(PUT,aTableIndex) else
    Exclude(PUT,aTableindex);
  if D then
    Include(DELETE,aTableIndex) else
    Exclude(DELETE,aTableindex);
end;

procedure TSQLAccessRights.Edit(aTableIndex: integer; aRights: TSQLOccasions);
begin
  if soInsert in aRights then
    Include(POST,aTableIndex) else
    Exclude(POST,aTableindex);
  if soSelect in aRights then
    Include(GET,aTableIndex) else
    Exclude(GET,aTableindex);
  if soUpdate in aRights then
    Include(PUT,aTableIndex) else
    Exclude(PUT,aTableindex);
  if soDelete in aRights then
    Include(DELETE,aTableIndex) else
    Exclude(DELETE,aTableindex);
end;

procedure TSQLAccessRights.FromString(P: PUTF8Char);
begin
  fillchar(self,sizeof(self),0);
  if P=nil then
    exit;
  AllowRemoteExecute := TSQLAllowRemoteExecute(byte(GetNextItemCardinal(P)));
  SetBitCSV(GET,MAX_SQLTABLES,P);
  SetBitCSV(POST,MAX_SQLTABLES,P);
  SetBitCSV(PUT,MAX_SQLTABLES,P);
  SetBitCSV(DELETE,MAX_SQLTABLES,P);
end;

function TSQLAccessRights.ToString: RawUTF8;
begin
  result := FormatUTF8('%,%,%,%,%',
    [Byte(AllowRemoteExecute),
     GetBitCSV(GET,MAX_SQLTABLES), GetBitCSV(POST,MAX_SQLTABLES),
     GetBitCSV(PUT,MAX_SQLTABLES), GetBitCSV(DELETE,MAX_SQLTABLES)]);
end;


{ TSQLAuthGroup }

function TSQLAuthGroup.GetSQLAccessRights: TSQLAccessRights;
begin
  if self=nil then
    fillchar(result,sizeof(result),0) else
    result.FromString(pointer(AccessRights));
end;

class procedure TSQLAuthGroup.InitializeTable(Server: TSQLRestServer;
  const FieldName: RawUTF8);
var G: TSQLAuthGroup;
    A: TSQLAccessRights;
    U: TSQLAuthUser;
    AuthUserIndex, AuthGroupIndex: integer;
    AdminID, SupervisorID, UserID: PtrInt;
begin
  inherited; // will create any needed index
  if (Server<>nil) and (FieldName='') then
    if Server.HandleAuthentication then begin
      // create default Groups and Users (we are already in a Transaction)
      AuthGroupIndex := Server.Model.GetTableIndexExisting(Server.fSQLAuthUserClass);
      AuthUserIndex := Server.Model.GetTableIndexExisting(Server.fSQLAuthGroupClass);
      G := Server.fSQLAuthGroupClass.Create;
      try
        //            POST SQL  Service Auth R  Auth W  Tables R  Tables W
        // Admin        Yes       Yes    Yes     Yes      Yes      Yes
        // Supervisor   No        Yes    Yes     No       Yes      Yes
        // User         No        Yes    No      No       Yes      Yes
        // Guest        No        No     No      No       Yes      No
        A := FULL_ACCESS_RIGHTS;
        G.Ident := 'Admin';
        G.SQLAccessRights := A;
        G.SessionTimeout := 10;
        AdminID := Server.Add(G,true);
        G.Ident := 'Supervisor';
        A.AllowRemoteExecute := SUPERVISOR_ACCESS_RIGHTS.AllowRemoteExecute;
        A.Edit(AuthUserIndex,[soSelect]); // AuthUser  R/O
        A.Edit(AuthGroupIndex,[soSelect]); // AuthGroup R/O
        G.SQLAccessRights := A;
        G.SessionTimeout := 60;
        SupervisorID := Server.Add(G,true);
        G.Ident := 'User';
        Exclude(A.GET,AuthUserIndex); // no Auth R
        Exclude(A.GET,AuthGroupIndex);
        G.SQLAccessRights := A;
        G.SessionTimeout := 60;
        UserID := Server.Add(G,true);
        G.Ident := 'Guest';
        A.AllowRemoteExecute := [];
        fillchar(A.POST,sizeof(TSQLFieldTables),0); // R/O access
        fillchar(A.PUT,sizeof(TSQLFieldTables),0);
        fillchar(A.DELETE,sizeof(TSQLFieldTables),0);
        G.SQLAccessRights := A;
        G.SessionTimeout := 60;
        Server.Add(G,true);
      finally
        G.Free;
      end;
      U := Server.fSQLAuthUserClass.Create;
      try
        U.LogonName := 'Admin';
        U.PasswordPlain := 'synopse';
        U.DisplayName := U.LogonName;
        U.GroupRights := TSQLAuthGroup(AdminID);
        Server.Add(U,true);
        U.LogonName := 'Supervisor';
        U.DisplayName := U.LogonName;
        U.GroupRights := TSQLAuthGroup(SupervisorID);
        Server.Add(U,true);
        U.LogonName := 'User';
        U.DisplayName := U.LogonName;
        U.GroupRights := TSQLAuthGroup(UserID);
        Server.Add(U,true);
      finally
        U.Free;
      end;
    end;
end;

procedure TSQLAuthGroup.SetSQLAccessRights(const Value: TSQLAccessRights);
begin
  if self<>nil then
    AccessRights := Value.ToString;
end;


{ TSQLAuthUser }

procedure TSQLAuthUser.SetPasswordPlain(const Value: RawUTF8);
begin
  if self<>nil then
    PasswordHashHexa := SHA256('salt'+Value);
end;


{ TSQLRestServerAuthentication }

constructor TSQLRestServerAuthentication.Create(aServer: TSQLRestServer);
begin
  fServer := aServer;
end;

function TSQLRestServerAuthentication.AuthSessionRelease(
  Ctxt: TSQLRestServerURIContext): boolean;
var aUserName: RawUTF8;
    aSessionID: cardinal;
    i: integer;
begin
  if UrlDecodeNeedParameters(Ctxt.Parameters,'Session') then begin
    // GET ModelRoot/auth?UserName=...&Session=... -> release session
    while Ctxt.Parameters<>nil do begin
      UrlDecodeValue(Ctxt.Parameters,'USERNAME=',aUserName);
      UrlDecodeCardinal(Ctxt.Parameters,'SESSION=',aSessionID,@Ctxt.Parameters);
    end;
    if (fServer.fSessions<>nil) and
       // allow only to delete its own session - ticket [7723fa7ebd]
       (aSessionID=Ctxt.Session) then
      for i := 0 to fServer.fSessions.Count-1 do
        with TAuthSession(fServer.fSessions.List[i]) do
        if (fIDCardinal=aSessionID) and (fUser.LogonName=aUserName) then begin
          fServer.SessionDelete(i,Ctxt);
          Ctxt.Success;
          break;
        end;
    result := true;
  end else
    result := false;
end;

function TSQLRestServerAuthentication.GetUser(Ctxt: TSQLRestServerURIContext;
  const aUserName: RawUTF8): TSQLAuthUser;
begin
  result := fServer.fSQLAuthUserClass.Create(fServer,'LogonName=?',[aUserName]);
  if result.fID=0 then begin
    {$ifdef WITHLOG}
    Ctxt.Log.Log(sllUserAuth,
      'User.LogonName=% not found in AuthUser table',[aUserName],self);
    {$endif}
    FreeAndNil(result);
  end;
end;

procedure TSQLRestServerAuthentication.SessionCreate(Ctxt: TSQLRestServerURIContext;
  var User: TSQLAuthUser);
var Session: TAuthSession;
begin
  if User<>nil then
  try
    // now client is authenticated -> create a session
    fServer.SessionCreate(User,Ctxt,Session);
    if Session<>nil then
      Ctxt.Returns(['result',Session.fPrivateSalt,'logonname',Session.User.LogonName]);
  finally
    User.Free;
  end;
end;

class function TSQLRestServerAuthentication.ClientSetUser(Sender: TSQLRestClientURI;
  const aUserName, aPassword: RawUTF8;
  aPassworKind: TSQLRestServerAuthenticationClientSetUserPassword=passClear): boolean;
var U: TSQLAuthUser;
begin
  result := false;
  if Sender=nil then
    exit;
  try
    Sender.SessionClose;
    U := TSQLAuthUser.Create;
    try
      U.LogonName := trim(aUserName);
      if aPassworKind<>passClear then
        U.PasswordHashHexa := aPassword else
        U.PasswordPlain := aPassword; // compute SHA256('salt'+aPassword);
      result := Sender.SessionCreate(self,U,ClientComputeSessionKey(Sender,U));
    finally
      U.Free;
    end;
  finally
    if Assigned(Sender.OnSetUser) then
      Sender.OnSetUser(Sender); // always notify of user change, even if failed
  end;
end;


{ TSQLRestServerAuthenticationURI }

function TSQLRestServerAuthenticationURI.RetrieveSession(
  Ctxt: TSQLRestServerURIContext): TAuthSession;
begin
  result := nil;
  if Ctxt.Parameters=nil then
    exit;
  // expected format is 'session_signature='Hexa8(SessionID)'...
  if (Ctxt.URISessionSignaturePos>0) and // should be LAST parameter in URL
     HexDisplayToCardinal(
       PAnsiChar(pointer(Ctxt.Call^.url))+Ctxt.URISessionSignaturePos+18,Ctxt.Session) then
    result := fServer.SessionAccess(Ctxt);
end;

class function TSQLRestServerAuthenticationURI.ClientSessionSign(
  Sender: TSQLRestClientURI; const url: RawUTF8): RawUTF8;
begin
  if (Sender=nil) or (Sender.fSessionID=0) or (Sender.fSessionUser=nil) then
    result := url else
    if PosEx(RawUTF8('?'),url,1)=0 then
      result := url+'?session_signature='+Sender.fSessionIDHexa8 else
      result := url+'&session_signature='+Sender.fSessionIDHexa8;
end;


{ TSQLRestServerAuthenticationSignedURI }

function TSQLRestServerAuthenticationSignedURI.RetrieveSession(
  Ctxt: TSQLRestServerURIContext): TAuthSession;
begin
  result := inherited RetrieveSession(Ctxt);
  if result=nil then
    exit;
  // expected format is 'session_signature='Hexa8(SessionID)+Hexa8(TimeStamp)+
  // Hexa8(crc32('SessionID+HexaSessionPrivateKey'+Sha256('salt'+PassWord)+
  //   Hexa8(TimeStamp)+url))
  if not result.IsValidURL(Ctxt) then
    // mark invalid query authentication
    result := nil;
end;

class function TSQLRestServerAuthenticationSignedURI.ClientSessionSign(
  Sender: TSQLRestClientURI; const url: RawUTF8): RawUTF8;
var Nonce: RawUTF8;
begin
  if (Sender=nil) or (Sender.fSessionID=0) or (Sender.fSessionUser=nil) then
    result := url else begin // timestamps have 256 ms resolution
    if PosEx(RawUTF8('?'),url,1)=0 then
      result := url+'?session_signature=' else
      result := url+'&session_signature=';
    with Sender do begin
      fSessionLastTick64 := GetTickCount64;
      Nonce := CardinalToHex(fSessionLastTick64 shr 8);
      result := result+fSessionIDHexa8+Nonce+CardinalToHex(
        crc32(crc32(fSessionPrivateKey,Pointer(Nonce),length(Nonce)),Pointer(url),length(url)));
    end;
    // Hexa8(SessionID)+Hexa8(TimeStamp)+
    // Hexa8(crc32('SessionID+HexaSessionPrivateKey'+Sha256('salt'+PassWord)+
    // Hexa8(TimeStamp)+url))
  end;
end;


{ TSQLRestServerAuthenticationDefault }

function TSQLRestServerAuthenticationDefault.Auth(
  Ctxt: TSQLRestServerURIContext): boolean;
var aUserName, aPassWord, aClientNonce: RawUTF8;
    User: TSQLAuthUser;
begin
  result := true;
  if AuthSessionRelease(Ctxt) then
    exit;
  if UrlDecodeNeedParameters(Ctxt.Parameters,'PassWord,ClientNonce') then begin
    // GET ModelRoot/auth?UserName=...&PassWord=...&ClientNonce=... -> handshaking
    while Ctxt.Parameters<>nil do begin
      UrlDecodeValue(Ctxt.Parameters,'USERNAME=',aUserName);
      UrlDecodeValue(Ctxt.Parameters,'PASSWORD=',aPassWord);
      UrlDecodeValue(Ctxt.Parameters,'CLIENTNONCE=',aClientNonce,@Ctxt.Parameters);
    end;
    User := GetUser(Ctxt,aUserName);
    if User<>nil then
    try
      // check if match TSQLRestClientURI.SetUser() algorithm
      if not CheckPassword(Ctxt,User,aClientNonce,aPassWord) then
        exit;
      // now client is authenticated -> create a session
      SessionCreate(Ctxt,User);
    finally
      User.Free;
    end;
  end else
    if PosChar(Ctxt.Parameters,'&')=nil then
      // only UserName=... -> return hexadecimal nonce content valid for 5 minutes
      Ctxt.Results([Nonce(false)]) else
      // parameters does not match any expected layout
      result := false;
end;

function TSQLRestServerAuthenticationDefault.CheckPassword(Ctxt: TSQLRestServerURIContext;
  User: TSQLAuthUser; const aClientNonce, aPassWord: RawUTF8): boolean;
var aSalt: RawUTF8;
begin
  aSalt := aClientNonce+User.LogonName+User.PasswordHashHexa;
  result := (aPassWord=SHA256(fServer.Model.Root+Nonce(false)+aSalt)) or
            // if current nonce failed, tries with previous 5 minutes nonce
            (aPassWord=SHA256(fServer.Model.Root+Nonce(true)+aSalt));
end;

class function TSQLRestServerAuthenticationDefault.ClientComputeSessionKey(
  Sender: TSQLRestClientURI; User: TSQLAuthUser): RawUTF8;
var aServerNonce, aClientNonce: RawUTF8;
begin
  result := '';
  if User.LogonName='' then
    exit;
  aServerNonce := Sender.CallBackGetResult('auth',['UserName',User.LogonName]);
  if aServerNonce='' then
    exit;
  aClientNonce := Nonce(false);
  result := Sender.CallBackGetResult('auth',['UserName',User.LogonName,'Password',
     Sha256(Sender.Model.Root+aServerNonce+aClientNonce+User.LogonName+User.PasswordHashHexa),
     'ClientNonce',aClientNonce]);
end;


{ TSQLRestServerAuthenticationNone }

function TSQLRestServerAuthenticationNone.RetrieveSession(
  Ctxt: TSQLRestServerURIContext): TAuthSession;
var i: integer;
begin
  result := nil;
  if Ctxt.Parameters=nil then
    exit;
  // expected format is 'session_signature='Hexa8(SessionID)'...
  if Ctxt.URISessionSignaturePos=0 then
    if IdemPChar(Ctxt.Parameters,'SESSION_SIGNATURE=') then begin
      if HexDisplayToCardinal(PAnsiChar(Ctxt.Parameters)+18,Ctxt.Session) then
        result := fServer.SessionAccess(Ctxt);
      exit;
    end else
      i := PosEx('session_signature=',Ctxt.Call^.url)-1 else
    i := Ctxt.URISessionSignaturePos;
  if (i>0) and // should be LAST parameter in URL
     HexDisplayToCardinal(PAnsiChar(pointer(Ctxt.Call^.url))+i+18,Ctxt.Session) then
    result := fServer.SessionAccess(Ctxt);
end;

function TSQLRestServerAuthenticationNone.Auth(Ctxt: TSQLRestServerURIContext): boolean;
var aUserName: RawUTF8;
    U: TSQLAuthUser;
begin
  result := true;
  if AuthSessionRelease(Ctxt) then
    exit;
  while Ctxt.Parameters<>nil do
    UrlDecodeValue(Ctxt.Parameters,'USERNAME=',aUserName,@Ctxt.Parameters);
  U := GetUser(Ctxt,aUserName);
  SessionCreate(Ctxt,U);
end;

class function TSQLRestServerAuthenticationNone.ClientComputeSessionKey(
  Sender: TSQLRestClientURI; User: TSQLAuthUser): RawUTF8;
begin
  result := Sender.CallBackGetResult('auth',['UserName',User.LogonName]);
end;


{$ifdef SSPIAUTH}

{ TSQLRestServerAuthenticationSSPI }

const
  /// maximum number of Windows Authentication context to be handled at once
  // - 32 should be big enough
  MAXSSPIAUTHCONTEXTS = 32;

function TSQLRestServerAuthenticationSSPI.Auth(
  Ctxt: TSQLRestServerURIContext): boolean;
var i: integer;
    ConnectionID, UserName, InDataEnc: RawUTF8;
    BrowserAuth: Boolean;
    CtxArr: TDynArray;
    SecCtxIdx: Integer;
    OutData: RawByteString;
    User: TSQLAuthUser;
    Session: TAuthSession;
begin
  result := AuthSessionRelease(Ctxt);
  if result or not UrlDecodeNeedParameters(Ctxt.Parameters,'DATA') then
    exit;
  // use ConnectionID to find authentication session
  ConnectionID := FindIniNameValue(PUTF8Char(Ctxt.Call.InHead),'CONNECTIONID: ');
  // GET ModelRoot/auth?UserName=&data=... -> windows SSPI auth
  while Ctxt.Parameters<>nil do
    UrlDecodeValue(Ctxt.Parameters,'DATA=',InDataEnc,@Ctxt.Parameters);
  if InDataEnc='' then begin
    // client is browser and used HTTP headers to send auth data
    InDataEnc := FindIniNameValue(PUTF8Char(Ctxt.Call.InHead), SECPKGNAMEHTTPAUTHORIZATION);
    if InDataEnc = '' then begin
      // no auth data sent, reply with supported auth methods
      Ctxt.Call.OutHead := SECPKGNAMEHTTPWWWAUTHENTICATE;
      Ctxt.Call.OutStatus := HTML_UNAUTHORIZED;
      StatusCodeToErrorMsg(Ctxt.Call.OutStatus, Ctxt.Call.OutBody);
      exit;
    end;
    BrowserAuth := True;
  end else
    BrowserAuth := False;
  CtxArr.InitSpecific(TypeInfo(TSecContextDynArray),fSSPIAuthContexts,djRawUTF8);
  // check for outdated auth context
  for i := High(fSSPIAuthContexts) downto 0 do
    if GetTickCount64>fSSPIAuthContexts[i].CreatedTick64+30000  then begin
      FreeSecContext(fSSPIAuthContexts[i]);
      CtxArr.Delete(i);
    end;
  // if no auth context specified, create a new one
  result := true;
  SecCtxIdx := CtxArr.Find(ConnectionID);
  if SecCtxIdx<0 then begin
    // 1st call: create SecCtxId
    if High(fSSPIAuthContexts)>MAXSSPIAUTHCONTEXTS then begin
      {$ifdef WITHLOG}
      SQLite3Log.Family.SynLog.Log(sllUserAuth,
        'Too many Windows Authenticated session in pending state: MAXSSPIAUTHCONTEXTS=%',
        [MAXSSPIAUTHCONTEXTS],self);
      {$endif}
      exit;
    end;
    SecCtxIdx := CtxArr.New; // add a new entry to fSSPIAuthContexts[]
    InvalidateSecContext(fSSPIAuthContexts[SecCtxIdx],ConnectionID);
  end;
  // call SSPI provider
  if ServerSSPIAuth(fSSPIAuthContexts[SecCtxIdx], Base64ToBin(InDataEnc), OutData) then begin
    if BrowserAuth then begin
      Ctxt.Call.OutHead := (SECPKGNAMEHTTPWWWAUTHENTICATE+' ')+BinToBase64(OutData);
      Ctxt.Call.OutStatus := HTML_UNAUTHORIZED;
      StatusCodeToErrorMsg(Ctxt.Call.OutStatus, Ctxt.Call.OutBody);
    end
    else
      Ctxt.Returns(['result','','data',BinToBase64(OutData)]);
    exit; // 1st call: send back OutData to the client
  end;
  // 2nd call: user was authenticated -> release used context
  ServerSSPIAuthUser(fSSPIAuthContexts[SecCtxIdx],UserName);
  {$ifdef WITHLOG}
  with SQLite3Log.Family do
  if sllUserAuth in Level then
    SynLog.Log(sllUserAuth,'% Authentication success for %',
      [SecPackageName(fSSPIAuthContexts[SecCtxIdx]),UserName],self);
  {$endif}
  // now client is authenticated -> create a session for aUserName
  // and send back OutData
  try
    if UserName='' then
      exit;
    User := GetUser(Ctxt,UserName);
    if User<>nil then
    try
      User.PasswordHashHexa := ''; // override with context
      fServer.SessionCreate(User,Ctxt,Session);
      if Session<>nil then begin
        if BrowserAuth then
          Ctxt.Returns(JSONEncode(['result',Session.fPrivateSalt,
            'logonname',Session.User.LogonName]),
            HTML_SUCCESS, (SECPKGNAMEHTTPWWWAUTHENTICATE+' ')+BinToBase64(OutData))
        else
          Ctxt.Returns(['result',BinToBase64(SecEncrypt(fSSPIAuthContexts[SecCtxIdx],Session.fPrivateSalt)),
            'logonname',Session.User.LogonName,'data',BinToBase64(OutData)]);
      end;
    finally
      User.Free;
    end;
  finally
    FreeSecContext(fSSPIAuthContexts[SecCtxIdx]);
    CtxArr.Delete(SecCtxIdx);
  end;
end;

class function TSQLRestServerAuthenticationSSPI.ClientComputeSessionKey(
  Sender: TSQLRestClientURI; User: TSQLAuthUser): RawUTF8;
var SecCtx: TSecContext;
    InData, OutData: RawByteString;
    Response: RawUTF8;
    Values: TPUtf8CharDynArray;
begin // User.PasswordHashHexa = SPN registration for Kerberos
  result := '';
  User.LogonName := '';
  InvalidateSecContext(SecCtx,'');
  try
    repeat
      ClientSSPIAuth(SecCtx, InData, User.PasswordHashHexa, OutData);
      if OutData='' then
        break;
      if result<>'' then
        break;
      // 1st call will return data, 2nd call SessionKey
      if Sender.CallBackGet('auth',['UserName','',
          'data',BinToBase64(OutData)],Response,nil,0)<>HTML_SUCCESS then
        exit;
      JSONDecode(Response,['result','data','logonname'],Values);
      result := Values[0];
      InData := Base64ToBin(Values[1]);
      User.LogonName := Values[2];
      if InData='' then
        break;
    until false;
    result := SecDecrypt(SecCtx,Base64ToBin(result));
  finally
    FreeSecContext(SecCtx);
  end;
  // authenticated by Windows on the server side: use the returned
  // SessionKey + PasswordHashHexa to sign the URI, as usual
  User.PasswordHashHexa := ''; // should not appear on URI signature
end;

constructor TSQLRestServerAuthenticationSSPI.Create(aServer: TSQLRestServer);
begin
  inherited Create(aServer);
end;

destructor TSQLRestServerAuthenticationSSPI.Destroy;
var i: integer;
begin
  for i := 0 to High(fSSPIAuthContexts) do
    FreeSecContext(fSSPIAuthContexts[i]);
  inherited;
end;

{$endif SSPIAUTH}


{ TServiceContainer }

type
  PInterfaceTypeData = ^TInterfaceTypeData;
  TInterfaceTypeData = packed record
    IntfParent : PPTypeInfo; // ancestor
    IntfFlags : set of (ifHasGuid, ifDispInterface, ifDispatch);
    IntfGuid : TGUID;
    IntfUnit : ShortString;
  end;

  TMethodKind = (mkProcedure, mkFunction, mkConstructor, mkDestructor,
    mkClassProcedure, mkClassFunction, { Obsolete } mkSafeProcedure, mkSafeFunction);

  TIntfMethodEntryTail = packed record
    Kind: TMethodKind;
    CC: TCallingConvention;
    ParamCount: Byte;
  end;

function TServiceContainer.AddInterface(
  const aInterfaces: array of PTypeInfo; aInstanceCreation: TServiceInstanceImplementation;
  aContractExpected: RawUTF8): boolean;
var i: integer;
    F: TServiceFactoryClient;
begin
  result := false;
  if (self=nil) or (high(aInterfaces)<0) then
    exit;
  CheckInterface(aInterfaces);
  for i := 0 to high(aInterfaces) do begin
    F := TServiceFactoryClient.Create(
      Rest,aInterfaces[i],aInstanceCreation,aContractExpected);
    AddServiceInternal(F);
    aContractExpected := ''; // supplied contract is only for the 1st interface
  end;
  result := true;
end;

function TServiceContainer.AddInterface(aInterface: PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation;
  const aContractExpected: RawUTF8=''): TServiceFactoryClient;
begin
  CheckInterface([aInterface]);
  result := TServiceFactoryClient.Create(Rest,aInterface,aInstanceCreation,aContractExpected);
  AddServiceInternal(result);
end;

function TServiceContainer.Count: integer;
begin
  if self=nil then
    result := 0 else
    result := fList.Count;
end;

constructor TServiceContainer.Create(aRest: TSQLRest);
begin
  fRest := aRest;
  fList := TRawUTF8ListHashed.Create;
  fList.CaseSensitive := false;
  fListInterfaceMethods.InitSpecific(TypeInfo(TServiceContainerInterfaceMethods),
    fListInterfaceMethod,djRawUTF8,nil,true);
end;

destructor TServiceContainer.Destroy;
var i: integer;
begin
  for i := 0 to fList.Count-1 do
    fList.Objects[i].Free;
  fList.Free;
  inherited;
end;

function TServiceContainer.AddServiceInternal(aService: TServiceFactory): integer;
var MethodIndex: integer;
  procedure AddOne(const aInterfaceDotMethodName: RawUTF8);
  begin
    with PServiceContainerInterfaceMethod(fListInterfaceMethods.AddUniqueName(
       aInterfaceDotMethodName,'',[]))^ do begin
      InterfaceService := aService;
      InterfaceMethodIndex := MethodIndex;
    end;
    inc(MethodIndex);
  end;
var aURI: RawUTF8;
    internal: TServiceInternalMethod;
    m: integer;
begin
  if (self=nil) or (aService=nil) then
    result := 0 else
  with aService do begin
    // add service factory
    if ExpectMangledURI then
      aURI := fInterfaceMangledURI else
      aURI := fInterfaceURI;
    result := fList.AddObject(aURI,aService);
    // add associated methods
    aURI := aURI+'.';
    MethodIndex := 0;
    for internal := Low(TServiceInternalMethod) to High(TServiceInternalMethod) do
      AddOne(aURI+SERVICE_PSEUDO_METHOD[internal]);
    for m := 0 to fInterface.fMethodsCount-1 do
      AddOne(aURI+fInterface.fMethods[m].URI);
  end;
end;

procedure TServiceContainer.CheckInterface(const aInterfaces: array of PTypeInfo);
var i: integer;
begin
  for i := 0 to high(aInterfaces) do
    if aInterfaces[i]=nil then
      raise EServiceException.Create('Supplied a nil interface type') else
    with aInterfaces[i]^, PInterfaceTypeData(ClassType)^ do
    if Kind<>tkInterface then
      raise EServiceException.CreateFmt('%s is not an interface',[Name]) else
    if not (ifHasGuid in IntfFlags) then
      raise EServiceException.CreateFmt('%s interface has no GUID',[Name]) else
    if Guid(IntfGuid)<>nil then
      raise EServiceException.CreateFmt('%s GUID already registered',[Name]);
end;

procedure TServiceContainer.SetExpectMangledURI(aValue: Boolean);
var f: Integer;
    Fac: array of TServiceFactory;
begin
  if aValue=fExpectMangledURI then
    exit;
  fExpectMangledURI := aValue;
  fList.CaseSensitive := aValue;
  SetLength(Fac,fList.Count);
  for f := 0 to fList.Count-1 do
    Fac[f] := fList.Objects[f] as TServiceFactory;
  fList.Clear;
  fListInterfaceMethods.InitSpecific(TypeInfo(TServiceContainerInterfaceMethods),
    fListInterfaceMethod,djRawUTF8,nil,not aValue);
  for f := 0 to High(Fac) do
    AddServiceInternal(Fac[f]);
end;

function TServiceContainer.GetService(const aURI: RawUTF8): TServiceFactory;
var i: Integer;
begin
  if (self<>nil) and (aURI<>'') then begin
    i := fList.IndexOf(aURI);
    if i>=0 then
      result := TServiceFactory(fList.Objects[i]) else
      result := nil;
  end else
    result := nil;
end;

function TServiceContainer.Info(aTypeInfo: PTypeInfo): TServiceFactory;
var i: Integer;
    Obj: PPointerArray;
begin
  if self<>nil then begin
    Obj := fList.ObjectPtr;
    for i := 0 to fList.Count-1 do begin
      result := Obj[i];
      if result.fInterface.fInterfaceTypeInfo=aTypeInfo then
        exit;
    end;
  end;
  result := nil;
end;

function TServiceContainer.Index(aIndex: integer): TServiceFactory;
begin
  if Self=nil then
    result := nil else
    result := TServiceFactory(fList.Objects[aIndex]);
end;

function TServiceContainer.GUID(const aGUID: TGUID): TServiceFactory;
var i: Integer;
    Obj: PPointerArray;
begin
  if self<>nil then begin
    Obj := fList.ObjectPtr;
    for i := 0 to fList.Count-1 do begin
      result := Obj[i];
      if IsEqualGUID(result.InterfaceIID,aGUID) then
        exit;
    end;
  end;
  result := nil;
end;


{ TInterfacedObjectFake (private class for TInterfaceFactory.CreateFakeInstance) }

// see http://docwiki.embarcadero.com/RADStudio/en/Program_Control
const
  // this is used to avoid creating dynamic arrays if not needed
  MAX_METHOD_ARGS = 32;

  // QueryInterface, _AddRef and _Release methods are hard-coded
  RESERVED_VTABLE_SLOTS = 3;

  {$ifdef CPU64}
  
  // maximum stack size at method execution must match .PARAMS 64 (minus 4 regs)
  MAX_EXECSTACK = 60*8;

  REGRCX = 1;
  REGRDX = 2;
  REGR8 = 3;
  REGR9 = 4;
  REGXMM0 = 1;
  REGXMM1 = 2;
  REGXMM2 = 3;
  REGXMM3 = 4;
  REG_FIRST = REGRCX;
  REG_LAST = REGR9;

  {$else}

  // maximum stack size at method execution
  MAX_EXECSTACK = 1024;

  REGEAX = 1;
  REGEDX = 2;
  REGECX = 3;
  REG_FIRST = REGEAX;
  REG_LAST = REGECX;

  {$endif CPU64}

  PTRSIZ = sizeof(Pointer);

  STACKOFFSET_NONE = -1;

  // ordinal values are stored within 64 bit buffer, and records in a RawUTF8
  CONST_ARGS_TO_VAR: array[TServiceMethodValueType] of TServiceMethodValueVar = (
    smvvNone, smvvSelf, smvv64, smvv64, smvv64, smvv64, smvv64, smvv64, smvv64,
    smvv64, smvv64,
    smvvRawUTF8, smvvString, smvvWideString, smvvRecord,
    {$ifndef NOVARIANTS}smvvRecord,{$endif} smvvObject, smvvRawUTF8, smvvDynArray);

  {$ifdef CPU64}
  CONST_STOREDINXMM: TServiceMethodValueTypes = [smvDouble, smvDateTime];
  {$else}
  // always 8 or x64
  CONST_ARGS_IN_STACK_SIZE: array[TServiceMethodValueType] of Cardinal = (
     0,  PTRSIZ,PTRSIZ, PTRSIZ,PTRSIZ,PTRSIZ, PTRSIZ,    8,     8,      8,
 // None, Self, Boolean, Enum, Set,  Integer, Cardinal, Int64, Double, DateTime,
     8,       PTRSIZ,  PTRSIZ, PTRSIZ,     PTRSIZ, {$ifndef NOVARIANTS}PTRSIZ,{$endif}
 // Currency, RawUTF8, String, WideString, Record,  Variant,
    PTRSIZ, PTRSIZ,  PTRSIZ);
 // Object, RawJSON, DynArray
   {$endif}

  CONST_ARGS_RESULT_BY_REF: TServiceMethodValueTypes = [
    smvRawUTF8, smvRawJSON, smvString, smvWideString, smvRecord,
    {$ifndef NOVARIANTS}smvVariant,{$endif} smvDynArray];

  CONST_PSEUDO_RESULT_NAME: string[6] = 'Result';

type
  /// map the stack memory layout at TInterfacedObjectFake.FakeCall()
  TFakeCallStack = packed record
    {$ifdef CPU64}
    XMM1, XMM2, XMM3: double;
    MethodIndex: PtrUInt;
    Frame, Ret: pointer;
    RCX, RDX, R8, R9: pointer;
    {$else}
    EDX, ECX, MethodIndex, EBP, Ret: Cardinal;
    {$endif}
    Stack: array[word] of byte;
  end;

  /// instances of this class will emulate a given interface
  TInterfacedObjectFake = class(TInterfacedObject)
  protected
    fVTable: PPointerArray;
    fFactory: TInterfaceFactory;
    fInvoke: TOnFakeInstanceInvoke;
    fNotifyDestroy: TOnFakeInstanceDestroy;
    fClientDrivenID: Cardinal;
    function FakeCall(var aCall: TFakeCallStack): Int64;
    function FakeQueryInterface(const IID: TGUID; out Obj): HResult; stdcall;
    function Fake_AddRef: Integer; stdcall;
    function Fake_Release: Integer; stdcall;
    function SelfFromInterface: TInterfacedObjectFake;
      {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
  public
    /// create an instance, using the specified interface
    constructor Create(aFactory: TInterfaceFactory;
      aInvoke: TOnFakeInstanceInvoke; aNotifyDestroy: TOnFakeInstanceDestroy);
    /// release the remote server instance (in sicClientDriven mode);
    destructor Destroy; override;
    /// the ID used in sicClientDriven mode
    property ClientDrivenID: Cardinal read fClientDrivenID;
  end;

  EInterfaceStub = class(EInterfaceFactoryException)
  public
    constructor Create(Sender: TInterfaceStub; const Method: TServiceMethod;
      const Error: string); overload;
    constructor Create(Sender: TInterfaceStub; const Method: TServiceMethod;
      const Format: string; const Args: array of const); overload;
  end;


constructor TInterfacedObjectFake.Create(aFactory: TInterfaceFactory;
  aInvoke: TOnFakeInstanceInvoke; aNotifyDestroy: TOnFakeInstanceDestroy);
begin
  inherited Create;
  fFactory := aFactory;
  fVTable := aFactory.GetMethodsVirtualTable;
  fInvoke := aInvoke;
  fNotifyDestroy := aNotifyDestroy;
end;

destructor TInterfacedObjectFake.Destroy;
var C: TClass;
begin
  if Assigned(fNotifyDestroy) then
  try // release server instance
    fNotifyDestroy(fClientDrivenID);
  except
    on E: Exception do begin
      C := E.ClassType;
      if (C=EInterfaceStub) or (C=EInterfaceFactoryException) or
         (C=EAccessViolation) {$IFNDEF  LVCL}or (C=EInvalidPointer){$endif} then
        raise; // ignore all low-level exceptions
    end;
  end;
  inherited;
end;

function TInterfacedObjectFake.SelfFromInterface: TInterfacedObjectFake;
{$ifdef PUREPASCAL}
begin
  result := pointer(PtrInt(self)-PtrInt(@TInterfacedObjectFake(nil).fVTable));
end;
{$else}
asm
  sub eax,TInterfacedObjectFake.fVTable
end;
{$endif}

function TInterfacedObjectFake.Fake_AddRef: Integer;
begin
  result := SelfFromInterface._AddRef;
end;

function TInterfacedObjectFake.Fake_Release: Integer;
begin
  result := SelfFromInterface._Release;
end;

function TInterfacedObjectFake.FakeQueryInterface(const IID: TGUID; out Obj): HResult;
begin
  self := SelfFromInterface;
  if IsEqualGUID(IID,fFactory.fInterfaceIID) then begin
    pointer(Obj) := @fVTable;
    _AddRef;
    result := NOERROR;
  end else
  if GetInterface(IID,Obj) then
    result := NOERROR else
    result := E_NOINTERFACE;
end;

procedure IgnoreComma(var P: PUTF8Char);
begin
  if P^ in [#1..' '] then repeat inc(P) until not(P^ in [#1..' ']);
  if P^=',' then inc(P);
end;

function TInterfacedObjectFake.FakeCall(var aCall: TFakeCallStack): Int64;
var method: ^TServiceMethod;
procedure RaiseError(const Msg: RawUTF8);
begin
  raise EInterfaceFactoryException.CreateFmt('Invalid fake %s.%s interface call: %s',
    [fFactory.fInterfaceTypeInfo^.Name,method^.URI,Msg]);
end;
var resultType: TServiceMethodValueType; // type of value stored into result
procedure InternalProcess;
var Params: TJSONSerializer;
    Error, ResArray: RawUTF8;
    arg, ValLen: integer;
    V: PPointer;
    R, Val: PUTF8Char;
    valid, wasString, resultAsJSONObject: boolean;
    ServiceCustomAnswerPoint: PServiceCustomAnswer;
    DynArrays: array[0..MAX_METHOD_ARGS-1] of TDynArray;
    Value: array[0..MAX_METHOD_ARGS-1] of pointer;
    I64s: array[0..MAX_METHOD_ARGS-1] of Int64;
begin
  method := @fFactory.fMethods[aCall.MethodIndex];
  Params := TJSONSerializer.CreateOwnedStream;
  try
    // create the parameters
    FillChar(I64s,method^.ArgsUsedCount[smvv64]*sizeof(Int64),0);
    for arg := 0 to high(method^.Args) do
    with method^.Args[arg] do
    if ValueType>smvSelf then begin
      case RegisterIdent of
      {$ifdef CPU64}
      REGRCX: begin
        RaiseError('unexpected self');
        V := nil; // make compiler happy
      end;
      REGRDX: if ValueType in CONST_STOREDINXMM then
                V := @aCall.XMM1 else
                V := @aCall.RDX;
      REGR8:  if ValueType in CONST_STOREDINXMM then
                V := @aCall.XMM2 else
                V := @aCall.R8;
      REGR9:  if ValueType in CONST_STOREDINXMM then
                V := @aCall.XMM3 else
                V := @aCall.R9;
      {$else}
      REGEAX: begin V := nil; RaiseError('unexpected self'); end;
      REGEDX: V := @aCall.EDX;
      REGECX: V := @aCall.ECX;
      {$endif}
      else if SizeInStack>0 then
        V := @aCall.Stack[InStackOffset] else
        V := @I64s[IndexVar]; // for results in CPU
      end;
      if vPassedByReference in ValueKindAsm then
        V := PPointer(V)^;
      if ValueType=smvDynArray then
        DynArrays[IndexVar].Init(TypeInfo,V^);
      Value[arg] := V;
      if ValueDirection in [smdConst,smdVar] then
        AddJSON(Params,V); 
    end;
    Params.CancelLastComma;
    // call remote server or stub implementation
    if method^.ArgsResultIsServiceCustomAnswer then
      ServiceCustomAnswerPoint := Value[method^.ArgsResultIndex] else
      ServiceCustomAnswerPoint := nil;
    if not fInvoke(method^,Params.Text,@ResArray,@Error,@fClientDrivenID,
       ServiceCustomAnswerPoint) then
      RaiseError(Error);
  finally
    Params.Free;
  end;
  // retrieve method result and var/out parameters content
  if ServiceCustomAnswerPoint=nil then begin
    R := pointer(ResArray);
    if R^ in [#1..' '] then repeat inc(R) until not(R^ in [#1..' ']);
    resultAsJSONObject := false; // [value,...] JSON array format
    if R^='{' then   // {"paramname":value,...} JSON object format
      resultAsJSONObject := true else
    if R^<>'[' then
      RaiseError('JSON array/object result expected');
    inc(R);
    arg := method^.ArgsOutFirst;
    if arg>0 then
    repeat
      if resultAsJSONObject then begin
        Val := GetJSONField(R,R,@wasString);
        if (Val=nil) or (not wasString) then
          break; // end of JSON object
        ValLen := StrLen(Val);
        if (arg>0) and not IdemPropName(method^.Args[arg].ParamName^,Val,ValLen) then begin
          arg := method^.ArgResultIndex(Val,ValLen); // only if were not in-order
          if arg<0 then
            RaiseError(FormatUTF8('unexpected parameter "%"',[Val]));
        end;
      end;
      with method^.Args[arg] do begin
        assert(ValueDirection in [smdVar,smdOut,smdResult]);
        V := Value[arg];
        case ValueType of
        smvObject: begin
          R := JSONToObject(V^,R,valid);
          if not valid then
            RaiseError('returned object');
          IgnoreComma(R);
        end;
        smvRawJSON: begin
          Val := R;
          R := GotoNextJSONItem(R);
          if R<=Val then
            RaiseError('returned RawJSON');
          SetString(PRawUTF8(V)^,PAnsiChar(Val),R-Val);
        end;
        smvDynArray: begin
          R := DynArrays[IndexVar].LoadFromJSON(R);
          if R=nil then
            RaiseError('returned array');
          IgnoreComma(R);
        end;
        smvBoolean..smvWideString: begin
          Val := GetJSONField(R,R,@wasString);
          if (Val=nil) or (wasString<>(vIsString in ValueKindAsm)) then
            if resultAsJSONObject then
              RaiseError('missing or invalid value') else
              RaiseError('missing or invalid value: '+
              'parameters shall follow method var/out/result order');
          if (ValueType=smvBoolean) and (PInteger(Val)^=TRUE_LOW) then
            Val := '1';
          case ValueType of
          smvBoolean, smvEnum, smvSet, smvCardinal:
            case SizeInStorage of
            1: PByte(V)^     := GetCardinal(Val);
            2: PWord(V)^     := GetCardinal(Val);
            4: PCardinal(V)^ := GetCardinal(Val);
            end;
          smvInteger:    PInteger(V)^ := GetInteger(Val);
          smvInt64:      SetInt64(Val,PInt64(V)^);
          smvDouble,smvDateTime: PDouble(V)^ := GetExtended(Val);
          smvCurrency:   PInt64(V)^   := StrToCurr64(Val);
          smvRawUTF8:    PRawUTF8(V)^ := Val;
          smvString:     UTF8DecodeToString(Val,StrLen(Val),PString(V)^);
          smvWideString: UTF8ToWideString(Val,StrLen(Val),PWideString(V)^);
          else RaiseError('ValueType?');
          end;
        end;
        smvRecord: begin
          R := RecordLoadJSON(V^,R,TypeInfo);
          if R=nil then
            RaiseError('returned record');
        end;
        {$ifndef NOVARIANTS}
        smvVariant: begin
          R := VariantLoadJSON(PVariant(V)^,R,nil,@fFactory.DocVariantOptions);
          if R=nil then
            RaiseError('returned variant');
        end;
        {$endif}
        end;
        if ValueDirection=smdResult then begin
          resultType := ValueType;
          if ValueType in [smvBoolean..smvCurrency] then
            // ordinal/real result values to CPU/FPU registers
            Move(V^,Result,SizeInStorage);
        end;
      end;
      if R=nil then
        break;
      if R^ in [#1..' '] then repeat inc(R) until not(R^ in [#1..' ']);
      if resultAsJSONObject then begin
        if (R^=#0) or (R^='}') then
          break else // end of JSON object
          if not method^.ArgResultNext(arg) then
            arg := 0; // no next result argument -> force manual search
      end else
      if not method^.ArgResultNext(arg) then
        break; // end of JSON array
    until false;
  end;
end;
begin
  self := SelfFromInterface;
  if aCall.MethodIndex>=fFactory.fMethodsCount then
    RaiseError('out of range method');
  if not Assigned(fInvoke)then
    RaiseError('missing FakeInterfaceInvoker');
  result := 0;
  resultType := smvNone;
  InternalProcess; // use an inner proc to ensure direct fld/fild FPU ops
  {$ifdef CPU64}
  if resultType in CONST_STOREDINXMM then
    aCall.XMM1 := PDouble(@result)^;
  {$else}
  case resultType of // al/ax/eax/eax:edx already in result
  smvDouble,smvDateTime: asm fld  qword ptr [result] end;  // in st(0)
  smvCurrency:           asm fild qword ptr [result] end;  // in st(0)
  end;
  {$endif}
end;


{ TInterfaceFactory }

function ToText(aValue: TServiceInstanceImplementation): RawUTF8;
begin
  result := GetEnumNameTrimed(TypeInfo(TServiceInstanceImplementation),aValue);
end;

function TypeInfoToMethodValueType(P: PTypeInfo): TServiceMethodValueType;
var IsObjCustomIndex: integer;
begin
  result := smvNone;
  if P<>nil then
  case P^.Kind of
  tkInteger:
    case P^.OrdType of
    otSLong: result := smvInteger;
    otULong: result := smvCardinal;
    end;
  tkInt64{$ifdef FPC}, tkQWord{$endif}:
    result := smvInt64;
  {$ifdef FPC}
  tkBool:
    result := smvBoolean;
  tkEnumeration:
    result := smvEnum;
  {$else}
  tkEnumeration:
    if P=TypeInfo(boolean) then
      result := smvBoolean else
      result := smvEnum;
  {$endif}
  tkSet:
    result := smvSet;
  tkFloat:
    if P=TypeInfo(TDateTime) then
      result := smvDateTime else
    case P^.FloatType of
      ftDoub: result := smvDouble;
      ftCurr: result := smvCurrency;
    end;
  tkLString:
    if P=TypeInfo(RawUTF8) then
      result := smvRawUTF8 else
    if P=TypeInfo(RawJSON) then
      result := smvRawJSON
{$ifndef UNICODE}
      else result := smvString;
{$else};
  tkUString:
    result := smvString;
{$endif}
  tkWString:
    result := smvWideString;
  tkClass:
    if JSONObject(P^.ClassType^.ClassType,IsObjCustomIndex,[cpRead,cpWrite]) in
       [{$ifndef LVCL}oCollection,{$endif}oObjectList,oUtfs,oStrings,
        oSQLRecord,oSQLMany,oPersistent,oCustom] then
      result := smvObject; // JSONToObject/ObjectToJSON types
  tkRecord:   // Base64 encoding of our RecordLoad / RecordSave binary format
    result := smvRecord;
  {$ifndef NOVARIANTS}
  tkVariant:
    result := smvVariant;
  {$endif}
  tkDynArray: // TDynArray.LoadFromJSON / TTextWriter.AddDynArrayJSON type
    result := smvDynArray;
  end;
end;

var
  InterfaceFactoryCache: TObjectList;
  InterfaceFactoryCacheLock: TRTLCriticalSection; // deleted with process

procedure EnterInterfaceFactoryCache;
begin
  if InterfaceFactoryCache=nil then begin
    InitializeCriticalSection(InterfaceFactoryCacheLock);
    EnterCriticalSection(InterfaceFactoryCacheLock);
    GarbageCollectorFreeAndNil(InterfaceFactoryCache,TObjectList.Create);
  end else
    EnterCriticalSection(InterfaceFactoryCacheLock);
end;

class function TInterfaceFactory.Get(aInterface: PTypeInfo): TInterfaceFactory;
var i: integer;
begin
  EnterInterfaceFactoryCache;
  try
    for i := 0 to InterfaceFactoryCache.Count-1 do begin
      result := InterfaceFactoryCache.List[i];
      if result.fInterfaceTypeInfo=aInterface then
        exit; // retrieved from cache
    end;
    // not existing -> create new instance
    result := TInterfaceFactory.Create(aInterface);
    InterfaceFactoryCache.Add(result);
  finally
    LeaveCriticalSection(InterfaceFactoryCacheLock);
  end;
end;

class procedure TInterfaceFactory.RegisterInterfaces(const aInterfaces: array of PTypeInfo);
var i: integer;
begin
  for i := 0 to high(aInterfaces) do
    Get(aInterfaces[i]);
end;

class function TInterfaceFactory.Get(const aGUID: TGUID): TInterfaceFactory;
var i: integer;
begin
  if InterfaceFactoryCache<>nil then
    for i := 0 to InterfaceFactoryCache.Count-1 do begin
      result := InterfaceFactoryCache.List[i];
      if IsEqualGUID(result.fInterfaceIID,aGUID) then
        exit; // retrieved from cache
    end;
  result := nil;
end;

class function TInterfaceFactory.Get(const aInterfaceName: RawUTF8): TInterfaceFactory;
var L,i: integer;
begin
  L := length(aInterfaceName);
  if (InterfaceFactoryCache<>nil) and (L<>0) then
    for i := 0 to InterfaceFactoryCache.Count-1 do begin
      result := InterfaceFactoryCache.List[i];
      if IdemPropName(result.fInterfaceTypeInfo^.Name,pointer(aInterfaceName),L) then
        exit; // retrieved from cache
    end;
  result := nil;
end;

function TInterfaceFactory.CreateFakeInstance(aInvoke: TOnFakeInstanceInvoke;
  aNotifyDestroy: TOnFakeInstanceDestroy): TInterfacedObject;
begin
  result := TInterfacedObjectFake.Create(self,aInvoke,aNotifyDestroy);
end;

constructor TInterfaceFactory.Create(aInterface: PTypeInfo);
var m,a,reg: integer;
    WR: TTextWriter;
{$ifdef CPU64}
    resultIsRDX: boolean;
{$else}
    offs: integer;
{$endif}
begin
  {$ifndef NOVARIANTS}
  fDocVariantOptions := JSON_OPTIONS[true];
  {$endif}
  fInterfaceTypeInfo := aInterface;
  fInterfaceIID := PInterfaceTypeData(aInterface^.ClassType)^.IntfGuid;
  // retrieve all interface methods (recursively including ancestors)
  fMethod.InitSpecific(TypeInfo(TServiceMethodDynArray),fMethods,djRawUTF8,@fMethodsCount,true);
  AddMethodsFromTypeInfo(aInterface);
  if fMethodsCount=0 then
    raise EInterfaceFactoryException.CreateFmt('%s interface has no RTTI',[aInterface^.Name]);
  SetLength(fMethods,fMethodsCount);
  // compute asm low-level layout of the parameters for each method
  for m := 0 to fMethodsCount-1 do
  with fMethods[m] do begin
    // prepare stack and register layout
    reg := REG_FIRST;
    {$ifdef CPU64}
    resultIsRDX := (ArgsResultIndex>=0) and
      (Args[ArgsResultIndex].ValueType in CONST_ARGS_RESULT_BY_REF);
    {$endif}
    for a := 0 to high(Args) do
    with Args[a] do begin
      ValueVar := CONST_ARGS_TO_VAR[ValueType];
      IndexVar := ArgsUsedCount[ValueVar];
      inc(ArgsUsedCount[ValueVar]);
      include(ArgsUsed,ValueType);
      if ValueType in [smvRawUTF8..smvWideString] then
        Include(ValueKindAsm,vIsString);
      if (ValueType in [smvRecord{$ifndef NOVARIANTS},smvVariant{$endif}]) or
         (ValueDirection in [smdVar,smdOut]) or
         ((ValueDirection=smdResult) and (ValueType in CONST_ARGS_RESULT_BY_REF)) then
        Include(ValueKindAsm,vPassedByReference);
      case ValueType of
        smvBoolean:
          SizeInStorage := 1;
        smvInteger, smvCardinal:
          SizeInStorage := 4;
        smvInt64, smvDouble, smvDateTime, smvCurrency:
          SizeInStorage := 8;
        smvEnum:
          case TypeInfo^.EnumBaseType^.MaxValue of
          0..255:     SizeInStorage := 1;
          256..65535: SizeInStorage := 2;
          else        SizeInStorage := 4;
          end;
        smvSet:
          case TypeInfo^.SetEnumType^.MaxValue of
          0..7:   SizeInStorage := 1;
          8..15:  SizeInStorage := 2;
          16..31: SizeInStorage := 4;
          else raise EInterfaceFactoryException.CreateFmt(
            '%s set too big in %s.%s method %s parameter',
            [TypeName^,fInterfaceTypeInfo^.Name,URI,ParamName^]);
          end;
        smvRecord:
          if TypeInfo^.RecordType^.Size<=PTRSIZ then
            raise EInterfaceFactoryException.CreateFmt(
              '%s record too small in %s.%s method %s parameter',
              [TypeName^,fInterfaceTypeInfo^.Name,URI,ParamName^]) else
            SizeInStorage := PTRSIZ; // handle only records when passed by ref
        else
          SizeInStorage := PTRSIZ;
      end;
      if ValueDirection=smdResult then begin
        if not(ValueType in CONST_ARGS_RESULT_BY_REF) then
          continue; // ordinal/real/class results are returned in CPU/FPU registers
        {$ifdef CPU64} // Delphi always put the result pointer as RDX in x64 
        InStackOffset := STACKOFFSET_NONE; 
        RegisterIdent := REGRDX;
        continue;
        {$endif}
      end;
      {$ifndef CPU64}
      if ValueDirection=smdConst then
        SizeInStack := CONST_ARGS_IN_STACK_SIZE[ValueType] else
      {$endif}
        SizeInStack := PTRSIZ;
      if (reg>REG_LAST) or (SizeInStack<>PTRSIZ) then begin
        InStackOffset := ArgsSizeInStack;
        inc(ArgsSizeInStack,SizeInStack);
      end else begin
        InStackOffset := STACKOFFSET_NONE;
        {$ifdef CPU64}
        if resultIsRDX and (reg=REGRDX) then
          inc(reg); // RDX is reserved by Delphi for function result pointer
        {$endif}
        RegisterIdent := reg;
        inc(reg);
      end;
    end;
    if ArgsSizeInStack>MAX_EXECSTACK then
        raise EInterfaceFactoryException.CreateFmt(
          'Stack size %d > %d for %s.%s method',
          [ArgsSizeInStack,MAX_EXECSTACK,fInterfaceTypeInfo^.Name,URI]);
    {$ifndef CPU64}
    // pascal/register convention are passed left-to-right -> reverse order
    offs := ArgsSizeInStack;
    for a := 0 to high(Args) do
    with Args[a] do
      if InStackOffset>=0 then begin
        dec(offs,SizeInStack);
        InStackOffset := offs;
      end;
    assert(offs=0);
    {$endif}
  end;
  WR := TTextWriter.CreateOwnedStream;
  try
    // compute the default result as a JSON array containing all methods
    for m := 0 to fMethodsCount-1 do
    with fMethods[m] do begin
      WR.CancelAll;
      WR.Add('[');
      for a := ArgsOutFirst to ArgsOutLast do
        with Args[a] do
        if ValueDirection in [smdVar,smdOut,smdResult] then
          AddDefaultJSON(WR);
      WR.CancelLastComma;
      WR.Add(']');
      WR.SetText(DefaultResult);
    end;
    // compute the method contract as a JSON object
    WR.CancelAll;
    WR.Add('[');
    for m := 0 to fMethodsCount-1 do
    with fMethods[m] do begin
      WR.Add('{"method":"%","arguments":[',[URI]);
      for a := 0 to High(Args) do
        Args[a].SerializeToContract(WR);
      WR.CancelLastComma;
      WR.AddShort(']},');
    end;
    WR.CancelLastComma;
    WR.Add(']');
    WR.SetText(fContract);
  finally
    WR.Free;
  end;
end;

procedure TInterfaceFactory.AddMethodsFromTypeInfo(aInterface: PTypeInfo);
var P: Pointer absolute aInterface;
    PB: PByte absolute aInterface;
    PI: PInterfaceTypeData absolute P;
    PW: PWord absolute P;
    PS: PShortString absolute P;
    PME: ^TIntfMethodEntryTail absolute P;
    PF: ^TParamFlags absolute P;
    PP: ^PPTypeInfo absolute P;
    Ancestor: PTypeInfo;
    Kind: TMethodKind;
    f: TParamFlags;
    i,j: integer;
    n: cardinal;
    aURI: RawUTF8;
    ErrorMsg: string;
    C: TClass;
begin
  // handle interface inheritance via recursive calls
  P := aInterface^.ClassType;
  if PI^.IntfParent<>nil then
    Ancestor := PI^.IntfParent^ else
    Ancestor := nil;
  if Ancestor<>nil then
    AddMethodsFromTypeInfo(Ancestor);
  P := @PI^.IntfUnit[ord(PI^.IntfUnit[0])+1];
  // retrieve methods for this interface level
  n := PW^; inc(PW);
  if (PW^=$ffff) or (n=0) then
    exit; // no RTTI or no method at this level of interface
  inc(PW);
  for i := fMethodsCount to fMethodsCount+n-1 do begin
    // retrieve method name, and add to the methods list (with hashing)
    SetString(aURI,PAnsiChar(@PS^[1]),ord(PS^[0]));
    with PServiceMethod(fMethod.AddUniqueName(aURI,
      '%s.%s method: duplicated name',[fInterfaceTypeInfo^.Name,aURI]))^ do begin
      ExecutionMethodIndex := i+RESERVED_VTABLE_SLOTS;
      PS := @PS^[ord(PS^[0])+1];
      Kind := PME^.Kind;
      if PME^.CC<>ccRegister then
        raise EInterfaceFactoryException.CreateFmt(
          '%s.%s method shall use register calling convention',
          [fInterfaceTypeInfo^.Name,URI]);
      // retrieve method call arguments
      n := PME^.ParamCount;
      inc(PME);
      if Kind=mkFunction then
        SetLength(Args,n+1) else
        SetLength(Args,n);
      if length(Args)>MAX_METHOD_ARGS then
        raise EInterfaceFactoryException.CreateFmt(
          '%s.%s method has too many parameters: %d>%d',
          [fInterfaceTypeInfo^.Name,URI,Length(Args),MAX_METHOD_ARGS]);
      ArgsInFirst := -1;
      ArgsInLast := -2;
      ArgsOutFirst := -1;
      ArgsOutLast := -2;
      for j := 0 to n-1 do
      with Args[j] do begin
        f := PF^;
        inc(PF);
        if pfVar in f then
          ValueDirection := smdVar else
        if pfOut in f then
          ValueDirection := smdOut;
        if ValueDirection<>smdConst then begin
          if ArgsOutFirst<0 then
            ArgsOutFirst := j;
          ArgsOutLast := j;
          inc(ArgsOutputValuesCount);
        end;
        ParamName := PS;
        PS := @PS^[ord(PS^[0])+1];
        TypeName := PS;
        PS := @PS^[ord(PS^[0])+1];
        if PP^=nil then
          raise EInterfaceFactoryException.CreateFmt(
            '%s.%s: %s parameter has no information',
            [fInterfaceTypeInfo^.Name,URI,ParamName^]);
        TypeInfo := PP^^;
        inc(PP);
        {$ifdef ISDELPHIXE}
        inc(PB,PW^); // skip custom attributes
        {$endif}
        if j=0 then
          ValueType := smvSelf else begin
          if ValueDirection<>smdOut then begin
            inc(ArgsInputValuesCount);
            if ArgsInFirst<0 then
              ArgsInFirst := j;
            ArgsInLast := j;
          end;
          ValueType := TypeInfoToMethodValueType(TypeInfo);
          case ValueType of
          smvNone: begin
            case TypeInfo^.Kind of
            tkClass: begin
              C := TypeInfo^.ClassType^.ClassType;
              if C.InheritsFrom(TList) then
                ErrorMsg := ' - use TObjectList instead' else
              {$ifndef LVCL}
              if (C.InheritsFrom(TCollection) and not C.InheritsFrom(TInterfacedCollection)) and
                (JSONSerializerRegisteredCollection.Find(TCollectionClass(C))=nil) then
                ErrorMsg := ' - inherit from TInterfacedCollection '+
                  'or use TJSONSerializer.RegisterCollectionForJSON()' else
              {$endif}
                ErrorMsg := ' - use TJSONSerializer.RegisterCustomSerializer()';
            end;
            tkInteger: ErrorMsg := ' - use integer/cardinal instead';
            tkFloat:   ErrorMsg := ' - use double/currency instead';
            end;
            raise EInterfaceFactoryException.CreateFmt(
              '%s.%s: %s parameter has unexpected type %s%s',
              [fInterfaceTypeInfo^.Name,URI,ParamName^,TypeInfo^.Name,ErrorMsg]);
          end;
          smvRecord: if f*[pfConst,pfVar,pfOut]=[] then
            raise EInterfaceFactoryException.CreateFmt(
              '%s.%s: %s record parameter should be declared as const, var or out',
              [fInterfaceTypeInfo^.Name,URI,ParamName^]);
          end;
        end;
      end;
      // add a pseudo argument after all arguments for functions
      if Kind=mkFunction then
      with Args[n] do begin
        ParamName := @CONST_PSEUDO_RESULT_NAME;
        ArgsResultIndex := n;
        if ArgsOutFirst<0 then
          ArgsOutFirst := n;
        ArgsOutLast := n;
        ValueDirection := smdResult;
        inc(ArgsOutputValuesCount);
        TypeName := PS;
        PS := @PS^[ord(PS^[0])+1];
        TypeInfo := PP^^;
        inc(PP);
        ValueType := TypeInfoToMethodValueType(TypeInfo);
      end else
        ArgsResultIndex := -1;
      // go to next method
      {$ifdef ISDELPHIXE}
      inc(PW); // skip attributes
      {$endif}
    end;
  end;
end;

function TInterfaceFactory.FindMethodIndex(const aMethodName: RawUTF8): integer;
begin
  if fMethodsCount<10 then begin
    for result := 0 to fMethodsCount-1 do
      if IdemPropNameU(fMethods[result].URI,aMethodName) then
        exit;
    result := -1;
  end else
    result := fMethod.FindHashed(aMethodName);
end;

function TInterfaceFactory.CheckMethodIndex(const aMethodName: RawUTF8): integer;
begin
  result := FindMethodIndex(aMethodName);
  if result<0 then
    raise EInterfaceFactoryException.CreateFmt('%s.%s does not exists',
      [fInterfaceTypeInfo^.Name,aMethodName]);
end;

function TInterfaceFactory.CheckMethodIndex(aMethodName: PUTF8Char): integer;
begin
  result := CheckMethodIndex(RawUTF8(aMethodName));
end;

{$ifdef CPU64}
procedure x64FakeStub;
var smetndx, sxmm3, sxmm2, sxmm1: pointer;
asm // mov ax,{MethodIndex}; jmp x64FakeStub
  .params 2 // FakeCall(self: TInterfacedObjectFake; var aCall: TFakeCallStack): Int64
  and rax,$ffff
  movsd sxmm1,xmm1
  movsd sxmm2,xmm2
  movsd sxmm3,xmm3
  mov smetndx,rax
  mov [rbp+$50],rcx
  mov [rbp+$58],rdx
  mov [rbp+$60],r8
  mov [rbp+$68],r9
  lea rdx,sxmm1
  call TInterfacedObjectFake.FakeCall
  // FakeCall should set Int64 result in method result, and float in aCall.XMM1
  movsd xmm0,sxmm1
end;
{$endif}

const
  STUB_SIZE = 65536; // 16*4 KB (4 KB = memory granularity)

type
  // internal memory buffer created with PAGE_EXECUTE_READWRITE flags
  TFakeStubBuffer = class
  protected
    fStub: PByteArray;
    fStubUsed: cardinal;
  public
    constructor Create;
    destructor Destroy; override;
    // call shall be protected by InterfaceFactoryCacheLock critical section
    class function Reserve(size: Cardinal): pointer;
  end;

var
  CurrentFakeStubBuffer: TFakeStubBuffer;

constructor TFakeStubBuffer.Create;
begin
  fStub := VirtualAlloc(nil,STUB_SIZE,MEM_COMMIT,PAGE_EXECUTE_READWRITE);
end;

destructor TFakeStubBuffer.Destroy;
begin
  VirtualFree(fStub,0,MEM_RELEASE);
  inherited;
end;

class function TFakeStubBuffer.Reserve(size: Cardinal): pointer;
begin
  if size>STUB_SIZE then
    raise EServiceException.CreateFmt('TFakeStubBuffer.Reserve(size=%d>%d)',
      [size,STUB_SIZE]);
  if CurrentFakeStubBuffer=nil then
    GarbageCollectorFreeAndNil(CurrentFakeStubBuffer,TFakeStubBuffer.Create) else
  if CurrentFakeStubBuffer.fStubUsed+size>STUB_SIZE then begin
    GarbageCollector.Add(CurrentFakeStubBuffer);
    CurrentFakeStubBuffer := TFakeStubBuffer.Create;
  end;
  with CurrentFakeStubBuffer do begin
    result := @fStub[fStubUsed];
    inc(fStubUsed,size);
  end;
end;


function TInterfaceFactory.GetMethodsVirtualTable: pointer;
var i: integer;
    P: PCardinal;
begin
  if fFakeVTable=nil then begin
    EnterCriticalSection(InterfaceFactoryCacheLock);
    try
      if fFakeVTable=nil then begin // avoid race condition error
        SetLength(fFakeVTable,fMethodsCount+RESERVED_VTABLE_SLOTS);
        fFakeVTable[0] := @TInterfacedObjectFake.FakeQueryInterface;
        fFakeVTable[1] := @TInterfacedObjectFake.Fake_AddRef;
        fFakeVTable[2] := @TInterfacedObjectFake.Fake_Release;
        fFakeStub := TFakeStubBuffer.Reserve(fMethodsCount*{$ifdef CPU64}12{$else}24{$endif});
        P := pointer(fFakeStub);
        for i := 0 to fMethodsCount-1 do begin
          fFakeVTable[i+RESERVED_VTABLE_SLOTS] := P;
          {$ifdef CPU64}
          P^ := $b866+(i shl 16); inc(P);          // mov ax,{MethodIndex}
          PByte(P)^ := $e9; inc(PByte(P));         // jmp x64FakeStub
          P^ := PtrUInt(@x64FakeStub)-PtrUInt(P)-4; inc(P);
          P^ := $909090;
          {$else}
          P^ := $68ec8b55; inc(P);                 // push ebp; mov ebp,esp
          P^ := i; inc(P);                         // push {MethodIndex}
          P^ := $e2895251; inc(P);                 // push ecx; push edx; mov edx,esp
          PByte(P)^ := $e8; inc(PByte(P));         // call FakeCall
          P^ := PtrUInt(@TInterfacedObjectFake.FakeCall)-PtrUInt(P)-4; inc(P);
          P^ := $c25dec89; inc(P);                 // mov esp,ebp; pop ebp
          P^ := fMethods[i].ArgsSizeInStack or $900000;  // ret {StackSize}; nop
          {$endif}
          inc(PByte(P),3);
        end;
      end;
    finally
      LeaveCriticalSection(InterfaceFactoryCacheLock);
    end;
  end;
  result := pointer(fFakeVTable);
end;


{ TInterfaceStubRules }

function TInterfaceStubRules.FindRuleIndex(const aParams: RawUTF8): integer;
begin
  for result := 0 to length(Rules)-1 do
    if Rules[result].Params=aParams then
      exit;
  result := -1;
end;

function TInterfaceStubRules.FindStrongRuleIndex(const aParams: RawUTF8): integer;
begin
  for result := 0 to length(Rules)-1 do
    if (Rules[result].Kind<>isUndefined) and (Rules[result].Params=aParams) then
      exit;
  result := -1;
end;

procedure TInterfaceStubRules.AddRule(Sender: TInterfaceStub;
  aKind: TInterfaceStubRuleKind; const aParams, aValues: RawUTF8;
  const aEvent: TNotifyEvent; aExceptionClass: ExceptClass;
  aExpectedPassCountOperator: TSQLQueryOperator; aValue: cardinal);
var n,ndx: integer;
begin
  ndx := FindRuleIndex(aParams);
  n := length(Rules);
  if ndx<0 then
    SetLength(Rules,n+1) else
    n := ndx;
  if (aParams='') and (aKind<>isUndefined) then
    DefaultRule := n;
  with Rules[n] do begin
    Params := aParams;
    case aKind of
    isUndefined:
      ; // do not overwrite Values for weak rules like ExpectsCount/ExpectsTrace
    isReturns:
      Values := '['+AValues+']';
    isFails:
      Values := RawUTF8(Sender.ClassName)+' returned error: '+aValues;
    else
      Values := aValues;
    end;
    if aKind=isUndefined then
      if aExpectedPassCountOperator=qoContains then
        ExpectedTraceHash := aValue else begin
        ExpectedPassCountOperator := aExpectedPassCountOperator;
        ExpectedPassCount := aValue;
      end else begin
      Kind := aKind;
      Execute := TMethod(aEvent);
      ExceptionClass := aExceptionClass;
    end;
  end;
end;


{ TInterfaceStub }

constructor EInterfaceStub.Create(Sender: TInterfaceStub;
  const Method: TServiceMethod; const Error: string);
begin
  inherited CreateFmt('Error in %s for %s.%s - %s',
    [Sender.ClassName,Sender.fInterface.fInterfaceTypeInfo^.Name,Method.URI,Error]);
end;

constructor EInterfaceStub.Create(Sender: TInterfaceStub;
  const Method: TServiceMethod; const Format: string; const Args: array of const);
begin
  Create(Sender,Method,SysUtils.format(Format,Args));
end;

function TInterfaceStubLog.Results: RawUTF8;
begin
  if CustomResults='' then
    result := Method^.DefaultResult else
    result := CustomResults;
end;

procedure TInterfaceStubLog.AddAsText(WR: TTextWriter; aScope: TInterfaceStubLogLayouts);
begin
  if wName in aScope then
    WR.AddString(Method^.URI);
  if wParams in aScope then begin
    WR.Add('(');
    WR.AddString(Params);
    WR.Add(')');
  end;
  if WasError then begin
    WR.AddShort(' error "');
    WR.AddString(CustomResults);
    WR.Add('"');
  end else
  if (wResults in aScope) and (Method^.ArgsResultIndex>=0) then begin
    if (wName in aScope) or (wParams in aScope) then
      WR.Add('=');
    if CustomResults='' then
      WR.AddString(Method^.DefaultResult) else
      WR.AddString(CustomResults);
  end;
  WR.Add(',');
end;

constructor TOnInterfaceStubExecuteParamsAbstract.Create(aSender: TInterfaceStub;
  aMethod: PServiceMethod; const aParams,aEventParams: RawUTF8);
begin
  fSender := aSender;
  fMethod := aMethod;
  fParams := aParams;
  fEventParams := aEventParams;
end;

procedure TOnInterfaceStubExecuteParamsAbstract.Error(Format: PUTF8Char; const Args: array of const);
begin
  Error(FormatUTF8(Format,Args));
end;

procedure TOnInterfaceStubExecuteParamsAbstract.Error(const aErrorMessage: RawUTF8);
begin
  fFailed := true;
  fResult := aErrorMessage;
end;

function TOnInterfaceStubExecuteParamsAbstract.GetSenderAsMockTestCase: TSynTestCase;
begin
  result := (fSender as TInterfaceMock).TestCase;
end;

procedure TOnInterfaceStubExecuteParamsJSON.Returns(const Values: array of const);
begin
  JSONEncodeArrayOfConst(Values,false,fResult);
end;

{$ifndef NOVARIANTS}

constructor TOnInterfaceStubExecuteParamsVariant.Create(aSender: TInterfaceStub;
  aMethod: PServiceMethod; const aParams, aEventParams: RawUTF8);
var i: integer;
    P: PUTF8Char;
begin
  inherited;
  SetLength(fInput,fMethod^.ArgsInputValuesCount);
  P := pointer(aParams);
  for i := 0 to fMethod^.ArgsInputValuesCount-1 do
    P := VariantLoadJSON(fInput[i],P,nil,@aSender.fInterface.DocVariantOptions);
  SetLength(fOutput,fMethod^.ArgsOutputValuesCount);
end;

function TOnInterfaceStubExecuteParamsVariant.GetInput(Index: Integer): variant;
begin
  if cardinal(Index)>=fMethod^.ArgsInputValuesCount then
    raise EInterfaceStub.Create(fSender,fMethod^,'Input[%d>=%d]',
      [Index,fMethod^.ArgsInputValuesCount]) else
    result := fInput[Index];
end;

procedure TOnInterfaceStubExecuteParamsVariant.SetOutput(Index: Integer;
  const Value: variant);
begin
  if cardinal(Index)>=fMethod^.ArgsOutputValuesCount then
    raise EInterfaceStub.Create(fSender,fMethod^,'Output[%d>=%d]',
      [Index,fMethod^.ArgsOutputValuesCount]) else
    fOutput[Index] := Value;
end;

function TOnInterfaceStubExecuteParamsVariant.GetInNamed(const aParamName: RawUTF8): variant;
var L,a,ndx: integer;
begin
  L := Length(aParamName);
  ndx := 0;
  if (L>0) and (fInput<>nil) then
    for a := fMethod^.ArgsInFirst to fMethod^.ArgsInLast do 
      with fMethod^.Args[a] do
      if ValueDirection in [smdConst,smdVar] then begin
        if IdemPropName(ParamName^,pointer(aParamName),L) then begin
          result := fInput[ndx];
          exit;
        end;
        inc(ndx);
        if cardinal(ndx)>=cardinal(fMethod^.ArgsInputValuesCount) then
          break;
      end;
  raise EInterfaceStub.Create(fSender,fMethod^,'unknown input parameter "%s"',[aParamName]);
end;

procedure TOnInterfaceStubExecuteParamsVariant.SetOutNamed(const aParamName: RawUTF8;
  const Value: variant);
var L,a,ndx: integer;
begin
  L := Length(aParamName);
  ndx := 0;
  if (L>0) and (fOutput<>nil) then
    for a := fMethod^.ArgsOutFirst to fMethod^.ArgsOutLast do
      with fMethod^.Args[a] do
      if ValueDirection<>smdConst then begin
        if IdemPropName(ParamName^,pointer(aParamName),L) then begin
          fOutput[ndx] := Value;
          exit;
        end;
        inc(ndx);
        if cardinal(ndx)>=cardinal(fMethod^.ArgsOutputValuesCount) then
          break;
      end;
  raise EInterfaceStub.Create(fSender,fMethod^,'unknown output parameter "%s"',[aParamName]);
end;

procedure TOnInterfaceStubExecuteParamsVariant.SetResult(var Result: RawUTF8);
var i: integer;
begin
  if fOutput=nil then
    fResult := '' else
    with TJSONSerializer.CreateOwnedStream do
    try
      Add('[');
      for i := 0 to fMethod^.ArgsOutputValuesCount-1 do begin
        if TVarData(fOutput[i]).VType=varEmpty then
          raise EInterfaceStub.Create(fSender,fMethod^,'Output[%d] not set',[i]);
        AddVariantJSON(fOutput[i],twJSONEscape);
        Add(',');
      end;
      CancelLastComma;
      Add(']');
      SetText(result);
    finally
      Free;
    end;
end;

{$endif}

procedure TInterfaceStub.InternalCreate(out aStubbedInterface);
var i: integer;
begin
  SetLength(fRules,fInterface.MethodsCount);
  for i := 0 to fInterface.MethodsCount-1 do
    fRules[i].DefaultRule := -1;
  fLog.Init(TypeInfo(TInterfaceStubLogDynArray),fLogs,@fLogCount);
  with TInterfacedObjectFake.Create(fInterface,Invoke,InstanceDestroyed) do begin
    pointer(aStubbedInterface) := @fVTable;
    _AddRef;
  end;
end;

function TInterfaceStub.InternalCheck(aValid: boolean; const aErrorMessage: RawUTF8;
  aExpectationFailed: boolean): boolean;
begin
  result := aValid;
  if aExpectationFailed and not aValid then
    raise EInterfaceFactoryException.CreateFmt('%s - Error validating %s.%s',
      [ClassName,fInterface.fInterfaceTypeInfo^.Name,aErrorMessage]);
end;

constructor TInterfaceStub.Create(const aInterfaceName: RawUTF8; out aStubbedInterface);
begin
  fInterface := TInterfaceFactory.Get(aInterfaceName);
  if fInterface=nil then
    raise EInterfaceStub.CreateFmt('Interface %s non registered',[aInterfaceName]);
  InternalCreate(aStubbedInterface);
end;

constructor TInterfaceStub.Create(const aGUID: TGUID; out aStubbedInterface);
begin
  fInterface := TInterfaceFactory.Get(aGUID);
  if fInterface=nil then
    raise EInterfaceStub.CreateFmt(
      'Interface %s non registered',[GUIDToString(aGUID)]);
  InternalCreate(aStubbedInterface);
end;

constructor TInterfaceStub.Create(aInterface: PTypeInfo; out aStubbedInterface);
begin
  fInterface := TInterfaceFactory.Get(aInterface);
  InternalCreate(aStubbedInterface);
end;

procedure TInterfaceStub.IntSetOptions(Options: TInterfaceStubOptions);
begin
  if Options=fOptions then
    exit;
  fOptions := Options;
end;

procedure TInterfaceStub.IntCheckCount(aMethodIndex, aComputed: cardinal;
  aOperator: TSQLQueryOperator; aCount: cardinal);
const
  OPERATORS: array[qoEqualTo..qoGreaterThanOrEqualTo] of RawUTF8 = (
    '=','<>','<','<=','>','>=');
function SQLQueryCompare(aOperator: TSQLQueryOperator; A,B: cardinal): boolean;
begin
  case aOperator of
  qoEqualTo:              result := A=B;
  qoNotEqualTo:           result := A<>B;
  qoLessThan:             result := A<B;
  qoLessThanOrEqualTo:    result := A<=B;
  qoGreaterThan:          result := A>B;
  qoGreaterThanOrEqualTo: result := A>=B;
  else raise EInterfaceStub.CreateFmt('Unexpected %d operator',[Ord(aOperator)]);
  end;
end;
begin
  InternalCheck(SQLQueryCompare(aOperator,aComputed,aCount),
    FormatUTF8('% pass count % % % failed',
      [fInterface.Methods[aMethodIndex].URI,
       aComputed,OPERATORS[aOperator],aCount]),True);
end;

procedure TInterfaceStub.InstanceDestroyed(aClientDrivenID: cardinal);
var m,r,asmndx: integer;
    num: cardinal;
begin
  if self<>nil then
  try
    if eCount in fHasExpects then
      for m := 0 to fInterface.MethodsCount-1 do
      with fRules[m] do
        for r := 0 to high(Rules) do
        with Rules[r] do
          if ExpectedPassCountOperator<>qoNone then begin
            if Params='' then
              num := MethodPassCount else
              num := RulePassCount;
            IntCheckCount(m,num,ExpectedPassCountOperator,ExpectedPassCount);
          end;
    if fInterfaceExpectedTraceHash<>0 then
      InternalCheck(LogHash=fInterfaceExpectedTraceHash,'* interface expected execution',True);
    if eTrace in fHasExpects then
      for m := 0 to fInterface.MethodsCount-1 do
      with fRules[m] do begin
        asmndx := m+RESERVED_VTABLE_SLOTS;
        for r := 0 to high(Rules) do
        with Rules[r] do
        if ExpectedTraceHash<>0 then
          InternalCheck(ExpectedTraceHash=
            Hash32(IntGetLogAsText(asmndx,Params,[wName,wParams,wResults])),
            fInterface.Methods[m].URI+' method expected execution',True);
      end;
  finally
    if not (imoFakeInstanceWontReleaseTInterfaceStub in Options) then
      Free; // creature will release its creator
  end;
end;

function TInterfaceStub.SetOptions(Options: TInterfaceStubOptions): TInterfaceStub;
begin
  IntSetOptions(Options);
  result := self;
end;


function TInterfaceStub.Executes(const aMethodName, aParams: RawUTF8;
  aEvent: TOnInterfaceStubExecuteJSON; const aEventParams: RawUTF8): TInterfaceStub;
begin
  fRules[fInterface.CheckMethodIndex(aMethodName)].
    AddRule(self,isExecutesJSON,aParams,aEventParams,TNotifyEvent(aEvent));
  result := self;
end;

function TInterfaceStub.Executes(const aMethodName: RawUTF8;
  aEvent: TOnInterfaceStubExecuteJSON; const aEventParams: RawUTF8): TInterfaceStub;
begin
  result := Executes(aMethodName,'',aEvent,aEventParams);
end;

function TInterfaceStub.Executes(const aMethodName: RawUTF8;
  const aParams: array of const; aEvent: TOnInterfaceStubExecuteJSON;
  const aEventParams: RawUTF8): TInterfaceStub;
begin
  result := Executes(aMethodName,JSONEncodeArrayOfConst(aParams,true),
    aEvent,aEventParams);
end;

{$ifndef NOVARIANTS}

function TInterfaceStub.Executes(const aMethodName, aParams: RawUTF8;
  aEvent: TOnInterfaceStubExecuteVariant; const aEventParams: RawUTF8): TInterfaceStub;
begin
  fRules[fInterface.CheckMethodIndex(aMethodName)].
    AddRule(self,isExecutesVariant,aParams,aEventParams,TNotifyEvent(aEvent));
  result := self;
end;

function TInterfaceStub.Executes(const aMethodName: RawUTF8;
  aEvent: TOnInterfaceStubExecuteVariant; const aEventParams: RawUTF8): TInterfaceStub;
begin
  result := Executes(aMethodName,'',aEvent,aEventParams);
end;

function TInterfaceStub.Executes(const aMethodName: RawUTF8;
  const aParams: array of const; aEvent: TOnInterfaceStubExecuteVariant;
  const aEventParams: RawUTF8): TInterfaceStub;
begin
  result := Executes(aMethodName,JSONEncodeArrayOfConst(aParams,true),
    aEvent,aEventParams);
end;

{$endif}

function TInterfaceStub.ExpectsCount(const aMethodName: RawUTF8; aOperator: TSQLQueryOperator;
  aValue: cardinal): TInterfaceStub;
begin
  result := ExpectsCount(aMethodName,'',aOperator,aValue);
end;

function TInterfaceStub.ExpectsCount(const aMethodName, aParams: RawUTF8; aOperator: TSQLQueryOperator;
  aValue: cardinal): TInterfaceStub;
var ndx: integer;
begin
  ndx := fInterface.CheckMethodIndex(aMethodName);
  if aOperator in [qoEqualTo..qoGreaterThanOrEqualTo] then
    with fRules[ndx] do
      AddRule(self,isUndefined,aParams,'',nil,nil,aOperator,aValue) else
    raise EInterfaceStub.Create(self,fInterface.fMethods[ndx],
      'incorrect ExpectsCount(aOperator)');
  include(fHasExpects,eCount);
  result := self;
end;

function TInterfaceStub.ExpectsCount(const aMethodName: RawUTF8;
  const aParams: array of const; aOperator: TSQLQueryOperator; aValue: cardinal): TInterfaceStub;
begin
  result := ExpectsCount(aMethodName,JSONEncodeArrayOfConst(aParams,true),aOperator,aValue);
end;

function TInterfaceStub.ExpectsTrace(aValue: cardinal): TInterfaceStub;
begin
  include(fOptions,imoLogMethodCallsAndResults);
  fInterfaceExpectedTraceHash := aValue;
  result := self;
end;

function TInterfaceStub.ExpectsTrace(const aMethodName: RawUTF8; aValue: cardinal): TInterfaceStub;
begin
  result := ExpectsTrace(aMethodName,'',aValue);
end;

function TInterfaceStub.ExpectsTrace(const aMethodName, aParams: RawUTF8;
  aValue: cardinal): TInterfaceStub;
begin
  fRules[fInterface.CheckMethodIndex(aMethodName)].
    AddRule(self,isUndefined,aParams,'',nil,nil,qoContains,aValue);
  include(fOptions,imoLogMethodCallsAndResults);
  include(fHasExpects,eTrace);
  result := self;
end;

function TInterfaceStub.ExpectsTrace(const aMethodName: RawUTF8;
  const aParams: array of const; aValue: cardinal): TInterfaceStub;
begin
  result := ExpectsTrace(aMethodName,JSONEncodeArrayOfConst(aParams,true),aValue);
end;

function TInterfaceStub.ExpectsTrace(const aValue: RawUTF8): TInterfaceStub; 
begin
  result := ExpectsTrace(Hash32(aValue));
end;

function TInterfaceStub.ExpectsTrace(const aMethodName, aValue: RawUTF8): TInterfaceStub;
begin
  result := ExpectsTrace(aMethodName,Hash32(aValue));
end;

function TInterfaceStub.ExpectsTrace(const aMethodName, aParams, aValue: RawUTF8): TInterfaceStub;
begin
  result := ExpectsTrace(aMethodName,aParams,Hash32(aValue));
end;

function TInterfaceStub.ExpectsTrace(const aMethodName: RawUTF8; const aParams: array of const;
  const aValue: RawUTF8): TInterfaceStub;
begin
  result := ExpectsTrace(aMethodName,aParams,Hash32(aValue));
end;

function TInterfaceStub.Fails(const aMethodName, aErrorMsg: RawUTF8): TInterfaceStub;
begin
  result := Fails(aMethodName,'',aErrorMsg);
end;

function TInterfaceStub.Fails(const aMethodName, aParams, aErrorMsg: RawUTF8): TInterfaceStub;
begin
  fRules[fInterface.CheckMethodIndex(aMethodName)].
    AddRule(self,isFails,aParams,aErrorMsg);
  result := self;
end;

function TInterfaceStub.Fails(const aMethodName: RawUTF8; const aParams: array of const;
  const aErrorMsg: RawUTF8): TInterfaceStub;
begin
  result := Fails(aMethodName,JSONEncodeArrayOfConst(aParams,true),aErrorMsg);
end;

function TInterfaceStub.Raises(const aMethodName, aParams: RawUTF8;
  aException: ExceptClass; const aMessage: string): TInterfaceStub;
begin
  fRules[fInterface.CheckMethodIndex(aMethodName)].
    AddRule(self,isRaises,aParams,StringToUTF8(aMessage),nil,aException);
  result := self;
end;

function TInterfaceStub.Raises(const aMethodName: RawUTF8;
  const aParams: array of const; aException: ExceptClass;
  const aMessage: string): TInterfaceStub;
begin
  result := Raises(aMethodName,JSONEncodeArrayOfConst(aParams,true),
    aException,aMessage);
end;

function TInterfaceStub.Raises(const aMethodName: RawUTF8;
  aException: ExceptClass; const aMessage: string): TInterfaceStub;
begin
  result := Raises(aMethodName,'',aException,aMessage);
end;

function TInterfaceStub.Returns(const aMethodName, aParams,
  aExpectedResults: RawUTF8): TInterfaceStub;
begin
  fRules[fInterface.CheckMethodIndex(aMethodName)].
    AddRule(self,isReturns,aParams,aExpectedResults);
  result := self;
end;

function TInterfaceStub.Returns(const aMethodName: RawUTF8; const aParams,
  aExpectedResults: array of const): TInterfaceStub;
begin
  result := Returns(aMethodName,JSONEncodeArrayOfConst(aParams,true),
    JSONEncodeArrayOfConst(aExpectedResults,true));
end;

function TInterfaceStub.Returns(const aMethodName,
  aExpectedResults: RawUTF8): TInterfaceStub;
begin
  result := Returns(aMethodName,'',aExpectedResults);
end;

function TInterfaceStub.Returns(const aMethodName: RawUTF8;
  const aExpectedResults: array of const): TInterfaceStub;
begin
  result := Returns(aMethodName,'',JSONEncodeArrayOfConst(aExpectedResults,true));
end;

function TInterfaceStub.Invoke(const aMethod: TServiceMethod;
  const aParams: RawUTF8; aResult, aErrorMsg: PRawUTF8;
  aClientDrivenID: PCardinal; aServiceCustomAnswer: PServiceCustomAnswer): boolean;
var ndx: cardinal;
    rule: integer;
    ExecutesCtxt: TOnInterfaceStubExecuteParamsAbstract;
    Log: TInterfaceStubLog;
begin
  ndx := aMethod.ExecutionMethodIndex-RESERVED_VTABLE_SLOTS;
  if ndx>=fInterface.MethodsCount then
    result := false else
    with fRules[ndx] do begin
      inc(MethodPassCount);
      rule := FindStrongRuleIndex(aParams);
      if rule<0 then begin
        rule := FindRuleIndex(aParams);
        if (rule>=0) and (DefaultRule>=0) then
          inc(Rules[rule].RulePassCount);
        rule := DefaultRule;
      end;
      if rule<0 then
        if imoRaiseExceptionIfNoRuleDefined in Options then
          raise EInterfaceStub.Create(self,aMethod,'No rule defined') else begin
        rule := FindRuleIndex(aParams);
        if rule>=0 then
          inc(Rules[rule].RulePassCount);
        if imoReturnErrorIfNoRuleDefined in Options then begin
          result := false;
          Log.CustomResults := FormatUTF8('No stubbing rule defined for %s.%s',
            [fInterface.fInterfaceTypeInfo^.Name,aMethod.URI]);
        end else
          result := true;
      end else
      with Rules[rule] do begin
        inc(RulePassCount);
        case Kind of
        isExecutesJSON: begin
          ExecutesCtxt := TOnInterfaceStubExecuteParamsJSON.Create(
            self,@aMethod,aParams,Values);
          try
            TOnInterfaceStubExecuteJSON(Execute)
              (TOnInterfaceStubExecuteParamsJSON(ExecutesCtxt));
            result := not ExecutesCtxt.fFailed;
            Log.CustomResults := ExecutesCtxt.fResult;
          finally
            ExecutesCtxt.Free;
          end;
        end;
{$ifndef NOVARIANTS}
        isExecutesVariant: begin
          ExecutesCtxt := TOnInterfaceStubExecuteParamsVariant.Create(
            self,@aMethod,aParams,Values);
          try
            TOnInterfaceStubExecuteVariant(Execute)
              (TOnInterfaceStubExecuteParamsVariant(ExecutesCtxt));
            result := not ExecutesCtxt.fFailed;
            if result then
              TOnInterfaceStubExecuteParamsVariant(ExecutesCtxt).
                SetResult(Log.CustomResults);
          finally
            ExecutesCtxt.Free;
          end;
        end;
{$endif}isRaises:
          raise ExceptionClass.Create(UTF8ToString(Values));
        isReturns: begin
          result := true;
          Log.CustomResults := Values;
        end;
        isFails: begin
          result := InternalCheck(false,Values,false);
          if not result then
            Log.CustomResults := Values;
        end;
        else
          result := true; // ignore isUndefined (ExpectsCount only) rules
        end;
      end;
      if result then begin
        if aResult<>nil then // make unique due to JSONDecode()
          if Log.CustomResults='' then
            SetString(aResult^,PAnsiChar(pointer(aMethod.DefaultResult)),
              length(aMethod.DefaultResult)) else
            SetString(aResult^,PAnsiChar(pointer(Log.CustomResults)),
              length(Log.CustomResults));
      end else
      if aErrorMsg<>nil then
        aErrorMsg^ := Log.CustomResults;
      if imoLogMethodCallsAndResults in Options then begin
        Log.TimeStamp64 := GetTickCount64;
        Log.WasError := not result;
        Log.Method := @aMethod;
        Log.Params := aParams;
        fLog.Add(Log);
      end;
    end;
end;

function TInterfaceStub.GetLogAsText: RawUTF8;
begin
  result := IntGetLogAsText(0,'',[wName,wParams,wResults]);
end;

function TInterfaceStub.IntGetLogAsText(asmndx: integer; const aParams: RawUTF8;
  aScope: TInterfaceStubLogLayouts): RawUTF8;
var i: integer;
    WR: TTextWriter;
    Log: ^TInterfaceStubLog;
begin
  if fLogCount=0 then
    result := '' else begin
    WR := TTextWriter.CreateOwnedStream;
    try
      Log := Pointer(fLogs);
      if asmndx<RESERVED_VTABLE_SLOTS then
        for i := 1 to fLogCount do begin
          Log^.AddAsText(WR,aScope);
          inc(Log);
        end else
        for i := 1 to fLogCount do begin
          if Log^.Method^.ExecutionMethodIndex=asmndx then
            if (aParams='') or (Log^.Params=aParams) then
              Log^.AddAsText(WR,aScope);
          inc(Log);
        end;
      WR.CancelLastComma;
      WR.SetText(result);
    finally
      WR.Free;
    end;
  end;
end;

function TInterfaceStub.GetLogHash: cardinal;
begin
  result := Hash32(GetLogAsText);
end;


{ TInterfaceMock }

constructor TInterfaceMock.Create(aInterface: PTypeInfo;
  out aMockedInterface; aTestCase: TSynTestCase);
begin
  inherited Create(aInterface,aMockedInterface);
  fTestCase := aTestCase;
end;

constructor TInterfaceMock.Create(const aGUID: TGUID; out aMockedInterface;
  aTestCase: TSynTestCase);
begin
  inherited Create(aGUID,aMockedInterface);
  fTestCase := aTestCase;
end;

constructor TInterfaceMock.Create(const aInterfaceName: RawUTF8;
  out aMockedInterface; aTestCase: TSynTestCase);
begin
  inherited Create(aInterfaceName,aMockedInterface);
  fTestCase := aTestCase;
end;

function TInterfaceMock.InternalCheck(aValid: boolean; const aErrorMessage: RawUTF8;
  aExpectationFailed: boolean): boolean;
begin
  if fTestCase=nil then
    result := inherited InternalCheck(aValid,aErrorMessage,aExpectationFailed) else begin
    fTestCase.Check(aValid xor (imoMockFailsWillPassTestCase in Options),
      UTF8ToString(aErrorMessage));
    result := true; // do not raise any exception at this stage for TInterfaceMock
  end;
end;


{ TInterfaceMockSpy }

procedure TInterfaceMockSpy.InternalCreate(out aStubbedInterface);
begin
  inherited;
  include(fOptions,imoLogMethodCallsAndResults);
end;

procedure TInterfaceMockSpy.IntSetOptions(Options: TInterfaceStubOptions);
begin
  include(Options,imoLogMethodCallsAndResults);
  inherited IntSetOptions(Options);
end;

procedure TInterfaceMockSpy.Verify(const aMethodName: RawUTF8;
  const aParams: array of const; aOperator: TSQLQueryOperator;
  aCount: cardinal);
begin
  Verify(aMethodName,JSONEncodeArrayOfConst(aParams,true),aOperator,aCount);
end;

procedure TInterfaceMockSpy.Verify(const aMethodName: RawUTF8;
  const aParams: array of const; const aTrace: RawUTF8);
begin
  Verify(aMethodName,JSONEncodeArrayOfConst(aParams,true),aTrace);
end;

procedure TInterfaceMockSpy.Verify(const aMethodName: RawUTF8;
  aOperator: TSQLQueryOperator; aCount: cardinal);
var m: integer;
begin
  m := fInterface.CheckMethodIndex(aMethodName);
  IntCheckCount(m,fRules[m].MethodPassCount,aOperator,aCount);
end;

procedure TInterfaceMockSpy.Verify(const aMethodName, aParams: RawUTF8;
  aOperator: TSQLQueryOperator; aCount: cardinal);
var asmndx, i: integer;
    c: cardinal;
begin
  asmndx := fInterface.CheckMethodIndex(aMethodName)+RESERVED_VTABLE_SLOTS;
  if aParams='' then
    c := fRules[asmndx-RESERVED_VTABLE_SLOTS].MethodPassCount else begin
    c := 0;
    for i := 0 to fLogCount-1 do
      with fLogs[i] do
      if (Method.ExecutionMethodIndex=asmndx) and (Params=aParams) then
        inc(c);
  end;
  IntCheckCount(asmndx-RESERVED_VTABLE_SLOTS,c,aOperator,aCount);
end;


procedure TInterfaceMockSpy.Verify(const aTrace: RawUTF8;
  aScope: TInterfaceMockSpyCheck);
const
  VERIFY_SCOPE: array[TInterfaceMockSpyCheck] of TInterfaceStubLogLayouts = (
    [wName], [wName, wParams], [wName, wParams, wResults]);
begin
  InternalCheck(IntGetLogAsText(0,'',VERIFY_SCOPE[aScope])=aTrace,'Verify() failed',true);
end;

procedure TInterfaceMockSpy.Verify(const aMethodName, aParams, aTrace: RawUTF8);
var m: integer;
begin
  m := fInterface.CheckMethodIndex(aMethodName);
  InternalCheck(
    IntGetLogAsText(m+RESERVED_VTABLE_SLOTS,aParams,[wResults])=aTrace,
    fInterface.Methods[m].URI+' Verify() failed',true);
end;

procedure TInterfaceMockSpy.Verify(const aMethodName, aTrace: RawUTF8;
  aScope: TInterfaceMockSpyCheck);
const
  VERIFY_SCOPE: array[TInterfaceMockSpyCheck] of TInterfaceStubLogLayouts = (
    [], [wParams], [wParams, wResults]);
var m: integer;
begin
  m := fInterface.CheckMethodIndex(aMethodName);
  if aScope=chkName then
    raise EInterfaceStub.Create(self,fInterface.Methods[m],'Invalid scope for Verify()');
  InternalCheck(
    IntGetLogAsText(m+RESERVED_VTABLE_SLOTS,'',VERIFY_SCOPE[aScope])=aTrace,
    fInterface.Methods[m].URI+' Verify() failed',true);
end;


{ TServiceFactory }

function TServiceFactory.GetInterfaceTypeInfo: PTypeInfo;
begin
  if (Self<>nil) and (fInterface<>nil) then
    result := fInterface.fInterfaceTypeInfo else
    result := nil;
end;

function TServiceFactory.GetInterfaceIID: TGUID;
begin
  result := fInterface.fInterfaceIID;
end;

constructor TServiceFactory.Create(aRest: TSQLRest;
  aInterface: PTypeInfo; aInstanceCreation: TServiceInstanceImplementation;
  const aContractExpected: RawUTF8);
var m,j: integer;
begin
  // check supplied interface
  if (aRest=nil) or (aInterface=nil) then
    raise EServiceException.Create('Invalid call');
  inherited Create;
  fInterface := TInterfaceFactory.Get(aInterface);
  fRest := aRest;
  fInstanceCreation := aInstanceCreation;
  fInterfaceURI := aInterface^.Name;
  fInterfaceMangledURI := BinToBase64URI(@fInterface.fInterfaceIID,sizeof(TGUID));
  if fInterfaceURI[1] in ['I','i'] then
    Delete(fInterfaceURI,1,1);
  if fRest.Model.GetTableIndex(fInterfaceURI)>=0 then
    raise EServiceException.CreateFmt('"%s" interface name is already used by a SQL table name',
      [fInterfaceURI]);
  for m := 0 to fInterface.fMethodsCount-1 do
  with fInterface.fMethods[m] do begin
    if ArgsResultIndex>=0 then
    with Args[ArgsResultIndex] do
    case ValueType of
    smvNone, smvObject:
      raise EServiceException.CreateFmt('%s.%s: unexpected result type %s',
        [fInterface.fInterfaceTypeInfo^.Name,URI,TypeName^]);
    smvRecord:
      if TypeInfo=System.TypeInfo(TServiceCustomAnswer) then
        if InstanceCreation=sicClientDriven then
          raise EServiceException.CreateFmt(
            '%s.%s: sicClientDriven mode not allowed with TServiceCustomAnswer result',
            [fInterface.fInterfaceTypeInfo^.Name,URI]) else begin
        for j := ArgsOutFirst to ArgsOutLast do
          if Args[j].ValueDirection in [smdVar,smdOut] then
            raise EServiceException.CreateFmt(
              '%s.%s: var/out parameter "%s" not allowed with TServiceCustomAnswer result',
              [fInterface.fInterfaceTypeInfo^.Name,URI,Args[j].ParamName^]);
        ArgsResultIsServiceCustomAnswer := true;
      end;
    end;
  end;
  SetLength(fExecution,fInterface.fMethodsCount);
  // compute interface signature (aka "contract"), serialized as a JSON object
  fContract := FormatUTF8('{"contract":"%","implementation":"%","methods":%}',
      [InterfaceURI,LowerCase(ToText(InstanceCreation)),fInterface.fContract]);
  fContractHash := '"'+CardinalToHex(Hash32(fContract))+
    CardinalToHex(CRC32string(fContract))+'"'; // 2 hashes to avoid collision
  if aContractExpected<>'' then // override default contract
    fContractExpected := aContractExpected else
    fContractExpected := fContractHash; // for security
end;


{ TServiceContainerServer }

function TServiceContainerServer.AddImplementation(
  aImplementationClass: TInterfacedClass; const aInterfaces: array of PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation;
  aSharedImplementation: TInterfacedObject): TServiceFactoryServer;
var C: TClass;
    T: PInterfaceTable;
    i, j: integer;
    UID: array of ^TGUID;
    F: TServiceFactoryServer;
begin
  result := nil;
  // check input parameters
  if (self=nil) or (aImplementationClass=nil) or (high(aInterfaces)<0) then
    exit;
  if aSharedImplementation<>nil then
    if (aSharedImplementation.ClassType<>aImplementationClass) or
       (aInstanceCreation<>sicShared) then
      raise EServiceException.CreateFmt('Invalid %s service registration',
        [aSharedImplementation.ClassName]);
  CheckInterface(aInterfaces);
  SetLength(UID,length(aInterfaces));
  for j := 0 to high(aInterfaces) do
    UID[j] := @PInterfaceTypeData(aInterfaces[j]^.ClassType)^.IntfGuid;
  // check that all interfaces are implemented by this class
  C := aImplementationClass;
  repeat
    T := C.GetInterfaceTable;
    if T<>nil then
      for i := 0 to T^.EntryCount-1 do
        with T^.Entries[i] do
        for j := 0 to high(aInterfaces) do
          if (UID[j]<>nil) and IsEqualGUID(UID[j]^,IID) then begin
            UID[j] := nil;
            break;
          end;
    C := C.ClassParent;
  until C=nil;
  for j := 0 to high(aInterfaces) do
    if UID[j]<>nil then
      raise EServiceException.CreateFmt('Interface %s not found in %s implementation',
        [aInterfaces[j]^.Name,aImplementationClass.ClassName]);
  // create the shared instance (if any)
  if (aInstanceCreation=sicShared) and (aSharedImplementation=nil) then
    if aImplementationClass.InheritsFrom(TInterfacedObjectWithCustomCreate) then
      aSharedImplementation := TInterfacedObjectWithCustomCreateClass(aImplementationClass).Create else
      aSharedImplementation := aImplementationClass.Create;
  // register this implementation class
  for j := 0 to high(aInterfaces) do begin
    F := TServiceFactoryServer.Create(Rest as TSQLRestServer,aInterfaces[j],
      aInstanceCreation,aImplementationClass,'',1800,aSharedImplementation);
    if result=nil then
      result := F; // returns the first registered interface
    AddServiceInternal(F);
  end;
end;

procedure TServiceContainerServer.OnCloseSession(aSessionID: cardinal);
var i: Integer;
    Inst: TServiceFactoryServerInstance;
begin
  Inst.InstanceID := aSessionID;
  for i := 0 to Count-1 do
    with TServiceFactoryServer(Index(i)) do
    if InstanceCreation=sicPerSession then
      InternalInstanceRetrieve(Inst,INTERNALINSTANCERETRIEVE_FREEINSTANCE);
end;

{ TInterfacedObjectWithCustomCreate }

constructor TInterfacedObjectWithCustomCreate.Create;
begin // nothing to do by default - overridden constructor may add custom code
end;

procedure TInterfacedObjectWithCustomCreate.InternalRelease;
begin
  if self<>nil then
    IInterface(self)._Release; // call the release interface
end;


{ TPersistentWithCustomCreate }

constructor TPersistentWithCustomCreate.Create;
begin // nothing to do by default - overridden constructor may add custom code
end;


{ TServiceFactoryServer }

constructor TServiceFactoryServer.Create(aRestServer: TSQLRestServer; aInterface: PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation;
  aImplementationClass: TInterfacedClass; const aContractExpected: RawUTF8;
  aTimeOutSec: cardinal; aSharedInstance: TInterfacedObject);
begin
  // extract RTTI from the interface
  inherited Create(aRestServer,aInterface,aInstanceCreation,aContractExpected);
  if fRest.MethodAddress(ShortString(InterfaceURI))<>nil then
    raise EServiceException.CreateFmt('I%s is already exposed as %s published method',
      [InterfaceURI,fRest.ClassName]) else
  fImplementationClass := aImplementationClass;
  if fImplementationClass.InheritsFrom(TInterfacedObjectWithCustomCreate) then
    fImplementationClassWithCustomCreate := true;
  fImplementationClassInterfaceEntry :=
    fImplementationClass.GetInterfaceEntry(fInterface.fInterfaceIID);
  if fImplementationClassInterfaceEntry=nil then
    raise EServiceException.CreateFmt('%s does not implement I%s',
      [fImplementationClass.ClassName,fInterfaceURI]) else
  // initialize the shared instance or client driven parameters
  if InstanceCreation<>sicPerThread then
    InitializeCriticalSection(fInstanceLock);
  case InstanceCreation of
  sicShared: begin
    if aSharedInstance=nil then
      fSharedInstance := CreateInstance(false) else
      fSharedInstance := aSharedInstance;
    if (fSharedInstance=nil) or
       not GetInterfaceFromEntry(fSharedInstance,fImplementationClassInterfaceEntry,fSharedInterface) then
      raise EServiceException.CreateFmt('No implementation available for I%s interface',
        [fInterfaceURI]);
  end;
  sicClientDriven, sicPerSession, sicPerUser, sicPerGroup, sicPerThread:
    if (aTimeOutSec=0) and (InstanceCreation<>sicPerThread) then
      fInstanceCreation := sicSingle else begin
      // only instances list is protected, since client calls shall be pipelined
      fInstance.InitSpecific(TypeInfo(TServiceFactoryServerInstanceDynArray),
        fInstances,djCardinal,@fInstancesCount); // sort by InstanceID: cardinal
      fInstanceTimeOut := aTimeOutSec*1000;
    end;
  end;
  fResultAsJSONObject := true;
end;

procedure TServiceFactoryServer.SetTimeoutSecInt(value: cardinal);
begin
  if (self=nil) or not (InstanceCreation in [
     sicClientDriven,sicPerSession,sicPerUser,sicPerGroup,sicPerThread]) then
    raise EServiceException.CreateFmt('SetTimeSec() with InstanceCreation=%s',
      [ToText(InstanceCreation)]);
  fInstanceTimeOut := value*1000;
end;

function TServiceFactoryServer.GetTimeoutSec: cardinal;
begin
  if (self=nil) or not (InstanceCreation in [
     sicClientDriven,sicPerSession,sicPerUser,sicPerGroup,sicPerThread]) then
    result := 0 else
    result := fInstanceTimeout div 1000;
end;

destructor TServiceFactoryServer.Destroy;
var i: integer;
begin
  try
    if InstanceCreation<>sicPerThread then
      EnterCriticalSection(fInstanceLock);
    try // release any internal instance (should have been done by client)
      try
        for i := 0 to fInstancesCount-1 do
          if fInstances[i].Instance<>nil then
            fInstances[i].SafeFreeInstance(self);
      finally
        {$ifndef LVCL}
        FreeAndNil(fBackgroundThread);
        {$endif}
      end;
    except
      ; // better ignore any error in business logic code
    end;
  finally
    if InstanceCreation<>sicPerThread then
      LeaveCriticalSection(fInstanceLock);
  end;
  if InstanceCreation<>sicPerThread then
    DeleteCriticalSection(fInstanceLock);
  inherited;
end;

function TServiceFactoryServer.Get(out Obj): Boolean;
var Inst: TServiceFactoryServerInstance;
begin
  result := false;
  if Self<>nil then
    case fInstanceCreation of
    sicShared:
    if fSharedInterface<>nil then begin
      IInterface(Obj) := fSharedInterface; // copy implementation interface
      result := true;
    end;
    sicPerThread: begin
      Inst.Instance := nil;
      Inst.InstanceID := GetCurrentThreadId;
      if not InternalInstanceRetrieve(Inst,0) and (Inst.Instance<>nil) then
        result := GetInterfaceFromEntry(Inst.Instance,fImplementationClassInterfaceEntry,Obj);
    end;
    else begin // no user/group/session on pure server-side -> always sicSingle
      Inst.Instance := CreateInstance(false);
      if Inst.Instance<>nil then
        result := GetInterfaceFromEntry(Inst.Instance,fImplementationClassInterfaceEntry,Obj);
    end;
    end;
end;

function TServiceFactoryServer.RetrieveSignature: RawUTF8;
begin
  if self=nil then
    result := '' else
    result := Contract; // just return the current value
end;

procedure TServiceFactoryServerInstance.SafeFreeInstance(Factory: TServiceFactoryServer);
var Obj: TInterfacedObject;
    Synch: TCallMethodSynchro;
begin
  InstanceID := 0;
  Obj := Instance;
  Instance := nil;
  {$ifndef LVCL}
  if (optFreeInMainThread in Factory.fAnyOptions) and
     (GetCurrentThreadID<>MainThreadID) then
    {$ifdef DELPHI6OROLDER}TThreadHook(nil).Synchronize(
    {$else}                TThread.Synchronize(nil,
    {$endif}  TInterfacedObjectWithCustomCreate(Obj).InternalRelease) else
  {$endif}
  if (optFreeInPerInterfaceThread in Factory.fAnyOptions) and
     Assigned(Factory.fBackgroundThread) then begin
    Synch.Action := syncInstanceRelease;
    Synch.InstanceToRelease := TInterfacedObjectWithCustomCreate(Obj);
    Factory.fBackgroundThread.RunAndWait(@Synch);
  end else
    IInterface(Obj)._Release;
end;

function TServiceFactoryServer.InternalInstanceRetrieve(
  var Inst: TServiceFactoryServerInstance; aMethodIndex: integer): boolean;
procedure AddNew;
var i: integer;
    P: ^TServiceFactoryServerInstance;
begin
  Inst.Instance := CreateInstance(true);
  if Inst.Instance=nil then
    exit;
  {$ifdef WITHLOG}
  SQLite3Log.Add.Log(sllServiceCall,'Adding % instance (id=%)',
    [fInterfaceURI,Inst.InstanceID],self);
  {$endif}
  P := pointer(fInstances);
  for i := 1 to fInstancesCount do
    if P^.InstanceID=0 then begin
      P^ := Inst; // found an empty entry -> re-use it
      exit;
    end else
    inc(P);
  fInstance.Add(Inst); // append a new entry
end;
var i: integer;
begin
  result := false;
  if InstanceCreation<>sicPerThread then
    EnterCriticalSection(fInstanceLock);
  try
    Inst.LastAccess64 := GetTickCount64;
    // first release any deprecated instances
    if fInstanceTimeout<>0 then
    for i := fInstancesCount-1 downto 0 do
      with fInstances[i] do
      if InstanceID<>0 then
      if Inst.LastAccess64>LastAccess64+fInstanceTimeout then begin
        // deprecated -> mark this entry as empty
        {$ifdef WITHLOG}
        SQLite3Log.Add.Log(sllServiceCall,
          'Deleted % instance (id=%) after % ms timeout (max % ms)',
          [fInterfaceURI,InstanceID,Inst.LastAccess64-LastAccess64,fInstanceTimeOut],self);
        {$endif}
        SafeFreeInstance(self);
      end;
    if Inst.InstanceID=0 then begin
      // retrieve or initialize a sicClientDriven instance
      if (cardinal(aMethodIndex)>=fInterface.fMethodsCount) or
         (InstanceCreation<>sicClientDriven) then
        exit;
      // initialize the new instance
      inc(fInstanceCurrentID);
      Inst.InstanceID := fInstanceCurrentID;
      AddNew;
    end else begin
      // search the instance corresponding to Inst.InstanceID
      for i := 0 to fInstancesCount-1 do
        with fInstances[i] do
        if InstanceID=Inst.InstanceID then begin
          if aMethodIndex=INTERNALINSTANCERETRIEVE_FREEINSTANCE then begin
            // aMethodIndex=-1 for {"method":"_free_", "params":[], "id":1234}
            SafeFreeInstance(self);
            result := true; // notify caller that successfully released instance
            exit;
          end;
          LastAccess64 := Inst.LastAccess64;
          Inst.Instance := Instance;
          exit;
        end;
      // add any new session/user/group instance if necessary
      if (InstanceCreation<>sicClientDriven) and
         (cardinal(aMethodIndex)<fInterface.fMethodsCount) then
        AddNew;
    end;
  finally
    if InstanceCreation<>sicPerThread then
      LeaveCriticalSection(fInstanceLock);
  end;
end;

function TServiceFactoryServer.RestServer: TSQLRestServer;
begin
  result := TSQLRestServer(Rest);
end;

function TServiceFactoryServer.CreateInstance(AndIncreaseRefCount: boolean): TInterfacedObject;
begin
  if fImplementationClassWithCustomCreate then
    result := TInterfacedObjectWithCustomCreateClass(fImplementationClass).Create else
    result := fImplementationClass.Create;
  if AndIncreaseRefCount then
    IInterface(result)._AddRef; // allow passing self to sub-methods
end;

procedure TServiceFactoryServer.ExecuteMethod(Ctxt: TSQLRestServerURIContext);
procedure Error(Msg: PUTF8Char);
begin
  Ctxt.Error(Msg,[UnCamelCase(ToText(InstanceCreation))]);
end;
var Inst: TServiceFactoryServerInstance;
    WR: TTextWriter;
    entry: PInterfaceEntry;
    ThreadServer: PServiceRunningContext;
begin
  // 1. initialize Inst.Instance and Inst.InstanceID
  Inst.InstanceID := 0;
  Inst.Instance := nil;
  case InstanceCreation of
    sicSingle:
      if cardinal(Ctxt.ServiceMethodIndex)>=fInterface.fMethodsCount then
        exit else
        Inst.Instance := CreateInstance(true);
    sicShared:
      if cardinal(Ctxt.ServiceMethodIndex)>=fInterface.fMethodsCount then
        exit else
        Inst.Instance := fSharedInstance;
    sicClientDriven, sicPerSession, sicPerUser, sicPerGroup, sicPerThread: begin
      case InstanceCreation of
      sicClientDriven:
        Inst.InstanceID := Ctxt.ServiceInstanceID;
      sicPerThread: 
        Inst.InstanceID := GetCurrentThreadId;
      else
        if Ctxt.Session>CONST_AUTHENTICATION_NOT_USED then
          case InstanceCreation of // authenticated user -> handle context
          sicPerSession: Inst.InstanceID := Ctxt.Session;
          sicPerUser:    Inst.InstanceID := Ctxt.SessionUser;
          sicPerGroup:   Inst.InstanceID := Ctxt.SessionGroup;
          end else begin
            Error('% mode expects an authenticated session');
            exit;
          end;
      end;
      if InternalInstanceRetrieve(Inst,Ctxt.ServiceMethodIndex) then begin
        Ctxt.Success;
        exit; // {"method":"_free_", "params":[], "id":1234}
      end;
    end;
  end;
  if Inst.Instance=nil then begin
    Error('% instance not found or deprecated');
    exit;
  end;
  Ctxt.ServiceInstanceID := Inst.InstanceID;
  // 2. call method implementation
  try
    entry := Inst.Instance.GetInterfaceEntry(fInterface.fInterfaceIID);
    if entry=nil then
      exit;
    if optExecInPerInterfaceThread in fExecution[Ctxt.ServiceMethodIndex].Options then
      if fBackgroundThread=nil then
        fBackgroundThread := TSynBackgroundThreadSQLRestServerProcedure.Create(RestServer);
    ThreadServer := @ServiceContext;
    WR := TJSONSerializer.CreateOwnedStream;
    try
      with ThreadServer^ do begin
        Factory := self;
        Request := Ctxt;
      end; // RunningThread is already set at thread initialization
      // root/calculator {"method":"add","params":[1,2]} -> {"result":[3],"id":0}
      Ctxt.ServiceResultStart(WR);
      try
        if optExecLockedPerInterface in fExecution[Ctxt.ServiceMethodIndex].Options then
          EnterCriticalSection(fInstanceLock);
        if not fInterface.fMethods[Ctxt.ServiceMethodIndex].InternalExecute(
            [PAnsiChar(Inst.Instance)+entry^.IOffset],Ctxt.ServiceParameters,
             WR,Ctxt.Call.OutHead,Ctxt.Call.OutStatus,
             fExecution[Ctxt.ServiceMethodIndex].Options,
             Ctxt.ForceServiceResultAsJSONObject,
             {$ifdef LVCL}nil{$else}fBackgroundThread{$endif}) then
          exit; // wrong request
      finally
        if optExecLockedPerInterface in fExecution[Ctxt.ServiceMethodIndex].Options then
          LeaveCriticalSection(fInstanceLock);
      end;
      if Ctxt.Call.OutHead='' then begin // <>'' for TServiceCustomAnswer
        Ctxt.ServiceResultEnd(WR,Inst.InstanceID);
        Ctxt.Call.OutHead := JSON_CONTENT_TYPE_HEADER;
        Ctxt.Call.OutStatus := HTML_SUCCESS;
      end;
      WR.SetText(Ctxt.Call.OutBody);
    finally
      with ThreadServer^ do begin
        Factory := nil;
        Request := nil;
      end;
      WR.Free;
    end;
  finally
    if InstanceCreation=sicSingle then // always release single shot instance
      Inst.SafeFreeInstance(self);
  end;
end;

function TServiceFactoryServer.AllowAll: TServiceFactoryServer;
var m: integer;
begin
  if self<>nil then
    for m := 0 to fInterface.fMethodsCount-1 do
      fillchar(fExecution[m].Denied,sizeof(fExecution[m].Denied),0);
  result := self;
end;

function TServiceFactoryServer.AllowAllByID(const aGroupID: array of integer): TServiceFactoryServer;
var m,g: integer;
begin
  if self<>nil then
    for m := 0 to fInterface.fMethodsCount-1 do
    with fExecution[m] do
      for g := 0 to high(aGroupID) do
        exclude(Denied,aGroupID[g]-1);
  result := self;
end;

function TServiceFactoryServer.AllowAllByName(const aGroup: array of RawUTF8): TServiceFactoryServer;
var IDs: TIntegerDynArray;
begin
  if self<>nil then
    if RestServer.MainFieldIDs(RestServer.fSQLAuthGroupClass,aGroup,IDs) then
      AllowAllByID(IDs);
  result := self;
end;

function TServiceFactoryServer.DenyAll: TServiceFactoryServer;
var m: integer;
begin
  if self<>nil then
    for m := 0 to fInterface.fMethodsCount-1 do
      fillchar(fExecution[m].Denied,sizeof(fExecution[m].Denied),255);
  result := self;
end;

function TServiceFactoryServer.DenyAllByID(const aGroupID: array of integer): TServiceFactoryServer;
var m,g: integer;
begin
  if self<>nil then
    for m := 0 to fInterface.fMethodsCount-1 do
    with fExecution[m] do
      for g := 0 to high(aGroupID) do
        include(Denied,aGroupID[g]-1);
  result := self;
end;

function TServiceFactoryServer.DenyAllByName(const aGroup: array of RawUTF8): TServiceFactoryServer;
var IDs: TIntegerDynArray;
begin
  if self<>nil then
    if RestServer.MainFieldIDs(RestServer.fSQLAuthGroupClass,aGroup,IDs) then
      DenyAllByID(IDs);
  result := self;
end;

function TServiceFactoryServer.Allow(const aMethod: array of RawUTF8): TServiceFactoryServer;
var m: integer;
begin
  if self<>nil then
    for m := 0 to high(aMethod) do
      fillchar(fExecution[fInterface.CheckMethodIndex(aMethod[m])].Denied,
        sizeof(fExecution[0].Denied),0);
  result := self;
end;

function TServiceFactoryServer.AllowByID(const aMethod: array of RawUTF8; const aGroupID: array of integer): TServiceFactoryServer;
var m,g: integer;
begin
  if self<>nil then 
    if high(aGroupID)>=0 then
    for m := 0 to high(aMethod) do
      with fExecution[fInterface.CheckMethodIndex(aMethod[m])] do
        for g := 0 to high(aGroupID) do
          exclude(Denied,aGroupID[g]-1);
  result := self;
end;

function TServiceFactoryServer.AllowByName(const aMethod: array of RawUTF8; const aGroup: array of RawUTF8): TServiceFactoryServer;
var IDs: TIntegerDynArray;
begin
  if self<>nil then
    if RestServer.MainFieldIDs(RestServer.fSQLAuthGroupClass,aGroup,IDs) then
      AllowByID(aMethod,IDs);
  result := self;
end;

function TServiceFactoryServer.Deny(const aMethod: array of RawUTF8): TServiceFactoryServer;
var m: integer;
begin
  if self<>nil then
    for m := 0 to high(aMethod) do
      fillchar(fExecution[fInterface.CheckMethodIndex(aMethod[m])].Denied,
        sizeof(fExecution[0].Denied),255);
  result := self;
end;

function TServiceFactoryServer.DenyByID(const aMethod: array of RawUTF8; const aGroupID: array of integer): TServiceFactoryServer;
var m,g: integer;
begin
  if self<>nil then
    for m := 0 to high(aMethod) do
      with fExecution[fInterface.CheckMethodIndex(aMethod[m])] do
        for g := 0 to high(aGroupID) do
          include(Denied,aGroupID[g]-1);
  result := self;
end;

function TServiceFactoryServer.DenyByName(const aMethod: array of RawUTF8; const aGroup: array of RawUTF8): TServiceFactoryServer;
var IDs: TIntegerDynArray;
begin
  if self<>nil then
    if RestServer.MainFieldIDs(RestServer.fSQLAuthGroupClass,aGroup,IDs) then
      DenyByID(aMethod,IDs);
  result := self;
end;

function TServiceFactoryServer.SetOptions(const aMethod: array of RawUTF8;
  aOptions: TServiceMethodOptions): TServiceFactoryServer;
var m,i: integer;
begin
  if self<>nil then begin
    if (fInstanceCreation=sicPerThread) and (optExecLockedPerInterface in aOptions) then
      raise EServiceException.CreateFmt(
        'optExecLockedPerInterface option not compatible with sicPerThread for I%s interface',
        [fInterfaceURI]);
    if (fInstanceCreation=sicPerThread) and
       ([{$ifndef LVCL}optExecInMainThread,optFreeInMainThread,{$endif}
         optExecInPerInterfaceThread,optFreeInPerInterfaceThread]*aOptions<>[]) then
      raise EServiceException.CreateFmt(
        'opt*In*Thread option not compatible with sicPerThread for I%s interface',
        [fInterfaceURI]);
    {$ifndef LVCL}
    if (optExecLockedPerInterface in aOptions) and
       ([optExecInMainThread,optFreeInMainThread,
         optExecInPerInterfaceThread,optFreeInPerInterfaceThread]*aOptions<>[]) then
      raise EServiceException.CreateFmt(
        'optExecLockedPerInterface with opt*In*Thread options for I%s interface',
        [fInterfaceURI]);
    {$endif}
    if high(aMethod)<0 then
      for i := 0 to fInterface.fMethodsCount-1 do
        fExecution[i].Options := aOptions else
    for m := 0 to high(aMethod) do
      fExecution[fInterface.CheckMethodIndex(aMethod[m])].Options := aOptions;
    fAnyOptions := [];
    for i := 0 to fInterface.fMethodsCount-1 do
      fAnyOptions := fAnyOptions+fExecution[i].Options;
    if (optFreeInPerInterfaceThread in fAnyOptions) and
       not (optExecInPerInterfaceThread in fAnyOptions) then
      raise EServiceException.CreateFmt(
        'optFreeInPerInterfaceThread without optExecInPerInterfaceThread for I%s interface',
        [fInterfaceURI]);
    {$ifndef LVCL}
    if ([optExecInMainThread,optFreeInMainThread]*fAnyOptions<>[]) and
       ([optExecInPerInterfaceThread,optFreeInPerInterfaceThread]*fAnyOptions<>[]) then
      raise EServiceException.CreateFmt(
        'Concurrent opt*InMainThread and opt*InPerInterfaceThread for I%s interface',
        [fInterfaceURI]);
    {$endif}
  end;
  result := self;
end;

function TServiceFactoryServer.SetTimeoutSec(value: cardinal): TServiceFactoryServer;
begin
  SetTimeoutSecInt(value);
  result := self;
end;


{ TServiceMethodArgument }

const
  CONST_METHODDIRTOJSON: array[TServiceMethodValueDirection] of string[4] = (
    // convert into generic in/out direction (assume result is out)
    'in','both','out','out');

  // AnsiString (Delphi <2009) is handled with care (may loose data otherwise)
  CONST_METHODTYPETOJSON: array[TServiceMethodValueType] of string[8] = (
    '??','self','boolean', '', '','integer','cardinal','int64',
    'double','datetime','currency','utf8',
    {$ifdef UNICODE}'utf8'{$else}''{$endif},'utf8','',
    {$ifndef NOVARIANTS}'variant',{$endif}'','json','');

procedure TServiceMethodArgument.SerializeToContract(WR: TTextWriter);
begin
  WR.AddShort('{"argument":"');
  WR.AddShort(ParamName^);
  WR.AddShort('","direction":"');
  WR.AddShort(CONST_METHODDIRTOJSON[ValueDirection]);
  WR.AddShort('","type":"');
  {$ifndef UNICODE} // should specify the Ansi code page for no data loss
  if ValueType=smvString then begin
    WR.AddShort('ansi');
    WR.AddU(CurrentAnsiConvert.CodePage);
  end else
  {$endif}
  if CONST_METHODTYPETOJSON[ValueType]='' then
    WR.AddShort(TypeInfo^.Name) else
    WR.AddShort(CONST_METHODTYPETOJSON[ValueType]);
  WR.AddShort('"},');
end;

procedure TServiceMethodArgument.AddJSON(WR: TTextWriter; V: pointer);
begin
  if vIsString in ValueKindAsm then
    WR.Add('"');
  case ValueType of
  smvBoolean:   WR.AddString(JSON_BOOLEAN[PBoolean(V)^]);
  smvEnum..smvInt64:
  case SizeInStorage of
    1: WR.Add(PByte(V)^);
    2: WR.Add(PWord(V)^);
    4: if ValueType=smvInteger then
         WR.Add(PInteger(V)^) else
         WR.AddU(PCardinal(V)^);
    8: WR.Add(PInt64(V)^);
  end;
  smvDouble, smvDateTime: WR.Add(PDouble(V)^);
  smvCurrency:   WR.AddCurr64(PInt64(V)^);
  smvRawUTF8:    WR.AddJSONEscape(PPointer(V)^);
  smvRawJSON:    WR.AddNoJSONEscape(PPointer(V)^);
  smvString:     {$ifdef UNICODE}
                 WR.AddJSONEscapeW(pointer(PString(V)^));
                 {$else}
                 WR.AddJSONEscapeAnsiString(PString(V)^);
                 {$endif}
  smvWideString: WR.AddJSONEscapeW(PPointer(V)^);
  smvObject:     WR.WriteObject(PPointer(V)^,[]);
  smvRecord:     WR.AddRecordJSON(V^,TypeInfo);
  {$ifndef NOVARIANTS}
  smvVariant:    WR.AddVariantJSON(PVariant(V)^,twJSONEscape);
  {$endif}
  smvDynArray:   WR.AddDynArrayJSON(TypeInfo,V^);
  end;
  if vIsString in ValueKindAsm then
    WR.AddShort('",') else
    WR.Add(',');
end;

procedure TServiceMethodArgument.AddValueJSON(WR: TTextWriter; const Value: RawUTF8);
begin
  if vIsString in ValueKindAsm then begin
    WR.Add('"');
    WR.AddJSONEscape(pointer(Value),length(Value));
    WR.AddShort('",');
  end else begin
    WR.AddString(Value);
    WR.Add(',');
  end;
end;

procedure TServiceMethodArgument.AddDefaultJSON(WR: TTextWriter);
begin
  case ValueType of
  smvBoolean:  WR.AddShort('false,');
  smvObject:   WR.AddShort('null,'); // may raise an error on the client side
  smvDynArray: WR.AddShort('[],');
  smvRecord:   begin
    WR.AddVoidRecordJSON(TypeInfo);
    WR.Add(',');
  end;
  {$ifndef NOVARIANTS}
  smvVariant: WR.AddShort('null,');
  {$endif}
  else
    if vIsString in ValueKindAsm then
      WR.AddShort('"",') else
      WR.AddShort('0,');
  end;
end;

{$ifndef LVCL}

{ TInterfacedCollection }

constructor TInterfacedCollection.Create;
begin
  inherited Create(GetClass);
end;

{$endif LVCL}

{ TServiceMethod }

type
  TDynArrayFake = record
    Wrapper: TDynArray;
    Value: Pointer;
  end;
  TCallMethodArgs = record
    StackSize, StackAddr, method: PtrInt;
    Regs: array[REG_FIRST..REG_LAST] of PtrInt;
    res64: Int64Rec;
    resKind: TServiceMethodValueType;
    callContext: PServiceRunningContext;
  end;

procedure CallMethod(var Args: TCallMethodArgs);
{$ifdef CPU64}
asm
    .params 64    // size for 64 parameters
    .pushnv r12   // generate prolog+epilog to save and restore non-volatile r12
    mov r12,Args
    // copy stack content (if any)
    mov rcx,[r12].TCallMethodArgs.StackAddr
    lea rdx,[rsp+$20]
    mov r8, [r12].TCallMethodArgs.StackSize
    call Move
    // call method
    mov rcx,[r12+TCallMethodArgs.Regs+REGRCX*8-8]
    mov rdx,[r12+TCallMethodArgs.Regs+REGRDX*8-8]
    mov r8, [r12+TCallMethodArgs.Regs+REGR8 *8-8]
    mov r9, [r12+TCallMethodArgs.Regs+REGR9 *8-8]
    movsd xmm0,[r12+TCallMethodArgs.Regs+REGXMM0*8-8]
    movsd xmm1,[r12+TCallMethodArgs.Regs+REGXMM1*8-8]
    movsd xmm2,[r12+TCallMethodArgs.Regs+REGXMM2*8-8]
    movsd xmm3,[r12+TCallMethodArgs.Regs+REGXMM3*8-8]
    call [r12].TCallMethodArgs.method
    // retrieve result
    mov [r12].TCallMethodArgs.res64,rax
    mov cl,[r12].TCallMethodArgs.resKind
    cmp cl,smvDouble
    je @d
    cmp cl,smvDateTime
    je @d
    cmp cl,smvCurrency
    jne @e
@d: movsd [r12].TCallMethodArgs.res64,xmm0
@e:
end;
{$else}
asm
    push esi
    push ebp
    mov ebp,esp
    mov esi,Args
    // copy stack content (if any)
    mov eax,[esi].TCallMethodArgs.StackSize
    mov edx,dword ptr [esi].TCallMethodArgs.StackAddr
    add edx,eax // pascal/register convention = left-to-right
    shr eax,2
    jz @z
@n: sub edx,4
    mov ecx,[edx]
    push ecx
    dec eax
    jnz @n
    // call method
@z: mov eax,[esi+TCallMethodArgs.Regs+REGEAX*4-4]
    mov edx,[esi+TCallMethodArgs.Regs+REGEDX*4-4]
    mov ecx,[esi+TCallMethodArgs.Regs+REGECX*4-4]
    call [esi].TCallMethodArgs.method
    // retrieve result
    mov cl,[esi].TCallMethodArgs.resKind
    cmp cl,smvDouble
    je @d
    cmp cl,smvDateTime
    je @d
    cmp cl,smvCurrency
    jne @i
    fistp qword [esi].TCallMethodArgs.res64
    jmp @e
@d: fstp qword [esi].TCallMethodArgs.res64
    jmp @e
@i: mov [esi].TCallMethodArgs.res64.Lo,eax
    mov [esi].TCallMethodArgs.res64.Hi,edx
@e: mov esp,ebp
    pop ebp
    pop esi
end;
{$endif CPU64}

procedure BackgroundExecuteProc(Call: Pointer);
var Synch: ^TCallMethodSynchro absolute Call;
    ThreadServer: PServiceRunningContext;
    backup: TServiceRunningContext;
begin
  case Synch.Action of
  syncCallMethod: begin
    ThreadServer := @ServiceContext; // faster to use a pointer than GetTls()
    backup := ThreadServer^;
    try
      with TCallMethodArgs(Synch.CallMethodArgs^).callContext^ do begin
        ThreadServer^.Factory := Factory;
        ThreadServer^.Request := Request;
      end;
      CallMethod(TCallMethodArgs(Synch.CallMethodArgs^));
    finally
      ThreadServer^ := backup;
    end;
  end;
  syncInstanceRelease:
    Synch.InstanceToRelease.InternalRelease;
  end;
end;

procedure CallMethodSynch(Args: pointer);
var Synch: TCallMethodSynchro;
begin
  Synch.Action := syncCallMethod;
  Synch.CallMethodArgs := Args;
  BackgroundExecuteProc(@Synch);
end;

{$ifndef LVCL}

type
  TCollectionClass = class of TInterfacedCollection;

{$endif LVCL}

function TServiceMethod.ArgResultIndex(ArgName: PUTF8Char; ArgNameLen: integer): integer;
begin
  if ArgNameLen>0 then
    for result := ArgsOutFirst to ArgsOutLast do
      with Args[result] do
      if IdemPropName(ParamName^,ArgName,ArgNameLen) then
        if ValueDirection in [smdVar,smdOut,smdResult] then
          exit else
          break; // right name, but wrong direction
  result := -1;
end;

function TServiceMethod.ArgResultNext(var arg: integer): boolean;
begin
  result := true;
  inc(arg);
  while arg<=ArgsOutLast do
    if Args[arg].ValueDirection in [smdVar,smdOut,smdResult] then
      exit else
      inc(arg);
  result := false;
end;

function TServiceMethod.InternalExecute(Instances: array of pointer;
  Par: PUTF8Char; Res: TTextWriter; out aHead: RawUTF8; out aStatus: cardinal;
  Options: TServiceMethodOptions; ResultAsJSONObject: boolean;
  BackgroundExecutionThread: TSynBackgroundThreadProcedure): boolean;
var RawUTF8s: TRawUTF8DynArray;
    Strings: TStringDynArray;
    WideStrings: TWideStringDynArray;
    Records: array of TBytes;
    Value: pointer;
    i,a: integer;
    wasString, valid: boolean;
    Val: PUTF8Char;
    call: TCallMethodArgs;
    {$ifndef LVCL}
    SyncMethod: TMethod;
    {$endif}
    Synch: TCallMethodSynchro;
    Stack: array[0..MAX_EXECSTACK-1] of byte;
    Int64s: array[0..MAX_METHOD_ARGS-1] of Int64;
    Objects: array[0..MAX_METHOD_ARGS-1] of TObject;
    DynArrays: array[0..MAX_METHOD_ARGS-1] of TDynArrayFake;
    Values: array[0..MAX_METHOD_ARGS-1] of PPointer;
begin
  result := false;
  if high(Instances)<0 then
    exit;
  if ArgsUsedCount[smvvRawUTF8]>0 then
    SetLength(RawUTF8s,ArgsUsedCount[smvvRawUTF8]);
  if ArgsUsedCount[smvvString]>0 then
    SetLength(Strings,ArgsUsedCount[smvvString]);
  if ArgsUsedCount[smvvWideString]>0 then
    SetLength(WideStrings,ArgsUsedCount[smvvWideString]);
  if ArgsUsedCount[smvvRecord]>0 then
    SetLength(Records,ArgsUsedCount[smvvRecord]);
  if ArgsUsedCount[smvvObject]>0 then
    fillchar(Objects,ArgsUsedCount[smvvObject]*sizeof(TObject),0); // for finally
  if ArgsUsedCount[smvvDynArray]>0 then
    fillchar(DynArrays,ArgsUsedCount[smvvDynArray]*sizeof(TDynArrayFake),0);
  try       
    // 1. read the parameters
    if ArgsInputValuesCount<>0 then begin // ignore if there is no in parameter
      if Par^ in [#1..' '] then repeat inc(Par) until not(Par^ in [#1..' ']);
      if Par^<>'[' then
        exit; // input arguments shall be as a JSON array , e.g. '[1,2,"three"]'
      inc(Par);
    end;
    for a:= 0 to high(Args) do
    with Args[a] do begin
      case ValueType of
      smvSelf:
        continue; // self parameter is never transmitted
      smvObject: begin
        Objects[IndexVar] := TypeInfo^.ClassCreate; 
        if ValueDirection in [smdConst,smdVar] then begin
          Par := JSONToObject(Objects[IndexVar],Par,valid);
          if not valid then
            exit;
          IgnoreComma(Par);
        end;
      end;
      smvRawJSON:
        if ValueDirection in [smdConst,smdVar] then begin
          Val := Par;
          Par := GotoNextJSONItem(Par);
          if Par<=Val then
            exit;
          SetString(RawUTF8s[IndexVar],PAnsiChar(Val),Par-Val);
        end;
      smvDynArray:
        with DynArrays[IndexVar] do begin
          Wrapper.Init(TypeInfo,Value);
          if ValueDirection in [smdConst,smdVar] then begin
            Par := Wrapper.LoadFromJSON(Par);
            if Par=nil then
              exit;
            IgnoreComma(Par);
          end;
        end;
      smvRecord: begin
        SetLength(Records[IndexVar],TypeInfo^.RecordType^.Size);
        if ValueDirection in [smdConst,smdVar] then
          Par := RecordLoadJSON(pointer(Records[IndexVar])^,Par,TypeInfo);
      end;
      {$ifndef NOVARIANTS}
      smvVariant: begin
        SetLength(Records[IndexVar],sizeof(Variant));
        if ValueDirection in [smdConst,smdVar] then
          Par := VariantLoadJSON(PVariant(pointer(Records[IndexVar]))^,Par,nil,
            @JSON_OPTIONS[optVariantCopiedByReference in Options]);
      end;
      {$endif}
      smvBoolean..smvWideString:
      if ValueDirection in [smdConst,smdVar] then begin
        Val := GetJSONField(Par,Par,@wasString);
        if (Val=nil) or (wasString<>(vIsString in ValueKindAsm)) then
          exit;
        case ValueType of
        smvBoolean: Int64s[IndexVar] := byte(PInteger(Val)^=TRUE_LOW);
        smvEnum..smvInt64:     SetInt64(Val,Int64s[IndexVar]);
        smvDouble,smvDateTime: PDouble(@Int64s[IndexVar])^ := GetExtended(Val);
        smvCurrency:   Int64s[IndexVar] := StrToCurr64(Val);
        smvRawUTF8:    RawUTF8s[IndexVar] := Val;
        smvString:     UTF8DecodeToString(Val,StrLen(Val),Strings[IndexVar]);
        smvWideString: UTF8ToWideString(Val,StrLen(Val),WideStrings[IndexVar]);
        else exit; // should not happen
        end;
      end;
      else exit; // unhandled type
      end;
    end;
    // 2. create the stack content
    call.StackAddr := PtrInt(@Stack);
    call.StackSize := ArgsSizeInStack;
    for a:= 0 to high(Args) do
    with Args[a] do begin
      case ValueVar of
      smvvSelf:       continue; // call.Regs[REG_FIRST] := Instance[i] below
      smvv64:         Value := @Int64s[IndexVar];
      smvvRawUTF8:    Value := @RawUTF8s[IndexVar];
      smvvString:     Value := @Strings[IndexVar];
      smvvWideString: Value := @WideStrings[IndexVar];
      smvvObject:     Value := @Objects[IndexVar];
      smvvRecord:     Value := pointer(Records[IndexVar]);
      smvvDynArray:   Value := @DynArrays[IndexVar].Value;
      else raise EInterfaceFactoryException.CreateFmt(
        'Invalid argument type %d',[ord(ValueType)]);
      end;
      Values[a] := Value;
      if (ValueDirection<>smdConst) or
         (ValueType in [smvRecord{$ifndef NOVARIANTS},smvVariant{$endif}]) then
        // pass by reference
        if RegisterIdent=0 then
          move(Value,Stack[InStackOffset],SizeInStack) else
          call.Regs[RegisterIdent] := PtrInt(Value) else
        // pass by value
        if RegisterIdent=0 then
          move(Value^,Stack[InStackOffset],SizeInStack) else
          call.Regs[RegisterIdent] := PPtrInt(Value)^;
    end;
    // 3. execute the method
    for i := 0 to high(Instances) do begin
      // 3.1 prepare the low-level call context for the asm stub
      call.Regs[REG_FIRST] := PtrInt(Instances[i]);
      call.method := PPtrIntArray(PPointer(Instances[i])^)^[ExecutionMethodIndex];
      if ArgsResultIndex>=0 then
      with Args[ArgsResultIndex] do begin
        call.resKind := ValueType;
        if ValueVar=smvv64 then
          Values[ArgsResultIndex] := @call.res64;
      end else
        call.resKind := smvNone;
      // 3.2 launch the asm stub in the expected execution context
      {$ifndef LVCL}
      if (optExecInMainThread in Options) and
         (GetCurrentThreadID<>MainThreadID) then begin
        call.callContext := @ServiceContext; // to be copied into main threadvar
        SyncMethod.Code := @CallMethodSynch;
        SyncMethod.Data := @call; // fake call: PCallMethodArgs(self)^=Params
        {$ifdef DELPHI6OROLDER}TThreadHook(call.callContext^.RunningThread).Synchronize(
        {$else}                TThread.Synchronize(call.callContext^.RunningThread,
        {$endif}  TThreadMethod(SyncMethod));
      end else
      {$endif}
      if optExecInPerInterfaceThread in Options then
        if not Assigned(BackgroundExecutionThread) then
          raise EInterfaceFactoryException.Create(
            'optExecInPerInterfaceThread with BackgroundExecutionThread=nil') else begin
        call.callContext := @ServiceContext; // to be copied into background threadvar
        Synch.Action := syncCallMethod;
        Synch.CallMethodArgs := @call;
        BackgroundExecutionThread.RunAndWait(@Synch);
      end else
        CallMethod(call);
    end;
    // 4. send back any result
    if Res<>nil then begin
      // 4.1 handle custom content (not JSON array/object answer)
      if (call.resKind=smvRecord) and ArgsResultIsServiceCustomAnswer then
        with PServiceCustomAnswer(Values[ArgsResultIndex])^ do
        if Header<>'' then begin
          aHead := Header;
          Res.ForceContent(Content);
          if Status=0 then // Values[]=@Records[] is filled with 0 by default
            aStatus := HTML_SUCCESS else
            aStatus := Status;
          Result := true;
          exit;
        end;
      // 4.2 write the '{"result":[...' array or object
      for a := ArgsOutFirst to ArgsOutLast do
      with Args[a] do
      if ValueDirection in [smdVar,smdOut,smdResult] then begin
        if ResultAsJSONObject then
          Res.AddPropName(ParamName^);
        AddJSON(Res,Values[a]);
      end;
      Res.CancelLastComma;
    end;
    Result := true;
  finally // manual release memory for Records[], Objects[] and DynArrays[]
    for i := 0 to ArgsUsedCount[smvvObject]-1 do
      Objects[i].Free;
    for i := 0 to ArgsUsedCount[smvvDynArray]-1 do
      DynArrays[i].Wrapper.Clear;
    if Records<>nil then begin
      i := 0;
      for a := 0 to high(Args) do
        with Args[a] do
        case ValueType of
        smvRecord: begin
          RecordClear(pointer(Records[i])^,TypeInfo);
          inc(i);
        end;
        {$ifndef NOVARIANTS}
        smvVariant: begin
          VarClear(PVariant(pointer(Records[i]))^); // fast
          inc(i);
        end;
        {$endif}
        end;
    end;
  end;
end;


{ TSynBackgroundThreadSQLRestServerProcedure }

constructor TSynBackgroundThreadSQLRestServerProcedure.Create(aServer: TSQLRestServer);
begin
  inherited Create(BackgroundExecuteProc,nil);
  fServer := aServer;
end;

procedure TSynBackgroundThreadSQLRestServerProcedure.Execute;
begin
  fServer.BeginCurrentThread(self);
  try
    inherited Execute;
  finally
    fServer.EndCurrentThread(self);
  end;
end;


{ TSynBackgroundThreadSQLRestServerMethod }

constructor TSynBackgroundThreadSQLRestServerMethod.Create(aServer: TSQLRestServer);
begin
  inherited Create(nil);
  fServer := aServer;
end;

procedure TSynBackgroundThreadSQLRestServerMethod.Execute;
begin
  fServer.BeginCurrentThread(self);
  try
    inherited Execute;
  finally
    fServer.EndCurrentThread(self);
  end;
end;


{ TServiceContainerClient }

function TServiceContainerClient.Info(aTypeInfo: PTypeInfo): TServiceFactory;
begin
  result := inherited Info(aTypeInfo);
  if result=nil then
    result := AddInterface(aTypeInfo,sicClientDriven);
end;


{ TServiceFactoryClient }

function TServiceFactoryClient.CreateFakeInstance: TInterfacedObject;
begin
  if fInstanceCreation=sicClientDriven then
    result := fInterface.CreateFakeInstance(Invoke,NotifyInstanceDestroyed) else
    result := fInterface.CreateFakeInstance(Invoke);
end;

function TServiceFactoryClient.Invoke(const aMethod: TServiceMethod;
  const aParams: RawUTF8; aResult: PRawUTF8; aErrorMsg: PRawUTF8;
  aClientDrivenID: PCardinal; aServiceCustomAnswer: PServiceCustomAnswer): boolean;
begin
  result := InternalInvoke(aMethod.URI,aParams,aResult,aErrorMsg,aClientDrivenID,aServiceCustomAnswer);
end;

function TServiceFactoryClient.InternalInvoke(const aMethod: RawUTF8;
  const aParams: RawUTF8=''; aResult: PRawUTF8=nil; aErrorMsg: PRawUTF8=nil;
  aClientDrivenID: PCardinal=nil; aServiceCustomAnswer: PServiceCustomAnswer=nil): boolean;
var uri,sent,resp,head,clientDrivenID: RawUTF8;
    Values: TPUtf8CharDynArray;
    {$ifdef WITHLOG}
    LogLevel: TSynLogInfos; // faster execution if logging is not enabled
    {$endif}
begin
  result := false;
  if Self=nil then
    exit;
  if fClient=nil then
    fClient := fRest as TSQLRestClientURI;
  {$ifdef WITHLOG}
  LogLevel := SQLite3Log.Family.Level;
  if sllEnter in LogLevel then
    SQLite3Log.Enter(Self,pointer(fInterfaceURI+'.'+aMethod),true);
  {$endif}
  // compute URI according to current routing scheme
  if fRest.Services.ExpectMangledURI then
    uri := fClient.Model.Root+'/'+fInterfaceMangledURI else
    uri := fClient.Model.Root+'/'+fInterfaceURI;
  if (aClientDrivenID<>nil) and (aClientDrivenID^>0) then
    UInt32ToUTF8(aClientDrivenID^,clientDrivenID);
  fRest.ServicesRouting.ClientSideInvoke(uri,aMethod,aParams,clientDrivenID,sent);
  // call remote server
  if fClient.URI(uri,'POST',@resp,@head,@sent).Lo<>HTML_SUCCESS then begin
    if aErrorMsg<>nil then
      aErrorMsg^ := ': '+resp;
    exit;
  end;
  // decode result
  if aServiceCustomAnswer=nil then begin // decode JSON object
    {$ifdef WITHLOG}
    if (sllServiceReturn in LogLevel) and (resp<>'') then
        SQLite3Log.Add.Log(sllServiceReturn,resp,nil,MAX_SIZE_RESPONSE_LOG);
    {$endif}
    JSONDecode(resp,['result','id'],Values,True);
    if Values[0]=nil then begin // assume ID=0 if no "id":... value 
      if aErrorMsg<>nil then
        aErrorMsg^ := 'Invalid returned JSON content: expects {"result":...}';
      exit;
    end;
    if aResult<>nil then
      aResult^ := Values[0];
    if aClientDrivenID<>nil then
      aClientDrivenID^ := GetCardinal(Values[1]);
  end else begin // free answer returned in TServiceCustomAnswer 
    {$ifdef WITHLOG}
    if sllServiceReturn in LogLevel then
      SQLite3Log.Add.Log(sllServiceReturn,'TServiceCustomAnswer(%) returned len=%',
        [head,length(resp)]);
    {$endif}
    aServiceCustomAnswer^.Header := head;
    aServiceCustomAnswer^.Content := resp;
    if aClientDrivenID<>nil then
      aClientDrivenID^ := 0;
  end;
  result := true;
end;

procedure TServiceFactoryClient.NotifyInstanceDestroyed(aClientDrivenID: cardinal);
begin
  if aClientDrivenID<>0 then
    InternalInvoke(SERVICE_PSEUDO_METHOD[imFree],'',nil,nil,@aClientDrivenID);
end;

constructor TServiceFactoryClient.Create(aRest: TSQLRest;
  aInterface: PTypeInfo; aInstanceCreation: TServiceInstanceImplementation;
  const aContractExpected: RawUTF8);
var Error, RemoteContract: RawUTF8;
begin
  // extract interface RTTI and create fake interface (and any shared instance)
  if not aRest.InheritsFrom(TSQLRestClientURI) then
    EServiceException.CreateFmt('%s interface needs a Client connection',
      [aInterface^.Name]);
  inherited Create(aRest,aInterface,aInstanceCreation,aContractExpected);
  // initialize a shared instance (if needed)
  if fInstanceCreation in [sicShared,sicPerSession,sicPerUser,sicPerGroup,sicPerThread] then begin
    // the instance shall remain active during the whole client session
    fSharedInstance := CreateFakeInstance;
    TInterfacedObjectFake(fSharedInstance)._AddRef; // force stay alive
  end;
  // check if this interface is supported on the server
  if not InternalInvoke(SERVICE_PSEUDO_METHOD[imContract],'',@RemoteContract,@Error) then
    raise EServiceException.CreateFmt('I%s interface or %s routing not supported by server%s',
      [fInterfaceURI,fRest.ServicesRouting.ClassName,Error]);
  if ('['+ContractExpected+']'<>RemoteContract) and
     ('{"contract":'+ContractExpected+'}'<>RemoteContract) then
    raise EServiceException.CreateFmt(
      'Server''s I%s contract differs from client''s: expected [%s], received %s',
      [fInterfaceURI,ContractExpected,RemoteContract]);
end;

destructor TServiceFactoryClient.Destroy;
begin
  if fSharedInstance<>nil then
  with TInterfacedObjectFake(fSharedInstance) do
    if fRefCount<>1 then
      raise EServiceException.CreateFmt(
        'RefCount=%d: shall release I%s interface (.. := nil) before Client.Free',
        [fRefCount,fInterfaceURI]) else
      _Release; // bonne nuit les petits
  inherited;
end;

function TServiceFactoryClient.RetrieveSignature: RawUTF8;
begin
  result := '';
  if InternalInvoke(SERVICE_PSEUDO_METHOD[imSignature],'',@result) and
     (result<>'') then
    if result[1]='[' then
      result := copy(result,2,length(result)-2) else
    if IdemPChar(pointer(result),'{"SIGNATURE":') then
      result := copy(result,14,length(result)-14);
end;

function TServiceFactoryClient.Get(out Obj): Boolean;
var O: TInterfacedObjectFake;
begin
  result := false;
  if Self=nil then
    exit;
  case fInstanceCreation of
  sicShared, sicPerSession, sicPerUser, sicPerGroup, sicPerThread:
    O := TInterfacedObjectFake(fSharedInstance);
  sicSingle, sicClientDriven:
    O := TInterfacedObjectFake(CreateFakeInstance);
  else exit;
  end;
  if O=nil then
    exit; 
  pointer(Obj) := @O.fVTable;
  O._AddRef;
  result := true;
end;



function ObjectFromInterface(const aValue: IInterface): TObject;
{$ifndef ISDELPHI2010}
{$ifndef CPU64}
type
  TObjectFromInterfaceStub = packed record
    Stub: cardinal;
    case integer of
    0: (ShortJmp: shortint);
    1: (LongJmp:  longint)
  end;
  PObjectFromInterfaceStub = ^TObjectFromInterfaceStub;
{$endif}
{$endif}
begin
  if aValue=nil then
    result := nil else
    {$ifdef CPU64}
    result := aValue as TObject;
    {$else}
    {$ifdef ISDELPHI2010}
    result := aValue as TObject; // slower but always working
    {$else}
    with PObjectFromInterfaceStub(PPointer(PPointer(aValue)^)^)^ do
    case Stub of // address of VMT[0] entry, i.e. QueryInterface
      $04244483: result := pointer(PtrInt(aValue)+ShortJmp);
      $04244481: result := pointer(PtrInt(aValue)+LongJmp);
      else // recognize TInterfaceFactory.CreateFakeInstance() mocks
      if Stub=PCardinal(@TInterfacedObjectFake.FakeQueryInterface)^ then
        result := TInterfacedObjectFake(pointer(aValue)).SelfFromInterface else
        result := nil;
    end;
    {$endif}
    {$endif}
end;

procedure SetWeak(aInterfaceField: PIInterface; const aValue: IInterface);
begin
  PPointer(aInterfaceField)^ := Pointer(aValue);
end;

type
  TSetWeakZeroInstance = class(TObjectListHashed)
  protected
    fInstance: TObject;
  public
    constructor Create(aObject: TObject; aReference: pointer);
    destructor Destroy; override;
    property Instance: TObject read fInstance;
  end;

  TSetWeakZeroClass = class(TObjectListPropertyHashed)
  protected
    fHookedFreeInstance: PtrUInt;
    fLock: TRTLCriticalSection;
    procedure HookedFreeInstance;
  public
    constructor Create(aClass: TClass);
    destructor Destroy; override;
    function Find(aObject: TObject): TSetWeakZeroInstance;
    function FindOrAdd(aObject: TObject; aReference: pointer): TSetWeakZeroInstance;
  end;

  
{ TSetWeakZeroInstance }

constructor TSetWeakZeroInstance.Create(aObject: TObject; aReference: pointer);
var wasAdded: boolean;
begin
  inherited Create(false);
  fInstance := aObject;
  Add(aReference,wasAdded);
  //assert(IndexOf(aReference)>=0);
end;

destructor TSetWeakZeroInstance.Destroy;
var i: integer;
begin
  for i := 0 to Count-1 do
    PPointer(List[i])^ := nil;
  inherited;
end;


{ TSetWeakZeroClass }

function WeakZeroClassSubProp(aObject: TObject): TObject;
begin
  result := TSetWeakZeroInstance(aObject).fInstance;
end;

constructor TSetWeakZeroClass.Create(aClass: TClass);
var PVMT: ^TObject;
    P: PPtrUInt;
begin
  inherited Create(@WeakZeroClassSubProp);
  PVMT := pointer(PtrInt(aClass)+vmtAutoTable);
  if PVMT^=nil then begin
    PatchCodePtrUInt(pointer(PVMT),PtrUInt(self),true); // LeaveUnprotected=true
    GarbageCollectorFreeAndNil(PVMT^,self); // set to nil at finalization
  end else
    if PPointer(PVMT^)^=TSQLRecordProperties then
      GarbageCollectorFreeAndNil(  // set to nil at finalization
        TSQLRecordProperties(PVMT^).fWeakZeroClass,self) else
      raise EORMException.CreateFmt(
        'SetWeakZero: %s.AutoTable VMT entry already used',
        [PShortString(PPointer(PtrInt(aClass)+vmtClassName)^)^]);
  InitializeCriticalSection(fLock);
  EnterCriticalSection(fLock);
  {$WARN SYMBOL_DEPRECATED OFF}
  P := pointer(PtrInt(aClass)+vmtFreeInstance);
  {$WARN SYMBOL_DEPRECATED ON}
  fHookedFreeInstance := P^;
  PatchCodePtrUInt(P,PtrUInt(@TSetWeakZeroClass.HookedFreeInstance));
end;

destructor TSetWeakZeroClass.Destroy;
begin
  DeleteCriticalSection(fLock);
  inherited;
end;

function EnterWeakZeroClass(aObject: TObject; CreateIfNonExisting: boolean): TSetWeakZeroClass;
 {$ifdef HASINLINE}inline;{$endif}
begin
  result := PPointer(PPtrInt(aObject)^+vmtAutoTable)^;
  if (result<>nil) and (PPointer(result)^=TSQLRecordProperties) then
    result := TSetWeakZeroClass(TSQLRecordProperties(result).fWeakZeroClass);
  if result<>nil then
    EnterCriticalSection(result.fLock) else
    if CreateIfNonExisting then
      result := TSetWeakZeroClass.Create(PPointer(aObject)^);
end;

procedure TSetWeakZeroClass.HookedFreeInstance;
type Call = procedure(self: TObject);
begin
  with EnterWeakZeroClass(self,false) do begin // if hooked -> never nil
    try
      Delete(self);
    finally
      LeaveCriticalSection(fLock);
    end;
    Call(fHookedFreeInstance)(self);
  end;
end;

function TSetWeakZeroClass.Find(aObject: TObject): TSetWeakZeroInstance;
var i: integer;
begin
  i := IndexOf(aObject); // search List[i].fInstance=aObject
  if i>=0 then
    result := TSetWeakZeroInstance(List[i]) else
    result := nil;
end;

function TSetWeakZeroClass.FindOrAdd(aObject: TObject; aReference: pointer): TSetWeakZeroInstance;
var wasAdded: boolean;
    i: integer;
begin
  i := inherited Add(aObject,wasAdded);
  if wasAdded then begin
    result := TSetWeakZeroInstance.Create(aObject,aReference);
    List[i] := result;
    //assert(IndexOf(aObject)>=0);
  end else begin
    result := TSetWeakZeroInstance(List[i]);
    result.Add(aReference,wasAdded);
  end;
  //assert(result.IndexOf(aReference)>=0);
  //assert(result.fInstance=aObject);
end;

procedure SetWeakZero(aObject: TObject; aObjectInterfaceField: PIInterface;
  const aValue: IInterface);
var aObjectWeakClass, aObjectInterfaceWeakClass: TSetWeakZeroClass;
    aObjectInterfaceObject, aValueObject: TObject;
begin
  if (aObjectInterfaceField=nil) or (aObject=nil) or (aObjectInterfaceField^=aValue) then
    exit;
  aObjectWeakClass := EnterWeakZeroClass(aObject,false);
  try
    if aObjectInterfaceField^<>nil then begin
      if aValue=nil then
        aObjectWeakClass.Delete(TObject(aObjectInterfaceField));
      aObjectInterfaceObject := ObjectFromInterface(aObjectInterfaceField^);
      if aObjectInterfaceObject<>nil then begin
        aObjectInterfaceWeakClass := EnterWeakZeroClass(aObjectInterfaceObject,false);
        if aObjectInterfaceWeakClass<>nil then
        try
          aObjectInterfaceWeakClass.Find(aObjectInterfaceObject).Delete(TObject(aObjectInterfaceField));
        finally
          LeaveCriticalSection(aObjectInterfaceWeakClass.fLock);
        end;
      end;
      SetWeak(aObjectInterfaceField,nil);
      if aValue=nil then
        exit;
    end;
    if aObjectWeakClass=nil then // for faster Delete() just above
      aObjectWeakClass := TSetWeakZeroClass.Create(PPointer(aObject)^);
    aObjectWeakClass.FindOrAdd(aObject,aObjectInterfaceField);
    aValueObject := ObjectFromInterface(aValue);
    if aValueObject<>nil then
      with EnterWeakZeroClass(aValueObject,true) do
      try
        FindOrAdd(aValueObject,aObjectInterfaceField);
      finally
        LeaveCriticalSection(fLock);
      end;
    SetWeak(aObjectInterfaceField,aValue);
  finally
    if aObjectWeakClass<>nil then
      LeaveCriticalSection(aObjectWeakClass.fLock);
  end;
end;

{$ifdef ISDELPHIXE}
procedure TWeakZeroInterfaceHelper.SetWeak0(aObjectInterfaceField: PIInterface;
  const aValue: IInterface);
begin
  SetWeakZero(self,aObjectInterfaceField,aValue);
end;
{$endif}


initialization
  pointer(@SQLFieldTypeComp[sftAnsiText]) := @AnsiIComp;
  pointer(@SQLFieldTypeComp[sftUTF8Custom]) := @AnsiIComp;
  pointer(@SQLFieldTypeComp[sftObject]) := @StrComp;
{$ifndef NOVARIANTS}
  pointer(@SQLFieldTypeComp[sftVariant]) := @StrComp;
{$endif}
{$ifndef USENORMTOUPPER}
  pointer(@SQLFieldTypeComp[sftUTF8Text]) := @AnsiIComp;
{$endif}
  ExeVersionRetrieve; // the sooner the better

  assert(sizeof(TServiceMethod)and 3=0,'Adjust padding');
end.

